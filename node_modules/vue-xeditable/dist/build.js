/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

eval("var disposed = false\nvar Component = __webpack_require__(11)(\n  /* script */\n  __webpack_require__(1),\n  /* template */\n  __webpack_require__(12),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\nComponent.options.__file = \"/Users/madao/dev/vue-editable/src/Editable.vue\"\nif (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== \"default\" && key.substr(0, 2) !== \"__\"})) {console.error(\"named exports are not supported in *.vue files.\")}\nif (Component.options.functional) {console.error(\"[vue-loader] Editable.vue: functional components are not supported with templates, they should use render functions.\")}\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-409b4816\", Component.options)\n  } else {\n    hotAPI.reload(\"data-v-409b4816\", Component.options)\n  }\n  module.hot.dispose(function (data) {\n    disposed = true\n  })\n})()}\n\nmodule.exports = Component.exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvRWRpdGFibGUudnVlP2EwZjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUFvSDtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLHNEQUFzRCxJQUFJO0FBQ3pJLG1DQUFtQzs7QUFFbkM7QUFDQSxZQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRpc3Bvc2VkID0gZmFsc2VcbnZhciBDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKShcbiAgLyogc2NyaXB0ICovXG4gIHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlciEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL0VkaXRhYmxlLnZ1ZVwiKSxcbiAgLyogdGVtcGxhdGUgKi9cbiAgcmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4P3tcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNDA5YjQ4MTZcXFwiLFxcXCJoYXNTY29wZWRcXFwiOmZhbHNlfSEuLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wIS4vRWRpdGFibGUudnVlXCIpLFxuICAvKiBzdHlsZXMgKi9cbiAgbnVsbCxcbiAgLyogc2NvcGVJZCAqL1xuICBudWxsLFxuICAvKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbiAgbnVsbFxuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCIvVXNlcnMvbWFkYW8vZGV2L3Z1ZS1lZGl0YWJsZS9zcmMvRWRpdGFibGUudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHtyZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkge2NvbnNvbGUuZXJyb3IoXCJuYW1lZCBleHBvcnRzIGFyZSBub3Qgc3VwcG9ydGVkIGluICoudnVlIGZpbGVzLlwiKX1cbmlmIChDb21wb25lbnQub3B0aW9ucy5mdW5jdGlvbmFsKSB7Y29uc29sZS5lcnJvcihcIlt2dWUtbG9hZGVyXSBFZGl0YWJsZS52dWU6IGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRlbXBsYXRlcywgdGhleSBzaG91bGQgdXNlIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNDA5YjQ4MTZcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi00MDliNDgxNlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfVxuICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkaXNwb3NlZCA9IHRydWVcbiAgfSlcbn0pKCl9XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9uZW50LmV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL0VkaXRhYmxlLnZ1ZVxuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__editable_css_bootstrap_min_css__ = __webpack_require__(15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__editable_css_bootstrap_min_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__editable_css_bootstrap_min_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__editable_css_bootstrap_editable_css__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__editable_css_bootstrap_editable_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__editable_css_bootstrap_editable_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__editable_css_bootstrap_wysihtml5_css__ = __webpack_require__(20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__editable_css_bootstrap_wysihtml5_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__editable_css_bootstrap_wysihtml5_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__editable_js_bootstrap_min_js__ = __webpack_require__(13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__editable_js_bootstrap_min_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__editable_js_bootstrap_min_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__editable_js_bootstrap_editable_js__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__editable_js_bootstrap_editable_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__editable_js_bootstrap_editable_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__editable_js_wysihtml5_js__ = __webpack_require__(22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__editable_js_wysihtml5_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__editable_js_wysihtml5_js__);\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n\n$.fn.editable.defaults.mode = 'inline';\n$.fn.editable.defaults.onblur = 'submit';\n$.fn.editable.defaults.showbuttons = false;\n$.fn.editable.defaults.clear = false;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  props: {\n    type: {\n      type: String,\n      default: 'text'\n    },\n    value: {\n      type: String,\n      default: ''\n    },\n    ajaxOptions: {\n      type: Object,\n      default: function _default() {\n        return {\n          type: 'put',\n          dataType: 'json'\n        };\n      }\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    emptytext: {\n      type: String,\n      default: 'æ— '\n    },\n    placeholder: {\n      type: String,\n      default: ''\n    },\n    display: {\n      type: Boolean,\n      default: true\n    },\n    shown: {\n      type: Function,\n      default: function _default() {}\n    },\n    hidden: {\n      type: Function,\n      default: function _default() {}\n    },\n    option: {\n      type: Object,\n      default: function _default() {\n        return {};\n      }\n    }\n  },\n  watch: {\n    'display': function display(value) {\n      var input_el = $(this.$el);\n      var action = value ? 'show' : 'hide';\n      input_el.editable(action);\n    }\n  },\n  data: function data() {},\n  created: function created() {},\n  mounted: function mounted() {\n    var self = this;\n    var el = $(this.$el);\n    if (el.data('editable')) {\n      el.editable().destroy();\n    }\n    var option = Object.assign(this.ajaxOptions, this.option);\n    el.editable(option).on('shown', function (e, editble) {\n      self.shown();\n    }).on('hidden', function (e, reason) {\n      self.hidden();\n    }).on('save', function (e, params) {\n      if (params.newValue == self.value) return;\n      self.handleChange(params.newValue);\n    });\n  },\n\n  methods: {\n    handleChange: function handleChange(value) {\n      this.value = value;\n      this.$emit('change', this.value);\n      this.$emit('input', this.value);\n    }\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vRWRpdGFibGUudnVlPzI5NzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7WUFJQTtlQUVBO0FBSEE7O1lBS0E7ZUFFQTtBQUhBOztZQUtBO21DQUNBOztnQkFFQTtvQkFFQTtBQUhBO0FBS0E7QUFSQTs7WUFVQTtlQUVBO0FBSEE7O1lBS0E7ZUFFQTtBQUhBOztZQUtBO2VBRUE7QUFIQTs7WUFLQTtlQUVBO0FBSEE7O1lBS0E7b0NBRUE7QUFIQTs7WUFLQTtvQ0FFQTtBQUhBOztZQUtBOzs7QUFHQTtBQUpBO0FBMUNBOzt1Q0FnREE7NEJBQ0E7b0NBQ0E7d0JBQ0E7QUFFQTtBQU5BO3dCQVFBLENBQ0E7OEJBQ0EsQ0FDQTs4QkFDQTtlQUNBO29CQUNBOzZCQUNBO29CQUNBO0FBQ0E7c0RBQ0E7MERBQ0E7V0FDQTt5Q0FDQTtXQUNBO3VDQUNBO3lDQUNBOytCQUNBO0FBQ0E7QUFDQTs7OytDQUVBO21CQUNBO2dDQUNBOytCQUNBO0FBRUE7QUFOQTtBQTVFQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxuICA8YSBocmVmPVwiamF2YXNjcmlwdDo7XCJcbiAgICAgOmRhdGEtdHlwZT1cInR5cGVcIlxuICAgICA6ZGlzYWJsZWQ9J2Rpc2FibGVkJ1xuICAgICA6ZW1wdHl0ZXh0PSdlbXB0eXRleHQnPnt7dmFsdWV9fTwvYT5cbjwvdGVtcGxhdGU+XG48c2NyaXB0PlxuICBpbXBvcnQgJy4vZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC5taW4uY3NzJ1xuICBpbXBvcnQgJy4vZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC1lZGl0YWJsZS5jc3MnXG4gIGltcG9ydCAnLi9lZGl0YWJsZS9jc3MvYm9vdHN0cmFwLXd5c2lodG1sNS5jc3MnXG5cbiAgaW1wb3J0ICcuL2VkaXRhYmxlL2pzL2Jvb3RzdHJhcC5taW4uanMnXG4gIGltcG9ydCAnLi9lZGl0YWJsZS9qcy9ib290c3RyYXAtZWRpdGFibGUuanMnXG4gIGltcG9ydCAnLi9lZGl0YWJsZS9qcy93eXNpaHRtbDUuanMnXG5cbiAgJC5mbi5lZGl0YWJsZS5kZWZhdWx0cy5tb2RlID0gJ2lubGluZSc7XG4gICQuZm4uZWRpdGFibGUuZGVmYXVsdHMub25ibHVyID0gJ3N1Ym1pdCc7XG4gICQuZm4uZWRpdGFibGUuZGVmYXVsdHMuc2hvd2J1dHRvbnMgPSBmYWxzZTtcbiAgJC5mbi5lZGl0YWJsZS5kZWZhdWx0cy5jbGVhciA9IGZhbHNlO1xuXG4gIGV4cG9ydCBkZWZhdWx0IHtcbiAgICBwcm9wczp7XG4gICAgICB0eXBlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ3RleHQnXG4gICAgICB9LFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiAnJ1xuICAgICAgfSxcbiAgICAgIGFqYXhPcHRpb25zOiB7XG4gICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdwdXQnLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICB9LFxuICAgICAgZW1wdHl0ZXh0OiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogJ+aXoCdcbiAgICAgIH0sXG4gICAgICBwbGFjZWhvbGRlcjoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6ICcnXG4gICAgICB9LFxuICAgICAgZGlzcGxheToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9LFxuICAgICAgc2hvd246IHtcbiAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uKCkge31cbiAgICAgIH0sXG4gICAgICBoaWRkZW46IHtcbiAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uKCkge31cbiAgICAgIH0sXG4gICAgICBvcHRpb246IHtcbiAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHsgfSB9XG4gICAgICB9XG4gICAgfSxcbiAgICB3YXRjaDoge1xuICAgICAgJ2Rpc3BsYXknOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgbGV0IGlucHV0X2VsID0gJCh0aGlzLiRlbClcbiAgICAgICAgbGV0IGFjdGlvbiA9IHZhbHVlID8gJ3Nob3cnIDogJ2hpZGUnXG4gICAgICAgIGlucHV0X2VsLmVkaXRhYmxlKGFjdGlvbilcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGEoKSB7XG5cbiAgICB9LFxuICAgIGNyZWF0ZWQoKSB7XG4gICAgfSxcbiAgICBtb3VudGVkKCl7XG4gICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICBsZXQgZWwgPSAkKHRoaXMuJGVsKVxuICAgICAgaWYgKGVsLmRhdGEoJ2VkaXRhYmxlJykpIHtcbiAgICAgICAgZWwuZWRpdGFibGUoKS5kZXN0cm95KClcbiAgICAgIH1cbiAgICAgIGxldCBvcHRpb24gPSBPYmplY3QuYXNzaWduKHRoaXMuYWpheE9wdGlvbnMsIHRoaXMub3B0aW9uKVxuICAgICAgZWwuZWRpdGFibGUob3B0aW9uKS5vbignc2hvd24nLCBmdW5jdGlvbihlLGVkaXRibGUpe1xuICAgICAgICBzZWxmLnNob3duKCk7XG4gICAgICB9KS5vbignaGlkZGVuJywgZnVuY3Rpb24oZSwgcmVhc29uKXtcbiAgICAgICAgc2VsZi5oaWRkZW4oKTtcbiAgICAgIH0pLm9uKCdzYXZlJywgZnVuY3Rpb24oZSwgcGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMubmV3VmFsdWUgPT0gc2VsZi52YWx1ZSkgcmV0dXJuXG4gICAgICAgIHNlbGYuaGFuZGxlQ2hhbmdlKHBhcmFtcy5uZXdWYWx1ZSlcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgaGFuZGxlQ2hhbmdlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy52YWx1ZSk7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgdGhpcy52YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBFZGl0YWJsZS52dWU/MjZhNWZiYTgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1\n");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! X-editable - v1.5.1 \n* In-place editing with Twitter Bootstrap, jQuery UI or pure jQuery\n* http://github.com/vitalets/x-editable\n* Copyright (c) 2013 Vitaliy Potapov; Licensed MIT */\n/**\nForm with single input element, two buttons and two states: normal/loading.\nApplied as jQuery method to DIV tag (not to form tag!). This is because form can be in loading state when spinner shown.\nEditableform is linked with one of input types, e.g. 'text', 'select' etc.\n\n@class editableform\n@uses text\n@uses textarea\n**/\n(function ($) {\n\n    var EditableForm = function EditableForm(div, options) {\n        this.options = $.extend({}, $.fn.editableform.defaults, options);\n        this.$div = $(div); //div, containing form. Not form tag. Not editable-element.\n        if (!this.options.scope) {\n            this.options.scope = this;\n        }\n        //nothing shown after init\n    };\n\n    EditableForm.prototype = {\n        constructor: EditableForm,\n        initInput: function initInput() {\n            //called once\n            //take input from options (as it is created in editable-element)\n            this.input = this.options.input;\n\n            //set initial value\n            //todo: may be add check: typeof str === 'string' ? \n            this.value = this.input.str2value(this.options.value);\n\n            //prerender: get input.$input\n            this.input.prerender();\n        },\n        initTemplate: function initTemplate() {\n            this.$form = $($.fn.editableform.template);\n        },\n        initButtons: function initButtons() {\n            var $btn = this.$form.find('.editable-buttons');\n            $btn.append($.fn.editableform.buttons);\n            if (this.options.showbuttons === 'bottom') {\n                $btn.addClass('editable-buttons-bottom');\n            }\n        },\n        /**\n        Renders editableform\n         @method render\n        **/\n        render: function render() {\n            //init loader\n            this.$loading = $($.fn.editableform.loading);\n            this.$div.empty().append(this.$loading);\n\n            //init form template and buttons\n            this.initTemplate();\n            if (this.options.showbuttons) {\n                this.initButtons();\n            } else {\n                this.$form.find('.editable-buttons').remove();\n            }\n\n            //show loading state\n            this.showLoading();\n\n            //flag showing is form now saving value to server. \n            //It is needed to wait when closing form.\n            this.isSaving = false;\n\n            /**        \n            Fired when rendering starts\n            @event rendering \n            @param {Object} event event object\n            **/\n            this.$div.triggerHandler('rendering');\n\n            //init input\n            this.initInput();\n\n            //append input to form\n            this.$form.find('div.editable-input').append(this.input.$tpl);\n\n            //append form to container\n            this.$div.append(this.$form);\n\n            //render input\n            $.when(this.input.render()).then($.proxy(function () {\n                //setup input to submit automatically when no buttons shown\n                if (!this.options.showbuttons) {\n                    this.input.autosubmit();\n                }\n\n                //attach 'cancel' handler\n                this.$form.find('.editable-cancel').click($.proxy(this.cancel, this));\n\n                if (this.input.error) {\n                    this.error(this.input.error);\n                    this.$form.find('.editable-submit').attr('disabled', true);\n                    this.input.$input.attr('disabled', true);\n                    //prevent form from submitting\n                    this.$form.submit(function (e) {\n                        e.preventDefault();\n                    });\n                } else {\n                    this.error(false);\n                    this.input.$input.removeAttr('disabled');\n                    this.$form.find('.editable-submit').removeAttr('disabled');\n                    var value = this.value === null || this.value === undefined || this.value === '' ? this.options.defaultValue : this.value;\n                    this.input.value2input(value);\n                    //attach submit handler\n                    this.$form.submit($.proxy(this.submit, this));\n                }\n\n                /**        \n                Fired when form is rendered\n                @event rendered\n                @param {Object} event event object\n                **/\n                this.$div.triggerHandler('rendered');\n\n                this.showForm();\n\n                //call postrender method to perform actions required visibility of form\n                if (this.input.postrender) {\n                    this.input.postrender();\n                }\n            }, this));\n        },\n        cancel: function cancel() {\n            /**        \n            Fired when form was cancelled by user\n            @event cancel \n            @param {Object} event event object\n            **/\n            this.$div.triggerHandler('cancel');\n        },\n        showLoading: function showLoading() {\n            var w, h;\n            if (this.$form) {\n                //set loading size equal to form\n                w = this.$form.outerWidth();\n                h = this.$form.outerHeight();\n                if (w) {\n                    this.$loading.width(w);\n                }\n                if (h) {\n                    this.$loading.height(h);\n                }\n                this.$form.hide();\n            } else {\n                //stretch loading to fill container width\n                w = this.$loading.parent().width();\n                if (w) {\n                    this.$loading.width(w);\n                }\n            }\n            this.$loading.show();\n        },\n\n        showForm: function showForm(activate) {\n            this.$loading.hide();\n            this.$form.show();\n            if (activate !== false) {\n                this.input.activate();\n            }\n            /**        \n            Fired when form is shown\n            @event show \n            @param {Object} event event object\n            **/\n            this.$div.triggerHandler('show');\n        },\n\n        error: function error(msg) {\n            var $group = this.$form.find('.control-group'),\n                $block = this.$form.find('.editable-error-block'),\n                lines;\n\n            if (msg === false) {\n                $group.removeClass($.fn.editableform.errorGroupClass);\n                $block.removeClass($.fn.editableform.errorBlockClass).empty().hide();\n            } else {\n                //convert newline to <br> for more pretty error display\n                if (msg) {\n                    lines = ('' + msg).split('\\n');\n                    for (var i = 0; i < lines.length; i++) {\n                        lines[i] = $('<div>').text(lines[i]).html();\n                    }\n                    msg = lines.join('<br>');\n                }\n                $group.addClass($.fn.editableform.errorGroupClass);\n                $block.addClass($.fn.editableform.errorBlockClass).html(msg).show();\n            }\n        },\n\n        submit: function submit(e) {\n            e.stopPropagation();\n            e.preventDefault();\n\n            //get new value from input\n            var newValue = this.input.input2value();\n\n            //validation: if validate returns string or truthy value - means error\n            //if returns object like {newValue: '...'} => submitted value is reassigned to it\n            var error = this.validate(newValue);\n            if ($.type(error) === 'object' && error.newValue !== undefined) {\n                newValue = error.newValue;\n                this.input.value2input(newValue);\n                if (typeof error.msg === 'string') {\n                    this.error(error.msg);\n                    this.showForm();\n                    return;\n                }\n            } else if (error) {\n                this.error(error);\n                this.showForm();\n                return;\n            }\n\n            //if value not changed --> trigger 'nochange' event and return\n            /*jslint eqeq: true*/\n            if (!this.options.savenochange && this.input.value2str(newValue) == this.input.value2str(this.value)) {\n                /*jslint eqeq: false*/\n                /**        \n                Fired when value not changed but form is submitted. Requires savenochange = false.\n                @event nochange \n                @param {Object} event event object\n                **/\n                this.$div.triggerHandler('nochange');\n                return;\n            }\n\n            //convert value for submitting to server\n            var submitValue = this.input.value2submit(newValue);\n\n            this.isSaving = true;\n\n            //sending data to server\n            $.when(this.save(submitValue)).done($.proxy(function (response) {\n                this.isSaving = false;\n\n                //run success callback\n                var res = typeof this.options.success === 'function' ? this.options.success.call(this.options.scope, response, newValue) : null;\n\n                //if success callback returns false --> keep form open and do not activate input\n                if (res === false) {\n                    this.error(false);\n                    this.showForm(false);\n                    return;\n                }\n\n                //if success callback returns string -->  keep form open, show error and activate input               \n                if (typeof res === 'string') {\n                    this.error(res);\n                    this.showForm();\n                    return;\n                }\n\n                //if success callback returns object like {newValue: <something>} --> use that value instead of submitted\n                //it is usefull if you want to chnage value in url-function\n                if (res && (typeof res === 'undefined' ? 'undefined' : _typeof(res)) === 'object' && res.hasOwnProperty('newValue')) {\n                    newValue = res.newValue;\n                }\n\n                //clear error message\n                this.error(false);\n                this.value = newValue;\n                /**        \n                Fired when form is submitted\n                @event save \n                @param {Object} event event object\n                @param {Object} params additional params\n                @param {mixed} params.newValue raw new value\n                @param {mixed} params.submitValue submitted value as string\n                @param {Object} params.response ajax response\n                 @example\n                $('#form-div').on('save'), function(e, params){\n                    if(params.newValue === 'username') {...}\n                });\n                **/\n                this.$div.triggerHandler('save', { newValue: newValue, submitValue: submitValue, response: response });\n            }, this)).fail($.proxy(function (xhr) {\n                this.isSaving = false;\n\n                var msg;\n                if (typeof this.options.error === 'function') {\n                    msg = this.options.error.call(this.options.scope, xhr, newValue);\n                } else {\n                    msg = typeof xhr === 'string' ? xhr : xhr.responseText || xhr.statusText || 'Unknown error!';\n                }\n\n                this.error(msg);\n                this.showForm();\n            }, this));\n        },\n\n        save: function save(submitValue) {\n            //try parse composite pk defined as json string in data-pk \n            this.options.pk = $.fn.editableutils.tryParseJson(this.options.pk, true);\n\n            var pk = typeof this.options.pk === 'function' ? this.options.pk.call(this.options.scope) : this.options.pk,\n\n            /*\n              send on server in following cases:\n              1. url is function\n              2. url is string AND (pk defined OR send option = always) \n            */\n            send = !!(typeof this.options.url === 'function' || this.options.url && (this.options.send === 'always' || this.options.send === 'auto' && pk !== null && pk !== undefined)),\n                params;\n\n            if (send) {\n                //send to server\n                this.showLoading();\n\n                //standard params\n                params = {\n                    name: this.options.name || '',\n                    value: submitValue,\n                    pk: pk\n                };\n\n                //additional params\n                if (typeof this.options.params === 'function') {\n                    params = this.options.params.call(this.options.scope, params);\n                } else {\n                    //try parse json in single quotes (from data-params attribute)\n                    this.options.params = $.fn.editableutils.tryParseJson(this.options.params, true);\n                    $.extend(params, this.options.params);\n                }\n\n                if (typeof this.options.url === 'function') {\n                    //user's function\n                    return this.options.url.call(this.options.scope, params);\n                } else {\n                    //send ajax to server and return deferred object\n                    return $.ajax($.extend({\n                        url: this.options.url,\n                        data: params,\n                        type: 'POST'\n                    }, this.options.ajaxOptions));\n                }\n            }\n        },\n\n        validate: function validate(value) {\n            if (value === undefined) {\n                value = this.value;\n            }\n            if (typeof this.options.validate === 'function') {\n                return this.options.validate.call(this.options.scope, value);\n            }\n        },\n\n        option: function option(key, value) {\n            if (key in this.options) {\n                this.options[key] = value;\n            }\n\n            if (key === 'value') {\n                this.setValue(value);\n            }\n\n            //do not pass option to input as it is passed in editable-element\n        },\n\n        setValue: function setValue(value, convertStr) {\n            if (convertStr) {\n                this.value = this.input.str2value(value);\n            } else {\n                this.value = value;\n            }\n\n            //if form is visible, update input\n            if (this.$form && this.$form.is(':visible')) {\n                this.input.value2input(this.value);\n            }\n        }\n    };\n\n    /*\n    Initialize editableform. Applied to jQuery object.\n     @method $().editableform(options)\n    @params {Object} options\n    @example\n    var $form = $('&lt;div&gt;').editableform({\n        type: 'text',\n        name: 'username',\n        url: '/post',\n        value: 'vitaliy'\n    });\n     //to display form you should call 'render' method\n    $form.editableform('render');     \n    */\n    $.fn.editableform = function (option) {\n        var args = arguments;\n        return this.each(function () {\n            var $this = $(this),\n                data = $this.data('editableform'),\n                options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) === 'object' && option;\n            if (!data) {\n                $this.data('editableform', data = new EditableForm(this, options));\n            }\n\n            if (typeof option === 'string') {\n                //call method \n                data[option].apply(data, Array.prototype.slice.call(args, 1));\n            }\n        });\n    };\n\n    //keep link to constructor to allow inheritance\n    $.fn.editableform.Constructor = EditableForm;\n\n    //defaults\n    $.fn.editableform.defaults = {\n        /* see also defaults for input */\n\n        /**\n        Type of input. Can be <code>text|textarea|select|date|checklist</code>\n         @property type \n        @type string\n        @default 'text'\n        **/\n        type: 'text',\n        /**\n        Url for submit, e.g. <code>'/post'</code>  \n        If function - it will be called instead of ajax. Function should return deferred object to run fail/done callbacks.\n         @property url \n        @type string|function\n        @default null\n        @example\n        url: function(params) {\n            var d = new $.Deferred;\n            if(params.value === 'abc') {\n                return d.reject('error message'); //returning error via deferred object\n            } else {\n                //async saving data in js model\n                someModel.asyncSaveMethod({\n                   ..., \n                   success: function(){\n                      d.resolve();\n                   }\n                }); \n                return d.promise();\n            }\n        } \n        **/\n        url: null,\n        /**\n        Additional params for submit. If defined as <code>object</code> - it is **appended** to original ajax data (pk, name and value).  \n        If defined as <code>function</code> - returned object **overwrites** original ajax data.\n        @example\n        params: function(params) {\n            //originally params contain pk, name and value\n            params.a = 1;\n            return params;\n        }\n         @property params \n        @type object|function\n        @default null\n        **/\n        params: null,\n        /**\n        Name of field. Will be submitted on server. Can be taken from <code>id</code> attribute\n         @property name \n        @type string\n        @default null\n        **/\n        name: null,\n        /**\n        Primary key of editable object (e.g. record id in database). For composite keys use object, e.g. <code>{id: 1, lang: 'en'}</code>.\n        Can be calculated dynamically via function.\n         @property pk \n        @type string|object|function\n        @default null\n        **/\n        pk: null,\n        /**\n        Initial value. If not defined - will be taken from element's content.\n        For __select__ type should be defined (as it is ID of shown text).\n         @property value \n        @type string|object\n        @default null\n        **/\n        value: null,\n        /**\n        Value that will be displayed in input if original field value is empty (`null|undefined|''`).\n         @property defaultValue \n        @type string|object\n        @default null\n        @since 1.4.6\n        **/\n        defaultValue: null,\n        /**\n        Strategy for sending data on server. Can be `auto|always|never`.\n        When 'auto' data will be sent on server **only if pk and url defined**, otherwise new value will be stored locally.\n         @property send \n        @type string\n        @default 'auto'\n        **/\n        send: 'auto',\n        /**\n        Function for client-side validation. If returns string - means validation not passed and string showed as error.\n        Since 1.5.1 you can modify submitted value by returning object from `validate`: \n        `{newValue: '...'}` or `{newValue: '...', msg: '...'}`\n         @property validate \n        @type function\n        @default null\n        @example\n        validate: function(value) {\n            if($.trim(value) == '') {\n                return 'This field is required';\n            }\n        }\n        **/\n        validate: null,\n        /**\n        Success callback. Called when value successfully sent on server and **response status = 200**.  \n        Usefull to work with json response. For example, if your backend response can be <code>{success: true}</code>\n        or <code>{success: false, msg: \"server error\"}</code> you can check it inside this callback.  \n        If it returns **string** - means error occured and string is shown as error message.  \n        If it returns **object like** <code>{newValue: &lt;something&gt;}</code> - it overwrites value, submitted by user.  \n        Otherwise newValue simply rendered into element.\n        \n        @property success \n        @type function\n        @default null\n        @example\n        success: function(response, newValue) {\n            if(!response.success) return response.msg;\n        }\n        **/\n        success: null,\n        /**\n        Error callback. Called when request failed (response status != 200).  \n        Usefull when you want to parse error response and display a custom message.\n        Must return **string** - the message to be displayed in the error block.\n                \n        @property error \n        @type function\n        @default null\n        @since 1.4.4\n        @example\n        error: function(response, newValue) {\n            if(response.status === 500) {\n                return 'Service unavailable. Please try later.';\n            } else {\n                return response.responseText;\n            }\n        }\n        **/\n        error: null,\n        /**\n        Additional options for submit ajax request.\n        List of values: http://api.jquery.com/jQuery.ajax\n        \n        @property ajaxOptions \n        @type object\n        @default null\n        @since 1.1.1        \n        @example \n        ajaxOptions: {\n            type: 'put',\n            dataType: 'json'\n        }        \n        **/\n        ajaxOptions: null,\n        /**\n        Where to show buttons: left(true)|bottom|false  \n        Form without buttons is auto-submitted.\n         @property showbuttons \n        @type boolean|string\n        @default true\n        @since 1.1.1\n        **/\n        showbuttons: true,\n        /**\n        Scope for callback methods (success, validate).  \n        If <code>null</code> means editableform instance itself. \n         @property scope \n        @type DOMElement|object\n        @default null\n        @since 1.2.0\n        @private\n        **/\n        scope: null,\n        /**\n        Whether to save or cancel value when it was not changed but form was submitted\n         @property savenochange \n        @type boolean\n        @default false\n        @since 1.2.0\n        **/\n        savenochange: false\n    };\n\n    /*\n    Note: following params could redefined in engine: bootstrap or jqueryui:\n    Classes 'control-group' and 'editable-error-block' must always present!\n    */\n    $.fn.editableform.template = '<form class=\"form-inline editableform\">' + '<div class=\"control-group\">' + '<div><div class=\"editable-input\"></div><div class=\"editable-buttons\"></div></div>' + '<div class=\"editable-error-block\"></div>' + '</div>' + '</form>';\n\n    //loading div\n    $.fn.editableform.loading = '<div class=\"editableform-loading\"></div>';\n\n    //buttons\n    $.fn.editableform.buttons = '<button type=\"submit\" class=\"editable-submit\">ok</button>' + '<button type=\"button\" class=\"editable-cancel\">cancel</button>';\n\n    //error class attached to control-group\n    $.fn.editableform.errorGroupClass = null;\n\n    //error class attached to editable-error-block\n    $.fn.editableform.errorBlockClass = 'editable-error';\n\n    //engine\n    $.fn.editableform.engine = 'jquery';\n})(window.jQuery);\n\n/**\n* EditableForm utilites\n*/\n(function ($) {\n\n    //utils\n    $.fn.editableutils = {\n        /**\n        * classic JS inheritance function\n        */\n        inherit: function inherit(Child, Parent) {\n            var F = function F() {};\n            F.prototype = Parent.prototype;\n            Child.prototype = new F();\n            Child.prototype.constructor = Child;\n            Child.superclass = Parent.prototype;\n        },\n\n        /**\n        * set caret position in input\n        * see http://stackoverflow.com/questions/499126/jquery-set-cursor-position-in-text-area\n        */\n        setCursorPosition: function setCursorPosition(elem, pos) {\n            if (elem.setSelectionRange) {\n                elem.setSelectionRange(pos, pos);\n            } else if (elem.createTextRange) {\n                var range = elem.createTextRange();\n                range.collapse(true);\n                range.moveEnd('character', pos);\n                range.moveStart('character', pos);\n                range.select();\n            }\n        },\n\n        /**\n        * function to parse JSON in *single* quotes. (jquery automatically parse only double quotes)\n        * That allows such code as: <a data-source=\"{'a': 'b', 'c': 'd'}\">\n        * safe = true --> means no exception will be thrown\n        * for details see http://stackoverflow.com/questions/7410348/how-to-set-json-format-to-html5-data-attributes-in-the-jquery\n        */\n        tryParseJson: function tryParseJson(s, safe) {\n            if (typeof s === 'string' && s.length && s.match(/^[\\{\\[].*[\\}\\]]$/)) {\n                if (safe) {\n                    try {\n                        /*jslint evil: true*/\n                        s = new Function('return ' + s)();\n                        /*jslint evil: false*/\n                    } catch (e) {} finally {\n                        return s;\n                    }\n                } else {\n                    /*jslint evil: true*/\n                    s = new Function('return ' + s)();\n                    /*jslint evil: false*/\n                }\n            }\n            return s;\n        },\n\n        /**\n        * slice object by specified keys\n        */\n        sliceObj: function sliceObj(obj, keys, caseSensitive /* default: false */) {\n            var key,\n                keyLower,\n                newObj = {};\n\n            if (!$.isArray(keys) || !keys.length) {\n                return newObj;\n            }\n\n            for (var i = 0; i < keys.length; i++) {\n                key = keys[i];\n                if (obj.hasOwnProperty(key)) {\n                    newObj[key] = obj[key];\n                }\n\n                if (caseSensitive === true) {\n                    continue;\n                }\n\n                //when getting data-* attributes via $.data() it's converted to lowercase.\n                //details: http://stackoverflow.com/questions/7602565/using-data-attributes-with-jquery\n                //workaround is code below.\n                keyLower = key.toLowerCase();\n                if (obj.hasOwnProperty(keyLower)) {\n                    newObj[key] = obj[keyLower];\n                }\n            }\n\n            return newObj;\n        },\n\n        /*\n        exclude complex objects from $.data() before pass to config\n        */\n        getConfigData: function getConfigData($element) {\n            var data = {};\n            $.each($element.data(), function (k, v) {\n                if ((typeof v === 'undefined' ? 'undefined' : _typeof(v)) !== 'object' || v && (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' && (v.constructor === Object || v.constructor === Array)) {\n                    data[k] = v;\n                }\n            });\n            return data;\n        },\n\n        /*\n         returns keys of object\n        */\n        objectKeys: function objectKeys(o) {\n            if (Object.keys) {\n                return Object.keys(o);\n            } else {\n                if (o !== Object(o)) {\n                    throw new TypeError('Object.keys called on a non-object');\n                }\n                var k = [],\n                    p;\n                for (p in o) {\n                    if (Object.prototype.hasOwnProperty.call(o, p)) {\n                        k.push(p);\n                    }\n                }\n                return k;\n            }\n        },\n\n        /**\n         method to escape html.\n        **/\n        escape: function escape(str) {\n            return $('<div>').text(str).html();\n        },\n\n        /*\n         returns array items from sourceData having value property equal or inArray of 'value'\n        */\n        itemsByValue: function itemsByValue(value, sourceData, valueProp) {\n            if (!sourceData || value === null) {\n                return [];\n            }\n\n            if (typeof valueProp !== \"function\") {\n                var idKey = valueProp || 'value';\n                valueProp = function valueProp(e) {\n                    return e[idKey];\n                };\n            }\n\n            var isValArray = $.isArray(value),\n                result = [],\n                that = this;\n\n            $.each(sourceData, function (i, o) {\n                if (o.children) {\n                    result = result.concat(that.itemsByValue(value, o.children, valueProp));\n                } else {\n                    /*jslint eqeq: true*/\n                    if (isValArray) {\n                        if ($.grep(value, function (v) {\n                            return v == (o && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' ? valueProp(o) : o);\n                        }).length) {\n                            result.push(o);\n                        }\n                    } else {\n                        var itemValue = o && (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' ? valueProp(o) : o;\n                        if (value == itemValue) {\n                            result.push(o);\n                        }\n                    }\n                    /*jslint eqeq: false*/\n                }\n            });\n\n            return result;\n        },\n\n        /*\n        Returns input by options: type, mode. \n        */\n        createInput: function createInput(options) {\n            var TypeConstructor,\n                typeOptions,\n                input,\n                type = options.type;\n\n            //`date` is some kind of virtual type that is transformed to one of exact types\n            //depending on mode and core lib\n            if (type === 'date') {\n                //inline\n                if (options.mode === 'inline') {\n                    if ($.fn.editabletypes.datefield) {\n                        type = 'datefield';\n                    } else if ($.fn.editabletypes.dateuifield) {\n                        type = 'dateuifield';\n                    }\n                    //popup\n                } else {\n                    if ($.fn.editabletypes.date) {\n                        type = 'date';\n                    } else if ($.fn.editabletypes.dateui) {\n                        type = 'dateui';\n                    }\n                }\n\n                //if type still `date` and not exist in types, replace with `combodate` that is base input\n                if (type === 'date' && !$.fn.editabletypes.date) {\n                    type = 'combodate';\n                }\n            }\n\n            //`datetime` should be datetimefield in 'inline' mode\n            if (type === 'datetime' && options.mode === 'inline') {\n                type = 'datetimefield';\n            }\n\n            //change wysihtml5 to textarea for jquery UI and plain versions\n            if (type === 'wysihtml5' && !$.fn.editabletypes[type]) {\n                type = 'textarea';\n            }\n\n            //create input of specified type. Input will be used for converting value, not in form\n            if (typeof $.fn.editabletypes[type] === 'function') {\n                TypeConstructor = $.fn.editabletypes[type];\n                typeOptions = this.sliceObj(options, this.objectKeys(TypeConstructor.defaults));\n                input = new TypeConstructor(typeOptions);\n                return input;\n            } else {\n                $.error('Unknown type: ' + type);\n                return false;\n            }\n        },\n\n        //see http://stackoverflow.com/questions/7264899/detect-css-transitions-using-javascript-and-without-modernizr\n        supportsTransitions: function supportsTransitions() {\n            var b = document.body || document.documentElement,\n                s = b.style,\n                p = 'transition',\n                v = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'];\n\n            if (typeof s[p] === 'string') {\n                return true;\n            }\n\n            // Tests for vendor specific prop\n            p = p.charAt(0).toUpperCase() + p.substr(1);\n            for (var i = 0; i < v.length; i++) {\n                if (typeof s[v[i] + p] === 'string') {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n    };\n})(window.jQuery);\n\n/**\nAttaches stand-alone container with editable-form to HTML element. Element is used only for positioning, value is not stored anywhere.<br>\nThis method applied internally in <code>$().editable()</code>. You should subscribe on it's events (save / cancel) to get profit of it.<br>\nFinal realization can be different: bootstrap-popover, jqueryui-tooltip, poshytip, inline-div. It depends on which js file you include.<br>\nApplied as jQuery method.\n\n@class editableContainer\n@uses editableform\n**/\n(function ($) {\n\n    var Popup = function Popup(element, options) {\n        this.init(element, options);\n    };\n\n    var Inline = function Inline(element, options) {\n        this.init(element, options);\n    };\n\n    //methods\n    Popup.prototype = {\n        containerName: null, //method to call container on element\n        containerDataName: null, //object name in element's .data()\n        innerCss: null, //tbd in child class\n        containerClass: 'editable-container editable-popup', //css class applied to container element\n        defaults: {}, //container itself defaults\n\n        init: function init(element, options) {\n            this.$element = $(element);\n            //since 1.4.1 container do not use data-* directly as they already merged into options.\n            this.options = $.extend({}, $.fn.editableContainer.defaults, options);\n            this.splitOptions();\n\n            //set scope of form callbacks to element\n            this.formOptions.scope = this.$element[0];\n\n            this.initContainer();\n\n            //flag to hide container, when saving value will finish\n            this.delayedHide = false;\n\n            //bind 'destroyed' listener to destroy container when element is removed from dom\n            this.$element.on('destroyed', $.proxy(function () {\n                this.destroy();\n            }, this));\n\n            //attach document handler to close containers on click / escape\n            if (!$(document).data('editable-handlers-attached')) {\n                //close all on escape\n                $(document).on('keyup.editable', function (e) {\n                    if (e.which === 27) {\n                        $('.editable-open').editableContainer('hide');\n                        //todo: return focus on element \n                    }\n                });\n\n                //close containers when click outside \n                //(mousedown could be better than click, it closes everything also on drag drop)\n                $(document).on('click.editable', function (e) {\n                    var $target = $(e.target),\n                        i,\n                        exclude_classes = ['.editable-container', '.ui-datepicker-header', '.datepicker', //in inline mode datepicker is rendered into body\n                    '.modal-backdrop', '.bootstrap-wysihtml5-insert-image-modal', '.bootstrap-wysihtml5-insert-link-modal'];\n\n                    //check if element is detached. It occurs when clicking in bootstrap datepicker\n                    if (!$.contains(document.documentElement, e.target)) {\n                        return;\n                    }\n\n                    //for some reason FF 20 generates extra event (click) in select2 widget with e.target = document\n                    //we need to filter it via construction below. See https://github.com/vitalets/x-editable/issues/199\n                    //Possibly related to http://stackoverflow.com/questions/10119793/why-does-firefox-react-differently-from-webkit-and-ie-to-click-event-on-selec\n                    if ($target.is(document)) {\n                        return;\n                    }\n\n                    //if click inside one of exclude classes --> no nothing\n                    for (i = 0; i < exclude_classes.length; i++) {\n                        if ($target.is(exclude_classes[i]) || $target.parents(exclude_classes[i]).length) {\n                            return;\n                        }\n                    }\n\n                    //close all open containers (except one - target)\n                    Popup.prototype.closeOthers(e.target);\n                });\n\n                $(document).data('editable-handlers-attached', true);\n            }\n        },\n\n        //split options on containerOptions and formOptions\n        splitOptions: function splitOptions() {\n            this.containerOptions = {};\n            this.formOptions = {};\n\n            if (!$.fn[this.containerName]) {\n                throw new Error(this.containerName + ' not found. Have you included corresponding js file?');\n            }\n\n            //keys defined in container defaults go to container, others go to form\n            for (var k in this.options) {\n                if (k in this.defaults) {\n                    this.containerOptions[k] = this.options[k];\n                } else {\n                    this.formOptions[k] = this.options[k];\n                }\n            }\n        },\n\n        /*\n        Returns jquery object of container\n        @method tip()\n        */\n        tip: function tip() {\n            return this.container() ? this.container().$tip : null;\n        },\n\n        /* returns container object */\n        container: function container() {\n            var container;\n            //first, try get it by `containerDataName`\n            if (this.containerDataName) {\n                if (container = this.$element.data(this.containerDataName)) {\n                    return container;\n                }\n            }\n            //second, try `containerName`\n            container = this.$element.data(this.containerName);\n            return container;\n        },\n\n        /* call native method of underlying container, e.g. this.$element.popover('method') */\n        call: function call() {\n            this.$element[this.containerName].apply(this.$element, arguments);\n        },\n\n        initContainer: function initContainer() {\n            this.call(this.containerOptions);\n        },\n\n        renderForm: function renderForm() {\n            this.$form.editableform(this.formOptions).on({\n                save: $.proxy(this.save, this), //click on submit button (value changed)\n                nochange: $.proxy(function () {\n                    this.hide('nochange');\n                }, this), //click on submit button (value NOT changed)                \n                cancel: $.proxy(function () {\n                    this.hide('cancel');\n                }, this), //click on calcel button\n                show: $.proxy(function () {\n                    if (this.delayedHide) {\n                        this.hide(this.delayedHide.reason);\n                        this.delayedHide = false;\n                    } else {\n                        this.setPosition();\n                    }\n                }, this), //re-position container every time form is shown (occurs each time after loading state)\n                rendering: $.proxy(this.setPosition, this), //this allows to place container correctly when loading shown\n                resize: $.proxy(this.setPosition, this), //this allows to re-position container when form size is changed \n                rendered: $.proxy(function () {\n                    /**        \n                    Fired when container is shown and form is rendered (for select will wait for loading dropdown options).  \n                    **Note:** Bootstrap popover has own `shown` event that now cannot be separated from x-editable's one.\n                    The workaround is to check `arguments.length` that is always `2` for x-editable.                     \n                    \n                    @event shown \n                    @param {Object} event event object\n                    @example\n                    $('#username').on('shown', function(e, editable) {\n                        editable.input.$input.val('overwriting value of input..');\n                    });                     \n                    **/\n                    /*\n                     TODO: added second param mainly to distinguish from bootstrap's shown event. It's a hotfix that will be solved in future versions via namespaced events.  \n                    */\n                    this.$element.triggerHandler('shown', $(this.options.scope).data('editable'));\n                }, this)\n            }).editableform('render');\n        },\n\n        /**\n        Shows container with form\n        @method show()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/\n        /* Note: poshytip owerwrites this method totally! */\n        show: function show(closeAll) {\n            this.$element.addClass('editable-open');\n            if (closeAll !== false) {\n                //close all open containers (except this)\n                this.closeOthers(this.$element[0]);\n            }\n\n            //show container itself\n            this.innerShow();\n            this.tip().addClass(this.containerClass);\n\n            /*\n            Currently, form is re-rendered on every show. \n            The main reason is that we dont know, what will container do with content when closed:\n            remove(), detach() or just hide() - it depends on container.\n            \n            Detaching form itself before hide and re-insert before show is good solution, \n            but visually it looks ugly --> container changes size before hide.  \n            */\n\n            //if form already exist - delete previous data \n            if (this.$form) {\n                //todo: destroy prev data!\n                //this.$form.destroy();\n            }\n\n            this.$form = $('<div>');\n\n            //insert form into container body\n            if (this.tip().is(this.innerCss)) {\n                //for inline container\n                this.tip().append(this.$form);\n            } else {\n                this.tip().find(this.innerCss).append(this.$form);\n            }\n\n            //render form\n            this.renderForm();\n        },\n\n        /**\n        Hides container with form\n        @method hide()\n        @param {string} reason Reason caused hiding. Can be <code>save|cancel|onblur|nochange|undefined (=manual)</code>\n        **/\n        hide: function hide(reason) {\n            if (!this.tip() || !this.tip().is(':visible') || !this.$element.hasClass('editable-open')) {\n                return;\n            }\n\n            //if form is saving value, schedule hide\n            if (this.$form.data('editableform').isSaving) {\n                this.delayedHide = { reason: reason };\n                return;\n            } else {\n                this.delayedHide = false;\n            }\n\n            this.$element.removeClass('editable-open');\n            this.innerHide();\n\n            /**\n            Fired when container was hidden. It occurs on both save or cancel.  \n            **Note:** Bootstrap popover has own `hidden` event that now cannot be separated from x-editable's one.\n            The workaround is to check `arguments.length` that is always `2` for x-editable. \n             @event hidden \n            @param {object} event event object\n            @param {string} reason Reason caused hiding. Can be <code>save|cancel|onblur|nochange|manual</code>\n            @example\n            $('#username').on('hidden', function(e, reason) {\n                if(reason === 'save' || reason === 'cancel') {\n                    //auto-open next editable\n                    $(this).closest('tr').next().find('.editable').editable('show');\n                } \n            });\n            **/\n            this.$element.triggerHandler('hidden', reason || 'manual');\n        },\n\n        /* internal show method. To be overwritten in child classes */\n        innerShow: function innerShow() {},\n\n        /* internal hide method. To be overwritten in child classes */\n        innerHide: function innerHide() {},\n\n        /**\n        Toggles container visibility (show / hide)\n        @method toggle()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/\n        toggle: function toggle(closeAll) {\n            if (this.container() && this.tip() && this.tip().is(':visible')) {\n                this.hide();\n            } else {\n                this.show(closeAll);\n            }\n        },\n\n        /*\n        Updates the position of container when content changed.\n        @method setPosition()\n        */\n        setPosition: function setPosition() {\n            //tbd in child class\n        },\n\n        save: function save(e, params) {\n            /**        \n            Fired when new value was submitted. You can use <code>$(this).data('editableContainer')</code> inside handler to access to editableContainer instance\n            \n            @event save \n            @param {Object} event event object\n            @param {Object} params additional params\n            @param {mixed} params.newValue submitted value\n            @param {Object} params.response ajax response\n            @example\n            $('#username').on('save', function(e, params) {\n                //assuming server response: '{success: true}'\n                var pk = $(this).data('editableContainer').options.pk;\n                if(params.response && params.response.success) {\n                    alert('value: ' + params.newValue + ' with pk: ' + pk + ' saved!');\n                } else {\n                    alert('error!'); \n                } \n            });\n            **/\n            this.$element.triggerHandler('save', params);\n\n            //hide must be after trigger, as saving value may require methods of plugin, applied to input\n            this.hide('save');\n        },\n\n        /**\n        Sets new option\n        \n        @method option(key, value)\n        @param {string} key \n        @param {mixed} value \n        **/\n        option: function option(key, value) {\n            this.options[key] = value;\n            if (key in this.containerOptions) {\n                this.containerOptions[key] = value;\n                this.setContainerOption(key, value);\n            } else {\n                this.formOptions[key] = value;\n                if (this.$form) {\n                    this.$form.editableform('option', key, value);\n                }\n            }\n        },\n\n        setContainerOption: function setContainerOption(key, value) {\n            this.call('option', key, value);\n        },\n\n        /**\n        Destroys the container instance\n        @method destroy()\n        **/\n        destroy: function destroy() {\n            this.hide();\n            this.innerDestroy();\n            this.$element.off('destroyed');\n            this.$element.removeData('editableContainer');\n        },\n\n        /* to be overwritten in child classes */\n        innerDestroy: function innerDestroy() {},\n\n        /*\n        Closes other containers except one related to passed element. \n        Other containers can be cancelled or submitted (depends on onblur option)\n        */\n        closeOthers: function closeOthers(element) {\n            $('.editable-open').each(function (i, el) {\n                //do nothing with passed element and it's children\n                if (el === element || $(el).find(element).length) {\n                    return;\n                }\n\n                //otherwise cancel or submit all open containers \n                var $el = $(el),\n                    ec = $el.data('editableContainer');\n\n                if (!ec) {\n                    return;\n                }\n\n                if (ec.options.onblur === 'cancel') {\n                    $el.data('editableContainer').hide('onblur');\n                } else if (ec.options.onblur === 'submit') {\n                    $el.data('editableContainer').tip().find('form').submit();\n                }\n            });\n        },\n\n        /**\n        Activates input of visible container (e.g. set focus)\n        @method activate()\n        **/\n        activate: function activate() {\n            if (this.tip && this.tip().is(':visible') && this.$form) {\n                this.$form.data('editableform').input.activate();\n            }\n        }\n\n    };\n\n    /**\n    jQuery method to initialize editableContainer.\n    \n    @method $().editableContainer(options)\n    @params {Object} options\n    @example\n    $('#edit').editableContainer({\n        type: 'text',\n        url: '/post',\n        pk: 1,\n        value: 'hello'\n    });\n    **/\n    $.fn.editableContainer = function (option) {\n        var args = arguments;\n        return this.each(function () {\n            var $this = $(this),\n                dataKey = 'editableContainer',\n                data = $this.data(dataKey),\n                options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) === 'object' && option,\n                Constructor = options.mode === 'inline' ? Inline : Popup;\n\n            if (!data) {\n                $this.data(dataKey, data = new Constructor(this, options));\n            }\n\n            if (typeof option === 'string') {\n                //call method \n                data[option].apply(data, Array.prototype.slice.call(args, 1));\n            }\n        });\n    };\n\n    //store constructors\n    $.fn.editableContainer.Popup = Popup;\n    $.fn.editableContainer.Inline = Inline;\n\n    //defaults\n    $.fn.editableContainer.defaults = {\n        /**\n        Initial value of form input\n         @property value \n        @type mixed\n        @default null\n        @private\n        **/\n        value: null,\n        /**\n        Placement of container relative to element. Can be <code>top|right|bottom|left</code>. Not used for inline container.\n         @property placement \n        @type string\n        @default 'top'\n        **/\n        placement: 'top',\n        /**\n        Whether to hide container on save/cancel.\n         @property autohide \n        @type boolean\n        @default true\n        @private \n        **/\n        autohide: true,\n        /**\n        Action when user clicks outside the container. Can be <code>cancel|submit|ignore</code>.  \n        Setting <code>ignore</code> allows to have several containers open. \n         @property onblur \n        @type string\n        @default 'cancel'\n        @since 1.1.1\n        **/\n        onblur: 'cancel',\n\n        /**\n        Animation speed (inline mode only)\n        @property anim \n        @type string\n        @default false\n        **/\n        anim: false,\n\n        /**\n        Mode of editable, can be `popup` or `inline` \n        \n        @property mode \n        @type string         \n        @default 'popup'\n        @since 1.4.0        \n        **/\n        mode: 'popup'\n    };\n\n    /* \n    * workaround to have 'destroyed' event to destroy popover when element is destroyed\n    * see http://stackoverflow.com/questions/2200494/jquery-trigger-event-when-an-element-is-removed-from-the-dom\n    */\n    jQuery.event.special.destroyed = {\n        remove: function remove(o) {\n            if (o.handler) {\n                o.handler();\n            }\n        }\n    };\n})(window.jQuery);\n\n/**\n* Editable Inline \n* ---------------------\n*/\n(function ($) {\n\n    //copy prototype from EditableContainer\n    //extend methods\n    $.extend($.fn.editableContainer.Inline.prototype, $.fn.editableContainer.Popup.prototype, {\n        containerName: 'editableform',\n        innerCss: '.editable-inline',\n        containerClass: 'editable-container editable-inline', //css class applied to container element\n\n        initContainer: function initContainer() {\n            //container is <span> element\n            this.$tip = $('<span></span>');\n\n            //convert anim to miliseconds (int)\n            if (!this.options.anim) {\n                this.options.anim = 0;\n            }\n        },\n\n        splitOptions: function splitOptions() {\n            //all options are passed to form\n            this.containerOptions = {};\n            this.formOptions = this.options;\n        },\n\n        tip: function tip() {\n            return this.$tip;\n        },\n\n        innerShow: function innerShow() {\n            this.$element.hide();\n            this.tip().insertAfter(this.$element).show();\n        },\n\n        innerHide: function innerHide() {\n            this.$tip.hide(this.options.anim, $.proxy(function () {\n                this.$element.show();\n                this.innerDestroy();\n            }, this));\n        },\n\n        innerDestroy: function innerDestroy() {\n            if (this.tip()) {\n                this.tip().empty().remove();\n            }\n        }\n    });\n})(window.jQuery);\n/**\nMakes editable any HTML element on the page. Applied as jQuery method.\n\n@class editable\n@uses editableContainer\n**/\n(function ($) {\n\n    var Editable = function Editable(element, options) {\n        this.$element = $(element);\n        //data-* has more priority over js options: because dynamically created elements may change data-* \n        this.options = $.extend({}, $.fn.editable.defaults, options, $.fn.editableutils.getConfigData(this.$element));\n        if (this.options.selector) {\n            this.initLive();\n        } else {\n            this.init();\n        }\n\n        //check for transition support\n        if (this.options.highlight && !$.fn.editableutils.supportsTransitions()) {\n            this.options.highlight = false;\n        }\n    };\n\n    Editable.prototype = {\n        constructor: Editable,\n        init: function init() {\n            var isValueByText = false,\n                doAutotext,\n                finalize;\n\n            //name\n            this.options.name = this.options.name || this.$element.attr('id');\n\n            //create input of specified type. Input needed already here to convert value for initial display (e.g. show text by id for select)\n            //also we set scope option to have access to element inside input specific callbacks (e. g. source as function)\n            this.options.scope = this.$element[0];\n            this.input = $.fn.editableutils.createInput(this.options);\n            if (!this.input) {\n                return;\n            }\n\n            //set value from settings or by element's text\n            if (this.options.value === undefined || this.options.value === null) {\n                this.value = this.input.html2value($.trim(this.$element.html()));\n                isValueByText = true;\n            } else {\n                /*\n                  value can be string when received from 'data-value' attribute\n                  for complext objects value can be set as json string in data-value attribute, \n                  e.g. data-value=\"{city: 'Moscow', street: 'Lenina'}\"\n                */\n                this.options.value = $.fn.editableutils.tryParseJson(this.options.value, true);\n                if (typeof this.options.value === 'string') {\n                    this.value = this.input.str2value(this.options.value);\n                } else {\n                    this.value = this.options.value;\n                }\n            }\n\n            //add 'editable' class to every editable element\n            this.$element.addClass('editable');\n\n            //specifically for \"textarea\" add class .editable-pre-wrapped to keep linebreaks\n            if (this.input.type === 'textarea') {\n                this.$element.addClass('editable-pre-wrapped');\n            }\n\n            //attach handler activating editable. In disabled mode it just prevent default action (useful for links)\n            if (this.options.toggle !== 'manual') {\n                this.$element.addClass('editable-click');\n                this.$element.on(this.options.toggle + '.editable', $.proxy(function (e) {\n                    //prevent following link if editable enabled\n                    if (!this.options.disabled) {\n                        e.preventDefault();\n                    }\n\n                    //stop propagation not required because in document click handler it checks event target\n                    //e.stopPropagation();\n\n                    if (this.options.toggle === 'mouseenter') {\n                        //for hover only show container\n                        this.show();\n                    } else {\n                        //when toggle='click' we should not close all other containers as they will be closed automatically in document click listener\n                        var closeAll = this.options.toggle !== 'click';\n                        this.toggle(closeAll);\n                    }\n                }, this));\n            } else {\n                this.$element.attr('tabindex', -1); //do not stop focus on element when toggled manually\n            }\n\n            //if display is function it's far more convinient to have autotext = always to render correctly on init\n            //see https://github.com/vitalets/x-editable-yii/issues/34\n            if (typeof this.options.display === 'function') {\n                this.options.autotext = 'always';\n            }\n\n            //check conditions for autotext:\n            switch (this.options.autotext) {\n                case 'always':\n                    doAutotext = true;\n                    break;\n                case 'auto':\n                    //if element text is empty and value is defined and value not generated by text --> run autotext\n                    doAutotext = !$.trim(this.$element.text()).length && this.value !== null && this.value !== undefined && !isValueByText;\n                    break;\n                default:\n                    doAutotext = false;\n            }\n\n            //depending on autotext run render() or just finilize init\n            $.when(doAutotext ? this.render() : true).then($.proxy(function () {\n                if (this.options.disabled) {\n                    this.disable();\n                } else {\n                    this.enable();\n                }\n                /**        \n                Fired when element was initialized by `$().editable()` method. \n                Please note that you should setup `init` handler **before** applying `editable`. \n                               \n                @event init \n                @param {Object} event event object\n                @param {Object} editable editable instance (as here it cannot accessed via data('editable'))\n                @since 1.2.0\n                @example\n                $('#username').on('init', function(e, editable) {\n                    alert('initialized ' + editable.options.name);\n                });\n                $('#username').editable();\n                **/\n                this.$element.triggerHandler('init', this);\n            }, this));\n        },\n\n        /*\n         Initializes parent element for live editables \n        */\n        initLive: function initLive() {\n            //store selector \n            var selector = this.options.selector;\n            //modify options for child elements\n            this.options.selector = false;\n            this.options.autotext = 'never';\n            //listen toggle events\n            this.$element.on(this.options.toggle + '.editable', selector, $.proxy(function (e) {\n                var $target = $(e.target);\n                if (!$target.data('editable')) {\n                    //if delegated element initially empty, we need to clear it's text (that was manually set to `empty` by user)\n                    //see https://github.com/vitalets/x-editable/issues/137 \n                    if ($target.hasClass(this.options.emptyclass)) {\n                        $target.empty();\n                    }\n                    $target.editable(this.options).trigger(e);\n                }\n            }, this));\n        },\n\n        /*\n        Renders value into element's text.\n        Can call custom display method from options.\n        Can return deferred object.\n        @method render()\n        @param {mixed} response server response (if exist) to pass into display function\n        */\n        render: function render(response) {\n            //do not display anything\n            if (this.options.display === false) {\n                return;\n            }\n\n            //if input has `value2htmlFinal` method, we pass callback in third param to be called when source is loaded\n            if (this.input.value2htmlFinal) {\n                return this.input.value2html(this.value, this.$element[0], this.options.display, response);\n                //if display method defined --> use it    \n            } else if (typeof this.options.display === 'function') {\n                return this.options.display.call(this.$element[0], this.value, response);\n                //else use input's original value2html() method    \n            } else {\n                return this.input.value2html(this.value, this.$element[0]);\n            }\n        },\n\n        /**\n        Enables editable\n        @method enable()\n        **/\n        enable: function enable() {\n            this.options.disabled = false;\n            this.$element.removeClass('editable-disabled');\n            this.handleEmpty(this.isEmpty);\n            if (this.options.toggle !== 'manual') {\n                if (this.$element.attr('tabindex') === '-1') {\n                    this.$element.removeAttr('tabindex');\n                }\n            }\n        },\n\n        /**\n        Disables editable\n        @method disable()\n        **/\n        disable: function disable() {\n            this.options.disabled = true;\n            this.hide();\n            this.$element.addClass('editable-disabled');\n            this.handleEmpty(this.isEmpty);\n            //do not stop focus on this element\n            this.$element.attr('tabindex', -1);\n        },\n\n        /**\n        Toggles enabled / disabled state of editable element\n        @method toggleDisabled()\n        **/\n        toggleDisabled: function toggleDisabled() {\n            if (this.options.disabled) {\n                this.enable();\n            } else {\n                this.disable();\n            }\n        },\n\n        /**\n        Sets new option\n        \n        @method option(key, value)\n        @param {string|object} key option name or object with several options\n        @param {mixed} value option new value\n        @example\n        $('.editable').editable('option', 'pk', 2);\n        **/\n        option: function option(key, value) {\n            //set option(s) by object\n            if (key && (typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {\n                $.each(key, $.proxy(function (k, v) {\n                    this.option($.trim(k), v);\n                }, this));\n                return;\n            }\n\n            //set option by string             \n            this.options[key] = value;\n\n            //disabled\n            if (key === 'disabled') {\n                return value ? this.disable() : this.enable();\n            }\n\n            //value\n            if (key === 'value') {\n                this.setValue(value);\n            }\n\n            //transfer new option to container! \n            if (this.container) {\n                this.container.option(key, value);\n            }\n\n            //pass option to input directly (as it points to the same in form)\n            if (this.input.option) {\n                this.input.option(key, value);\n            }\n        },\n\n        /*\n        * set emptytext if element is empty\n        */\n        handleEmpty: function handleEmpty(isEmpty) {\n            //do not handle empty if we do not display anything\n            if (this.options.display === false) {\n                return;\n            }\n\n            /* \n            isEmpty may be set directly as param of method.\n            It is required when we enable/disable field and can't rely on content \n            as node content is text: \"Empty\" that is not empty %)\n            */\n            if (isEmpty !== undefined) {\n                this.isEmpty = isEmpty;\n            } else {\n                //detect empty\n                //for some inputs we need more smart check\n                //e.g. wysihtml5 may have <br>, <p></p>, <img>\n                if (typeof this.input.isEmpty === 'function') {\n                    this.isEmpty = this.input.isEmpty(this.$element);\n                } else {\n                    this.isEmpty = $.trim(this.$element.html()) === '';\n                }\n            }\n\n            //emptytext shown only for enabled\n            if (!this.options.disabled) {\n                if (this.isEmpty) {\n                    this.$element.html(this.options.emptytext);\n                    if (this.options.emptyclass) {\n                        this.$element.addClass(this.options.emptyclass);\n                    }\n                } else if (this.options.emptyclass) {\n                    this.$element.removeClass(this.options.emptyclass);\n                }\n            } else {\n                //below required if element disable property was changed\n                if (this.isEmpty) {\n                    this.$element.empty();\n                    if (this.options.emptyclass) {\n                        this.$element.removeClass(this.options.emptyclass);\n                    }\n                }\n            }\n        },\n\n        /**\n        Shows container with form\n        @method show()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/\n        show: function show(closeAll) {\n            if (this.options.disabled) {\n                return;\n            }\n\n            //init editableContainer: popover, tooltip, inline, etc..\n            if (!this.container) {\n                var containerOptions = $.extend({}, this.options, {\n                    value: this.value,\n                    input: this.input //pass input to form (as it is already created)\n                });\n                this.$element.editableContainer(containerOptions);\n                //listen `save` event \n                this.$element.on(\"save.internal\", $.proxy(this.save, this));\n                this.container = this.$element.data('editableContainer');\n            } else if (this.container.tip().is(':visible')) {\n                return;\n            }\n\n            //show container\n            this.container.show(closeAll);\n        },\n\n        /**\n        Hides container with form\n        @method hide()\n        **/\n        hide: function hide() {\n            if (this.container) {\n                this.container.hide();\n            }\n        },\n\n        /**\n        Toggles container visibility (show / hide)\n        @method toggle()\n        @param {boolean} closeAll Whether to close all other editable containers when showing this one. Default true.\n        **/\n        toggle: function toggle(closeAll) {\n            if (this.container && this.container.tip().is(':visible')) {\n                this.hide();\n            } else {\n                this.show(closeAll);\n            }\n        },\n\n        /*\n        * called when form was submitted\n        */\n        save: function save(e, params) {\n            //mark element with unsaved class if needed\n            if (this.options.unsavedclass) {\n                /*\n                 Add unsaved css to element if:\n                  - url is not user's function \n                  - value was not sent to server\n                  - params.response === undefined, that means data was not sent\n                  - value changed \n                */\n                var sent = false;\n                sent = sent || typeof this.options.url === 'function';\n                sent = sent || this.options.display === false;\n                sent = sent || params.response !== undefined;\n                sent = sent || this.input.value2str(this.value) !== this.input.value2str(params.newValue);\n\n                if (sent) {\n                    this.$element.removeClass(this.options.unsavedclass);\n                } else {\n                    this.$element.addClass(this.options.unsavedclass);\n                }\n            }\n\n            //highlight when saving\n            if (this.options.highlight) {\n                var $e = this.$element,\n                    bgColor = $e.css('background-color');\n\n                $e.css('background-color', this.options.highlight);\n                setTimeout(function () {\n                    if (bgColor === 'transparent') {\n                        bgColor = '';\n                    }\n                    $e.css('background-color', bgColor);\n                    $e.addClass('editable-bg-transition');\n                    setTimeout(function () {\n                        $e.removeClass('editable-bg-transition');\n                    }, 1700);\n                }, 10);\n            }\n\n            //set new value\n            this.setValue(params.newValue, false, params.response);\n\n            /**        \n            Fired when new value was submitted. You can use <code>$(this).data('editable')</code> to access to editable instance\n            \n            @event save \n            @param {Object} event event object\n            @param {Object} params additional params\n            @param {mixed} params.newValue submitted value\n            @param {Object} params.response ajax response\n            @example\n            $('#username').on('save', function(e, params) {\n                alert('Saved value: ' + params.newValue);\n            });\n            **/\n            //event itself is triggered by editableContainer. Description here is only for documentation              \n        },\n\n        validate: function validate() {\n            if (typeof this.options.validate === 'function') {\n                return this.options.validate.call(this, this.value);\n            }\n        },\n\n        /**\n        Sets new value of editable\n        @method setValue(value, convertStr)\n        @param {mixed} value new value \n        @param {boolean} convertStr whether to convert value from string to internal format\n        **/\n        setValue: function setValue(value, convertStr, response) {\n            if (convertStr) {\n                this.value = this.input.str2value(value);\n            } else {\n                this.value = value;\n            }\n            if (this.container) {\n                this.container.option('value', this.value);\n            }\n            $.when(this.render(response)).then($.proxy(function () {\n                this.handleEmpty();\n            }, this));\n        },\n\n        /**\n        Activates input of visible container (e.g. set focus)\n        @method activate()\n        **/\n        activate: function activate() {\n            if (this.container) {\n                this.container.activate();\n            }\n        },\n\n        /**\n        Removes editable feature from element\n        @method destroy()\n        **/\n        destroy: function destroy() {\n            this.disable();\n\n            if (this.container) {\n                this.container.destroy();\n            }\n\n            this.input.destroy();\n\n            if (this.options.toggle !== 'manual') {\n                this.$element.removeClass('editable-click');\n                this.$element.off(this.options.toggle + '.editable');\n            }\n\n            this.$element.off(\"save.internal\");\n\n            this.$element.removeClass('editable editable-open editable-disabled');\n            this.$element.removeData('editable');\n        }\n    };\n\n    /* EDITABLE PLUGIN DEFINITION\n    * ======================= */\n\n    /**\n    jQuery method to initialize editable element.\n    \n    @method $().editable(options)\n    @params {Object} options\n    @example\n    $('#username').editable({\n        type: 'text',\n        url: '/post',\n        pk: 1\n    });\n    **/\n    $.fn.editable = function (option) {\n        //special API methods returning non-jquery object\n        var result = {},\n            args = arguments,\n            datakey = 'editable';\n        switch (option) {\n            /**\n            Runs client-side validation for all matched editables\n            \n            @method validate()\n            @returns {Object} validation errors map\n            @example\n            $('#username, #fullname').editable('validate');\n            // possible result:\n            {\n              username: \"username is required\",\n              fullname: \"fullname should be minimum 3 letters length\"\n            }\n            **/\n            case 'validate':\n                this.each(function () {\n                    var $this = $(this),\n                        data = $this.data(datakey),\n                        error;\n                    if (data && (error = data.validate())) {\n                        result[data.options.name] = error;\n                    }\n                });\n                return result;\n\n            /**\n            Returns current values of editable elements.   \n            Note that it returns an **object** with name-value pairs, not a value itself. It allows to get data from several elements.    \n            If value of some editable is `null` or `undefined` it is excluded from result object.\n            When param `isSingle` is set to **true** - it is supposed you have single element and will return value of editable instead of object.   \n             \n            @method getValue()\n            @param {bool} isSingle whether to return just value of single element\n            @returns {Object} object of element names and values\n            @example\n            $('#username, #fullname').editable('getValue');\n            //result:\n            {\n            username: \"superuser\",\n            fullname: \"John\"\n            }\n            //isSingle = true\n            $('#username').editable('getValue', true);\n            //result \"superuser\" \n            **/\n            case 'getValue':\n                if (arguments.length === 2 && arguments[1] === true) {\n                    //isSingle = true\n                    result = this.eq(0).data(datakey).value;\n                } else {\n                    this.each(function () {\n                        var $this = $(this),\n                            data = $this.data(datakey);\n                        if (data && data.value !== undefined && data.value !== null) {\n                            result[data.options.name] = data.input.value2submit(data.value);\n                        }\n                    });\n                }\n                return result;\n\n            /**\n            This method collects values from several editable elements and submit them all to server.   \n            Internally it runs client-side validation for all fields and submits only in case of success.  \n            See <a href=\"#newrecord\">creating new records</a> for details.  \n            Since 1.5.1 `submit` can be applied to single element to send data programmatically. In that case\n            `url`, `success` and `error` is taken from initial options and you can just call `$('#username').editable('submit')`. \n            \n            @method submit(options)\n            @param {object} options \n            @param {object} options.url url to submit data \n            @param {object} options.data additional data to submit\n            @param {object} options.ajaxOptions additional ajax options\n            @param {function} options.error(obj) error handler \n            @param {function} options.success(obj,config) success handler\n            @returns {Object} jQuery object\n            **/\n            case 'submit':\n                //collects value, validate and submit to server for creating new record\n                var config = arguments[1] || {},\n                    $elems = this,\n                    errors = this.editable('validate');\n\n                // validation ok\n                if ($.isEmptyObject(errors)) {\n                    var ajaxOptions = {};\n\n                    // for single element use url, success etc from options\n                    if ($elems.length === 1) {\n                        var editable = $elems.data('editable');\n                        //standard params\n                        var params = {\n                            name: editable.options.name || '',\n                            value: editable.input.value2submit(editable.value),\n                            pk: typeof editable.options.pk === 'function' ? editable.options.pk.call(editable.options.scope) : editable.options.pk\n                        };\n\n                        //additional params\n                        if (typeof editable.options.params === 'function') {\n                            params = editable.options.params.call(editable.options.scope, params);\n                        } else {\n                            //try parse json in single quotes (from data-params attribute)\n                            editable.options.params = $.fn.editableutils.tryParseJson(editable.options.params, true);\n                            $.extend(params, editable.options.params);\n                        }\n\n                        ajaxOptions = {\n                            url: editable.options.url,\n                            data: params,\n                            type: 'POST'\n                        };\n\n                        // use success / error from options \n                        config.success = config.success || editable.options.success;\n                        config.error = config.error || editable.options.error;\n\n                        // multiple elements\n                    } else {\n                        var values = this.editable('getValue');\n\n                        ajaxOptions = {\n                            url: config.url,\n                            data: values,\n                            type: 'POST'\n                        };\n                    }\n\n                    // ajax success callabck (response 200 OK)\n                    ajaxOptions.success = typeof config.success === 'function' ? function (response) {\n                        config.success.call($elems, response, config);\n                    } : $.noop;\n\n                    // ajax error callabck\n                    ajaxOptions.error = typeof config.error === 'function' ? function () {\n                        config.error.apply($elems, arguments);\n                    } : $.noop;\n\n                    // extend ajaxOptions    \n                    if (config.ajaxOptions) {\n                        $.extend(ajaxOptions, config.ajaxOptions);\n                    }\n\n                    // extra data \n                    if (config.data) {\n                        $.extend(ajaxOptions.data, config.data);\n                    }\n\n                    // perform ajax request\n                    $.ajax(ajaxOptions);\n                } else {\n                    //client-side validation error\n                    if (typeof config.error === 'function') {\n                        config.error.call($elems, errors);\n                    }\n                }\n                return this;\n        }\n\n        //return jquery object\n        return this.each(function () {\n            var $this = $(this),\n                data = $this.data(datakey),\n                options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) === 'object' && option;\n\n            //for delegated targets do not store `editable` object for element\n            //it's allows several different selectors.\n            //see: https://github.com/vitalets/x-editable/issues/312    \n            if (options && options.selector) {\n                data = new Editable(this, options);\n                return;\n            }\n\n            if (!data) {\n                $this.data(datakey, data = new Editable(this, options));\n            }\n\n            if (typeof option === 'string') {\n                //call method \n                data[option].apply(data, Array.prototype.slice.call(args, 1));\n            }\n        });\n    };\n\n    $.fn.editable.defaults = {\n        /**\n        Type of input. Can be <code>text|textarea|select|date|checklist</code> and more\n         @property type \n        @type string\n        @default 'text'\n        **/\n        type: 'text',\n        /**\n        Sets disabled state of editable\n         @property disabled \n        @type boolean\n        @default false\n        **/\n        disabled: false,\n        /**\n        How to toggle editable. Can be <code>click|dblclick|mouseenter|manual</code>.   \n        When set to <code>manual</code> you should manually call <code>show/hide</code> methods of editable.    \n        **Note**: if you call <code>show</code> or <code>toggle</code> inside **click** handler of some DOM element, \n        you need to apply <code>e.stopPropagation()</code> because containers are being closed on any click on document.\n        \n        @example\n        $('#edit-button').click(function(e) {\n            e.stopPropagation();\n            $('#username').editable('toggle');\n        });\n         @property toggle \n        @type string\n        @default 'click'\n        **/\n        toggle: 'click',\n        /**\n        Text shown when element is empty.\n         @property emptytext \n        @type string\n        @default 'Empty'\n        **/\n        emptytext: 'Empty',\n        /**\n        Allows to automatically set element's text based on it's value. Can be <code>auto|always|never</code>. Useful for select and date.\n        For example, if dropdown list is <code>{1: 'a', 2: 'b'}</code> and element's value set to <code>1</code>, it's html will be automatically set to <code>'a'</code>.  \n        <code>auto</code> - text will be automatically set only if element is empty.  \n        <code>always|never</code> - always(never) try to set element's text.\n         @property autotext \n        @type string\n        @default 'auto'\n        **/\n        autotext: 'auto',\n        /**\n        Initial value of input. If not set, taken from element's text.  \n        Note, that if element's text is empty - text is automatically generated from value and can be customized (see `autotext` option).  \n        For example, to display currency sign:\n        @example\n        <a id=\"price\" data-type=\"text\" data-value=\"100\"></a>\n        <script>\n        $('#price').editable({\n            ...\n            display: function(value) {\n              $(this).text(value + '$');\n            } \n        }) \n        </script>\n                \n        @property value \n        @type mixed\n        @default element's text\n        **/\n        value: null,\n        /**\n        Callback to perform custom displaying of value in element's text.  \n        If `null`, default input's display used.  \n        If `false`, no displaying methods will be called, element's text will never change.  \n        Runs under element's scope.  \n        _**Parameters:**_  \n        \n        * `value` current value to be displayed\n        * `response` server response (if display called after ajax submit), since 1.4.0\n         \n        For _inputs with source_ (select, checklist) parameters are different:  \n          \n        * `value` current value to be displayed\n        * `sourceData` array of items for current input (e.g. dropdown items) \n        * `response` server response (if display called after ajax submit), since 1.4.0\n                  \n        To get currently selected items use `$.fn.editableutils.itemsByValue(value, sourceData)`.\n        \n        @property display \n        @type function|boolean\n        @default null\n        @since 1.2.0\n        @example\n        display: function(value, sourceData) {\n           //display checklist as comma-separated values\n           var html = [],\n               checked = $.fn.editableutils.itemsByValue(value, sourceData);\n               \n           if(checked.length) {\n               $.each(checked, function(i, v) { html.push($.fn.editableutils.escape(v.text)); });\n               $(this).html(html.join(', '));\n           } else {\n               $(this).empty(); \n           }\n        }\n        **/\n        display: null,\n        /**\n        Css class applied when editable text is empty.\n         @property emptyclass \n        @type string\n        @since 1.4.1        \n        @default editable-empty\n        **/\n        emptyclass: 'editable-empty',\n        /**\n        Css class applied when value was stored but not sent to server (`pk` is empty or `send = 'never'`).  \n        You may set it to `null` if you work with editables locally and submit them together.  \n         @property unsavedclass \n        @type string\n        @since 1.4.1        \n        @default editable-unsaved\n        **/\n        unsavedclass: 'editable-unsaved',\n        /**\n        If selector is provided, editable will be delegated to the specified targets.  \n        Usefull for dynamically generated DOM elements.  \n        **Please note**, that delegated targets can't be initialized with `emptytext` and `autotext` options, \n        as they actually become editable only after first click.  \n        You should manually set class `editable-click` to these elements.  \n        Also, if element originally empty you should add class `editable-empty`, set `data-value=\"\"` and write emptytext into element:\n         @property selector \n        @type string\n        @since 1.4.1        \n        @default null\n        @example\n        <div id=\"user\">\n          <!-- empty -->\n          <a href=\"#\" data-name=\"username\" data-type=\"text\" class=\"editable-click editable-empty\" data-value=\"\" title=\"Username\">Empty</a>\n          <!-- non-empty -->\n          <a href=\"#\" data-name=\"group\" data-type=\"select\" data-source=\"/groups\" data-value=\"1\" class=\"editable-click\" title=\"Group\">Operator</a>\n        </div>     \n        \n        <script>\n        $('#user').editable({\n            selector: 'a',\n            url: '/post',\n            pk: 1\n        });\n        </script>\n        **/\n        selector: null,\n        /**\n        Color used to highlight element after update. Implemented via CSS3 transition, works in modern browsers.\n        \n        @property highlight \n        @type string|boolean\n        @since 1.4.5        \n        @default #FFFF80 \n        **/\n        highlight: '#FFFF80'\n    };\n})(window.jQuery);\n\n/**\nAbstractInput - base class for all editable inputs.\nIt defines interface to be implemented by any input type.\nTo create your own input you can inherit from this class.\n\n@class abstractinput\n**/\n(function ($) {\n\n    //types\n    $.fn.editabletypes = {};\n\n    var AbstractInput = function AbstractInput() {};\n\n    AbstractInput.prototype = {\n        /**\n         Initializes input\n          @method init() \n         **/\n        init: function init(type, options, defaults) {\n            this.type = type;\n            this.options = $.extend({}, defaults, options);\n        },\n\n        /*\n        this method called before render to init $tpl that is inserted in DOM\n        */\n        prerender: function prerender() {\n            this.$tpl = $(this.options.tpl); //whole tpl as jquery object    \n            this.$input = this.$tpl; //control itself, can be changed in render method\n            this.$clear = null; //clear button\n            this.error = null; //error message, if input cannot be rendered           \n        },\n\n        /**\n         Renders input from tpl. Can return jQuery deferred object.\n         Can be overwritten in child objects\n          @method render()\n        **/\n        render: function render() {},\n\n        /**\n         Sets element's html by value. \n          @method value2html(value, element)\n         @param {mixed} value\n         @param {DOMElement} element\n        **/\n        value2html: function value2html(value, element) {\n            $(element)[this.options.escape ? 'text' : 'html']($.trim(value));\n        },\n\n        /**\n         Converts element's html to value\n          @method html2value(html)\n         @param {string} html\n         @returns {mixed}\n        **/\n        html2value: function html2value(html) {\n            return $('<div>').html(html).text();\n        },\n\n        /**\n         Converts value to string (for internal compare). For submitting to server used value2submit().\n          @method value2str(value) \n         @param {mixed} value\n         @returns {string}\n        **/\n        value2str: function value2str(value) {\n            return value;\n        },\n\n        /**\n         Converts string received from server into value. Usually from `data-value` attribute.\n          @method str2value(str)\n         @param {string} str\n         @returns {mixed}\n        **/\n        str2value: function str2value(str) {\n            return str;\n        },\n\n        /**\n         Converts value for submitting to server. Result can be string or object.\n          @method value2submit(value) \n         @param {mixed} value\n         @returns {mixed}\n        **/\n        value2submit: function value2submit(value) {\n            return value;\n        },\n\n        /**\n         Sets value of input.\n          @method value2input(value) \n         @param {mixed} value\n        **/\n        value2input: function value2input(value) {\n            this.$input.val(value);\n        },\n\n        /**\n         Returns value of input. Value can be object (e.g. datepicker)\n          @method input2value() \n        **/\n        input2value: function input2value() {\n            return this.$input.val();\n        },\n\n        /**\n         Activates input. For text it sets focus.\n          @method activate() \n        **/\n        activate: function activate() {\n            if (this.$input.is(':visible')) {\n                this.$input.focus();\n            }\n        },\n\n        /**\n         Creates input.\n          @method clear() \n        **/\n        clear: function clear() {\n            this.$input.val(null);\n        },\n\n        /**\n         method to escape html.\n        **/\n        escape: function escape(str) {\n            return $('<div>').text(str).html();\n        },\n\n        /**\n         attach handler to automatically submit form when value changed (useful when buttons not shown)\n        **/\n        autosubmit: function autosubmit() {},\n\n        /**\n        Additional actions when destroying element \n        **/\n        destroy: function destroy() {},\n\n        // -------- helper functions --------\n        setClass: function setClass() {\n            if (this.options.inputclass) {\n                this.$input.addClass(this.options.inputclass);\n            }\n        },\n\n        setAttr: function setAttr(attr) {\n            if (this.options[attr] !== undefined && this.options[attr] !== null) {\n                this.$input.attr(attr, this.options[attr]);\n            }\n        },\n\n        option: function option(key, value) {\n            this.options[key] = value;\n        }\n\n    };\n\n    AbstractInput.defaults = {\n        /**\n        HTML template of input. Normally you should not change it.\n         @property tpl \n        @type string\n        @default ''\n        **/\n        tpl: '',\n        /**\n        CSS class automatically applied to input\n        \n        @property inputclass \n        @type string\n        @default null\n        **/\n        inputclass: null,\n\n        /**\n        If `true` - html will be escaped in content of element via $.text() method.  \n        If `false` - html will not be escaped, $.html() used.  \n        When you use own `display` function, this option obviosly has no effect.\n        \n        @property escape \n        @type boolean\n        @since 1.5.0\n        @default true\n        **/\n        escape: true,\n\n        //scope for external methods (e.g. source defined as function)\n        //for internal use only\n        scope: null,\n\n        //need to re-declare showbuttons here to get it's value from common config (passed only options existing in defaults)\n        showbuttons: true\n    };\n\n    $.extend($.fn.editabletypes, { abstractinput: AbstractInput });\n})(window.jQuery);\n\n/**\nList - abstract class for inputs that have source option loaded from js array or via ajax\n\n@class list\n@extends abstractinput\n**/\n(function ($) {\n\n    var List = function List(options) {};\n\n    $.fn.editableutils.inherit(List, $.fn.editabletypes.abstractinput);\n\n    $.extend(List.prototype, {\n        render: function render() {\n            var deferred = $.Deferred();\n\n            this.error = null;\n            this.onSourceReady(function () {\n                this.renderList();\n                deferred.resolve();\n            }, function () {\n                this.error = this.options.sourceError;\n                deferred.resolve();\n            });\n\n            return deferred.promise();\n        },\n\n        html2value: function html2value(html) {\n            return null; //can't set value by text\n        },\n\n        value2html: function value2html(value, element, display, response) {\n            var deferred = $.Deferred(),\n                success = function success() {\n                if (typeof display === 'function') {\n                    //custom display method\n                    display.call(element, value, this.sourceData, response);\n                } else {\n                    this.value2htmlFinal(value, element);\n                }\n                deferred.resolve();\n            };\n\n            //for null value just call success without loading source\n            if (value === null) {\n                success.call(this);\n            } else {\n                this.onSourceReady(success, function () {\n                    deferred.resolve();\n                });\n            }\n\n            return deferred.promise();\n        },\n\n        // ------------- additional functions ------------\n\n        onSourceReady: function onSourceReady(success, error) {\n            //run source if it function\n            var source;\n            if ($.isFunction(this.options.source)) {\n                source = this.options.source.call(this.options.scope);\n                this.sourceData = null;\n                //note: if function returns the same source as URL - sourceData will be taken from cahce and no extra request performed\n            } else {\n                source = this.options.source;\n            }\n\n            //if allready loaded just call success\n            if (this.options.sourceCache && $.isArray(this.sourceData)) {\n                success.call(this);\n                return;\n            }\n\n            //try parse json in single quotes (for double quotes jquery does automatically)\n            try {\n                source = $.fn.editableutils.tryParseJson(source, false);\n            } catch (e) {\n                error.call(this);\n                return;\n            }\n\n            //loading from url\n            if (typeof source === 'string') {\n                //try to get sourceData from cache\n                if (this.options.sourceCache) {\n                    var cacheID = source,\n                        cache;\n\n                    if (!$(document).data(cacheID)) {\n                        $(document).data(cacheID, {});\n                    }\n                    cache = $(document).data(cacheID);\n\n                    //check for cached data\n                    if (cache.loading === false && cache.sourceData) {\n                        //take source from cache\n                        this.sourceData = cache.sourceData;\n                        this.doPrepend();\n                        success.call(this);\n                        return;\n                    } else if (cache.loading === true) {\n                        //cache is loading, put callback in stack to be called later\n                        cache.callbacks.push($.proxy(function () {\n                            this.sourceData = cache.sourceData;\n                            this.doPrepend();\n                            success.call(this);\n                        }, this));\n\n                        //also collecting error callbacks\n                        cache.err_callbacks.push($.proxy(error, this));\n                        return;\n                    } else {\n                        //no cache yet, activate it\n                        cache.loading = true;\n                        cache.callbacks = [];\n                        cache.err_callbacks = [];\n                    }\n                }\n\n                //ajaxOptions for source. Can be overwritten bt options.sourceOptions\n                var ajaxOptions = $.extend({\n                    url: source,\n                    type: 'get',\n                    cache: false,\n                    dataType: 'json',\n                    success: $.proxy(function (data) {\n                        if (cache) {\n                            cache.loading = false;\n                        }\n                        this.sourceData = this.makeArray(data);\n                        if ($.isArray(this.sourceData)) {\n                            if (cache) {\n                                //store result in cache\n                                cache.sourceData = this.sourceData;\n                                //run success callbacks for other fields waiting for this source\n                                $.each(cache.callbacks, function () {\n                                    this.call();\n                                });\n                            }\n                            this.doPrepend();\n                            success.call(this);\n                        } else {\n                            error.call(this);\n                            if (cache) {\n                                //run error callbacks for other fields waiting for this source\n                                $.each(cache.err_callbacks, function () {\n                                    this.call();\n                                });\n                            }\n                        }\n                    }, this),\n                    error: $.proxy(function () {\n                        error.call(this);\n                        if (cache) {\n                            cache.loading = false;\n                            //run error callbacks for other fields\n                            $.each(cache.err_callbacks, function () {\n                                this.call();\n                            });\n                        }\n                    }, this)\n                }, this.options.sourceOptions);\n\n                //loading sourceData from server\n                $.ajax(ajaxOptions);\n            } else {\n                //options as json/array\n                this.sourceData = this.makeArray(source);\n\n                if ($.isArray(this.sourceData)) {\n                    this.doPrepend();\n                    success.call(this);\n                } else {\n                    error.call(this);\n                }\n            }\n        },\n\n        doPrepend: function doPrepend() {\n            if (this.options.prepend === null || this.options.prepend === undefined) {\n                return;\n            }\n\n            if (!$.isArray(this.prependData)) {\n                //run prepend if it is function (once)\n                if ($.isFunction(this.options.prepend)) {\n                    this.options.prepend = this.options.prepend.call(this.options.scope);\n                }\n\n                //try parse json in single quotes\n                this.options.prepend = $.fn.editableutils.tryParseJson(this.options.prepend, true);\n\n                //convert prepend from string to object\n                if (typeof this.options.prepend === 'string') {\n                    this.options.prepend = { '': this.options.prepend };\n                }\n\n                this.prependData = this.makeArray(this.options.prepend);\n            }\n\n            if ($.isArray(this.prependData) && $.isArray(this.sourceData)) {\n                this.sourceData = this.prependData.concat(this.sourceData);\n            }\n        },\n\n        /*\n         renders input list\n        */\n        renderList: function renderList() {\n            // this method should be overwritten in child class\n        },\n\n        /*\n        set element's html by value\n        */\n        value2htmlFinal: function value2htmlFinal(value, element) {\n            // this method should be overwritten in child class\n        },\n\n        /**\n        * convert data to array suitable for sourceData, e.g. [{value: 1, text: 'abc'}, {...}]\n        */\n        makeArray: function makeArray(data) {\n            var count,\n                obj,\n                result = [],\n                item,\n                iterateItem;\n            if (!data || typeof data === 'string') {\n                return null;\n            }\n\n            if ($.isArray(data)) {\n                //array\n                /* \n                   function to iterate inside item of array if item is object.\n                   Caclulates count of keys in item and store in obj. \n                */\n                iterateItem = function iterateItem(k, v) {\n                    obj = { value: k, text: v };\n                    if (count++ >= 2) {\n                        return false; // exit from `each` if item has more than one key.\n                    }\n                };\n\n                for (var i = 0; i < data.length; i++) {\n                    item = data[i];\n                    if ((typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object') {\n                        count = 0; //count of keys inside item\n                        $.each(item, iterateItem);\n                        //case: [{val1: 'text1'}, {val2: 'text2} ...]\n                        if (count === 1) {\n                            result.push(obj);\n                            //case: [{value: 1, text: 'text1'}, {value: 2, text: 'text2'}, ...]\n                        } else if (count > 1) {\n                            //removed check of existance: item.hasOwnProperty('value') && item.hasOwnProperty('text')\n                            if (item.children) {\n                                item.children = this.makeArray(item.children);\n                            }\n                            result.push(item);\n                        }\n                    } else {\n                        //case: ['text1', 'text2' ...]\n                        result.push({ value: item, text: item });\n                    }\n                }\n            } else {\n                //case: {val1: 'text1', val2: 'text2, ...}\n                $.each(data, function (k, v) {\n                    result.push({ value: k, text: v });\n                });\n            }\n            return result;\n        },\n\n        option: function option(key, value) {\n            this.options[key] = value;\n            if (key === 'source') {\n                this.sourceData = null;\n            }\n            if (key === 'prepend') {\n                this.prependData = null;\n            }\n        }\n\n    });\n\n    List.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        Source data for list.  \n        If **array** - it should be in format: `[{value: 1, text: \"text1\"}, {value: 2, text: \"text2\"}, ...]`  \n        For compability, object format is also supported: `{\"1\": \"text1\", \"2\": \"text2\" ...}` but it does not guarantee elements order.\n        \n        If **string** - considered ajax url to load items. In that case results will be cached for fields with the same source and name. See also `sourceCache` option.\n          \n        If **function**, it should return data in format above (since 1.4.0).\n        \n        Since 1.4.1 key `children` supported to render OPTGROUP (for **select** input only).  \n        `[{text: \"group1\", children: [{value: 1, text: \"text1\"}, {value: 2, text: \"text2\"}]}, ...]` \n            @property source \n        @type string | array | object | function\n        @default null\n        **/\n        source: null,\n        /**\n        Data automatically prepended to the beginning of dropdown list.\n        \n        @property prepend \n        @type string | array | object | function\n        @default false\n        **/\n        prepend: false,\n        /**\n        Error message when list cannot be loaded (e.g. ajax error)\n        \n        @property sourceError \n        @type string\n        @default Error when loading list\n        **/\n        sourceError: 'Error when loading list',\n        /**\n        if <code>true</code> and source is **string url** - results will be cached for fields with the same source.    \n        Usefull for editable column in grid to prevent extra requests.\n        \n        @property sourceCache \n        @type boolean\n        @default true\n        @since 1.2.0\n        **/\n        sourceCache: true,\n        /**\n        Additional ajax options to be used in $.ajax() when loading list from server.\n        Useful to send extra parameters (`data` key) or change request method (`type` key).\n        \n        @property sourceOptions \n        @type object|function\n        @default null\n        @since 1.5.0\n        **/\n        sourceOptions: null\n    });\n\n    $.fn.editabletypes.list = List;\n})(window.jQuery);\n\n/**\nText input\n\n@class text\n@extends abstractinput\n@final\n@example\n<a href=\"#\" id=\"username\" data-type=\"text\" data-pk=\"1\">awesome</a>\n<script>\n$(function(){\n    $('#username').editable({\n        url: '/post',\n        title: 'Enter username'\n    });\n});\n</script>\n**/\n(function ($) {\n\n    var Text = function Text(options) {\n        this.init('text', options, Text.defaults);\n    };\n\n    $.fn.editableutils.inherit(Text, $.fn.editabletypes.abstractinput);\n\n    $.extend(Text.prototype, {\n        render: function render() {\n            this.renderClear();\n            this.setClass();\n            this.setAttr('placeholder');\n        },\n\n        activate: function activate() {\n            if (this.$input.is(':visible')) {\n                this.$input.focus();\n                $.fn.editableutils.setCursorPosition(this.$input.get(0), this.$input.val().length);\n                if (this.toggleClear) {\n                    this.toggleClear();\n                }\n            }\n        },\n\n        //render clear button\n        renderClear: function renderClear() {\n            if (this.options.clear) {\n                this.$clear = $('<span class=\"editable-clear-x\"></span>');\n                this.$input.after(this.$clear).css('padding-right', 24).keyup($.proxy(function (e) {\n                    //arrows, enter, tab, etc\n                    if (~$.inArray(e.keyCode, [40, 38, 9, 13, 27])) {\n                        return;\n                    }\n\n                    clearTimeout(this.t);\n                    var that = this;\n                    this.t = setTimeout(function () {\n                        that.toggleClear(e);\n                    }, 100);\n                }, this)).parent().css('position', 'relative');\n\n                this.$clear.click($.proxy(this.clear, this));\n            }\n        },\n\n        postrender: function postrender() {\n            /*\n            //now `clear` is positioned via css\n            if(this.$clear) {\n                //can position clear button only here, when form is shown and height can be calculated\n            //                var h = this.$input.outerHeight(true) || 20,\n                var h = this.$clear.parent().height(),\n                    delta = (h - this.$clear.height()) / 2;\n                    \n                //this.$clear.css({bottom: delta, right: delta});\n            }\n            */\n        },\n\n        //show / hide clear button\n        toggleClear: function toggleClear(e) {\n            if (!this.$clear) {\n                return;\n            }\n\n            var len = this.$input.val().length,\n                visible = this.$clear.is(':visible');\n\n            if (len && !visible) {\n                this.$clear.show();\n            }\n\n            if (!len && visible) {\n                this.$clear.hide();\n            }\n        },\n\n        clear: function clear() {\n            this.$clear.hide();\n            this.$input.val('').focus();\n        }\n    });\n\n    Text.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <input type=\"text\">\n        **/\n        tpl: '<input type=\"text\">',\n        /**\n        Placeholder attribute of input. Shown when input is empty.\n         @property placeholder \n        @type string\n        @default null\n        **/\n        placeholder: null,\n\n        /**\n        Whether to show `clear` button \n        \n        @property clear \n        @type boolean\n        @default true        \n        **/\n        clear: true\n    });\n\n    $.fn.editabletypes.text = Text;\n})(window.jQuery);\n\n/**\nTextarea input\n\n@class textarea\n@extends abstractinput\n@final\n@example\n<a href=\"#\" id=\"comments\" data-type=\"textarea\" data-pk=\"1\">awesome comment!</a>\n<script>\n$(function(){\n    $('#comments').editable({\n        url: '/post',\n        title: 'Enter comments',\n        rows: 10\n    });\n});\n</script>\n**/\n(function ($) {\n\n    var Textarea = function Textarea(options) {\n        this.init('textarea', options, Textarea.defaults);\n    };\n\n    $.fn.editableutils.inherit(Textarea, $.fn.editabletypes.abstractinput);\n\n    $.extend(Textarea.prototype, {\n        render: function render() {\n            this.setClass();\n            this.setAttr('placeholder');\n            this.setAttr('rows');\n\n            //ctrl + enter\n            this.$input.keydown(function (e) {\n                if (e.ctrlKey && e.which === 13) {\n                    $(this).closest('form').submit();\n                }\n            });\n        },\n\n        //using `white-space: pre-wrap` solves \\n  <--> BR conversion very elegant!\n        /* \n        value2html: function(value, element) {\n             var html = '', lines;\n             if(value) {\n                 lines = value.split(\"\\n\");\n                 for (var i = 0; i < lines.length; i++) {\n                     lines[i] = $('<div>').text(lines[i]).html();\n                 }\n                 html = lines.join('<br>');\n             }\n             $(element).html(html);\n         },\n        \n         html2value: function(html) {\n             if(!html) {\n                 return '';\n             }\n              var regex = new RegExp(String.fromCharCode(10), 'g');\n             var lines = html.split(/<br\\s*\\/?>/i);\n             for (var i = 0; i < lines.length; i++) {\n                 var text = $('<div>').html(lines[i]).text();\n                  // Remove newline characters (\\n) to avoid them being converted by value2html() method\n                 // thus adding extra <br> tags\n                 text = text.replace(regex, '');\n                  lines[i] = text;\n             }\n             return lines.join(\"\\n\");\n         },\n          */\n        activate: function activate() {\n            $.fn.editabletypes.text.prototype.activate.call(this);\n        }\n    });\n\n    Textarea.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl\n        @default <textarea></textarea>\n        **/\n        tpl: '<textarea></textarea>',\n        /**\n        @property inputclass\n        @default input-large\n        **/\n        inputclass: 'input-large',\n        /**\n        Placeholder attribute of input. Shown when input is empty.\n         @property placeholder\n        @type string\n        @default null\n        **/\n        placeholder: null,\n        /**\n        Number of rows in textarea\n         @property rows\n        @type integer\n        @default 7\n        **/\n        rows: 7\n    });\n\n    $.fn.editabletypes.textarea = Textarea;\n})(window.jQuery);\n\n/**\nSelect (dropdown)\n\n@class select\n@extends list\n@final\n@example\n<a href=\"#\" id=\"status\" data-type=\"select\" data-pk=\"1\" data-url=\"/post\" data-title=\"Select status\"></a>\n<script>\n$(function(){\n    $('#status').editable({\n        value: 2,    \n        source: [\n              {value: 1, text: 'Active'},\n              {value: 2, text: 'Blocked'},\n              {value: 3, text: 'Deleted'}\n           ]\n    });\n});\n</script>\n**/\n(function ($) {\n    ;\n\n    var Select = function Select(options) {\n        this.init('select', options, Select.defaults);\n    };\n\n    $.fn.editableutils.inherit(Select, $.fn.editabletypes.list);\n\n    $.extend(Select.prototype, {\n        renderList: function renderList() {\n            this.$input.empty();\n\n            var fillItems = function fillItems($el, data) {\n                var attr;\n                if ($.isArray(data)) {\n                    for (var i = 0; i < data.length; i++) {\n                        attr = {};\n                        if (data[i].children) {\n                            attr.label = data[i].text;\n                            $el.append(fillItems($('<optgroup>', attr), data[i].children));\n                        } else {\n                            attr.value = data[i].value;\n                            if (data[i].disabled) {\n                                attr.disabled = true;\n                            }\n                            $el.append($('<option>', attr).text(data[i].text));\n                        }\n                    }\n                }\n                return $el;\n            };\n\n            fillItems(this.$input, this.sourceData);\n\n            this.setClass();\n\n            //enter submit\n            this.$input.on('keydown.editable', function (e) {\n                if (e.which === 13) {\n                    $(this).closest('form').submit();\n                }\n            });\n        },\n\n        value2htmlFinal: function value2htmlFinal(value, element) {\n            var text = '',\n                items = $.fn.editableutils.itemsByValue(value, this.sourceData);\n\n            if (items.length) {\n                text = items[0].text;\n            }\n\n            //$(element).text(text);\n            $.fn.editabletypes.abstractinput.prototype.value2html.call(this, text, element);\n        },\n\n        autosubmit: function autosubmit() {\n            this.$input.off('keydown.editable').on('change.editable', function () {\n                $(this).closest('form').submit();\n            });\n        }\n    });\n\n    Select.defaults = $.extend({}, $.fn.editabletypes.list.defaults, {\n        /**\n        @property tpl \n        @default <select></select>\n        **/\n        tpl: '<select></select>'\n    });\n\n    $.fn.editabletypes.select = Select;\n})(window.jQuery);\n\n/**\nList of checkboxes. \nInternally value stored as javascript array of values.\n\n@class checklist\n@extends list\n@final\n@example\n<a href=\"#\" id=\"options\" data-type=\"checklist\" data-pk=\"1\" data-url=\"/post\" data-title=\"Select options\"></a>\n<script>\n$(function(){\n    $('#options').editable({\n        value: [2, 3],    \n        source: [\n              {value: 1, text: 'option1'},\n              {value: 2, text: 'option2'},\n              {value: 3, text: 'option3'}\n           ]\n    });\n});\n</script>\n**/\n(function ($) {\n    ;\n\n    var Checklist = function Checklist(options) {\n        this.init('checklist', options, Checklist.defaults);\n    };\n\n    $.fn.editableutils.inherit(Checklist, $.fn.editabletypes.list);\n\n    $.extend(Checklist.prototype, {\n        renderList: function renderList() {\n            var $label, $div;\n\n            this.$tpl.empty();\n\n            if (!$.isArray(this.sourceData)) {\n                return;\n            }\n\n            for (var i = 0; i < this.sourceData.length; i++) {\n                $label = $('<label>').append($('<input>', {\n                    type: 'checkbox',\n                    value: this.sourceData[i].value\n                })).append($('<span>').text(' ' + this.sourceData[i].text));\n\n                $('<div>').append($label).appendTo(this.$tpl);\n            }\n\n            this.$input = this.$tpl.find('input[type=\"checkbox\"]');\n            this.setClass();\n        },\n\n        value2str: function value2str(value) {\n            return $.isArray(value) ? value.sort().join($.trim(this.options.separator)) : '';\n        },\n\n        //parse separated string\n        str2value: function str2value(str) {\n            var reg,\n                value = null;\n            if (typeof str === 'string' && str.length) {\n                reg = new RegExp('\\\\s*' + $.trim(this.options.separator) + '\\\\s*');\n                value = str.split(reg);\n            } else if ($.isArray(str)) {\n                value = str;\n            } else {\n                value = [str];\n            }\n            return value;\n        },\n\n        //set checked on required checkboxes\n        value2input: function value2input(value) {\n            this.$input.prop('checked', false);\n            if ($.isArray(value) && value.length) {\n                this.$input.each(function (i, el) {\n                    var $el = $(el);\n                    // cannot use $.inArray as it performs strict comparison\n                    $.each(value, function (j, val) {\n                        /*jslint eqeq: true*/\n                        if ($el.val() == val) {\n                            /*jslint eqeq: false*/\n                            $el.prop('checked', true);\n                        }\n                    });\n                });\n            }\n        },\n\n        input2value: function input2value() {\n            var checked = [];\n            this.$input.filter(':checked').each(function (i, el) {\n                checked.push($(el).val());\n            });\n            return checked;\n        },\n\n        //collect text of checked boxes\n        value2htmlFinal: function value2htmlFinal(value, element) {\n            var html = [],\n                checked = $.fn.editableutils.itemsByValue(value, this.sourceData),\n                escape = this.options.escape;\n\n            if (checked.length) {\n                $.each(checked, function (i, v) {\n                    var text = escape ? $.fn.editableutils.escape(v.text) : v.text;\n                    html.push(text);\n                });\n                $(element).html(html.join('<br>'));\n            } else {\n                $(element).empty();\n            }\n        },\n\n        activate: function activate() {\n            this.$input.first().focus();\n        },\n\n        autosubmit: function autosubmit() {\n            this.$input.on('keydown', function (e) {\n                if (e.which === 13) {\n                    $(this).closest('form').submit();\n                }\n            });\n        }\n    });\n\n    Checklist.defaults = $.extend({}, $.fn.editabletypes.list.defaults, {\n        /**\n        @property tpl \n        @default <div></div>\n        **/\n        tpl: '<div class=\"editable-checklist\"></div>',\n\n        /**\n        @property inputclass \n        @type string\n        @default null\n        **/\n        inputclass: null,\n\n        /**\n        Separator of values when reading from `data-value` attribute\n         @property separator \n        @type string\n        @default ','\n        **/\n        separator: ','\n    });\n\n    $.fn.editabletypes.checklist = Checklist;\n})(window.jQuery);\n\n/**\nHTML5 input types.\nFollowing types are supported:\n\n* password\n* email\n* url\n* tel\n* number\n* range\n* time\n\nLearn more about html5 inputs:  \nhttp://www.w3.org/wiki/HTML5_form_additions  \nTo check browser compatibility please see:  \nhttps://developer.mozilla.org/en-US/docs/HTML/Element/Input\n            \n@class html5types \n@extends text\n@final\n@since 1.3.0\n@example\n<a href=\"#\" id=\"email\" data-type=\"email\" data-pk=\"1\">admin@example.com</a>\n<script>\n$(function(){\n    $('#email').editable({\n        url: '/post',\n        title: 'Enter email'\n    });\n});\n</script>\n**/\n\n/**\n@property tpl \n@default depends on type\n**/\n\n/*\nPassword\n*/\n(function ($) {\n    ;\n\n    var Password = function Password(options) {\n        this.init('password', options, Password.defaults);\n    };\n    $.fn.editableutils.inherit(Password, $.fn.editabletypes.text);\n    $.extend(Password.prototype, {\n        //do not display password, show '[hidden]' instead\n        value2html: function value2html(value, element) {\n            if (value) {\n                $(element).text('[hidden]');\n            } else {\n                $(element).empty();\n            }\n        },\n        //as password not displayed, should not set value by html\n        html2value: function html2value(html) {\n            return null;\n        }\n    });\n    Password.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"password\">'\n    });\n    $.fn.editabletypes.password = Password;\n})(window.jQuery);\n\n/*\nEmail\n*/\n(function ($) {\n    ;\n\n    var Email = function Email(options) {\n        this.init('email', options, Email.defaults);\n    };\n    $.fn.editableutils.inherit(Email, $.fn.editabletypes.text);\n    Email.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"email\">'\n    });\n    $.fn.editabletypes.email = Email;\n})(window.jQuery);\n\n/*\nUrl\n*/\n(function ($) {\n    ;\n\n    var Url = function Url(options) {\n        this.init('url', options, Url.defaults);\n    };\n    $.fn.editableutils.inherit(Url, $.fn.editabletypes.text);\n    Url.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"url\">'\n    });\n    $.fn.editabletypes.url = Url;\n})(window.jQuery);\n\n/*\nTel\n*/\n(function ($) {\n    ;\n\n    var Tel = function Tel(options) {\n        this.init('tel', options, Tel.defaults);\n    };\n    $.fn.editableutils.inherit(Tel, $.fn.editabletypes.text);\n    Tel.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"tel\">'\n    });\n    $.fn.editabletypes.tel = Tel;\n})(window.jQuery);\n\n/*\nNumber\n*/\n(function ($) {\n    ;\n\n    var NumberInput = function NumberInput(options) {\n        this.init('number', options, NumberInput.defaults);\n    };\n    $.fn.editableutils.inherit(NumberInput, $.fn.editabletypes.text);\n    $.extend(NumberInput.prototype, {\n        render: function render() {\n            NumberInput.superclass.render.call(this);\n            this.setAttr('min');\n            this.setAttr('max');\n            this.setAttr('step');\n        },\n        postrender: function postrender() {\n            if (this.$clear) {\n                //increase right ffset  for up/down arrows\n                this.$clear.css({ right: 24 });\n                /*\n                //can position clear button only here, when form is shown and height can be calculated\n                var h = this.$input.outerHeight(true) || 20,\n                    delta = (h - this.$clear.height()) / 2;\n                \n                //add 12px to offset right for up/down arrows    \n                this.$clear.css({top: delta, right: delta + 16});\n                */\n            }\n        }\n    });\n    NumberInput.defaults = $.extend({}, $.fn.editabletypes.text.defaults, {\n        tpl: '<input type=\"number\">',\n        inputclass: 'input-mini',\n        min: null,\n        max: null,\n        step: null\n    });\n    $.fn.editabletypes.number = NumberInput;\n})(window.jQuery);\n\n/*\nRange (inherit from number)\n*/\n(function ($) {\n    ;\n\n    var Range = function Range(options) {\n        this.init('range', options, Range.defaults);\n    };\n    $.fn.editableutils.inherit(Range, $.fn.editabletypes.number);\n    $.extend(Range.prototype, {\n        render: function render() {\n            this.$input = this.$tpl.filter('input');\n\n            this.setClass();\n            this.setAttr('min');\n            this.setAttr('max');\n            this.setAttr('step');\n\n            this.$input.on('input', function () {\n                $(this).siblings('output').text($(this).val());\n            });\n        },\n        activate: function activate() {\n            this.$input.focus();\n        }\n    });\n    Range.defaults = $.extend({}, $.fn.editabletypes.number.defaults, {\n        tpl: '<input type=\"range\"><output style=\"width: 30px; display: inline-block\"></output>',\n        inputclass: 'input-medium'\n    });\n    $.fn.editabletypes.range = Range;\n})(window.jQuery);\n\n/*\nTime\n*/\n(function ($) {\n    ;\n\n    var Time = function Time(options) {\n        this.init('time', options, Time.defaults);\n    };\n    //inherit from abstract, as inheritance from text gives selection error.\n    $.fn.editableutils.inherit(Time, $.fn.editabletypes.abstractinput);\n    $.extend(Time.prototype, {\n        render: function render() {\n            this.setClass();\n        }\n    });\n    Time.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        tpl: '<input type=\"time\">'\n    });\n    $.fn.editabletypes.time = Time;\n})(window.jQuery);\n\n/**\nSelect2 input. Based on amazing work of Igor Vaynberg https://github.com/ivaynberg/select2.  \nPlease see [original select2 docs](http://ivaynberg.github.com/select2) for detailed description and options.  \n \nYou should manually download and include select2 distributive:  \n\n    <link href=\"select2/select2.css\" rel=\"stylesheet\" type=\"text/css\"></link>  \n    <script src=\"select2/select2.js\"></script>  \n    \nTo make it **bootstrap-styled** you can use css from [here](https://github.com/t0m/select2-bootstrap-css): \n\n    <link href=\"select2-bootstrap.css\" rel=\"stylesheet\" type=\"text/css\"></link>    \n    \n**Note:** currently `autotext` feature does not work for select2 with `ajax` remote source.    \nYou need initially put both `data-value` and element's text youself:    \n\n    <a href=\"#\" data-type=\"select2\" data-value=\"1\">Text1</a>\n    \n    \n@class select2\n@extends abstractinput\n@since 1.4.1\n@final\n@example\n<a href=\"#\" id=\"country\" data-type=\"select2\" data-pk=\"1\" data-value=\"ru\" data-url=\"/post\" data-title=\"Select country\"></a>\n<script>\n$(function(){\n    //local source\n    $('#country').editable({\n        source: [\n              {id: 'gb', text: 'Great Britain'},\n              {id: 'us', text: 'United States'},\n              {id: 'ru', text: 'Russia'}\n           ],\n        select2: {\n           multiple: true\n        }\n    });\n    //remote source (simple)\n    $('#country').editable({\n        source: '/getCountries',\n        select2: {\n            placeholder: 'Select Country',\n            minimumInputLength: 1\n        }\n    });\n    //remote source (advanced)\n    $('#country').editable({\n        select2: {\n            placeholder: 'Select Country',\n            allowClear: true,\n            minimumInputLength: 3,\n            id: function (item) {\n                return item.CountryId;\n            },\n            ajax: {\n                url: '/getCountries',\n                dataType: 'json',\n                data: function (term, page) {\n                    return { query: term };\n                },\n                results: function (data, page) {\n                    return { results: data };\n                }\n            },\n            formatResult: function (item) {\n                return item.CountryName;\n            },\n            formatSelection: function (item) {\n                return item.CountryName;\n            },\n            initSelection: function (element, callback) {\n                return $.get('/getCountryById', { query: element.val() }, function (data) {\n                    callback(data);\n                });\n            } \n        }  \n    });\n});\n</script>\n**/\n(function ($) {\n    ;\n\n    var Constructor = function Constructor(options) {\n        this.init('select2', options, Constructor.defaults);\n\n        options.select2 = options.select2 || {};\n\n        this.sourceData = null;\n\n        //placeholder\n        if (options.placeholder) {\n            options.select2.placeholder = options.placeholder;\n        }\n\n        //if not `tags` mode, use source\n        if (!options.select2.tags && options.source) {\n            var source = options.source;\n            //if source is function, call it (once!)\n            if ($.isFunction(options.source)) {\n                source = options.source.call(options.scope);\n            }\n\n            if (typeof source === 'string') {\n                options.select2.ajax = options.select2.ajax || {};\n                //some default ajax params\n                if (!options.select2.ajax.data) {\n                    options.select2.ajax.data = function (term) {\n                        return { query: term };\n                    };\n                }\n                if (!options.select2.ajax.results) {\n                    options.select2.ajax.results = function (data) {\n                        return { results: data };\n                    };\n                }\n                options.select2.ajax.url = source;\n            } else {\n                //check format and convert x-editable format to select2 format (if needed)\n                this.sourceData = this.convertSource(source);\n                options.select2.data = this.sourceData;\n            }\n        }\n\n        //overriding objects in config (as by default jQuery extend() is not recursive)\n        this.options.select2 = $.extend({}, Constructor.defaults.select2, options.select2);\n\n        //detect whether it is multi-valued\n        this.isMultiple = this.options.select2.tags || this.options.select2.multiple;\n        this.isRemote = 'ajax' in this.options.select2;\n\n        //store function returning ID of item\n        //should be here as used inautotext for local source\n        this.idFunc = this.options.select2.id;\n        if (typeof this.idFunc !== \"function\") {\n            var idKey = this.idFunc || 'id';\n            this.idFunc = function (e) {\n                return e[idKey];\n            };\n        }\n\n        //store function that renders text in select2\n        this.formatSelection = this.options.select2.formatSelection;\n        if (typeof this.formatSelection !== \"function\") {\n            this.formatSelection = function (e) {\n                return e.text;\n            };\n        }\n    };\n\n    $.fn.editableutils.inherit(Constructor, $.fn.editabletypes.abstractinput);\n\n    $.extend(Constructor.prototype, {\n        render: function render() {\n            this.setClass();\n\n            //can not apply select2 here as it calls initSelection \n            //over input that does not have correct value yet.\n            //apply select2 only in value2input\n            //this.$input.select2(this.options.select2);\n\n            //when data is loaded via ajax, we need to know when it's done to populate listData\n            if (this.isRemote) {\n                //listen to loaded event to populate data\n                this.$input.on('select2-loaded', $.proxy(function (e) {\n                    this.sourceData = e.items.results;\n                }, this));\n            }\n\n            //trigger resize of editableform to re-position container in multi-valued mode\n            if (this.isMultiple) {\n                this.$input.on('change', function () {\n                    $(this).closest('form').parent().triggerHandler('resize');\n                });\n            }\n        },\n\n        value2html: function value2html(value, element) {\n            var text = '',\n                data,\n                that = this;\n\n            if (this.options.select2.tags) {\n                //in tags mode just assign value\n                data = value;\n                //data = $.fn.editableutils.itemsByValue(value, this.options.select2.tags, this.idFunc);\n            } else if (this.sourceData) {\n                data = $.fn.editableutils.itemsByValue(value, this.sourceData, this.idFunc);\n            } else {}\n            //can not get list of possible values \n            //(e.g. autotext for select2 with ajax source)\n\n\n            //data may be array (when multiple values allowed)\n            if ($.isArray(data)) {\n                //collect selected data and show with separator\n                text = [];\n                $.each(data, function (k, v) {\n                    text.push(v && (typeof v === 'undefined' ? 'undefined' : _typeof(v)) === 'object' ? that.formatSelection(v) : v);\n                });\n            } else if (data) {\n                text = that.formatSelection(data);\n            }\n\n            text = $.isArray(text) ? text.join(this.options.viewseparator) : text;\n\n            //$(element).text(text);\n            Constructor.superclass.value2html.call(this, text, element);\n        },\n\n        html2value: function html2value(html) {\n            return this.options.select2.tags ? this.str2value(html, this.options.viewseparator) : null;\n        },\n\n        value2input: function value2input(value) {\n            // if value array => join it anyway\n            if ($.isArray(value)) {\n                value = value.join(this.getSeparator());\n            }\n\n            //for remote source just set value, text is updated by initSelection\n            if (!this.$input.data('select2')) {\n                this.$input.val(value);\n                this.$input.select2(this.options.select2);\n            } else {\n                //second argument needed to separate initial change from user's click (for autosubmit)   \n                this.$input.val(value).trigger('change', true);\n\n                //Uncaught Error: cannot call val() if initSelection() is not defined\n                //this.$input.select2('val', value);\n            }\n\n            // if defined remote source AND no multiple mode AND no user's initSelection provided --> \n            // we should somehow get text for provided id.\n            // The solution is to use element's text as text for that id (exclude empty)\n            if (this.isRemote && !this.isMultiple && !this.options.select2.initSelection) {\n                // customId and customText are methods to extract `id` and `text` from data object\n                // we can use this workaround only if user did not define these methods\n                // otherwise we cant construct data object\n                var customId = this.options.select2.id,\n                    customText = this.options.select2.formatSelection;\n\n                if (!customId && !customText) {\n                    var $el = $(this.options.scope);\n                    if (!$el.data('editable').isEmpty) {\n                        var data = { id: value, text: $el.text() };\n                        this.$input.select2('data', data);\n                    }\n                }\n            }\n        },\n\n        input2value: function input2value() {\n            return this.$input.select2('val');\n        },\n\n        str2value: function str2value(str, separator) {\n            if (typeof str !== 'string' || !this.isMultiple) {\n                return str;\n            }\n\n            separator = separator || this.getSeparator();\n\n            var val, i, l;\n\n            if (str === null || str.length < 1) {\n                return null;\n            }\n            val = str.split(separator);\n            for (i = 0, l = val.length; i < l; i = i + 1) {\n                val[i] = $.trim(val[i]);\n            }\n\n            return val;\n        },\n\n        autosubmit: function autosubmit() {\n            this.$input.on('change', function (e, isInitial) {\n                if (!isInitial) {\n                    $(this).closest('form').submit();\n                }\n            });\n        },\n\n        getSeparator: function getSeparator() {\n            return this.options.select2.separator || $.fn.select2.defaults.separator;\n        },\n\n        /*\n        Converts source from x-editable format: {value: 1, text: \"1\"} to\n        select2 format: {id: 1, text: \"1\"}\n        */\n        convertSource: function convertSource(source) {\n            if ($.isArray(source) && source.length && source[0].value !== undefined) {\n                for (var i = 0; i < source.length; i++) {\n                    if (source[i].value !== undefined) {\n                        source[i].id = source[i].value;\n                        delete source[i].value;\n                    }\n                }\n            }\n            return source;\n        },\n\n        destroy: function destroy() {\n            if (this.$input.data('select2')) {\n                this.$input.select2('destroy');\n            }\n        }\n\n    });\n\n    Constructor.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <input type=\"hidden\">\n        **/\n        tpl: '<input type=\"hidden\">',\n        /**\n        Configuration of select2. [Full list of options](http://ivaynberg.github.com/select2).\n         @property select2 \n        @type object\n        @default null\n        **/\n        select2: null,\n        /**\n        Placeholder attribute of select\n         @property placeholder \n        @type string\n        @default null\n        **/\n        placeholder: null,\n        /**\n        Source data for select. It will be assigned to select2 `data` property and kept here just for convenience.\n        Please note, that format is different from simple `select` input: use 'id' instead of 'value'.\n        E.g. `[{id: 1, text: \"text1\"}, {id: 2, text: \"text2\"}, ...]`.\n         @property source \n        @type array|string|function\n        @default null        \n        **/\n        source: null,\n        /**\n        Separator used to display tags.\n         @property viewseparator \n        @type string\n        @default ', '        \n        **/\n        viewseparator: ', '\n    });\n\n    $.fn.editabletypes.select2 = Constructor;\n})(window.jQuery);\n\n/**\n* Combodate - 1.0.5\n* Dropdown date and time picker.\n* Converts text input into dropdowns to pick day, month, year, hour, minute and second.\n* Uses momentjs as datetime library http://momentjs.com.\n* For i18n include corresponding file from https://github.com/timrwood/moment/tree/master/lang \n*\n* Confusion at noon and midnight - see http://en.wikipedia.org/wiki/12-hour_clock#Confusion_at_noon_and_midnight\n* In combodate: \n* 12:00 pm --> 12:00 (24-h format, midday)\n* 12:00 am --> 00:00 (24-h format, midnight, start of day)\n* \n* Differs from momentjs parse rules:\n* 00:00 pm, 12:00 pm --> 12:00 (24-h format, day not change)\n* 00:00 am, 12:00 am --> 00:00 (24-h format, day not change)\n* \n* \n* Author: Vitaliy Potapov\n* Project page: http://github.com/vitalets/combodate\n* Copyright (c) 2012 Vitaliy Potapov. Released under MIT License.\n**/\n(function ($) {\n\n    var Combodate = function Combodate(element, options) {\n        this.$element = $(element);\n        if (!this.$element.is('input')) {\n            $.error('Combodate should be applied to INPUT element');\n            return;\n        }\n        this.options = $.extend({}, $.fn.combodate.defaults, options, this.$element.data());\n        this.init();\n    };\n\n    Combodate.prototype = {\n        constructor: Combodate,\n        init: function init() {\n            this.map = {\n                //key   regexp    moment.method\n                day: ['D', 'date'],\n                month: ['M', 'month'],\n                year: ['Y', 'year'],\n                hour: ['[Hh]', 'hours'],\n                minute: ['m', 'minutes'],\n                second: ['s', 'seconds'],\n                ampm: ['[Aa]', '']\n            };\n\n            this.$widget = $('<span class=\"combodate\"></span>').html(this.getTemplate());\n\n            this.initCombos();\n\n            //update original input on change \n            this.$widget.on('change', 'select', $.proxy(function (e) {\n                this.$element.val(this.getValue()).change();\n                // update days count if month or year changes\n                if (this.options.smartDays) {\n                    if ($(e.target).is('.month') || $(e.target).is('.year')) {\n                        this.fillCombo('day');\n                    }\n                }\n            }, this));\n\n            this.$widget.find('select').css('width', 'auto');\n\n            // hide original input and insert widget                                       \n            this.$element.hide().after(this.$widget);\n\n            // set initial value\n            this.setValue(this.$element.val() || this.options.value);\n        },\n\n        /*\n         Replace tokens in template with <select> elements \n        */\n        getTemplate: function getTemplate() {\n            var tpl = this.options.template;\n\n            //first pass\n            $.each(this.map, function (k, v) {\n                v = v[0];\n                var r = new RegExp(v + '+'),\n                    token = v.length > 1 ? v.substring(1, 2) : v;\n\n                tpl = tpl.replace(r, '{' + token + '}');\n            });\n\n            //replace spaces with &nbsp;\n            tpl = tpl.replace(/ /g, '&nbsp;');\n\n            //second pass\n            $.each(this.map, function (k, v) {\n                v = v[0];\n                var token = v.length > 1 ? v.substring(1, 2) : v;\n\n                tpl = tpl.replace('{' + token + '}', '<select class=\"' + k + '\"></select>');\n            });\n\n            return tpl;\n        },\n\n        /*\n         Initialize combos that presents in template \n        */\n        initCombos: function initCombos() {\n            for (var k in this.map) {\n                var $c = this.$widget.find('.' + k);\n                // set properties like this.$day, this.$month etc.\n                this['$' + k] = $c.length ? $c : null;\n                // fill with items\n                this.fillCombo(k);\n            }\n        },\n\n        /*\n         Fill combo with items \n        */\n        fillCombo: function fillCombo(k) {\n            var $combo = this['$' + k];\n            if (!$combo) {\n                return;\n            }\n\n            // define method name to fill items, e.g `fillDays`\n            var f = 'fill' + k.charAt(0).toUpperCase() + k.slice(1);\n            var items = this[f]();\n            var value = $combo.val();\n\n            $combo.empty();\n            for (var i = 0; i < items.length; i++) {\n                $combo.append('<option value=\"' + items[i][0] + '\">' + items[i][1] + '</option>');\n            }\n\n            $combo.val(value);\n        },\n\n        /*\n         Initialize items of combos. Handles `firstItem` option \n        */\n        fillCommon: function fillCommon(key) {\n            var values = [],\n                relTime;\n\n            if (this.options.firstItem === 'name') {\n                //need both to support moment ver < 2 and  >= 2\n                relTime = moment.relativeTime || moment.langData()._relativeTime;\n                var header = typeof relTime[key] === 'function' ? relTime[key](1, true, key, false) : relTime[key];\n                //take last entry (see momentjs lang files structure) \n                header = header.split(' ').reverse()[0];\n                values.push(['', header]);\n            } else if (this.options.firstItem === 'empty') {\n                values.push(['', '']);\n            }\n            return values;\n        },\n\n        /*\n        fill day\n        */\n        fillDay: function fillDay() {\n            var items = this.fillCommon('d'),\n                name,\n                i,\n                twoDigit = this.options.template.indexOf('DD') !== -1,\n                daysCount = 31;\n\n            // detect days count (depends on month and year)\n            // originally https://github.com/vitalets/combodate/pull/7\n            if (this.options.smartDays && this.$month && this.$year) {\n                var month = parseInt(this.$month.val(), 10);\n                var year = parseInt(this.$year.val(), 10);\n\n                if (!isNaN(month) && !isNaN(year)) {\n                    daysCount = moment([year, month]).daysInMonth();\n                }\n            }\n\n            for (i = 1; i <= daysCount; i++) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            }\n            return items;\n        },\n\n        /*\n        fill month\n        */\n        fillMonth: function fillMonth() {\n            var items = this.fillCommon('M'),\n                name,\n                i,\n                longNames = this.options.template.indexOf('MMMM') !== -1,\n                shortNames = this.options.template.indexOf('MMM') !== -1,\n                twoDigit = this.options.template.indexOf('MM') !== -1;\n\n            for (i = 0; i <= 11; i++) {\n                if (longNames) {\n                    //see https://github.com/timrwood/momentjs.com/pull/36\n                    name = moment().date(1).month(i).format('MMMM');\n                } else if (shortNames) {\n                    name = moment().date(1).month(i).format('MMM');\n                } else if (twoDigit) {\n                    name = this.leadZero(i + 1);\n                } else {\n                    name = i + 1;\n                }\n                items.push([i, name]);\n            }\n            return items;\n        },\n\n        /*\n        fill year\n        */\n        fillYear: function fillYear() {\n            var items = [],\n                name,\n                i,\n                longNames = this.options.template.indexOf('YYYY') !== -1;\n\n            for (i = this.options.maxYear; i >= this.options.minYear; i--) {\n                name = longNames ? i : (i + '').substring(2);\n                items[this.options.yearDescending ? 'push' : 'unshift']([i, name]);\n            }\n\n            items = this.fillCommon('y').concat(items);\n\n            return items;\n        },\n\n        /*\n        fill hour\n        */\n        fillHour: function fillHour() {\n            var items = this.fillCommon('h'),\n                name,\n                i,\n                h12 = this.options.template.indexOf('h') !== -1,\n                h24 = this.options.template.indexOf('H') !== -1,\n                twoDigit = this.options.template.toLowerCase().indexOf('hh') !== -1,\n                min = h12 ? 1 : 0,\n                max = h12 ? 12 : 23;\n\n            for (i = min; i <= max; i++) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            }\n            return items;\n        },\n\n        /*\n        fill minute\n        */\n        fillMinute: function fillMinute() {\n            var items = this.fillCommon('m'),\n                name,\n                i,\n                twoDigit = this.options.template.indexOf('mm') !== -1;\n\n            for (i = 0; i <= 59; i += this.options.minuteStep) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            }\n            return items;\n        },\n\n        /*\n        fill second\n        */\n        fillSecond: function fillSecond() {\n            var items = this.fillCommon('s'),\n                name,\n                i,\n                twoDigit = this.options.template.indexOf('ss') !== -1;\n\n            for (i = 0; i <= 59; i += this.options.secondStep) {\n                name = twoDigit ? this.leadZero(i) : i;\n                items.push([i, name]);\n            }\n            return items;\n        },\n\n        /*\n        fill ampm\n        */\n        fillAmpm: function fillAmpm() {\n            var ampmL = this.options.template.indexOf('a') !== -1,\n                ampmU = this.options.template.indexOf('A') !== -1,\n                items = [['am', ampmL ? 'am' : 'AM'], ['pm', ampmL ? 'pm' : 'PM']];\n            return items;\n        },\n\n        /*\n         Returns current date value from combos. \n         If format not specified - `options.format` used.\n         If format = `null` - Moment object returned.\n        */\n        getValue: function getValue(format) {\n            var dt,\n                values = {},\n                that = this,\n                notSelected = false;\n\n            //getting selected values    \n            $.each(this.map, function (k, v) {\n                if (k === 'ampm') {\n                    return;\n                }\n                var def = k === 'day' ? 1 : 0;\n\n                values[k] = that['$' + k] ? parseInt(that['$' + k].val(), 10) : def;\n\n                if (isNaN(values[k])) {\n                    notSelected = true;\n                    return false;\n                }\n            });\n\n            //if at least one visible combo not selected - return empty string\n            if (notSelected) {\n                return '';\n            }\n\n            //convert hours 12h --> 24h \n            if (this.$ampm) {\n                //12:00 pm --> 12:00 (24-h format, midday), 12:00 am --> 00:00 (24-h format, midnight, start of day)\n                if (values.hour === 12) {\n                    values.hour = this.$ampm.val() === 'am' ? 0 : 12;\n                } else {\n                    values.hour = this.$ampm.val() === 'am' ? values.hour : values.hour + 12;\n                }\n            }\n\n            dt = moment([values.year, values.month, values.day, values.hour, values.minute, values.second]);\n\n            //highlight invalid date\n            this.highlight(dt);\n\n            format = format === undefined ? this.options.format : format;\n            if (format === null) {\n                return dt.isValid() ? dt : null;\n            } else {\n                return dt.isValid() ? dt.format(format) : '';\n            }\n        },\n\n        setValue: function setValue(value) {\n            if (!value) {\n                return;\n            }\n\n            var dt = typeof value === 'string' ? moment(value, this.options.format) : moment(value),\n                that = this,\n                values = {};\n\n            //function to find nearest value in select options\n            function getNearest($select, value) {\n                var delta = {};\n                $select.children('option').each(function (i, opt) {\n                    var optValue = $(opt).attr('value'),\n                        distance;\n\n                    if (optValue === '') return;\n                    distance = Math.abs(optValue - value);\n                    if (typeof delta.distance === 'undefined' || distance < delta.distance) {\n                        delta = { value: optValue, distance: distance };\n                    }\n                });\n                return delta.value;\n            }\n\n            if (dt.isValid()) {\n                //read values from date object\n                $.each(this.map, function (k, v) {\n                    if (k === 'ampm') {\n                        return;\n                    }\n                    values[k] = dt[v[1]]();\n                });\n\n                if (this.$ampm) {\n                    //12:00 pm --> 12:00 (24-h format, midday), 12:00 am --> 00:00 (24-h format, midnight, start of day)\n                    if (values.hour >= 12) {\n                        values.ampm = 'pm';\n                        if (values.hour > 12) {\n                            values.hour -= 12;\n                        }\n                    } else {\n                        values.ampm = 'am';\n                        if (values.hour === 0) {\n                            values.hour = 12;\n                        }\n                    }\n                }\n\n                $.each(values, function (k, v) {\n                    //call val() for each existing combo, e.g. this.$hour.val()\n                    if (that['$' + k]) {\n\n                        if (k === 'minute' && that.options.minuteStep > 1 && that.options.roundTime) {\n                            v = getNearest(that['$' + k], v);\n                        }\n\n                        if (k === 'second' && that.options.secondStep > 1 && that.options.roundTime) {\n                            v = getNearest(that['$' + k], v);\n                        }\n\n                        that['$' + k].val(v);\n                    }\n                });\n\n                // update days count\n                if (this.options.smartDays) {\n                    this.fillCombo('day');\n                }\n\n                this.$element.val(dt.format(this.options.format)).change();\n            }\n        },\n\n        /*\n         highlight combos if date is invalid\n        */\n        highlight: function highlight(dt) {\n            if (!dt.isValid()) {\n                if (this.options.errorClass) {\n                    this.$widget.addClass(this.options.errorClass);\n                } else {\n                    //store original border color\n                    if (!this.borderColor) {\n                        this.borderColor = this.$widget.find('select').css('border-color');\n                    }\n                    this.$widget.find('select').css('border-color', 'red');\n                }\n            } else {\n                if (this.options.errorClass) {\n                    this.$widget.removeClass(this.options.errorClass);\n                } else {\n                    this.$widget.find('select').css('border-color', this.borderColor);\n                }\n            }\n        },\n\n        leadZero: function leadZero(v) {\n            return v <= 9 ? '0' + v : v;\n        },\n\n        destroy: function destroy() {\n            this.$widget.remove();\n            this.$element.removeData('combodate').show();\n        }\n\n        //todo: clear method        \n    };\n\n    $.fn.combodate = function (option) {\n        var d,\n            args = Array.apply(null, arguments);\n        args.shift();\n\n        //getValue returns date as string / object (not jQuery object)\n        if (option === 'getValue' && this.length && (d = this.eq(0).data('combodate'))) {\n            return d.getValue.apply(d, args);\n        }\n\n        return this.each(function () {\n            var $this = $(this),\n                data = $this.data('combodate'),\n                options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option;\n            if (!data) {\n                $this.data('combodate', data = new Combodate(this, options));\n            }\n            if (typeof option == 'string' && typeof data[option] == 'function') {\n                data[option].apply(data, args);\n            }\n        });\n    };\n\n    $.fn.combodate.defaults = {\n        //in this format value stored in original input\n        format: 'DD-MM-YYYY HH:mm',\n        //in this format items in dropdowns are displayed\n        template: 'D / MMM / YYYY   H : mm',\n        //initial value, can be `new Date()`    \n        value: null,\n        minYear: 1970,\n        maxYear: 2015,\n        yearDescending: true,\n        minuteStep: 5,\n        secondStep: 1,\n        firstItem: 'empty', //'name', 'empty', 'none'\n        errorClass: null,\n        roundTime: true, // whether to round minutes and seconds if step > 1\n        smartDays: false // whether days in combo depend on selected month: 31, 30, 28\n    };\n})(window.jQuery);\n/**\nCombodate input - dropdown date and time picker.    \nBased on [combodate](http://vitalets.github.com/combodate) plugin (included). To use it you should manually include [momentjs](http://momentjs.com).\n\n    <script src=\"js/moment.min.js\"></script>\n   \nAllows to input:\n\n* only date\n* only time \n* both date and time  \n\nPlease note, that format is taken from momentjs and **not compatible** with bootstrap-datepicker / jquery UI datepicker.  \nInternally value stored as `momentjs` object. \n\n@class combodate\n@extends abstractinput\n@final\n@since 1.4.0\n@example\n<a href=\"#\" id=\"dob\" data-type=\"combodate\" data-pk=\"1\" data-url=\"/post\" data-value=\"1984-05-15\" data-title=\"Select date\"></a>\n<script>\n$(function(){\n    $('#dob').editable({\n        format: 'YYYY-MM-DD',    \n        viewformat: 'DD.MM.YYYY',    \n        template: 'D / MMMM / YYYY',    \n        combodate: {\n                minYear: 2000,\n                maxYear: 2015,\n                minuteStep: 1\n           }\n        }\n    });\n});\n</script>\n**/\n\n/*global moment*/\n\n(function ($) {\n    ;\n\n    var Constructor = function Constructor(options) {\n        this.init('combodate', options, Constructor.defaults);\n\n        //by default viewformat equals to format\n        if (!this.options.viewformat) {\n            this.options.viewformat = this.options.format;\n        }\n\n        //try parse combodate config defined as json string in data-combodate\n        options.combodate = $.fn.editableutils.tryParseJson(options.combodate, true);\n\n        //overriding combodate config (as by default jQuery extend() is not recursive)\n        this.options.combodate = $.extend({}, Constructor.defaults.combodate, options.combodate, {\n            format: this.options.format,\n            template: this.options.template\n        });\n    };\n\n    $.fn.editableutils.inherit(Constructor, $.fn.editabletypes.abstractinput);\n\n    $.extend(Constructor.prototype, {\n        render: function render() {\n            this.$input.combodate(this.options.combodate);\n\n            if ($.fn.editableform.engine === 'bs3') {\n                this.$input.siblings().find('select').addClass('form-control');\n            }\n\n            if (this.options.inputclass) {\n                this.$input.siblings().find('select').addClass(this.options.inputclass);\n            }\n            //\"clear\" link\n            /*\n            if(this.options.clear) {\n                this.$clear = $('<a href=\"#\"></a>').html(this.options.clear).click($.proxy(function(e){\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.clear();\n                }, this));\n                \n                this.$tpl.parent().append($('<div class=\"editable-clear\">').append(this.$clear));  \n            } \n            */\n        },\n\n        value2html: function value2html(value, element) {\n            var text = value ? value.format(this.options.viewformat) : '';\n            //$(element).text(text);\n            Constructor.superclass.value2html.call(this, text, element);\n        },\n\n        html2value: function html2value(html) {\n            return html ? moment(html, this.options.viewformat) : null;\n        },\n\n        value2str: function value2str(value) {\n            return value ? value.format(this.options.format) : '';\n        },\n\n        str2value: function str2value(str) {\n            return str ? moment(str, this.options.format) : null;\n        },\n\n        value2submit: function value2submit(value) {\n            return this.value2str(value);\n        },\n\n        value2input: function value2input(value) {\n            this.$input.combodate('setValue', value);\n        },\n\n        input2value: function input2value() {\n            return this.$input.combodate('getValue', null);\n        },\n\n        activate: function activate() {\n            this.$input.siblings('.combodate').find('select').eq(0).focus();\n        },\n\n        /*\n        clear:  function() {\n           this.$input.data('datepicker').date = null;\n           this.$input.find('.active').removeClass('active');\n        },\n        */\n\n        autosubmit: function autosubmit() {}\n\n    });\n\n    Constructor.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <input type=\"text\">\n        **/\n        tpl: '<input type=\"text\">',\n        /**\n        @property inputclass \n        @default null\n        **/\n        inputclass: null,\n        /**\n        Format used for sending value to server. Also applied when converting date from <code>data-value</code> attribute.<br>\n        See list of tokens in [momentjs docs](http://momentjs.com/docs/#/parsing/string-format)  \n        \n        @property format \n        @type string\n        @default YYYY-MM-DD\n        **/\n        format: 'YYYY-MM-DD',\n        /**\n        Format used for displaying date. Also applied when converting date from element's text on init.   \n        If not specified equals to `format`.\n        \n        @property viewformat \n        @type string\n        @default null\n        **/\n        viewformat: null,\n        /**\n        Template used for displaying dropdowns.\n        \n        @property template \n        @type string\n        @default D / MMM / YYYY\n        **/\n        template: 'D / MMM / YYYY',\n        /**\n        Configuration of combodate.\n        Full list of options: http://vitalets.github.com/combodate/#docs\n        \n        @property combodate \n        @type object\n        @default null\n        **/\n        combodate: null\n\n        /*\n        (not implemented yet)\n        Text shown as clear date button. \n        If <code>false</code> clear button will not be rendered.\n        \n        @property clear \n        @type boolean|string\n        @default 'x clear'         \n        */\n        //clear: '&times; clear'\n    });\n\n    $.fn.editabletypes.combodate = Constructor;\n})(window.jQuery);\n\n/*\nEditableform based on Twitter Bootstrap 3\n*/\n(function ($) {\n    ;\n\n    //store parent methods\n    var pInitInput = $.fn.editableform.Constructor.prototype.initInput;\n\n    $.extend($.fn.editableform.Constructor.prototype, {\n        initTemplate: function initTemplate() {\n            this.$form = $($.fn.editableform.template);\n            this.$form.find('.control-group').addClass('form-group');\n            this.$form.find('.editable-error-block').addClass('help-block');\n        },\n        initInput: function initInput() {\n            pInitInput.apply(this);\n\n            //for bs3 set default class `input-sm` to standard inputs\n            var emptyInputClass = this.input.options.inputclass === null || this.input.options.inputclass === false;\n            var defaultClass = 'input-sm';\n\n            //bs3 add `form-control` class to standard inputs\n            var stdtypes = 'text,select,textarea,password,email,url,tel,number,range,time,typeaheadjs'.split(',');\n            if (~$.inArray(this.input.type, stdtypes)) {\n                this.input.$input.addClass('form-control');\n                if (emptyInputClass) {\n                    this.input.options.inputclass = defaultClass;\n                    this.input.$input.addClass(defaultClass);\n                }\n            }\n\n            //apply bs3 size class also to buttons (to fit size of control)\n            var $btn = this.$form.find('.editable-buttons');\n            var classes = emptyInputClass ? [defaultClass] : this.input.options.inputclass.split(' ');\n            for (var i = 0; i < classes.length; i++) {\n                // `btn-sm` is default now\n                /*\n                if(classes[i].toLowerCase() === 'input-sm') { \n                    $btn.find('button').addClass('btn-sm');  \n                }\n                */\n                if (classes[i].toLowerCase() === 'input-lg') {\n                    $btn.find('button').removeClass('btn-sm').addClass('btn-lg');\n                }\n            }\n        }\n    });\n\n    //buttons\n    $.fn.editableform.buttons = '<button type=\"submit\" class=\"btn btn-primary btn-sm editable-submit\">' + '<i class=\"fa fa-ok\"></i>' + '</button>' + '<button type=\"button\" class=\"btn btn-default btn-sm editable-cancel\">' + '<i class=\"fa fa-remove\"></i>' + '</button>';\n\n    //error classes\n    $.fn.editableform.errorGroupClass = 'has-error';\n    $.fn.editableform.errorBlockClass = null;\n    //engine\n    $.fn.editableform.engine = 'bs3';\n})(window.jQuery);\n/**\n* Editable Popover3 (for Bootstrap 3) \n* ---------------------\n* requires bootstrap-popover.js\n*/\n(function ($) {\n    ;\n\n    //extend methods\n    $.extend($.fn.editableContainer.Popup.prototype, {\n        containerName: 'popover',\n        containerDataName: 'bs.popover',\n        innerCss: '.popover-content',\n        defaults: $.fn.popover.Constructor.DEFAULTS,\n\n        initContainer: function initContainer() {\n            $.extend(this.containerOptions, {\n                trigger: 'manual',\n                selector: false,\n                content: ' ',\n                template: this.defaults.template\n            });\n\n            //as template property is used in inputs, hide it from popover\n            var t;\n            if (this.$element.data('template')) {\n                t = this.$element.data('template');\n                this.$element.removeData('template');\n            }\n\n            this.call(this.containerOptions);\n\n            if (t) {\n                //restore data('template')\n                this.$element.data('template', t);\n            }\n        },\n\n        /* show */\n        innerShow: function innerShow() {\n            this.call('show');\n        },\n\n        /* hide */\n        innerHide: function innerHide() {\n            this.call('hide');\n        },\n\n        /* destroy */\n        innerDestroy: function innerDestroy() {\n            this.call('destroy');\n        },\n\n        setContainerOption: function setContainerOption(key, value) {\n            this.container().options[key] = value;\n        },\n\n        /**\n        * move popover to new position. This function mainly copied from bootstrap-popover.\n        */\n        /*jshint laxcomma: true, eqeqeq: false*/\n        setPosition: function setPosition() {\n\n            (function () {\n                /*    \n                    var $tip = this.tip()\n                    , inside\n                    , pos\n                    , actualWidth\n                    , actualHeight\n                    , placement\n                    , tp\n                    , tpt\n                    , tpb\n                    , tpl\n                    , tpr;\n                     placement = typeof this.options.placement === 'function' ?\n                    this.options.placement.call(this, $tip[0], this.$element[0]) :\n                    this.options.placement;\n                     inside = /in/.test(placement);\n                   \n                    $tip\n                  //  .detach()\n                  //vitalets: remove any placement class because otherwise they dont influence on re-positioning of visible popover\n                    .removeClass('top right bottom left')\n                    .css({ top: 0, left: 0, display: 'block' });\n                  //  .insertAfter(this.$element);\n                   \n                    pos = this.getPosition(inside);\n                     actualWidth = $tip[0].offsetWidth;\n                    actualHeight = $tip[0].offsetHeight;\n                     placement = inside ? placement.split(' ')[1] : placement;\n                     tpb = {top: pos.top + pos.height, left: pos.left + pos.width / 2 - actualWidth / 2};\n                    tpt = {top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2};\n                    tpl = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth};\n                    tpr = {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width};\n                     switch (placement) {\n                        case 'bottom':\n                            if ((tpb.top + actualHeight) > ($(window).scrollTop() + $(window).height())) {\n                                if (tpt.top > $(window).scrollTop()) {\n                                    placement = 'top';\n                                } else if ((tpr.left + actualWidth) < ($(window).scrollLeft() + $(window).width())) {\n                                    placement = 'right';\n                                } else if (tpl.left > $(window).scrollLeft()) {\n                                    placement = 'left';\n                                } else {\n                                    placement = 'right';\n                                }\n                            }\n                            break;\n                        case 'top':\n                            if (tpt.top < $(window).scrollTop()) {\n                                if ((tpb.top + actualHeight) < ($(window).scrollTop() + $(window).height())) {\n                                    placement = 'bottom';\n                                } else if ((tpr.left + actualWidth) < ($(window).scrollLeft() + $(window).width())) {\n                                    placement = 'right';\n                                } else if (tpl.left > $(window).scrollLeft()) {\n                                    placement = 'left';\n                                } else {\n                                    placement = 'right';\n                                }\n                            }\n                            break;\n                        case 'left':\n                            if (tpl.left < $(window).scrollLeft()) {\n                                if ((tpr.left + actualWidth) < ($(window).scrollLeft() + $(window).width())) {\n                                    placement = 'right';\n                                } else if (tpt.top > $(window).scrollTop()) {\n                                    placement = 'top';\n                                } else if (tpt.top > $(window).scrollTop()) {\n                                    placement = 'bottom';\n                                } else {\n                                    placement = 'right';\n                                }\n                            }\n                            break;\n                        case 'right':\n                            if ((tpr.left + actualWidth) > ($(window).scrollLeft() + $(window).width())) {\n                                if (tpl.left > $(window).scrollLeft()) {\n                                    placement = 'left';\n                                } else if (tpt.top > $(window).scrollTop()) {\n                                    placement = 'top';\n                                } else if (tpt.top > $(window).scrollTop()) {\n                                    placement = 'bottom';\n                                }\n                            }\n                            break;\n                    }\n                     switch (placement) {\n                        case 'bottom':\n                            tp = tpb;\n                            break;\n                        case 'top':\n                            tp = tpt;\n                            break;\n                        case 'left':\n                            tp = tpl;\n                            break;\n                        case 'right':\n                            tp = tpr;\n                            break;\n                    }\n                     $tip\n                    .offset(tp)\n                    .addClass(placement)\n                    .addClass('in');\n                */\n\n                var $tip = this.tip();\n\n                var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;\n\n                var autoToken = /\\s?auto?\\s?/i;\n                var autoPlace = autoToken.test(placement);\n                if (autoPlace) {\n                    placement = placement.replace(autoToken, '') || 'top';\n                }\n\n                var pos = this.getPosition();\n                var actualWidth = $tip[0].offsetWidth;\n                var actualHeight = $tip[0].offsetHeight;\n\n                if (autoPlace) {\n                    var $parent = this.$element.parent();\n\n                    var orgPlacement = placement;\n                    var docScroll = document.documentElement.scrollTop || document.body.scrollTop;\n                    var parentWidth = this.options.container == 'body' ? window.innerWidth : $parent.outerWidth();\n                    var parentHeight = this.options.container == 'body' ? window.innerHeight : $parent.outerHeight();\n                    var parentLeft = this.options.container == 'body' ? 0 : $parent.offset().left;\n\n                    placement = placement == 'bottom' && pos.top + pos.height + actualHeight - docScroll > parentHeight ? 'top' : placement == 'top' && pos.top - docScroll - actualHeight < 0 ? 'bottom' : placement == 'right' && pos.right + actualWidth > parentWidth ? 'left' : placement == 'left' && pos.left - actualWidth < parentLeft ? 'right' : placement;\n\n                    $tip.removeClass(orgPlacement).addClass(placement);\n                }\n\n                var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);\n\n                this.applyPlacement(calculatedOffset, placement);\n            }).call(this.container());\n            /*jshint laxcomma: false, eqeqeq: true*/\n        }\n    });\n})(window.jQuery);\n\n/* =========================================================\n * bootstrap-datepicker.js\n * http://www.eyecon.ro/bootstrap-datepicker\n * =========================================================\n * Copyright 2012 Stefan Petre\n * Improvements by Andrew Rowls\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ========================================================= */\n\n(function ($) {\n\n    function UTCDate() {\n        return new Date(Date.UTC.apply(Date, arguments));\n    }\n    function UTCToday() {\n        var today = new Date();\n        return UTCDate(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate());\n    }\n\n    // Picker object\n\n    var Datepicker = function Datepicker(element, options) {\n        var that = this;\n\n        this._process_options(options);\n\n        this.element = $(element);\n        this.isInline = false;\n        this.isInput = this.element.is('input');\n        this.component = this.element.is('.date') ? this.element.find('.add-on, .btn') : false;\n        this.hasInput = this.component && this.element.find('input').length;\n        if (this.component && this.component.length === 0) this.component = false;\n\n        this.picker = $(DPGlobal.template);\n        this._buildEvents();\n        this._attachEvents();\n\n        if (this.isInline) {\n            this.picker.addClass('datepicker-inline').appendTo(this.element);\n        } else {\n            this.picker.addClass('datepicker-dropdown dropdown-menu');\n        }\n\n        if (this.o.rtl) {\n            this.picker.addClass('datepicker-rtl');\n            this.picker.find('.prev i, .next i').toggleClass('icon-arrow-left icon-arrow-right');\n        }\n\n        this.viewMode = this.o.startView;\n\n        if (this.o.calendarWeeks) this.picker.find('tfoot th.today').attr('colspan', function (i, val) {\n            return parseInt(val) + 1;\n        });\n\n        this._allow_update = false;\n\n        this.setStartDate(this.o.startDate);\n        this.setEndDate(this.o.endDate);\n        this.setDaysOfWeekDisabled(this.o.daysOfWeekDisabled);\n\n        this.fillDow();\n        this.fillMonths();\n\n        this._allow_update = true;\n\n        this.update();\n        this.showMode();\n\n        if (this.isInline) {\n            this.show();\n        }\n    };\n\n    Datepicker.prototype = {\n        constructor: Datepicker,\n\n        _process_options: function _process_options(opts) {\n            // Store raw options for reference\n            this._o = $.extend({}, this._o, opts);\n            // Processed options\n            var o = this.o = $.extend({}, this._o);\n\n            // Check if \"de-DE\" style date is available, if not language should\n            // fallback to 2 letter code eg \"de\"\n            var lang = o.language;\n            if (!dates[lang]) {\n                lang = lang.split('-')[0];\n                if (!dates[lang]) lang = defaults.language;\n            }\n            o.language = lang;\n\n            switch (o.startView) {\n                case 2:\n                case 'decade':\n                    o.startView = 2;\n                    break;\n                case 1:\n                case 'year':\n                    o.startView = 1;\n                    break;\n                default:\n                    o.startView = 0;\n            }\n\n            switch (o.minViewMode) {\n                case 1:\n                case 'months':\n                    o.minViewMode = 1;\n                    break;\n                case 2:\n                case 'years':\n                    o.minViewMode = 2;\n                    break;\n                default:\n                    o.minViewMode = 0;\n            }\n\n            o.startView = Math.max(o.startView, o.minViewMode);\n\n            o.weekStart %= 7;\n            o.weekEnd = (o.weekStart + 6) % 7;\n\n            var format = DPGlobal.parseFormat(o.format);\n            if (o.startDate !== -Infinity) {\n                o.startDate = DPGlobal.parseDate(o.startDate, format, o.language);\n            }\n            if (o.endDate !== Infinity) {\n                o.endDate = DPGlobal.parseDate(o.endDate, format, o.language);\n            }\n\n            o.daysOfWeekDisabled = o.daysOfWeekDisabled || [];\n            if (!$.isArray(o.daysOfWeekDisabled)) o.daysOfWeekDisabled = o.daysOfWeekDisabled.split(/[,\\s]*/);\n            o.daysOfWeekDisabled = $.map(o.daysOfWeekDisabled, function (d) {\n                return parseInt(d, 10);\n            });\n        },\n        _events: [],\n        _secondaryEvents: [],\n        _applyEvents: function _applyEvents(evs) {\n            for (var i = 0, el, ev; i < evs.length; i++) {\n                el = evs[i][0];\n                ev = evs[i][1];\n                el.on(ev);\n            }\n        },\n        _unapplyEvents: function _unapplyEvents(evs) {\n            for (var i = 0, el, ev; i < evs.length; i++) {\n                el = evs[i][0];\n                ev = evs[i][1];\n                el.off(ev);\n            }\n        },\n        _buildEvents: function _buildEvents() {\n            if (this.isInput) {\n                // single input\n                this._events = [[this.element, {\n                    focus: $.proxy(this.show, this),\n                    keyup: $.proxy(this.update, this),\n                    keydown: $.proxy(this.keydown, this)\n                }]];\n            } else if (this.component && this.hasInput) {\n                // component: input + button\n                this._events = [\n                // For components that are not readonly, allow keyboard nav\n                [this.element.find('input'), {\n                    focus: $.proxy(this.show, this),\n                    keyup: $.proxy(this.update, this),\n                    keydown: $.proxy(this.keydown, this)\n                }], [this.component, {\n                    click: $.proxy(this.show, this)\n                }]];\n            } else if (this.element.is('div')) {\n                // inline datepicker\n                this.isInline = true;\n            } else {\n                this._events = [[this.element, {\n                    click: $.proxy(this.show, this)\n                }]];\n            }\n\n            this._secondaryEvents = [[this.picker, {\n                click: $.proxy(this.click, this)\n            }], [$(window), {\n                resize: $.proxy(this.place, this)\n            }], [$(document), {\n                mousedown: $.proxy(function (e) {\n                    // Clicked outside the datepicker, hide it\n                    if (!(this.element.is(e.target) || this.element.find(e.target).size() || this.picker.is(e.target) || this.picker.find(e.target).size())) {\n                        this.hide();\n                    }\n                }, this)\n            }]];\n        },\n        _attachEvents: function _attachEvents() {\n            this._detachEvents();\n            this._applyEvents(this._events);\n        },\n        _detachEvents: function _detachEvents() {\n            this._unapplyEvents(this._events);\n        },\n        _attachSecondaryEvents: function _attachSecondaryEvents() {\n            this._detachSecondaryEvents();\n            this._applyEvents(this._secondaryEvents);\n        },\n        _detachSecondaryEvents: function _detachSecondaryEvents() {\n            this._unapplyEvents(this._secondaryEvents);\n        },\n        _trigger: function _trigger(event, altdate) {\n            var date = altdate || this.date,\n                local_date = new Date(date.getTime() + date.getTimezoneOffset() * 60000);\n\n            this.element.trigger({\n                type: event,\n                date: local_date,\n                format: $.proxy(function (altformat) {\n                    var format = altformat || this.o.format;\n                    return DPGlobal.formatDate(date, format, this.o.language);\n                }, this)\n            });\n        },\n\n        show: function show(e) {\n            if (!this.isInline) this.picker.appendTo('body');\n            this.picker.show();\n            this.height = this.component ? this.component.outerHeight() : this.element.outerHeight();\n            this.place();\n            this._attachSecondaryEvents();\n            if (e) {\n                e.preventDefault();\n            }\n            this._trigger('show');\n        },\n\n        hide: function hide(e) {\n            if (this.isInline) return;\n            if (!this.picker.is(':visible')) return;\n            this.picker.hide().detach();\n            this._detachSecondaryEvents();\n            this.viewMode = this.o.startView;\n            this.showMode();\n\n            if (this.o.forceParse && (this.isInput && this.element.val() || this.hasInput && this.element.find('input').val())) this.setValue();\n            this._trigger('hide');\n        },\n\n        remove: function remove() {\n            this.hide();\n            this._detachEvents();\n            this._detachSecondaryEvents();\n            this.picker.remove();\n            delete this.element.data().datepicker;\n            if (!this.isInput) {\n                delete this.element.data().date;\n            }\n        },\n\n        getDate: function getDate() {\n            var d = this.getUTCDate();\n            return new Date(d.getTime() + d.getTimezoneOffset() * 60000);\n        },\n\n        getUTCDate: function getUTCDate() {\n            return this.date;\n        },\n\n        setDate: function setDate(d) {\n            this.setUTCDate(new Date(d.getTime() - d.getTimezoneOffset() * 60000));\n        },\n\n        setUTCDate: function setUTCDate(d) {\n            this.date = d;\n            this.setValue();\n        },\n\n        setValue: function setValue() {\n            var formatted = this.getFormattedDate();\n            if (!this.isInput) {\n                if (this.component) {\n                    this.element.find('input').val(formatted);\n                }\n            } else {\n                this.element.val(formatted);\n            }\n        },\n\n        getFormattedDate: function getFormattedDate(format) {\n            if (format === undefined) format = this.o.format;\n            return DPGlobal.formatDate(this.date, format, this.o.language);\n        },\n\n        setStartDate: function setStartDate(startDate) {\n            this._process_options({ startDate: startDate });\n            this.update();\n            this.updateNavArrows();\n        },\n\n        setEndDate: function setEndDate(endDate) {\n            this._process_options({ endDate: endDate });\n            this.update();\n            this.updateNavArrows();\n        },\n\n        setDaysOfWeekDisabled: function setDaysOfWeekDisabled(daysOfWeekDisabled) {\n            this._process_options({ daysOfWeekDisabled: daysOfWeekDisabled });\n            this.update();\n            this.updateNavArrows();\n        },\n\n        place: function place() {\n            if (this.isInline) return;\n            var zIndex = parseInt(this.element.parents().filter(function () {\n                return $(this).css('z-index') != 'auto';\n            }).first().css('z-index')) + 10;\n            var offset = this.component ? this.component.parent().offset() : this.element.offset();\n            var height = this.component ? this.component.outerHeight(true) : this.element.outerHeight(true);\n            this.picker.css({\n                top: offset.top + height,\n                left: offset.left,\n                zIndex: zIndex\n            });\n        },\n\n        _allow_update: true,\n        update: function update() {\n            if (!this._allow_update) return;\n\n            var date,\n                fromArgs = false;\n            if (arguments && arguments.length && (typeof arguments[0] === 'string' || arguments[0] instanceof Date)) {\n                date = arguments[0];\n                fromArgs = true;\n            } else {\n                date = this.isInput ? this.element.val() : this.element.data('date') || this.element.find('input').val();\n                delete this.element.data().date;\n            }\n\n            this.date = DPGlobal.parseDate(date, this.o.format, this.o.language);\n\n            if (fromArgs) this.setValue();\n\n            if (this.date < this.o.startDate) {\n                this.viewDate = new Date(this.o.startDate);\n            } else if (this.date > this.o.endDate) {\n                this.viewDate = new Date(this.o.endDate);\n            } else {\n                this.viewDate = new Date(this.date);\n            }\n            this.fill();\n        },\n\n        fillDow: function fillDow() {\n            var dowCnt = this.o.weekStart,\n                html = '<tr>';\n            if (this.o.calendarWeeks) {\n                var cell = '<th class=\"cw\">&nbsp;</th>';\n                html += cell;\n                this.picker.find('.datepicker-days thead tr:first-child').prepend(cell);\n            }\n            while (dowCnt < this.o.weekStart + 7) {\n                html += '<th class=\"dow\">' + dates[this.o.language].daysMin[dowCnt++ % 7] + '</th>';\n            }\n            html += '</tr>';\n            this.picker.find('.datepicker-days thead').append(html);\n        },\n\n        fillMonths: function fillMonths() {\n            var html = '',\n                i = 0;\n            while (i < 12) {\n                html += '<span class=\"month\">' + dates[this.o.language].monthsShort[i++] + '</span>';\n            }\n            this.picker.find('.datepicker-months td').html(html);\n        },\n\n        setRange: function setRange(range) {\n            if (!range || !range.length) delete this.range;else this.range = $.map(range, function (d) {\n                return d.valueOf();\n            });\n            this.fill();\n        },\n\n        getClassNames: function getClassNames(date) {\n            var cls = [],\n                year = this.viewDate.getUTCFullYear(),\n                month = this.viewDate.getUTCMonth(),\n                currentDate = this.date.valueOf(),\n                today = new Date();\n            if (date.getUTCFullYear() < year || date.getUTCFullYear() == year && date.getUTCMonth() < month) {\n                cls.push('old');\n            } else if (date.getUTCFullYear() > year || date.getUTCFullYear() == year && date.getUTCMonth() > month) {\n                cls.push('new');\n            }\n            // Compare internal UTC date with local today, not UTC today\n            if (this.o.todayHighlight && date.getUTCFullYear() == today.getFullYear() && date.getUTCMonth() == today.getMonth() && date.getUTCDate() == today.getDate()) {\n                cls.push('today');\n            }\n            if (currentDate && date.valueOf() == currentDate) {\n                cls.push('active');\n            }\n            if (date.valueOf() < this.o.startDate || date.valueOf() > this.o.endDate || $.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1) {\n                cls.push('disabled');\n            }\n            if (this.range) {\n                if (date > this.range[0] && date < this.range[this.range.length - 1]) {\n                    cls.push('range');\n                }\n                if ($.inArray(date.valueOf(), this.range) != -1) {\n                    cls.push('selected');\n                }\n            }\n            return cls;\n        },\n\n        fill: function fill() {\n            var d = new Date(this.viewDate),\n                year = d.getUTCFullYear(),\n                month = d.getUTCMonth(),\n                startYear = this.o.startDate !== -Infinity ? this.o.startDate.getUTCFullYear() : -Infinity,\n                startMonth = this.o.startDate !== -Infinity ? this.o.startDate.getUTCMonth() : -Infinity,\n                endYear = this.o.endDate !== Infinity ? this.o.endDate.getUTCFullYear() : Infinity,\n                endMonth = this.o.endDate !== Infinity ? this.o.endDate.getUTCMonth() : Infinity,\n                currentDate = this.date && this.date.valueOf(),\n                tooltip;\n            this.picker.find('.datepicker-days thead th.datepicker-switch').text(dates[this.o.language].months[month] + ' ' + year);\n            this.picker.find('tfoot th.today').text(dates[this.o.language].today).toggle(this.o.todayBtn !== false);\n            this.picker.find('tfoot th.clear').text(dates[this.o.language].clear).toggle(this.o.clearBtn !== false);\n            this.updateNavArrows();\n            this.fillMonths();\n            var prevMonth = UTCDate(year, month - 1, 28, 0, 0, 0, 0),\n                day = DPGlobal.getDaysInMonth(prevMonth.getUTCFullYear(), prevMonth.getUTCMonth());\n            prevMonth.setUTCDate(day);\n            prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7) % 7);\n            var nextMonth = new Date(prevMonth);\n            nextMonth.setUTCDate(nextMonth.getUTCDate() + 42);\n            nextMonth = nextMonth.valueOf();\n            var html = [];\n            var clsName;\n            while (prevMonth.valueOf() < nextMonth) {\n                if (prevMonth.getUTCDay() == this.o.weekStart) {\n                    html.push('<tr>');\n                    if (this.o.calendarWeeks) {\n                        // ISO 8601: First week contains first thursday.\n                        // ISO also states week starts on Monday, but we can be more abstract here.\n                        var\n                        // Start of current week: based on weekstart/current date\n                        ws = new Date(+prevMonth + (this.o.weekStart - prevMonth.getUTCDay() - 7) % 7 * 864e5),\n\n                        // Thursday of this week\n                        th = new Date(+ws + (7 + 4 - ws.getUTCDay()) % 7 * 864e5),\n\n                        // First Thursday of year, year from thursday\n                        yth = new Date(+(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (7 + 4 - yth.getUTCDay()) % 7 * 864e5),\n\n                        // Calendar week: ms between thursdays, div ms per day, div 7 days\n                        calWeek = (th - yth) / 864e5 / 7 + 1;\n                        html.push('<td class=\"cw\">' + calWeek + '</td>');\n                    }\n                }\n                clsName = this.getClassNames(prevMonth);\n                clsName.push('day');\n\n                var before = this.o.beforeShowDay(prevMonth);\n                if (before === undefined) before = {};else if (typeof before === 'boolean') before = { enabled: before };else if (typeof before === 'string') before = { classes: before };\n                if (before.enabled === false) clsName.push('disabled');\n                if (before.classes) clsName = clsName.concat(before.classes.split(/\\s+/));\n                if (before.tooltip) tooltip = before.tooltip;\n\n                clsName = $.unique(clsName);\n                html.push('<td class=\"' + clsName.join(' ') + '\"' + (tooltip ? ' title=\"' + tooltip + '\"' : '') + '>' + prevMonth.getUTCDate() + '</td>');\n                if (prevMonth.getUTCDay() == this.o.weekEnd) {\n                    html.push('</tr>');\n                }\n                prevMonth.setUTCDate(prevMonth.getUTCDate() + 1);\n            }\n            this.picker.find('.datepicker-days tbody').empty().append(html.join(''));\n            var currentYear = this.date && this.date.getUTCFullYear();\n\n            var months = this.picker.find('.datepicker-months').find('th:eq(1)').text(year).end().find('span').removeClass('active');\n            if (currentYear && currentYear == year) {\n                months.eq(this.date.getUTCMonth()).addClass('active');\n            }\n            if (year < startYear || year > endYear) {\n                months.addClass('disabled');\n            }\n            if (year == startYear) {\n                months.slice(0, startMonth).addClass('disabled');\n            }\n            if (year == endYear) {\n                months.slice(endMonth + 1).addClass('disabled');\n            }\n\n            html = '';\n            year = parseInt(year / 10, 10) * 10;\n            var yearCont = this.picker.find('.datepicker-years').find('th:eq(1)').text(year + '-' + (year + 9)).end().find('td');\n            year -= 1;\n            for (var i = -1; i < 11; i++) {\n                html += '<span class=\"year' + (i == -1 ? ' old' : i == 10 ? ' new' : '') + (currentYear == year ? ' active' : '') + (year < startYear || year > endYear ? ' disabled' : '') + '\">' + year + '</span>';\n                year += 1;\n            }\n            yearCont.html(html);\n        },\n\n        updateNavArrows: function updateNavArrows() {\n            if (!this._allow_update) return;\n\n            var d = new Date(this.viewDate),\n                year = d.getUTCFullYear(),\n                month = d.getUTCMonth();\n            switch (this.viewMode) {\n                case 0:\n                    if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear() && month <= this.o.startDate.getUTCMonth()) {\n                        this.picker.find('.prev').css({ visibility: 'hidden' });\n                    } else {\n                        this.picker.find('.prev').css({ visibility: 'visible' });\n                    }\n                    if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear() && month >= this.o.endDate.getUTCMonth()) {\n                        this.picker.find('.next').css({ visibility: 'hidden' });\n                    } else {\n                        this.picker.find('.next').css({ visibility: 'visible' });\n                    }\n                    break;\n                case 1:\n                case 2:\n                    if (this.o.startDate !== -Infinity && year <= this.o.startDate.getUTCFullYear()) {\n                        this.picker.find('.prev').css({ visibility: 'hidden' });\n                    } else {\n                        this.picker.find('.prev').css({ visibility: 'visible' });\n                    }\n                    if (this.o.endDate !== Infinity && year >= this.o.endDate.getUTCFullYear()) {\n                        this.picker.find('.next').css({ visibility: 'hidden' });\n                    } else {\n                        this.picker.find('.next').css({ visibility: 'visible' });\n                    }\n                    break;\n            }\n        },\n\n        click: function click(e) {\n            e.preventDefault();\n            var target = $(e.target).closest('span, td, th');\n            if (target.length == 1) {\n                switch (target[0].nodeName.toLowerCase()) {\n                    case 'th':\n                        switch (target[0].className) {\n                            case 'datepicker-switch':\n                                this.showMode(1);\n                                break;\n                            case 'prev':\n                            case 'next':\n                                var dir = DPGlobal.modes[this.viewMode].navStep * (target[0].className == 'prev' ? -1 : 1);\n                                switch (this.viewMode) {\n                                    case 0:\n                                        this.viewDate = this.moveMonth(this.viewDate, dir);\n                                        break;\n                                    case 1:\n                                    case 2:\n                                        this.viewDate = this.moveYear(this.viewDate, dir);\n                                        break;\n                                }\n                                this.fill();\n                                break;\n                            case 'today':\n                                var date = new Date();\n                                date = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);\n\n                                this.showMode(-2);\n                                var which = this.o.todayBtn == 'linked' ? null : 'view';\n                                this._setDate(date, which);\n                                break;\n                            case 'clear':\n                                var element;\n                                if (this.isInput) element = this.element;else if (this.component) element = this.element.find('input');\n                                if (element) element.val(\"\").change();\n                                this._trigger('changeDate');\n                                this.update();\n                                if (this.o.autoclose) this.hide();\n                                break;\n                        }\n                        break;\n                    case 'span':\n                        if (!target.is('.disabled')) {\n                            this.viewDate.setUTCDate(1);\n                            if (target.is('.month')) {\n                                var day = 1;\n                                var month = target.parent().find('span').index(target);\n                                var year = this.viewDate.getUTCFullYear();\n                                this.viewDate.setUTCMonth(month);\n                                this._trigger('changeMonth', this.viewDate);\n                                if (this.o.minViewMode === 1) {\n                                    this._setDate(UTCDate(year, month, day, 0, 0, 0, 0));\n                                }\n                            } else {\n                                var year = parseInt(target.text(), 10) || 0;\n                                var day = 1;\n                                var month = 0;\n                                this.viewDate.setUTCFullYear(year);\n                                this._trigger('changeYear', this.viewDate);\n                                if (this.o.minViewMode === 2) {\n                                    this._setDate(UTCDate(year, month, day, 0, 0, 0, 0));\n                                }\n                            }\n                            this.showMode(-1);\n                            this.fill();\n                        }\n                        break;\n                    case 'td':\n                        if (target.is('.day') && !target.is('.disabled')) {\n                            var day = parseInt(target.text(), 10) || 1;\n                            var year = this.viewDate.getUTCFullYear(),\n                                month = this.viewDate.getUTCMonth();\n                            if (target.is('.old')) {\n                                if (month === 0) {\n                                    month = 11;\n                                    year -= 1;\n                                } else {\n                                    month -= 1;\n                                }\n                            } else if (target.is('.new')) {\n                                if (month == 11) {\n                                    month = 0;\n                                    year += 1;\n                                } else {\n                                    month += 1;\n                                }\n                            }\n                            this._setDate(UTCDate(year, month, day, 0, 0, 0, 0));\n                        }\n                        break;\n                }\n            }\n        },\n\n        _setDate: function _setDate(date, which) {\n            if (!which || which == 'date') this.date = new Date(date);\n            if (!which || which == 'view') this.viewDate = new Date(date);\n            this.fill();\n            this.setValue();\n            this._trigger('changeDate');\n            var element;\n            if (this.isInput) {\n                element = this.element;\n            } else if (this.component) {\n                element = this.element.find('input');\n            }\n            if (element) {\n                element.change();\n                if (this.o.autoclose && (!which || which == 'date')) {\n                    this.hide();\n                }\n            }\n        },\n\n        moveMonth: function moveMonth(date, dir) {\n            if (!dir) return date;\n            var new_date = new Date(date.valueOf()),\n                day = new_date.getUTCDate(),\n                month = new_date.getUTCMonth(),\n                mag = Math.abs(dir),\n                new_month,\n                test;\n            dir = dir > 0 ? 1 : -1;\n            if (mag == 1) {\n                test = dir == -1\n                // If going back one month, make sure month is not current month\n                // (eg, Mar 31 -> Feb 31 == Feb 28, not Mar 02)\n                ? function () {\n                    return new_date.getUTCMonth() == month;\n                }\n                // If going forward one month, make sure month is as expected\n                // (eg, Jan 31 -> Feb 31 == Feb 28, not Mar 02)\n                : function () {\n                    return new_date.getUTCMonth() != new_month;\n                };\n                new_month = month + dir;\n                new_date.setUTCMonth(new_month);\n                // Dec -> Jan (12) or Jan -> Dec (-1) -- limit expected date to 0-11\n                if (new_month < 0 || new_month > 11) new_month = (new_month + 12) % 12;\n            } else {\n                // For magnitudes >1, move one month at a time...\n                for (var i = 0; i < mag; i++) {\n                    // ...which might decrease the day (eg, Jan 31 to Feb 28, etc)...\n                    new_date = this.moveMonth(new_date, dir);\n                } // ...then reset the day, keeping it in the new month\n                new_month = new_date.getUTCMonth();\n                new_date.setUTCDate(day);\n                test = function test() {\n                    return new_month != new_date.getUTCMonth();\n                };\n            }\n            // Common date-resetting loop -- if date is beyond end of month, make it\n            // end of month\n            while (test()) {\n                new_date.setUTCDate(--day);\n                new_date.setUTCMonth(new_month);\n            }\n            return new_date;\n        },\n\n        moveYear: function moveYear(date, dir) {\n            return this.moveMonth(date, dir * 12);\n        },\n\n        dateWithinRange: function dateWithinRange(date) {\n            return date >= this.o.startDate && date <= this.o.endDate;\n        },\n\n        keydown: function keydown(e) {\n            if (this.picker.is(':not(:visible)')) {\n                if (e.keyCode == 27) // allow escape to hide and re-show picker\n                    this.show();\n                return;\n            }\n            var dateChanged = false,\n                dir,\n                day,\n                month,\n                newDate,\n                newViewDate;\n            switch (e.keyCode) {\n                case 27:\n                    // escape\n                    this.hide();\n                    e.preventDefault();\n                    break;\n                case 37: // left\n                case 39:\n                    // right\n                    if (!this.o.keyboardNavigation) break;\n                    dir = e.keyCode == 37 ? -1 : 1;\n                    if (e.ctrlKey) {\n                        newDate = this.moveYear(this.date, dir);\n                        newViewDate = this.moveYear(this.viewDate, dir);\n                    } else if (e.shiftKey) {\n                        newDate = this.moveMonth(this.date, dir);\n                        newViewDate = this.moveMonth(this.viewDate, dir);\n                    } else {\n                        newDate = new Date(this.date);\n                        newDate.setUTCDate(this.date.getUTCDate() + dir);\n                        newViewDate = new Date(this.viewDate);\n                        newViewDate.setUTCDate(this.viewDate.getUTCDate() + dir);\n                    }\n                    if (this.dateWithinRange(newDate)) {\n                        this.date = newDate;\n                        this.viewDate = newViewDate;\n                        this.setValue();\n                        this.update();\n                        e.preventDefault();\n                        dateChanged = true;\n                    }\n                    break;\n                case 38: // up\n                case 40:\n                    // down\n                    if (!this.o.keyboardNavigation) break;\n                    dir = e.keyCode == 38 ? -1 : 1;\n                    if (e.ctrlKey) {\n                        newDate = this.moveYear(this.date, dir);\n                        newViewDate = this.moveYear(this.viewDate, dir);\n                    } else if (e.shiftKey) {\n                        newDate = this.moveMonth(this.date, dir);\n                        newViewDate = this.moveMonth(this.viewDate, dir);\n                    } else {\n                        newDate = new Date(this.date);\n                        newDate.setUTCDate(this.date.getUTCDate() + dir * 7);\n                        newViewDate = new Date(this.viewDate);\n                        newViewDate.setUTCDate(this.viewDate.getUTCDate() + dir * 7);\n                    }\n                    if (this.dateWithinRange(newDate)) {\n                        this.date = newDate;\n                        this.viewDate = newViewDate;\n                        this.setValue();\n                        this.update();\n                        e.preventDefault();\n                        dateChanged = true;\n                    }\n                    break;\n                case 13:\n                    // enter\n                    this.hide();\n                    e.preventDefault();\n                    break;\n                case 9:\n                    // tab\n                    this.hide();\n                    break;\n            }\n            if (dateChanged) {\n                this._trigger('changeDate');\n                var element;\n                if (this.isInput) {\n                    element = this.element;\n                } else if (this.component) {\n                    element = this.element.find('input');\n                }\n                if (element) {\n                    element.change();\n                }\n            }\n        },\n\n        showMode: function showMode(dir) {\n            if (dir) {\n                this.viewMode = Math.max(this.o.minViewMode, Math.min(2, this.viewMode + dir));\n            }\n            /*\n            \tvitalets: fixing bug of very special conditions:\n            \tjquery 1.7.1 + webkit + show inline datepicker in bootstrap popover.\n            \tMethod show() does not set display css correctly and datepicker is not shown.\n            \tChanged to .css('display', 'block') solve the problem.\n            \tSee https://github.com/vitalets/x-editable/issues/37\n            \t\tIn jquery 1.7.2+ everything works fine.\n            */\n            //this.picker.find('>div').hide().filter('.datepicker-'+DPGlobal.modes[this.viewMode].clsName).show();\n            this.picker.find('>div').hide().filter('.datepicker-' + DPGlobal.modes[this.viewMode].clsName).css('display', 'block');\n            this.updateNavArrows();\n        }\n    };\n\n    var DateRangePicker = function DateRangePicker(element, options) {\n        this.element = $(element);\n        this.inputs = $.map(options.inputs, function (i) {\n            return i.jquery ? i[0] : i;\n        });\n        delete options.inputs;\n\n        $(this.inputs).datepicker(options).bind('changeDate', $.proxy(this.dateUpdated, this));\n\n        this.pickers = $.map(this.inputs, function (i) {\n            return $(i).data('datepicker');\n        });\n        this.updateDates();\n    };\n    DateRangePicker.prototype = {\n        updateDates: function updateDates() {\n            this.dates = $.map(this.pickers, function (i) {\n                return i.date;\n            });\n            this.updateRanges();\n        },\n        updateRanges: function updateRanges() {\n            var range = $.map(this.dates, function (d) {\n                return d.valueOf();\n            });\n            $.each(this.pickers, function (i, p) {\n                p.setRange(range);\n            });\n        },\n        dateUpdated: function dateUpdated(e) {\n            var dp = $(e.target).data('datepicker'),\n                new_date = dp.getUTCDate(),\n                i = $.inArray(e.target, this.inputs),\n                l = this.inputs.length;\n            if (i == -1) return;\n\n            if (new_date < this.dates[i]) {\n                // Date being moved earlier/left\n                while (i >= 0 && new_date < this.dates[i]) {\n                    this.pickers[i--].setUTCDate(new_date);\n                }\n            } else if (new_date > this.dates[i]) {\n                // Date being moved later/right\n                while (i < l && new_date > this.dates[i]) {\n                    this.pickers[i++].setUTCDate(new_date);\n                }\n            }\n            this.updateDates();\n        },\n        remove: function remove() {\n            $.map(this.pickers, function (p) {\n                p.remove();\n            });\n            delete this.element.data().datepicker;\n        }\n    };\n\n    function opts_from_el(el, prefix) {\n        // Derive options from element data-attrs\n        var data = $(el).data(),\n            out = {},\n            inkey,\n            replace = new RegExp('^' + prefix.toLowerCase() + '([A-Z])'),\n            prefix = new RegExp('^' + prefix.toLowerCase());\n        for (var key in data) {\n            if (prefix.test(key)) {\n                inkey = key.replace(replace, function (_, a) {\n                    return a.toLowerCase();\n                });\n                out[inkey] = data[key];\n            }\n        }return out;\n    }\n\n    function opts_from_locale(lang) {\n        // Derive options from locale plugins\n        var out = {};\n        // Check if \"de-DE\" style date is available, if not language should\n        // fallback to 2 letter code eg \"de\"\n        if (!dates[lang]) {\n            lang = lang.split('-')[0];\n            if (!dates[lang]) return;\n        }\n        var d = dates[lang];\n        $.each(locale_opts, function (i, k) {\n            if (k in d) out[k] = d[k];\n        });\n        return out;\n    }\n\n    var old = $.fn.datepicker;\n    var datepicker = $.fn.datepicker = function (option) {\n        var args = Array.apply(null, arguments);\n        args.shift();\n        var internal_return, this_return;\n        this.each(function () {\n            var $this = $(this),\n                data = $this.data('datepicker'),\n                options = (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option;\n            if (!data) {\n                var elopts = opts_from_el(this, 'date'),\n\n                // Preliminary otions\n                xopts = $.extend({}, defaults, elopts, options),\n                    locopts = opts_from_locale(xopts.language),\n\n                // Options priority: js args, data-attrs, locales, defaults\n                opts = $.extend({}, defaults, locopts, elopts, options);\n                if ($this.is('.input-daterange') || opts.inputs) {\n                    var ropts = {\n                        inputs: opts.inputs || $this.find('input').toArray()\n                    };\n                    $this.data('datepicker', data = new DateRangePicker(this, $.extend(opts, ropts)));\n                } else {\n                    $this.data('datepicker', data = new Datepicker(this, opts));\n                }\n            }\n            if (typeof option == 'string' && typeof data[option] == 'function') {\n                internal_return = data[option].apply(data, args);\n                if (internal_return !== undefined) return false;\n            }\n        });\n        if (internal_return !== undefined) return internal_return;else return this;\n    };\n\n    var defaults = $.fn.datepicker.defaults = {\n        autoclose: false,\n        beforeShowDay: $.noop,\n        calendarWeeks: false,\n        clearBtn: false,\n        daysOfWeekDisabled: [],\n        endDate: Infinity,\n        forceParse: true,\n        format: 'mm/dd/yyyy',\n        keyboardNavigation: true,\n        language: 'en',\n        minViewMode: 0,\n        rtl: false,\n        startDate: -Infinity,\n        startView: 0,\n        todayBtn: false,\n        todayHighlight: false,\n        weekStart: 0\n    };\n    var locale_opts = $.fn.datepicker.locale_opts = ['format', 'rtl', 'weekStart'];\n    $.fn.datepicker.Constructor = Datepicker;\n    var dates = $.fn.datepicker.dates = {\n        en: {\n            days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"],\n            daysShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\"],\n            daysMin: [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\", \"Su\"],\n            months: [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"],\n            monthsShort: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"],\n            today: \"Today\",\n            clear: \"Clear\"\n        }\n    };\n\n    var DPGlobal = {\n        modes: [{\n            clsName: 'days',\n            navFnc: 'Month',\n            navStep: 1\n        }, {\n            clsName: 'months',\n            navFnc: 'FullYear',\n            navStep: 1\n        }, {\n            clsName: 'years',\n            navFnc: 'FullYear',\n            navStep: 10\n        }],\n        isLeapYear: function isLeapYear(year) {\n            return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n        },\n        getDaysInMonth: function getDaysInMonth(year, month) {\n            return [31, DPGlobal.isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];\n        },\n        validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,\n        nonpunctuation: /[^ -\\/:-@\\[\\u3400-\\u9fff-`{-~\\t\\n\\r]+/g,\n        parseFormat: function parseFormat(format) {\n            // IE treats \\0 as a string end in inputs (truncating the value),\n            // so it's a bad format delimiter, anyway\n            var separators = format.replace(this.validParts, '\\0').split('\\0'),\n                parts = format.match(this.validParts);\n            if (!separators || !separators.length || !parts || parts.length === 0) {\n                throw new Error(\"Invalid date format.\");\n            }\n            return { separators: separators, parts: parts };\n        },\n        parseDate: function parseDate(date, format, language) {\n            if (date instanceof Date) return date;\n            if (typeof format === 'string') format = DPGlobal.parseFormat(format);\n            if (/^[\\-+]\\d+[dmwy]([\\s,]+[\\-+]\\d+[dmwy])*$/.test(date)) {\n                var part_re = /([\\-+]\\d+)([dmwy])/,\n                    parts = date.match(/([\\-+]\\d+)([dmwy])/g),\n                    part,\n                    dir;\n                date = new Date();\n                for (var i = 0; i < parts.length; i++) {\n                    part = part_re.exec(parts[i]);\n                    dir = parseInt(part[1]);\n                    switch (part[2]) {\n                        case 'd':\n                            date.setUTCDate(date.getUTCDate() + dir);\n                            break;\n                        case 'm':\n                            date = Datepicker.prototype.moveMonth.call(Datepicker.prototype, date, dir);\n                            break;\n                        case 'w':\n                            date.setUTCDate(date.getUTCDate() + dir * 7);\n                            break;\n                        case 'y':\n                            date = Datepicker.prototype.moveYear.call(Datepicker.prototype, date, dir);\n                            break;\n                    }\n                }\n                return UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0);\n            }\n            var parts = date && date.match(this.nonpunctuation) || [],\n                date = new Date(),\n                parsed = {},\n                setters_order = ['yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'd', 'dd'],\n                setters_map = {\n                yyyy: function yyyy(d, v) {\n                    return d.setUTCFullYear(v);\n                },\n                yy: function yy(d, v) {\n                    return d.setUTCFullYear(2000 + v);\n                },\n                m: function m(d, v) {\n                    v -= 1;\n                    while (v < 0) {\n                        v += 12;\n                    }v %= 12;\n                    d.setUTCMonth(v);\n                    while (d.getUTCMonth() != v) {\n                        d.setUTCDate(d.getUTCDate() - 1);\n                    }return d;\n                },\n                d: function d(_d, v) {\n                    return _d.setUTCDate(v);\n                }\n            },\n                val,\n                filtered,\n                part;\n            setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];\n            setters_map['dd'] = setters_map['d'];\n            date = UTCDate(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0);\n            var fparts = format.parts.slice();\n            // Remove noop parts\n            if (parts.length != fparts.length) {\n                fparts = $(fparts).filter(function (i, p) {\n                    return $.inArray(p, setters_order) !== -1;\n                }).toArray();\n            }\n            // Process remainder\n            if (parts.length == fparts.length) {\n                for (var i = 0, cnt = fparts.length; i < cnt; i++) {\n                    val = parseInt(parts[i], 10);\n                    part = fparts[i];\n                    if (isNaN(val)) {\n                        switch (part) {\n                            case 'MM':\n                                filtered = $(dates[language].months).filter(function () {\n                                    var m = this.slice(0, parts[i].length),\n                                        p = parts[i].slice(0, m.length);\n                                    return m == p;\n                                });\n                                val = $.inArray(filtered[0], dates[language].months) + 1;\n                                break;\n                            case 'M':\n                                filtered = $(dates[language].monthsShort).filter(function () {\n                                    var m = this.slice(0, parts[i].length),\n                                        p = parts[i].slice(0, m.length);\n                                    return m == p;\n                                });\n                                val = $.inArray(filtered[0], dates[language].monthsShort) + 1;\n                                break;\n                        }\n                    }\n                    parsed[part] = val;\n                }\n                for (var i = 0, s; i < setters_order.length; i++) {\n                    s = setters_order[i];\n                    if (s in parsed && !isNaN(parsed[s])) setters_map[s](date, parsed[s]);\n                }\n            }\n            return date;\n        },\n        formatDate: function formatDate(date, format, language) {\n            if (typeof format === 'string') format = DPGlobal.parseFormat(format);\n            var val = {\n                d: date.getUTCDate(),\n                D: dates[language].daysShort[date.getUTCDay()],\n                DD: dates[language].days[date.getUTCDay()],\n                m: date.getUTCMonth() + 1,\n                M: dates[language].monthsShort[date.getUTCMonth()],\n                MM: dates[language].months[date.getUTCMonth()],\n                yy: date.getUTCFullYear().toString().substring(2),\n                yyyy: date.getUTCFullYear()\n            };\n            val.dd = (val.d < 10 ? '0' : '') + val.d;\n            val.mm = (val.m < 10 ? '0' : '') + val.m;\n            var date = [],\n                seps = $.extend([], format.separators);\n            for (var i = 0, cnt = format.parts.length; i <= cnt; i++) {\n                if (seps.length) date.push(seps.shift());\n                date.push(val[format.parts[i]]);\n            }\n            return date.join('');\n        },\n        headTemplate: '<thead>' + '<tr>' + '<th class=\"prev\"><i class=\"icon-arrow-left\"/></th>' + '<th colspan=\"5\" class=\"datepicker-switch\"></th>' + '<th class=\"next\"><i class=\"icon-arrow-right\"/></th>' + '</tr>' + '</thead>',\n        contTemplate: '<tbody><tr><td colspan=\"7\"></td></tr></tbody>',\n        footTemplate: '<tfoot><tr><th colspan=\"7\" class=\"today\"></th></tr><tr><th colspan=\"7\" class=\"clear\"></th></tr></tfoot>'\n    };\n    DPGlobal.template = '<div class=\"datepicker\">' + '<div class=\"datepicker-days\">' + '<table class=\" table-condensed\">' + DPGlobal.headTemplate + '<tbody></tbody>' + DPGlobal.footTemplate + '</table>' + '</div>' + '<div class=\"datepicker-months\">' + '<table class=\"table-condensed\">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + '</table>' + '</div>' + '<div class=\"datepicker-years\">' + '<table class=\"table-condensed\">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + '</table>' + '</div>' + '</div>';\n\n    $.fn.datepicker.DPGlobal = DPGlobal;\n\n    /* DATEPICKER NO CONFLICT\n    * =================== */\n\n    $.fn.datepicker.noConflict = function () {\n        $.fn.datepicker = old;\n        return this;\n    };\n\n    /* DATEPICKER DATA-API\n    * ================== */\n\n    $(document).on('focus.datepicker.data-api click.datepicker.data-api', '[data-provide=\"datepicker\"]', function (e) {\n        var $this = $(this);\n        if ($this.data('datepicker')) return;\n        e.preventDefault();\n        // component click requires us to explicitly show it\n        datepicker.call($this, 'show');\n    });\n    $(function () {\n        //$('[data-provide=\"datepicker-inline\"]').datepicker();\n        //vit: changed to support noConflict()\n        datepicker.call($('[data-provide=\"datepicker-inline\"]'));\n    });\n})(window.jQuery);\n\n/**\nBootstrap-datepicker.  \nDescription and examples: https://github.com/eternicode/bootstrap-datepicker.  \nFor **i18n** you should include js file from here: https://github.com/eternicode/bootstrap-datepicker/tree/master/js/locales\nand set `language` option.  \nSince 1.4.0 date has different appearance in **popup** and **inline** modes. \n\n@class date\n@extends abstractinput\n@final\n@example\n<a href=\"#\" id=\"dob\" data-type=\"date\" data-pk=\"1\" data-url=\"/post\" data-title=\"Select date\">15/05/1984</a>\n<script>\n$(function(){\n    $('#dob').editable({\n        format: 'yyyy-mm-dd',    \n        viewformat: 'dd/mm/yyyy',    \n        datepicker: {\n                weekStart: 1\n           }\n        }\n    });\n});\n</script>\n**/\n(function ($) {\n    ;\n\n    //store bootstrap-datepicker as bdateicker to exclude conflict with jQuery UI one\n    $.fn.bdatepicker = $.fn.datepicker.noConflict();\n    if (!$.fn.datepicker) {\n        //if there were no other datepickers, keep also original name\n        $.fn.datepicker = $.fn.bdatepicker;\n    }\n\n    var Date = function Date(options) {\n        this.init('date', options, Date.defaults);\n        this.initPicker(options, Date.defaults);\n    };\n\n    $.fn.editableutils.inherit(Date, $.fn.editabletypes.abstractinput);\n\n    $.extend(Date.prototype, {\n        initPicker: function initPicker(options, defaults) {\n            //'format' is set directly from settings or data-* attributes\n\n            //by default viewformat equals to format\n            if (!this.options.viewformat) {\n                this.options.viewformat = this.options.format;\n            }\n\n            //try parse datepicker config defined as json string in data-datepicker\n            options.datepicker = $.fn.editableutils.tryParseJson(options.datepicker, true);\n\n            //overriding datepicker config (as by default jQuery extend() is not recursive)\n            //since 1.4 datepicker internally uses viewformat instead of format. Format is for submit only\n            this.options.datepicker = $.extend({}, defaults.datepicker, options.datepicker, {\n                format: this.options.viewformat\n            });\n\n            //language\n            this.options.datepicker.language = this.options.datepicker.language || 'en';\n\n            //store DPglobal\n            this.dpg = $.fn.bdatepicker.DPGlobal;\n\n            //store parsed formats\n            this.parsedFormat = this.dpg.parseFormat(this.options.format);\n            this.parsedViewFormat = this.dpg.parseFormat(this.options.viewformat);\n        },\n\n        render: function render() {\n            this.$input.bdatepicker(this.options.datepicker);\n\n            //\"clear\" link\n            if (this.options.clear) {\n                this.$clear = $('<a href=\"#\"></a>').html(this.options.clear).click($.proxy(function (e) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.clear();\n                }, this));\n\n                this.$tpl.parent().append($('<div class=\"editable-clear\">').append(this.$clear));\n            }\n        },\n\n        value2html: function value2html(value, element) {\n            var text = value ? this.dpg.formatDate(value, this.parsedViewFormat, this.options.datepicker.language) : '';\n            Date.superclass.value2html.call(this, text, element);\n        },\n\n        html2value: function html2value(html) {\n            return this.parseDate(html, this.parsedViewFormat);\n        },\n\n        value2str: function value2str(value) {\n            return value ? this.dpg.formatDate(value, this.parsedFormat, this.options.datepicker.language) : '';\n        },\n\n        str2value: function str2value(str) {\n            return this.parseDate(str, this.parsedFormat);\n        },\n\n        value2submit: function value2submit(value) {\n            return this.value2str(value);\n        },\n\n        value2input: function value2input(value) {\n            this.$input.bdatepicker('update', value);\n        },\n\n        input2value: function input2value() {\n            return this.$input.data('datepicker').date;\n        },\n\n        activate: function activate() {},\n\n        clear: function clear() {\n            this.$input.data('datepicker').date = null;\n            this.$input.find('.active').removeClass('active');\n            if (!this.options.showbuttons) {\n                this.$input.closest('form').submit();\n            }\n        },\n\n        autosubmit: function autosubmit() {\n            this.$input.on('mouseup', '.day', function (e) {\n                if ($(e.currentTarget).is('.old') || $(e.currentTarget).is('.new')) {\n                    return;\n                }\n                var $form = $(this).closest('form');\n                setTimeout(function () {\n                    $form.submit();\n                }, 200);\n            });\n            //changedate is not suitable as it triggered when showing datepicker. see #149\n            /*\n            this.$input.on('changeDate', function(e){\n                var $form = $(this).closest('form');\n                setTimeout(function() {\n                    $form.submit();\n                }, 200);\n            });\n            */\n        },\n\n        /*\n         For incorrect date bootstrap-datepicker returns current date that is not suitable\n         for datefield.\n         This function returns null for incorrect date.  \n        */\n        parseDate: function parseDate(str, format) {\n            var date = null,\n                formattedBack;\n            if (str) {\n                date = this.dpg.parseDate(str, format, this.options.datepicker.language);\n                if (typeof str === 'string') {\n                    formattedBack = this.dpg.formatDate(date, format, this.options.datepicker.language);\n                    if (str !== formattedBack) {\n                        date = null;\n                    }\n                }\n            }\n            return date;\n        }\n\n    });\n\n    Date.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <div></div>\n        **/\n        tpl: '<div class=\"editable-date well\"></div>',\n        /**\n        @property inputclass \n        @default null\n        **/\n        inputclass: null,\n        /**\n        Format used for sending value to server. Also applied when converting date from <code>data-value</code> attribute.<br>\n        Possible tokens are: <code>d, dd, m, mm, yy, yyyy</code>  \n         @property format \n        @type string\n        @default yyyy-mm-dd\n        **/\n        format: 'yyyy-mm-dd',\n        /**\n        Format used for displaying date. Also applied when converting date from element's text on init.   \n        If not specified equals to <code>format</code>\n         @property viewformat \n        @type string\n        @default null\n        **/\n        viewformat: null,\n        /**\n        Configuration of datepicker.\n        Full list of options: http://bootstrap-datepicker.readthedocs.org/en/latest/options.html\n         @property datepicker \n        @type object\n        @default {\n            weekStart: 0,\n            startView: 0,\n            minViewMode: 0,\n            autoclose: false\n        }\n        **/\n        datepicker: {\n            weekStart: 0,\n            startView: 0,\n            minViewMode: 0,\n            autoclose: false\n        },\n        /**\n        Text shown as clear date button. \n        If <code>false</code> clear button will not be rendered.\n         @property clear \n        @type boolean|string\n        @default 'x clear'\n        **/\n        clear: '&times; clear'\n    });\n\n    $.fn.editabletypes.date = Date;\n})(window.jQuery);\n\n/**\nBootstrap datefield input - modification for inline mode.\nShows normal <input type=\"text\"> and binds popup datepicker.  \nAutomatically shown in inline mode.\n\n@class datefield\n@extends date\n\n@since 1.4.0\n**/\n(function ($) {\n    ;\n\n    var DateField = function DateField(options) {\n        this.init('datefield', options, DateField.defaults);\n        this.initPicker(options, DateField.defaults);\n    };\n\n    $.fn.editableutils.inherit(DateField, $.fn.editabletypes.date);\n\n    $.extend(DateField.prototype, {\n        render: function render() {\n            this.$input = this.$tpl.find('input');\n            this.setClass();\n            this.setAttr('placeholder');\n\n            //bootstrap-datepicker is set `bdateicker` to exclude conflict with jQuery UI one. (in date.js)        \n            this.$tpl.bdatepicker(this.options.datepicker);\n\n            //need to disable original event handlers\n            this.$input.off('focus keydown');\n\n            //update value of datepicker\n            this.$input.keyup($.proxy(function () {\n                this.$tpl.removeData('date');\n                this.$tpl.bdatepicker('update');\n            }, this));\n        },\n\n        value2input: function value2input(value) {\n            this.$input.val(value ? this.dpg.formatDate(value, this.parsedViewFormat, this.options.datepicker.language) : '');\n            this.$tpl.bdatepicker('update');\n        },\n\n        input2value: function input2value() {\n            return this.html2value(this.$input.val());\n        },\n\n        activate: function activate() {\n            $.fn.editabletypes.text.prototype.activate.call(this);\n        },\n\n        autosubmit: function autosubmit() {\n            //reset autosubmit to empty  \n        }\n    });\n\n    DateField.defaults = $.extend({}, $.fn.editabletypes.date.defaults, {\n        /**\n        @property tpl \n        **/\n        tpl: '<div class=\"input-append date\"><input type=\"text\"/><span class=\"add-on\"><i class=\"icon-th\"></i></span></div>',\n        /**\n        @property inputclass \n        @default 'input-small'\n        **/\n        inputclass: 'input-small',\n\n        /* datepicker config */\n        datepicker: {\n            weekStart: 0,\n            startView: 0,\n            minViewMode: 0,\n            autoclose: true\n        }\n    });\n\n    $.fn.editabletypes.datefield = DateField;\n})(window.jQuery);\n/**\nBootstrap-datetimepicker.  \nBased on [smalot bootstrap-datetimepicker plugin](https://github.com/smalot/bootstrap-datetimepicker). \nBefore usage you should manually include dependent js and css:\n\n    <link href=\"css/datetimepicker.css\" rel=\"stylesheet\" type=\"text/css\"></link> \n    <script src=\"js/bootstrap-datetimepicker.js\"></script>\n\nFor **i18n** you should include js file from here: https://github.com/smalot/bootstrap-datetimepicker/tree/master/js/locales\nand set `language` option.  \n\n@class datetime\n@extends abstractinput\n@final\n@since 1.4.4\n@example\n<a href=\"#\" id=\"last_seen\" data-type=\"datetime\" data-pk=\"1\" data-url=\"/post\" title=\"Select date & time\">15/03/2013 12:45</a>\n<script>\n$(function(){\n    $('#last_seen').editable({\n        format: 'yyyy-mm-dd hh:ii',    \n        viewformat: 'dd/mm/yyyy hh:ii',    \n        datetimepicker: {\n                weekStart: 1\n           }\n        }\n    });\n});\n</script>\n**/\n(function ($) {\n    ;\n\n    var DateTime = function DateTime(options) {\n        this.init('datetime', options, DateTime.defaults);\n        this.initPicker(options, DateTime.defaults);\n    };\n\n    $.fn.editableutils.inherit(DateTime, $.fn.editabletypes.abstractinput);\n\n    $.extend(DateTime.prototype, {\n        initPicker: function initPicker(options, defaults) {\n            //'format' is set directly from settings or data-* attributes\n\n            //by default viewformat equals to format\n            if (!this.options.viewformat) {\n                this.options.viewformat = this.options.format;\n            }\n\n            //try parse datetimepicker config defined as json string in data-datetimepicker\n            options.datetimepicker = $.fn.editableutils.tryParseJson(options.datetimepicker, true);\n\n            //overriding datetimepicker config (as by default jQuery extend() is not recursive)\n            //since 1.4 datetimepicker internally uses viewformat instead of format. Format is for submit only\n            this.options.datetimepicker = $.extend({}, defaults.datetimepicker, options.datetimepicker, {\n                format: this.options.viewformat\n            });\n\n            //language\n            this.options.datetimepicker.language = this.options.datetimepicker.language || 'en';\n\n            //store DPglobal\n            this.dpg = $.fn.datetimepicker.DPGlobal;\n\n            //store parsed formats\n            this.parsedFormat = this.dpg.parseFormat(this.options.format, this.options.formatType);\n            this.parsedViewFormat = this.dpg.parseFormat(this.options.viewformat, this.options.formatType);\n        },\n\n        render: function render() {\n            this.$input.datetimepicker(this.options.datetimepicker);\n\n            //adjust container position when viewMode changes\n            //see https://github.com/smalot/bootstrap-datetimepicker/pull/80\n            this.$input.on('changeMode', function (e) {\n                var f = $(this).closest('form').parent();\n                //timeout here, otherwise container changes position before form has new size\n                setTimeout(function () {\n                    f.triggerHandler('resize');\n                }, 0);\n            });\n\n            //\"clear\" link\n            if (this.options.clear) {\n                this.$clear = $('<a href=\"#\"></a>').html(this.options.clear).click($.proxy(function (e) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                    this.clear();\n                }, this));\n\n                this.$tpl.parent().append($('<div class=\"editable-clear\">').append(this.$clear));\n            }\n        },\n\n        value2html: function value2html(value, element) {\n            //formatDate works with UTCDate!\n            var text = value ? this.dpg.formatDate(this.toUTC(value), this.parsedViewFormat, this.options.datetimepicker.language, this.options.formatType) : '';\n            if (element) {\n                DateTime.superclass.value2html.call(this, text, element);\n            } else {\n                return text;\n            }\n        },\n\n        html2value: function html2value(html) {\n            //parseDate return utc date!\n            var value = this.parseDate(html, this.parsedViewFormat);\n            return value ? this.fromUTC(value) : null;\n        },\n\n        value2str: function value2str(value) {\n            //formatDate works with UTCDate!\n            return value ? this.dpg.formatDate(this.toUTC(value), this.parsedFormat, this.options.datetimepicker.language, this.options.formatType) : '';\n        },\n\n        str2value: function str2value(str) {\n            //parseDate return utc date!\n            var value = this.parseDate(str, this.parsedFormat);\n            return value ? this.fromUTC(value) : null;\n        },\n\n        value2submit: function value2submit(value) {\n            return this.value2str(value);\n        },\n\n        value2input: function value2input(value) {\n            if (value) {\n                this.$input.data('datetimepicker').setDate(value);\n            }\n        },\n\n        input2value: function input2value() {\n            //date may be cleared, in that case getDate() triggers error\n            var dt = this.$input.data('datetimepicker');\n            return dt.date ? dt.getDate() : null;\n        },\n\n        activate: function activate() {},\n\n        clear: function clear() {\n            this.$input.data('datetimepicker').date = null;\n            this.$input.find('.active').removeClass('active');\n            if (!this.options.showbuttons) {\n                this.$input.closest('form').submit();\n            }\n        },\n\n        autosubmit: function autosubmit() {\n            this.$input.on('mouseup', '.minute', function (e) {\n                var $form = $(this).closest('form');\n                setTimeout(function () {\n                    $form.submit();\n                }, 200);\n            });\n        },\n\n        //convert date from local to utc\n        toUTC: function toUTC(value) {\n            return value ? new Date(value.valueOf() - value.getTimezoneOffset() * 60000) : value;\n        },\n\n        //convert date from utc to local\n        fromUTC: function fromUTC(value) {\n            return value ? new Date(value.valueOf() + value.getTimezoneOffset() * 60000) : value;\n        },\n\n        /*\n         For incorrect date bootstrap-datetimepicker returns current date that is not suitable\n         for datetimefield.\n         This function returns null for incorrect date.  \n        */\n        parseDate: function parseDate(str, format) {\n            var date = null,\n                formattedBack;\n            if (str) {\n                date = this.dpg.parseDate(str, format, this.options.datetimepicker.language, this.options.formatType);\n                if (typeof str === 'string') {\n                    formattedBack = this.dpg.formatDate(date, format, this.options.datetimepicker.language, this.options.formatType);\n                    if (str !== formattedBack) {\n                        date = null;\n                    }\n                }\n            }\n            return date;\n        }\n\n    });\n\n    DateTime.defaults = $.extend({}, $.fn.editabletypes.abstractinput.defaults, {\n        /**\n        @property tpl \n        @default <div></div>\n        **/\n        tpl: '<div class=\"editable-date well\"></div>',\n        /**\n        @property inputclass \n        @default null\n        **/\n        inputclass: null,\n        /**\n        Format used for sending value to server. Also applied when converting date from <code>data-value</code> attribute.<br>\n        Possible tokens are: <code>d, dd, m, mm, yy, yyyy, h, i</code>  \n        \n        @property format \n        @type string\n        @default yyyy-mm-dd hh:ii\n        **/\n        format: 'yyyy-mm-dd hh:ii',\n        formatType: 'standard',\n        /**\n        Format used for displaying date. Also applied when converting date from element's text on init.   \n        If not specified equals to <code>format</code>\n        \n        @property viewformat \n        @type string\n        @default null\n        **/\n        viewformat: null,\n        /**\n        Configuration of datetimepicker.\n        Full list of options: https://github.com/smalot/bootstrap-datetimepicker\n         @property datetimepicker \n        @type object\n        @default { }\n        **/\n        datetimepicker: {\n            todayHighlight: false,\n            autoclose: false\n        },\n        /**\n        Text shown as clear date button. \n        If <code>false</code> clear button will not be rendered.\n         @property clear \n        @type boolean|string\n        @default 'x clear'\n        **/\n        clear: '&times; clear'\n    });\n\n    $.fn.editabletypes.datetime = DateTime;\n})(window.jQuery);\n/**\nBootstrap datetimefield input - datetime input for inline mode.\nShows normal <input type=\"text\"> and binds popup datetimepicker.  \nAutomatically shown in inline mode.\n\n@class datetimefield\n@extends datetime\n\n**/\n(function ($) {\n    ;\n\n    var DateTimeField = function DateTimeField(options) {\n        this.init('datetimefield', options, DateTimeField.defaults);\n        this.initPicker(options, DateTimeField.defaults);\n    };\n\n    $.fn.editableutils.inherit(DateTimeField, $.fn.editabletypes.datetime);\n\n    $.extend(DateTimeField.prototype, {\n        render: function render() {\n            this.$input = this.$tpl.find('input');\n            this.setClass();\n            this.setAttr('placeholder');\n\n            this.$tpl.datetimepicker(this.options.datetimepicker);\n\n            //need to disable original event handlers\n            this.$input.off('focus keydown');\n\n            //update value of datepicker\n            this.$input.keyup($.proxy(function () {\n                this.$tpl.removeData('date');\n                this.$tpl.datetimepicker('update');\n            }, this));\n        },\n\n        value2input: function value2input(value) {\n            this.$input.val(this.value2html(value));\n            this.$tpl.datetimepicker('update');\n        },\n\n        input2value: function input2value() {\n            return this.html2value(this.$input.val());\n        },\n\n        activate: function activate() {\n            $.fn.editabletypes.text.prototype.activate.call(this);\n        },\n\n        autosubmit: function autosubmit() {\n            //reset autosubmit to empty  \n        }\n    });\n\n    DateTimeField.defaults = $.extend({}, $.fn.editabletypes.datetime.defaults, {\n        /**\n        @property tpl \n        **/\n        tpl: '<div class=\"input-append date\"><input type=\"text\"/><span class=\"add-on\"><i class=\"icon-th\"></i></span></div>',\n        /**\n        @property inputclass \n        @default 'input-medium'\n        **/\n        inputclass: 'input-medium',\n\n        /* datetimepicker config */\n        datetimepicker: {\n            todayHighlight: false,\n            autoclose: true\n        }\n    });\n\n    $.fn.editabletypes.datetimefield = DateTimeField;\n})(window.jQuery);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvanMvYm9vdHN0cmFwLWVkaXRhYmxlLmpzPzI5MzQiXSwibmFtZXMiOlsiJCIsIkVkaXRhYmxlRm9ybSIsImRpdiIsIm9wdGlvbnMiLCJleHRlbmQiLCJmbiIsImVkaXRhYmxlZm9ybSIsImRlZmF1bHRzIiwiJGRpdiIsInNjb3BlIiwicHJvdG90eXBlIiwiY29uc3RydWN0b3IiLCJpbml0SW5wdXQiLCJpbnB1dCIsInZhbHVlIiwic3RyMnZhbHVlIiwicHJlcmVuZGVyIiwiaW5pdFRlbXBsYXRlIiwiJGZvcm0iLCJ0ZW1wbGF0ZSIsImluaXRCdXR0b25zIiwiJGJ0biIsImZpbmQiLCJhcHBlbmQiLCJidXR0b25zIiwic2hvd2J1dHRvbnMiLCJhZGRDbGFzcyIsInJlbmRlciIsIiRsb2FkaW5nIiwibG9hZGluZyIsImVtcHR5IiwicmVtb3ZlIiwic2hvd0xvYWRpbmciLCJpc1NhdmluZyIsInRyaWdnZXJIYW5kbGVyIiwiJHRwbCIsIndoZW4iLCJ0aGVuIiwicHJveHkiLCJhdXRvc3VibWl0IiwiY2xpY2siLCJjYW5jZWwiLCJlcnJvciIsImF0dHIiLCIkaW5wdXQiLCJzdWJtaXQiLCJlIiwicHJldmVudERlZmF1bHQiLCJyZW1vdmVBdHRyIiwidW5kZWZpbmVkIiwiZGVmYXVsdFZhbHVlIiwidmFsdWUyaW5wdXQiLCJzaG93Rm9ybSIsInBvc3RyZW5kZXIiLCJ3IiwiaCIsIm91dGVyV2lkdGgiLCJvdXRlckhlaWdodCIsIndpZHRoIiwiaGVpZ2h0IiwiaGlkZSIsInBhcmVudCIsInNob3ciLCJhY3RpdmF0ZSIsIm1zZyIsIiRncm91cCIsIiRibG9jayIsImxpbmVzIiwicmVtb3ZlQ2xhc3MiLCJlcnJvckdyb3VwQ2xhc3MiLCJlcnJvckJsb2NrQ2xhc3MiLCJzcGxpdCIsImkiLCJsZW5ndGgiLCJ0ZXh0IiwiaHRtbCIsImpvaW4iLCJzdG9wUHJvcGFnYXRpb24iLCJuZXdWYWx1ZSIsImlucHV0MnZhbHVlIiwidmFsaWRhdGUiLCJ0eXBlIiwic2F2ZW5vY2hhbmdlIiwidmFsdWUyc3RyIiwic3VibWl0VmFsdWUiLCJ2YWx1ZTJzdWJtaXQiLCJzYXZlIiwiZG9uZSIsInJlc3BvbnNlIiwicmVzIiwic3VjY2VzcyIsImNhbGwiLCJoYXNPd25Qcm9wZXJ0eSIsImZhaWwiLCJ4aHIiLCJyZXNwb25zZVRleHQiLCJzdGF0dXNUZXh0IiwicGsiLCJlZGl0YWJsZXV0aWxzIiwidHJ5UGFyc2VKc29uIiwic2VuZCIsInVybCIsInBhcmFtcyIsIm5hbWUiLCJhamF4IiwiZGF0YSIsImFqYXhPcHRpb25zIiwib3B0aW9uIiwia2V5Iiwic2V0VmFsdWUiLCJjb252ZXJ0U3RyIiwiaXMiLCJhcmdzIiwiYXJndW1lbnRzIiwiZWFjaCIsIiR0aGlzIiwiYXBwbHkiLCJBcnJheSIsInNsaWNlIiwiQ29uc3RydWN0b3IiLCJlbmdpbmUiLCJ3aW5kb3ciLCJqUXVlcnkiLCJpbmhlcml0IiwiQ2hpbGQiLCJQYXJlbnQiLCJGIiwic3VwZXJjbGFzcyIsInNldEN1cnNvclBvc2l0aW9uIiwiZWxlbSIsInBvcyIsInNldFNlbGVjdGlvblJhbmdlIiwiY3JlYXRlVGV4dFJhbmdlIiwicmFuZ2UiLCJjb2xsYXBzZSIsIm1vdmVFbmQiLCJtb3ZlU3RhcnQiLCJzZWxlY3QiLCJzIiwic2FmZSIsIm1hdGNoIiwiRnVuY3Rpb24iLCJzbGljZU9iaiIsIm9iaiIsImtleXMiLCJjYXNlU2Vuc2l0aXZlIiwia2V5TG93ZXIiLCJuZXdPYmoiLCJpc0FycmF5IiwidG9Mb3dlckNhc2UiLCJnZXRDb25maWdEYXRhIiwiJGVsZW1lbnQiLCJrIiwidiIsIk9iamVjdCIsIm9iamVjdEtleXMiLCJvIiwiVHlwZUVycm9yIiwicCIsInB1c2giLCJlc2NhcGUiLCJzdHIiLCJpdGVtc0J5VmFsdWUiLCJzb3VyY2VEYXRhIiwidmFsdWVQcm9wIiwiaWRLZXkiLCJpc1ZhbEFycmF5IiwicmVzdWx0IiwidGhhdCIsImNoaWxkcmVuIiwiY29uY2F0IiwiZ3JlcCIsIml0ZW1WYWx1ZSIsImNyZWF0ZUlucHV0IiwiVHlwZUNvbnN0cnVjdG9yIiwidHlwZU9wdGlvbnMiLCJtb2RlIiwiZWRpdGFibGV0eXBlcyIsImRhdGVmaWVsZCIsImRhdGV1aWZpZWxkIiwiZGF0ZSIsImRhdGV1aSIsInN1cHBvcnRzVHJhbnNpdGlvbnMiLCJiIiwiZG9jdW1lbnQiLCJib2R5IiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInN1YnN0ciIsIlBvcHVwIiwiZWxlbWVudCIsImluaXQiLCJJbmxpbmUiLCJjb250YWluZXJOYW1lIiwiY29udGFpbmVyRGF0YU5hbWUiLCJpbm5lckNzcyIsImNvbnRhaW5lckNsYXNzIiwiZWRpdGFibGVDb250YWluZXIiLCJzcGxpdE9wdGlvbnMiLCJmb3JtT3B0aW9ucyIsImluaXRDb250YWluZXIiLCJkZWxheWVkSGlkZSIsIm9uIiwiZGVzdHJveSIsIndoaWNoIiwiJHRhcmdldCIsInRhcmdldCIsImV4Y2x1ZGVfY2xhc3NlcyIsImNvbnRhaW5zIiwicGFyZW50cyIsImNsb3NlT3RoZXJzIiwiY29udGFpbmVyT3B0aW9ucyIsIkVycm9yIiwidGlwIiwiY29udGFpbmVyIiwiJHRpcCIsInJlbmRlckZvcm0iLCJub2NoYW5nZSIsInJlYXNvbiIsInNldFBvc2l0aW9uIiwicmVuZGVyaW5nIiwicmVzaXplIiwicmVuZGVyZWQiLCJjbG9zZUFsbCIsImlubmVyU2hvdyIsImhhc0NsYXNzIiwiaW5uZXJIaWRlIiwidG9nZ2xlIiwic2V0Q29udGFpbmVyT3B0aW9uIiwiaW5uZXJEZXN0cm95Iiwib2ZmIiwicmVtb3ZlRGF0YSIsImVsIiwiJGVsIiwiZWMiLCJvbmJsdXIiLCJkYXRhS2V5IiwicGxhY2VtZW50IiwiYXV0b2hpZGUiLCJhbmltIiwiZXZlbnQiLCJzcGVjaWFsIiwiZGVzdHJveWVkIiwiaGFuZGxlciIsImluc2VydEFmdGVyIiwiRWRpdGFibGUiLCJlZGl0YWJsZSIsInNlbGVjdG9yIiwiaW5pdExpdmUiLCJoaWdobGlnaHQiLCJpc1ZhbHVlQnlUZXh0IiwiZG9BdXRvdGV4dCIsImZpbmFsaXplIiwiaHRtbDJ2YWx1ZSIsInRyaW0iLCJkaXNhYmxlZCIsImRpc3BsYXkiLCJhdXRvdGV4dCIsImRpc2FibGUiLCJlbmFibGUiLCJlbXB0eWNsYXNzIiwidHJpZ2dlciIsInZhbHVlMmh0bWxGaW5hbCIsInZhbHVlMmh0bWwiLCJoYW5kbGVFbXB0eSIsImlzRW1wdHkiLCJ0b2dnbGVEaXNhYmxlZCIsImVtcHR5dGV4dCIsInVuc2F2ZWRjbGFzcyIsInNlbnQiLCIkZSIsImJnQ29sb3IiLCJjc3MiLCJzZXRUaW1lb3V0IiwiZGF0YWtleSIsImVxIiwiY29uZmlnIiwiJGVsZW1zIiwiZXJyb3JzIiwiaXNFbXB0eU9iamVjdCIsInZhbHVlcyIsIm5vb3AiLCJBYnN0cmFjdElucHV0IiwidHBsIiwiJGNsZWFyIiwidmFsIiwiZm9jdXMiLCJjbGVhciIsInNldENsYXNzIiwiaW5wdXRjbGFzcyIsInNldEF0dHIiLCJhYnN0cmFjdGlucHV0IiwiTGlzdCIsImRlZmVycmVkIiwiRGVmZXJyZWQiLCJvblNvdXJjZVJlYWR5IiwicmVuZGVyTGlzdCIsInJlc29sdmUiLCJzb3VyY2VFcnJvciIsInByb21pc2UiLCJzb3VyY2UiLCJpc0Z1bmN0aW9uIiwic291cmNlQ2FjaGUiLCJjYWNoZUlEIiwiY2FjaGUiLCJkb1ByZXBlbmQiLCJjYWxsYmFja3MiLCJlcnJfY2FsbGJhY2tzIiwiZGF0YVR5cGUiLCJtYWtlQXJyYXkiLCJzb3VyY2VPcHRpb25zIiwicHJlcGVuZCIsInByZXBlbmREYXRhIiwiY291bnQiLCJpdGVtIiwiaXRlcmF0ZUl0ZW0iLCJsaXN0IiwiVGV4dCIsInJlbmRlckNsZWFyIiwiZ2V0IiwidG9nZ2xlQ2xlYXIiLCJhZnRlciIsImtleXVwIiwiaW5BcnJheSIsImtleUNvZGUiLCJjbGVhclRpbWVvdXQiLCJ0IiwibGVuIiwidmlzaWJsZSIsInBsYWNlaG9sZGVyIiwiVGV4dGFyZWEiLCJrZXlkb3duIiwiY3RybEtleSIsImNsb3Nlc3QiLCJyb3dzIiwidGV4dGFyZWEiLCJTZWxlY3QiLCJmaWxsSXRlbXMiLCJsYWJlbCIsIml0ZW1zIiwiQ2hlY2tsaXN0IiwiJGxhYmVsIiwiYXBwZW5kVG8iLCJzb3J0Iiwic2VwYXJhdG9yIiwicmVnIiwiUmVnRXhwIiwicHJvcCIsImoiLCJjaGVja2VkIiwiZmlsdGVyIiwiZmlyc3QiLCJjaGVja2xpc3QiLCJQYXNzd29yZCIsInBhc3N3b3JkIiwiRW1haWwiLCJlbWFpbCIsIlVybCIsIlRlbCIsInRlbCIsIk51bWJlcklucHV0IiwicmlnaHQiLCJtaW4iLCJtYXgiLCJzdGVwIiwibnVtYmVyIiwiUmFuZ2UiLCJzaWJsaW5ncyIsIlRpbWUiLCJ0aW1lIiwic2VsZWN0MiIsInRhZ3MiLCJ0ZXJtIiwicXVlcnkiLCJyZXN1bHRzIiwiY29udmVydFNvdXJjZSIsImlzTXVsdGlwbGUiLCJtdWx0aXBsZSIsImlzUmVtb3RlIiwiaWRGdW5jIiwiaWQiLCJmb3JtYXRTZWxlY3Rpb24iLCJ2aWV3c2VwYXJhdG9yIiwiZ2V0U2VwYXJhdG9yIiwiaW5pdFNlbGVjdGlvbiIsImN1c3RvbUlkIiwiY3VzdG9tVGV4dCIsImwiLCJpc0luaXRpYWwiLCJDb21ib2RhdGUiLCJjb21ib2RhdGUiLCJtYXAiLCJkYXkiLCJtb250aCIsInllYXIiLCJob3VyIiwibWludXRlIiwic2Vjb25kIiwiYW1wbSIsIiR3aWRnZXQiLCJnZXRUZW1wbGF0ZSIsImluaXRDb21ib3MiLCJnZXRWYWx1ZSIsImNoYW5nZSIsInNtYXJ0RGF5cyIsImZpbGxDb21ibyIsInIiLCJ0b2tlbiIsInN1YnN0cmluZyIsInJlcGxhY2UiLCIkYyIsIiRjb21ibyIsImYiLCJmaWxsQ29tbW9uIiwicmVsVGltZSIsImZpcnN0SXRlbSIsIm1vbWVudCIsInJlbGF0aXZlVGltZSIsImxhbmdEYXRhIiwiX3JlbGF0aXZlVGltZSIsImhlYWRlciIsInJldmVyc2UiLCJmaWxsRGF5IiwidHdvRGlnaXQiLCJpbmRleE9mIiwiZGF5c0NvdW50IiwiJG1vbnRoIiwiJHllYXIiLCJwYXJzZUludCIsImlzTmFOIiwiZGF5c0luTW9udGgiLCJsZWFkWmVybyIsImZpbGxNb250aCIsImxvbmdOYW1lcyIsInNob3J0TmFtZXMiLCJmb3JtYXQiLCJmaWxsWWVhciIsIm1heFllYXIiLCJtaW5ZZWFyIiwieWVhckRlc2NlbmRpbmciLCJmaWxsSG91ciIsImgxMiIsImgyNCIsImZpbGxNaW51dGUiLCJtaW51dGVTdGVwIiwiZmlsbFNlY29uZCIsInNlY29uZFN0ZXAiLCJmaWxsQW1wbSIsImFtcG1MIiwiYW1wbVUiLCJkdCIsIm5vdFNlbGVjdGVkIiwiZGVmIiwiJGFtcG0iLCJpc1ZhbGlkIiwiZ2V0TmVhcmVzdCIsIiRzZWxlY3QiLCJkZWx0YSIsIm9wdCIsIm9wdFZhbHVlIiwiZGlzdGFuY2UiLCJNYXRoIiwiYWJzIiwicm91bmRUaW1lIiwiZXJyb3JDbGFzcyIsImJvcmRlckNvbG9yIiwiZCIsInNoaWZ0Iiwidmlld2Zvcm1hdCIsInBJbml0SW5wdXQiLCJlbXB0eUlucHV0Q2xhc3MiLCJkZWZhdWx0Q2xhc3MiLCJzdGR0eXBlcyIsImNsYXNzZXMiLCJwb3BvdmVyIiwiREVGQVVMVFMiLCJjb250ZW50IiwiYXV0b1Rva2VuIiwiYXV0b1BsYWNlIiwidGVzdCIsImdldFBvc2l0aW9uIiwiYWN0dWFsV2lkdGgiLCJvZmZzZXRXaWR0aCIsImFjdHVhbEhlaWdodCIsIm9mZnNldEhlaWdodCIsIiRwYXJlbnQiLCJvcmdQbGFjZW1lbnQiLCJkb2NTY3JvbGwiLCJzY3JvbGxUb3AiLCJwYXJlbnRXaWR0aCIsImlubmVyV2lkdGgiLCJwYXJlbnRIZWlnaHQiLCJpbm5lckhlaWdodCIsInBhcmVudExlZnQiLCJvZmZzZXQiLCJsZWZ0IiwidG9wIiwiY2FsY3VsYXRlZE9mZnNldCIsImdldENhbGN1bGF0ZWRPZmZzZXQiLCJhcHBseVBsYWNlbWVudCIsIlVUQ0RhdGUiLCJEYXRlIiwiVVRDIiwiVVRDVG9kYXkiLCJ0b2RheSIsImdldFVUQ0Z1bGxZZWFyIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENEYXRlIiwiRGF0ZXBpY2tlciIsIl9wcm9jZXNzX29wdGlvbnMiLCJpc0lubGluZSIsImlzSW5wdXQiLCJjb21wb25lbnQiLCJoYXNJbnB1dCIsInBpY2tlciIsIkRQR2xvYmFsIiwiX2J1aWxkRXZlbnRzIiwiX2F0dGFjaEV2ZW50cyIsInJ0bCIsInRvZ2dsZUNsYXNzIiwidmlld01vZGUiLCJzdGFydFZpZXciLCJjYWxlbmRhcldlZWtzIiwiX2FsbG93X3VwZGF0ZSIsInNldFN0YXJ0RGF0ZSIsInN0YXJ0RGF0ZSIsInNldEVuZERhdGUiLCJlbmREYXRlIiwic2V0RGF5c09mV2Vla0Rpc2FibGVkIiwiZGF5c09mV2Vla0Rpc2FibGVkIiwiZmlsbERvdyIsImZpbGxNb250aHMiLCJ1cGRhdGUiLCJzaG93TW9kZSIsIm9wdHMiLCJfbyIsImxhbmciLCJsYW5ndWFnZSIsImRhdGVzIiwibWluVmlld01vZGUiLCJ3ZWVrU3RhcnQiLCJ3ZWVrRW5kIiwicGFyc2VGb3JtYXQiLCJJbmZpbml0eSIsInBhcnNlRGF0ZSIsIl9ldmVudHMiLCJfc2Vjb25kYXJ5RXZlbnRzIiwiX2FwcGx5RXZlbnRzIiwiZXZzIiwiZXYiLCJfdW5hcHBseUV2ZW50cyIsInBsYWNlIiwibW91c2Vkb3duIiwic2l6ZSIsIl9kZXRhY2hFdmVudHMiLCJfYXR0YWNoU2Vjb25kYXJ5RXZlbnRzIiwiX2RldGFjaFNlY29uZGFyeUV2ZW50cyIsIl90cmlnZ2VyIiwiYWx0ZGF0ZSIsImxvY2FsX2RhdGUiLCJnZXRUaW1lIiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJhbHRmb3JtYXQiLCJmb3JtYXREYXRlIiwiZGV0YWNoIiwiZm9yY2VQYXJzZSIsImRhdGVwaWNrZXIiLCJnZXREYXRlIiwic2V0RGF0ZSIsInNldFVUQ0RhdGUiLCJmb3JtYXR0ZWQiLCJnZXRGb3JtYXR0ZWREYXRlIiwidXBkYXRlTmF2QXJyb3dzIiwiekluZGV4IiwiZnJvbUFyZ3MiLCJ2aWV3RGF0ZSIsImZpbGwiLCJkb3dDbnQiLCJjZWxsIiwiZGF5c01pbiIsIm1vbnRoc1Nob3J0Iiwic2V0UmFuZ2UiLCJ2YWx1ZU9mIiwiZ2V0Q2xhc3NOYW1lcyIsImNscyIsImN1cnJlbnREYXRlIiwidG9kYXlIaWdobGlnaHQiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0VVRDRGF5Iiwic3RhcnRZZWFyIiwic3RhcnRNb250aCIsImVuZFllYXIiLCJlbmRNb250aCIsInRvb2x0aXAiLCJtb250aHMiLCJ0b2RheUJ0biIsImNsZWFyQnRuIiwicHJldk1vbnRoIiwiZ2V0RGF5c0luTW9udGgiLCJuZXh0TW9udGgiLCJjbHNOYW1lIiwid3MiLCJ0aCIsInl0aCIsImNhbFdlZWsiLCJiZWZvcmUiLCJiZWZvcmVTaG93RGF5IiwiZW5hYmxlZCIsInVuaXF1ZSIsImN1cnJlbnRZZWFyIiwiZW5kIiwieWVhckNvbnQiLCJ2aXNpYmlsaXR5Iiwibm9kZU5hbWUiLCJjbGFzc05hbWUiLCJkaXIiLCJtb2RlcyIsIm5hdlN0ZXAiLCJtb3ZlTW9udGgiLCJtb3ZlWWVhciIsIl9zZXREYXRlIiwiYXV0b2Nsb3NlIiwiaW5kZXgiLCJzZXRVVENNb250aCIsInNldFVUQ0Z1bGxZZWFyIiwibmV3X2RhdGUiLCJtYWciLCJuZXdfbW9udGgiLCJkYXRlV2l0aGluUmFuZ2UiLCJkYXRlQ2hhbmdlZCIsIm5ld0RhdGUiLCJuZXdWaWV3RGF0ZSIsImtleWJvYXJkTmF2aWdhdGlvbiIsInNoaWZ0S2V5IiwiRGF0ZVJhbmdlUGlja2VyIiwiaW5wdXRzIiwianF1ZXJ5IiwiYmluZCIsImRhdGVVcGRhdGVkIiwicGlja2VycyIsInVwZGF0ZURhdGVzIiwidXBkYXRlUmFuZ2VzIiwiZHAiLCJvcHRzX2Zyb21fZWwiLCJwcmVmaXgiLCJvdXQiLCJpbmtleSIsIl8iLCJhIiwib3B0c19mcm9tX2xvY2FsZSIsImxvY2FsZV9vcHRzIiwib2xkIiwiaW50ZXJuYWxfcmV0dXJuIiwidGhpc19yZXR1cm4iLCJlbG9wdHMiLCJ4b3B0cyIsImxvY29wdHMiLCJyb3B0cyIsInRvQXJyYXkiLCJlbiIsImRheXMiLCJkYXlzU2hvcnQiLCJuYXZGbmMiLCJpc0xlYXBZZWFyIiwidmFsaWRQYXJ0cyIsIm5vbnB1bmN0dWF0aW9uIiwic2VwYXJhdG9ycyIsInBhcnRzIiwicGFydF9yZSIsInBhcnQiLCJleGVjIiwicGFyc2VkIiwic2V0dGVyc19vcmRlciIsInNldHRlcnNfbWFwIiwieXl5eSIsInl5IiwibSIsImZpbHRlcmVkIiwiZnBhcnRzIiwiY250IiwiRCIsIkREIiwiTSIsIk1NIiwidG9TdHJpbmciLCJkZCIsIm1tIiwic2VwcyIsImhlYWRUZW1wbGF0ZSIsImNvbnRUZW1wbGF0ZSIsImZvb3RUZW1wbGF0ZSIsIm5vQ29uZmxpY3QiLCJiZGF0ZXBpY2tlciIsImluaXRQaWNrZXIiLCJkcGciLCJwYXJzZWRGb3JtYXQiLCJwYXJzZWRWaWV3Rm9ybWF0IiwiY3VycmVudFRhcmdldCIsImZvcm1hdHRlZEJhY2siLCJEYXRlRmllbGQiLCJEYXRlVGltZSIsImRhdGV0aW1lcGlja2VyIiwiZm9ybWF0VHlwZSIsInRvVVRDIiwiZnJvbVVUQyIsImRhdGV0aW1lIiwiRGF0ZVRpbWVGaWVsZCIsImRhdGV0aW1lZmllbGQiXSwibWFwcGluZ3MiOiI7O0FBQUE7Ozs7QUFJQTs7Ozs7Ozs7O0FBU0MsV0FBVUEsQ0FBVixFQUFhOztBQUVWLFFBQUlDLGVBQWUsU0FBZkEsWUFBZSxDQUFVQyxHQUFWLEVBQWVDLE9BQWYsRUFBd0I7QUFDdkMsYUFBS0EsT0FBTCxHQUFlSCxFQUFFSSxNQUFGLENBQVMsRUFBVCxFQUFhSixFQUFFSyxFQUFGLENBQUtDLFlBQUwsQ0FBa0JDLFFBQS9CLEVBQXlDSixPQUF6QyxDQUFmO0FBQ0EsYUFBS0ssSUFBTCxHQUFZUixFQUFFRSxHQUFGLENBQVosQ0FGdUMsQ0FFbkI7QUFDcEIsWUFBRyxDQUFDLEtBQUtDLE9BQUwsQ0FBYU0sS0FBakIsRUFBd0I7QUFDcEIsaUJBQUtOLE9BQUwsQ0FBYU0sS0FBYixHQUFxQixJQUFyQjtBQUNIO0FBQ0Q7QUFDSCxLQVBEOztBQVNBUixpQkFBYVMs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QW1CcWhCLGFBQW5CLEdBQW1DRCxhQUFuQztBQUVILENBbkVBLEVBbUVDNWtCLE9BQU9DLE1BbkVSLENBQUQiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBYLWVkaXRhYmxlIC0gdjEuNS4xIFxuKiBJbi1wbGFjZSBlZGl0aW5nIHdpdGggVHdpdHRlciBCb290c3RyYXAsIGpRdWVyeSBVSSBvciBwdXJlIGpRdWVyeVxuKiBodHRwOi8vZ2l0aHViLmNvbS92aXRhbGV0cy94LWVkaXRhYmxlXG4qIENvcHlyaWdodCAoYykgMjAxMyBWaXRhbGl5IFBvdGFwb3Y7IExpY2Vuc2VkIE1JVCAqL1xuLyoqXG5Gb3JtIHdpdGggc2luZ2xlIGlucHV0IGVsZW1lbnQsIHR3byBidXR0b25zIGFuZCB0d28gc3RhdGVzOiBub3JtYWwvbG9hZGluZy5cbkFwcGxpZWQgYXMgalF1ZXJ5IG1ldGhvZCB0byBESVYgdGFnIChub3QgdG8gZm9ybSB0YWchKS4gVGhpcyBpcyBiZWNhdXNlIGZvcm0gY2FuIGJlIGluIGxvYWRpbmcgc3RhdGUgd2hlbiBzcGlubmVyIHNob3duLlxuRWRpdGFibGVmb3JtIGlzIGxpbmtlZCB3aXRoIG9uZSBvZiBpbnB1dCB0eXBlcywgZS5nLiAndGV4dCcsICdzZWxlY3QnIGV0Yy5cblxuQGNsYXNzIGVkaXRhYmxlZm9ybVxuQHVzZXMgdGV4dFxuQHVzZXMgdGV4dGFyZWFcbioqL1xuKGZ1bmN0aW9uICgkKSB7XG5cbiAgICB2YXIgRWRpdGFibGVGb3JtID0gZnVuY3Rpb24gKGRpdiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZWZvcm0uZGVmYXVsdHMsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLiRkaXYgPSAkKGRpdik7IC8vZGl2LCBjb250YWluaW5nIGZvcm0uIE5vdCBmb3JtIHRhZy4gTm90IGVkaXRhYmxlLWVsZW1lbnQuXG4gICAgICAgIGlmKCF0aGlzLm9wdGlvbnMuc2NvcGUpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zY29wZSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy9ub3RoaW5nIHNob3duIGFmdGVyIGluaXRcbiAgICB9O1xuXG4gICAgRWRpdGFibGVGb3JtLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IEVkaXRhYmxlRm9ybSxcbiAgICAgICAgaW5pdElucHV0OiBmdW5jdGlvbigpIHsgIC8vY2FsbGVkIG9uY2VcbiAgICAgICAgICAgIC8vdGFrZSBpbnB1dCBmcm9tIG9wdGlvbnMgKGFzIGl0IGlzIGNyZWF0ZWQgaW4gZWRpdGFibGUtZWxlbWVudClcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLm9wdGlvbnMuaW5wdXQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vc2V0IGluaXRpYWwgdmFsdWVcbiAgICAgICAgICAgIC8vdG9kbzogbWF5IGJlIGFkZCBjaGVjazogdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgPyBcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmlucHV0LnN0cjJ2YWx1ZSh0aGlzLm9wdGlvbnMudmFsdWUpOyBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9wcmVyZW5kZXI6IGdldCBpbnB1dC4kaW5wdXRcbiAgICAgICAgICAgIHRoaXMuaW5wdXQucHJlcmVuZGVyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRUZW1wbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRmb3JtID0gJCgkLmZuLmVkaXRhYmxlZm9ybS50ZW1wbGF0ZSk7IFxuICAgICAgICB9LFxuICAgICAgICBpbml0QnV0dG9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgJGJ0biA9IHRoaXMuJGZvcm0uZmluZCgnLmVkaXRhYmxlLWJ1dHRvbnMnKTtcbiAgICAgICAgICAgICRidG4uYXBwZW5kKCQuZm4uZWRpdGFibGVmb3JtLmJ1dHRvbnMpO1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnNob3didXR0b25zID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICAgICRidG4uYWRkQ2xhc3MoJ2VkaXRhYmxlLWJ1dHRvbnMtYm90dG9tJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICBSZW5kZXJzIGVkaXRhYmxlZm9ybVxuXG4gICAgICAgIEBtZXRob2QgcmVuZGVyXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvL2luaXQgbG9hZGVyXG4gICAgICAgICAgICB0aGlzLiRsb2FkaW5nID0gJCgkLmZuLmVkaXRhYmxlZm9ybS5sb2FkaW5nKTsgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kZGl2LmVtcHR5KCkuYXBwZW5kKHRoaXMuJGxvYWRpbmcpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2luaXQgZm9ybSB0ZW1wbGF0ZSBhbmQgYnV0dG9uc1xuICAgICAgICAgICAgdGhpcy5pbml0VGVtcGxhdGUoKTtcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5zaG93YnV0dG9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdEJ1dHRvbnMoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZm9ybS5maW5kKCcuZWRpdGFibGUtYnV0dG9ucycpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL3Nob3cgbG9hZGluZyBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5zaG93TG9hZGluZygpOyAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2ZsYWcgc2hvd2luZyBpcyBmb3JtIG5vdyBzYXZpbmcgdmFsdWUgdG8gc2VydmVyLiBcbiAgICAgICAgICAgIC8vSXQgaXMgbmVlZGVkIHRvIHdhaXQgd2hlbiBjbG9zaW5nIGZvcm0uXG4gICAgICAgICAgICB0aGlzLmlzU2F2aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICBGaXJlZCB3aGVuIHJlbmRlcmluZyBzdGFydHNcbiAgICAgICAgICAgIEBldmVudCByZW5kZXJpbmcgXG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAqKi8gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJGRpdi50cmlnZ2VySGFuZGxlcigncmVuZGVyaW5nJyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaW5pdCBpbnB1dFxuICAgICAgICAgICAgdGhpcy5pbml0SW5wdXQoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9hcHBlbmQgaW5wdXQgdG8gZm9ybVxuICAgICAgICAgICAgdGhpcy4kZm9ybS5maW5kKCdkaXYuZWRpdGFibGUtaW5wdXQnKS5hcHBlbmQodGhpcy5pbnB1dC4kdHBsKTsgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9hcHBlbmQgZm9ybSB0byBjb250YWluZXJcbiAgICAgICAgICAgIHRoaXMuJGRpdi5hcHBlbmQodGhpcy4kZm9ybSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vcmVuZGVyIGlucHV0XG4gICAgICAgICAgICAkLndoZW4odGhpcy5pbnB1dC5yZW5kZXIoKSlcbiAgICAgICAgICAgIC50aGVuKCQucHJveHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vc2V0dXAgaW5wdXQgdG8gc3VibWl0IGF1dG9tYXRpY2FsbHkgd2hlbiBubyBidXR0b25zIHNob3duXG4gICAgICAgICAgICAgICAgaWYoIXRoaXMub3B0aW9ucy5zaG93YnV0dG9ucykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LmF1dG9zdWJtaXQoKTsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL2F0dGFjaCAnY2FuY2VsJyBoYW5kbGVyXG4gICAgICAgICAgICAgICAgdGhpcy4kZm9ybS5maW5kKCcuZWRpdGFibGUtY2FuY2VsJykuY2xpY2soJC5wcm94eSh0aGlzLmNhbmNlbCwgdGhpcykpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHRoaXMuaW5wdXQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcih0aGlzLmlucHV0LmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZm9ybS5maW5kKCcuZWRpdGFibGUtc3VibWl0JykuYXR0cignZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC4kaW5wdXQuYXR0cignZGlzYWJsZWQnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IGZvcm0gZnJvbSBzdWJtaXR0aW5nXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGZvcm0uc3VibWl0KGZ1bmN0aW9uKGUpeyBlLnByZXZlbnREZWZhdWx0KCk7IH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LiRpbnB1dC5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRmb3JtLmZpbmQoJy5lZGl0YWJsZS1zdWJtaXQnKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAodGhpcy52YWx1ZSA9PT0gbnVsbCB8fCB0aGlzLnZhbHVlID09PSB1bmRlZmluZWQgfHwgdGhpcy52YWx1ZSA9PT0gJycpID8gdGhpcy5vcHRpb25zLmRlZmF1bHRWYWx1ZSA6IHRoaXMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQudmFsdWUyaW5wdXQodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAvL2F0dGFjaCBzdWJtaXQgaGFuZGxlclxuICAgICAgICAgICAgICAgICAgICB0aGlzLiRmb3JtLnN1Ym1pdCgkLnByb3h5KHRoaXMuc3VibWl0LCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyoqICAgICAgICBcbiAgICAgICAgICAgICAgICBGaXJlZCB3aGVuIGZvcm0gaXMgcmVuZGVyZWRcbiAgICAgICAgICAgICAgICBAZXZlbnQgcmVuZGVyZWRcbiAgICAgICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAgICAgKiovICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy4kZGl2LnRyaWdnZXJIYW5kbGVyKCdyZW5kZXJlZCcpOyAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Zvcm0oKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL2NhbGwgcG9zdHJlbmRlciBtZXRob2QgdG8gcGVyZm9ybSBhY3Rpb25zIHJlcXVpcmVkIHZpc2liaWxpdHkgb2YgZm9ybVxuICAgICAgICAgICAgICAgIGlmKHRoaXMuaW5wdXQucG9zdHJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnBvc3RyZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkgeyAgIFxuICAgICAgICAgICAgLyoqICAgICAgICBcbiAgICAgICAgICAgIEZpcmVkIHdoZW4gZm9ybSB3YXMgY2FuY2VsbGVkIGJ5IHVzZXJcbiAgICAgICAgICAgIEBldmVudCBjYW5jZWwgXG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAqKi8gICAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kZGl2LnRyaWdnZXJIYW5kbGVyKCdjYW5jZWwnKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2hvd0xvYWRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHcsIGg7XG4gICAgICAgICAgICBpZih0aGlzLiRmb3JtKSB7XG4gICAgICAgICAgICAgICAgLy9zZXQgbG9hZGluZyBzaXplIGVxdWFsIHRvIGZvcm1cbiAgICAgICAgICAgICAgICB3ID0gdGhpcy4kZm9ybS5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgICAgICAgaCA9IHRoaXMuJGZvcm0ub3V0ZXJIZWlnaHQoKTsgXG4gICAgICAgICAgICAgICAgaWYodykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRsb2FkaW5nLndpZHRoKHcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGxvYWRpbmcuaGVpZ2h0KGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiRmb3JtLmhpZGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9zdHJldGNoIGxvYWRpbmcgdG8gZmlsbCBjb250YWluZXIgd2lkdGhcbiAgICAgICAgICAgICAgICB3ID0gdGhpcy4kbG9hZGluZy5wYXJlbnQoKS53aWR0aCgpO1xuICAgICAgICAgICAgICAgIGlmKHcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kbG9hZGluZy53aWR0aCh3KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiRsb2FkaW5nLnNob3coKTsgXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvd0Zvcm06IGZ1bmN0aW9uKGFjdGl2YXRlKSB7XG4gICAgICAgICAgICB0aGlzLiRsb2FkaW5nLmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuJGZvcm0uc2hvdygpO1xuICAgICAgICAgICAgaWYoYWN0aXZhdGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC5hY3RpdmF0ZSgpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICBGaXJlZCB3aGVuIGZvcm0gaXMgc2hvd25cbiAgICAgICAgICAgIEBldmVudCBzaG93IFxuICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGV2ZW50IGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgKiovICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJGRpdi50cmlnZ2VySGFuZGxlcignc2hvdycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgICAgIHZhciAkZ3JvdXAgPSB0aGlzLiRmb3JtLmZpbmQoJy5jb250cm9sLWdyb3VwJyksXG4gICAgICAgICAgICAgICAgJGJsb2NrID0gdGhpcy4kZm9ybS5maW5kKCcuZWRpdGFibGUtZXJyb3ItYmxvY2snKSxcbiAgICAgICAgICAgICAgICBsaW5lcztcblxuICAgICAgICAgICAgaWYobXNnID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICRncm91cC5yZW1vdmVDbGFzcygkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckdyb3VwQ2xhc3MpO1xuICAgICAgICAgICAgICAgICRibG9jay5yZW1vdmVDbGFzcygkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckJsb2NrQ2xhc3MpLmVtcHR5KCkuaGlkZSgpOyBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IG5ld2xpbmUgdG8gPGJyPiBmb3IgbW9yZSBwcmV0dHkgZXJyb3IgZGlzcGxheVxuICAgICAgICAgICAgICAgIGlmKG1zZykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lcyA9ICgnJyttc2cpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNbaV0gPSAkKCc8ZGl2PicpLnRleHQobGluZXNbaV0pLmh0bWwoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtc2cgPSBsaW5lcy5qb2luKCc8YnI+Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICRncm91cC5hZGRDbGFzcygkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckdyb3VwQ2xhc3MpO1xuICAgICAgICAgICAgICAgICRibG9jay5hZGRDbGFzcygkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckJsb2NrQ2xhc3MpLmh0bWwobXNnKS5zaG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3VibWl0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2dldCBuZXcgdmFsdWUgZnJvbSBpbnB1dFxuICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gdGhpcy5pbnB1dC5pbnB1dDJ2YWx1ZSgpOyBcblxuICAgICAgICAgICAgLy92YWxpZGF0aW9uOiBpZiB2YWxpZGF0ZSByZXR1cm5zIHN0cmluZyBvciB0cnV0aHkgdmFsdWUgLSBtZWFucyBlcnJvclxuICAgICAgICAgICAgLy9pZiByZXR1cm5zIG9iamVjdCBsaWtlIHtuZXdWYWx1ZTogJy4uLid9ID0+IHN1Ym1pdHRlZCB2YWx1ZSBpcyByZWFzc2lnbmVkIHRvIGl0XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRlKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGlmICgkLnR5cGUoZXJyb3IpID09PSAnb2JqZWN0JyAmJiBlcnJvci5uZXdWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBlcnJvci5uZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0LnZhbHVlMmlucHV0KG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgZXJyb3IubXNnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVycm9yLm1zZyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Zvcm0oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dGb3JtKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pZiB2YWx1ZSBub3QgY2hhbmdlZCAtLT4gdHJpZ2dlciAnbm9jaGFuZ2UnIGV2ZW50IGFuZCByZXR1cm5cbiAgICAgICAgICAgIC8qanNsaW50IGVxZXE6IHRydWUqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2F2ZW5vY2hhbmdlICYmIHRoaXMuaW5wdXQudmFsdWUyc3RyKG5ld1ZhbHVlKSA9PSB0aGlzLmlucHV0LnZhbHVlMnN0cih0aGlzLnZhbHVlKSkge1xuICAgICAgICAgICAgLypqc2xpbnQgZXFlcTogZmFsc2UqLyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvKiogICAgICAgIFxuICAgICAgICAgICAgICAgIEZpcmVkIHdoZW4gdmFsdWUgbm90IGNoYW5nZWQgYnV0IGZvcm0gaXMgc3VibWl0dGVkLiBSZXF1aXJlcyBzYXZlbm9jaGFuZ2UgPSBmYWxzZS5cbiAgICAgICAgICAgICAgICBAZXZlbnQgbm9jaGFuZ2UgXG4gICAgICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGV2ZW50IGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgICAgICoqLyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy4kZGl2LnRyaWdnZXJIYW5kbGVyKCdub2NoYW5nZScpOyAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgIC8vY29udmVydCB2YWx1ZSBmb3Igc3VibWl0dGluZyB0byBzZXJ2ZXJcbiAgICAgICAgICAgIHZhciBzdWJtaXRWYWx1ZSA9IHRoaXMuaW5wdXQudmFsdWUyc3VibWl0KG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5pc1NhdmluZyA9IHRydWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vc2VuZGluZyBkYXRhIHRvIHNlcnZlclxuICAgICAgICAgICAgJC53aGVuKHRoaXMuc2F2ZShzdWJtaXRWYWx1ZSkpXG4gICAgICAgICAgICAuZG9uZSgkLnByb3h5KGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc1NhdmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy9ydW4gc3VjY2VzcyBjYWxsYmFja1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSB0eXBlb2YgdGhpcy5vcHRpb25zLnN1Y2Nlc3MgPT09ICdmdW5jdGlvbicgPyB0aGlzLm9wdGlvbnMuc3VjY2Vzcy5jYWxsKHRoaXMub3B0aW9ucy5zY29wZSwgcmVzcG9uc2UsIG5ld1ZhbHVlKSA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvL2lmIHN1Y2Nlc3MgY2FsbGJhY2sgcmV0dXJucyBmYWxzZSAtLT4ga2VlcCBmb3JtIG9wZW4gYW5kIGRvIG5vdCBhY3RpdmF0ZSBpbnB1dFxuICAgICAgICAgICAgICAgIGlmKHJlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0Zvcm0oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9pZiBzdWNjZXNzIGNhbGxiYWNrIHJldHVybnMgc3RyaW5nIC0tPiAga2VlcCBmb3JtIG9wZW4sIHNob3cgZXJyb3IgYW5kIGFjdGl2YXRlIGlucHV0ICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIHJlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcihyZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dGb3JtKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2lmIHN1Y2Nlc3MgY2FsbGJhY2sgcmV0dXJucyBvYmplY3QgbGlrZSB7bmV3VmFsdWU6IDxzb21ldGhpbmc+fSAtLT4gdXNlIHRoYXQgdmFsdWUgaW5zdGVhZCBvZiBzdWJtaXR0ZWRcbiAgICAgICAgICAgICAgICAvL2l0IGlzIHVzZWZ1bGwgaWYgeW91IHdhbnQgdG8gY2huYWdlIHZhbHVlIGluIHVybC1mdW5jdGlvblxuICAgICAgICAgICAgICAgIGlmKHJlcyAmJiB0eXBlb2YgcmVzID09PSAnb2JqZWN0JyAmJiByZXMuaGFzT3duUHJvcGVydHkoJ25ld1ZhbHVlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWUgPSByZXMubmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9jbGVhciBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvcihmYWxzZSk7ICAgXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICAgICAgRmlyZWQgd2hlbiBmb3JtIGlzIHN1Ym1pdHRlZFxuICAgICAgICAgICAgICAgIEBldmVudCBzYXZlIFxuICAgICAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBldmVudCBldmVudCBvYmplY3RcbiAgICAgICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gcGFyYW1zIGFkZGl0aW9uYWwgcGFyYW1zXG4gICAgICAgICAgICAgICAgQHBhcmFtIHttaXhlZH0gcGFyYW1zLm5ld1ZhbHVlIHJhdyBuZXcgdmFsdWVcbiAgICAgICAgICAgICAgICBAcGFyYW0ge21peGVkfSBwYXJhbXMuc3VibWl0VmFsdWUgc3VibWl0dGVkIHZhbHVlIGFzIHN0cmluZ1xuICAgICAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMucmVzcG9uc2UgYWpheCByZXNwb25zZVxuXG4gICAgICAgICAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAkKCcjZm9ybS1kaXYnKS5vbignc2F2ZScpLCBmdW5jdGlvbihlLCBwYXJhbXMpe1xuICAgICAgICAgICAgICAgICAgICBpZihwYXJhbXMubmV3VmFsdWUgPT09ICd1c2VybmFtZScpIHsuLi59XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgKiovXG4gICAgICAgICAgICAgICAgdGhpcy4kZGl2LnRyaWdnZXJIYW5kbGVyKCdzYXZlJywge25ld1ZhbHVlOiBuZXdWYWx1ZSwgc3VibWl0VmFsdWU6IHN1Ym1pdFZhbHVlLCByZXNwb25zZTogcmVzcG9uc2V9KTtcbiAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgLmZhaWwoJC5wcm94eShmdW5jdGlvbih4aHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2F2aW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB2YXIgbXNnO1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiB0aGlzLm9wdGlvbnMuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnID0gdGhpcy5vcHRpb25zLmVycm9yLmNhbGwodGhpcy5vcHRpb25zLnNjb3BlLCB4aHIsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtc2cgPSB0eXBlb2YgeGhyID09PSAnc3RyaW5nJyA/IHhociA6IHhoci5yZXNwb25zZVRleHQgfHwgeGhyLnN0YXR1c1RleHQgfHwgJ1Vua25vd24gZXJyb3IhJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yKG1zZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93Rm9ybSgpO1xuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNhdmU6IGZ1bmN0aW9uKHN1Ym1pdFZhbHVlKSB7XG4gICAgICAgICAgICAvL3RyeSBwYXJzZSBjb21wb3NpdGUgcGsgZGVmaW5lZCBhcyBqc29uIHN0cmluZyBpbiBkYXRhLXBrIFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBrID0gJC5mbi5lZGl0YWJsZXV0aWxzLnRyeVBhcnNlSnNvbih0aGlzLm9wdGlvbnMucGssIHRydWUpOyBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHBrID0gKHR5cGVvZiB0aGlzLm9wdGlvbnMucGsgPT09ICdmdW5jdGlvbicpID8gdGhpcy5vcHRpb25zLnBrLmNhbGwodGhpcy5vcHRpb25zLnNjb3BlKSA6IHRoaXMub3B0aW9ucy5wayxcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgIHNlbmQgb24gc2VydmVyIGluIGZvbGxvd2luZyBjYXNlczpcbiAgICAgICAgICAgICAgMS4gdXJsIGlzIGZ1bmN0aW9uXG4gICAgICAgICAgICAgIDIuIHVybCBpcyBzdHJpbmcgQU5EIChwayBkZWZpbmVkIE9SIHNlbmQgb3B0aW9uID0gYWx3YXlzKSBcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZW5kID0gISEodHlwZW9mIHRoaXMub3B0aW9ucy51cmwgPT09ICdmdW5jdGlvbicgfHwgKHRoaXMub3B0aW9ucy51cmwgJiYgKCh0aGlzLm9wdGlvbnMuc2VuZCA9PT0gJ2Fsd2F5cycpIHx8ICh0aGlzLm9wdGlvbnMuc2VuZCA9PT0gJ2F1dG8nICYmIHBrICE9PSBudWxsICYmIHBrICE9PSB1bmRlZmluZWQpKSkpLFxuICAgICAgICAgICAgcGFyYW1zO1xuXG4gICAgICAgICAgICBpZiAoc2VuZCkgeyAvL3NlbmQgdG8gc2VydmVyXG4gICAgICAgICAgICAgICAgdGhpcy5zaG93TG9hZGluZygpO1xuXG4gICAgICAgICAgICAgICAgLy9zdGFuZGFyZCBwYXJhbXNcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMub3B0aW9ucy5uYW1lIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc3VibWl0VmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBrOiBwayBcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy9hZGRpdGlvbmFsIHBhcmFtc1xuICAgICAgICAgICAgICAgIGlmKHR5cGVvZiB0aGlzLm9wdGlvbnMucGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHRoaXMub3B0aW9ucy5wYXJhbXMuY2FsbCh0aGlzLm9wdGlvbnMuc2NvcGUsIHBhcmFtcyk7ICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL3RyeSBwYXJzZSBqc29uIGluIHNpbmdsZSBxdW90ZXMgKGZyb20gZGF0YS1wYXJhbXMgYXR0cmlidXRlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucGFyYW1zID0gJC5mbi5lZGl0YWJsZXV0aWxzLnRyeVBhcnNlSnNvbih0aGlzLm9wdGlvbnMucGFyYW1zLCB0cnVlKTsgICBcbiAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQocGFyYW1zLCB0aGlzLm9wdGlvbnMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZih0eXBlb2YgdGhpcy5vcHRpb25zLnVybCA9PT0gJ2Z1bmN0aW9uJykgeyAvL3VzZXIncyBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnVybC5jYWxsKHRoaXMub3B0aW9ucy5zY29wZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAgXG4gICAgICAgICAgICAgICAgICAgIC8vc2VuZCBhamF4IHRvIHNlcnZlciBhbmQgcmV0dXJuIGRlZmVycmVkIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5hamF4KCQuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCAgICAgOiB0aGlzLm9wdGlvbnMudXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSAgICA6IHBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgICAgOiAnUE9TVCdcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLmFqYXhPcHRpb25zKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBcblxuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnZhbGlkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52YWxpZGF0ZS5jYWxsKHRoaXMub3B0aW9ucy5zY29wZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYoa2V5IGluIHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2RvIG5vdCBwYXNzIG9wdGlvbiB0byBpbnB1dCBhcyBpdCBpcyBwYXNzZWQgaW4gZWRpdGFibGUtZWxlbWVudFxuICAgICAgICB9LFxuXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgY29udmVydFN0cikge1xuICAgICAgICAgICAgaWYoY29udmVydFN0cikge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmlucHV0LnN0cjJ2YWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pZiBmb3JtIGlzIHZpc2libGUsIHVwZGF0ZSBpbnB1dFxuICAgICAgICAgICAgaWYodGhpcy4kZm9ybSAmJiB0aGlzLiRmb3JtLmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC52YWx1ZTJpbnB1dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgfSAgICAgICAgICAgICAgIFxuICAgIH07XG5cbiAgICAvKlxuICAgIEluaXRpYWxpemUgZWRpdGFibGVmb3JtLiBBcHBsaWVkIHRvIGpRdWVyeSBvYmplY3QuXG5cbiAgICBAbWV0aG9kICQoKS5lZGl0YWJsZWZvcm0ob3B0aW9ucylcbiAgICBAcGFyYW1zIHtPYmplY3R9IG9wdGlvbnNcbiAgICBAZXhhbXBsZVxuICAgIHZhciAkZm9ybSA9ICQoJyZsdDtkaXYmZ3Q7JykuZWRpdGFibGVmb3JtKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICBuYW1lOiAndXNlcm5hbWUnLFxuICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgIHZhbHVlOiAndml0YWxpeSdcbiAgICB9KTtcblxuICAgIC8vdG8gZGlzcGxheSBmb3JtIHlvdSBzaG91bGQgY2FsbCAncmVuZGVyJyBtZXRob2RcbiAgICAkZm9ybS5lZGl0YWJsZWZvcm0oJ3JlbmRlcicpOyAgICAgXG4gICAgKi9cbiAgICAkLmZuLmVkaXRhYmxlZm9ybSA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSwgXG4gICAgICAgICAgICBkYXRhID0gJHRoaXMuZGF0YSgnZWRpdGFibGVmb3JtJyksIFxuICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT09ICdvYmplY3QnICYmIG9wdGlvbjsgXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKCdlZGl0YWJsZWZvcm0nLCAoZGF0YSA9IG5ldyBFZGl0YWJsZUZvcm0odGhpcywgb3B0aW9ucykpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdzdHJpbmcnKSB7IC8vY2FsbCBtZXRob2QgXG4gICAgICAgICAgICAgICAgZGF0YVtvcHRpb25dLmFwcGx5KGRhdGEsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvL2tlZXAgbGluayB0byBjb25zdHJ1Y3RvciB0byBhbGxvdyBpbmhlcml0YW5jZVxuICAgICQuZm4uZWRpdGFibGVmb3JtLkNvbnN0cnVjdG9yID0gRWRpdGFibGVGb3JtOyAgICBcblxuICAgIC8vZGVmYXVsdHNcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5kZWZhdWx0cyA9IHtcbiAgICAgICAgLyogc2VlIGFsc28gZGVmYXVsdHMgZm9yIGlucHV0ICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgIFR5cGUgb2YgaW5wdXQuIENhbiBiZSA8Y29kZT50ZXh0fHRleHRhcmVhfHNlbGVjdHxkYXRlfGNoZWNrbGlzdDwvY29kZT5cblxuICAgICAgICBAcHJvcGVydHkgdHlwZSBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICd0ZXh0J1xuICAgICAgICAqKi9cbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAvKipcbiAgICAgICAgVXJsIGZvciBzdWJtaXQsIGUuZy4gPGNvZGU+Jy9wb3N0JzwvY29kZT4gIFxuICAgICAgICBJZiBmdW5jdGlvbiAtIGl0IHdpbGwgYmUgY2FsbGVkIGluc3RlYWQgb2YgYWpheC4gRnVuY3Rpb24gc2hvdWxkIHJldHVybiBkZWZlcnJlZCBvYmplY3QgdG8gcnVuIGZhaWwvZG9uZSBjYWxsYmFja3MuXG5cbiAgICAgICAgQHByb3BlcnR5IHVybCBcbiAgICAgICAgQHR5cGUgc3RyaW5nfGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgdXJsOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBkID0gbmV3ICQuRGVmZXJyZWQ7XG4gICAgICAgICAgICBpZihwYXJhbXMudmFsdWUgPT09ICdhYmMnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGQucmVqZWN0KCdlcnJvciBtZXNzYWdlJyk7IC8vcmV0dXJuaW5nIGVycm9yIHZpYSBkZWZlcnJlZCBvYmplY3RcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9hc3luYyBzYXZpbmcgZGF0YSBpbiBqcyBtb2RlbFxuICAgICAgICAgICAgICAgIHNvbWVNb2RlbC5hc3luY1NhdmVNZXRob2Qoe1xuICAgICAgICAgICAgICAgICAgIC4uLiwgXG4gICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICBkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7IFxuICAgICAgICAgICAgICAgIHJldHVybiBkLnByb21pc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgdXJsOm51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBBZGRpdGlvbmFsIHBhcmFtcyBmb3Igc3VibWl0LiBJZiBkZWZpbmVkIGFzIDxjb2RlPm9iamVjdDwvY29kZT4gLSBpdCBpcyAqKmFwcGVuZGVkKiogdG8gb3JpZ2luYWwgYWpheCBkYXRhIChwaywgbmFtZSBhbmQgdmFsdWUpLiAgXG4gICAgICAgIElmIGRlZmluZWQgYXMgPGNvZGU+ZnVuY3Rpb248L2NvZGU+IC0gcmV0dXJuZWQgb2JqZWN0ICoqb3ZlcndyaXRlcyoqIG9yaWdpbmFsIGFqYXggZGF0YS5cbiAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgcGFyYW1zOiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgICAgIC8vb3JpZ2luYWxseSBwYXJhbXMgY29udGFpbiBwaywgbmFtZSBhbmQgdmFsdWVcbiAgICAgICAgICAgIHBhcmFtcy5hID0gMTtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH1cblxuICAgICAgICBAcHJvcGVydHkgcGFyYW1zIFxuICAgICAgICBAdHlwZSBvYmplY3R8ZnVuY3Rpb25cbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgICAgXG4gICAgICAgIHBhcmFtczpudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgTmFtZSBvZiBmaWVsZC4gV2lsbCBiZSBzdWJtaXR0ZWQgb24gc2VydmVyLiBDYW4gYmUgdGFrZW4gZnJvbSA8Y29kZT5pZDwvY29kZT4gYXR0cmlidXRlXG5cbiAgICAgICAgQHByb3BlcnR5IG5hbWUgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgUHJpbWFyeSBrZXkgb2YgZWRpdGFibGUgb2JqZWN0IChlLmcuIHJlY29yZCBpZCBpbiBkYXRhYmFzZSkuIEZvciBjb21wb3NpdGUga2V5cyB1c2Ugb2JqZWN0LCBlLmcuIDxjb2RlPntpZDogMSwgbGFuZzogJ2VuJ308L2NvZGU+LlxuICAgICAgICBDYW4gYmUgY2FsY3VsYXRlZCBkeW5hbWljYWxseSB2aWEgZnVuY3Rpb24uXG5cbiAgICAgICAgQHByb3BlcnR5IHBrIFxuICAgICAgICBAdHlwZSBzdHJpbmd8b2JqZWN0fGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHBrOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgSW5pdGlhbCB2YWx1ZS4gSWYgbm90IGRlZmluZWQgLSB3aWxsIGJlIHRha2VuIGZyb20gZWxlbWVudCdzIGNvbnRlbnQuXG4gICAgICAgIEZvciBfX3NlbGVjdF9fIHR5cGUgc2hvdWxkIGJlIGRlZmluZWQgKGFzIGl0IGlzIElEIG9mIHNob3duIHRleHQpLlxuXG4gICAgICAgIEBwcm9wZXJ0eSB2YWx1ZSBcbiAgICAgICAgQHR5cGUgc3RyaW5nfG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgVmFsdWUgdGhhdCB3aWxsIGJlIGRpc3BsYXllZCBpbiBpbnB1dCBpZiBvcmlnaW5hbCBmaWVsZCB2YWx1ZSBpcyBlbXB0eSAoYG51bGx8dW5kZWZpbmVkfCcnYCkuXG5cbiAgICAgICAgQHByb3BlcnR5IGRlZmF1bHRWYWx1ZSBcbiAgICAgICAgQHR5cGUgc3RyaW5nfG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBzaW5jZSAxLjQuNlxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBkZWZhdWx0VmFsdWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBTdHJhdGVneSBmb3Igc2VuZGluZyBkYXRhIG9uIHNlcnZlci4gQ2FuIGJlIGBhdXRvfGFsd2F5c3xuZXZlcmAuXG4gICAgICAgIFdoZW4gJ2F1dG8nIGRhdGEgd2lsbCBiZSBzZW50IG9uIHNlcnZlciAqKm9ubHkgaWYgcGsgYW5kIHVybCBkZWZpbmVkKiosIG90aGVyd2lzZSBuZXcgdmFsdWUgd2lsbCBiZSBzdG9yZWQgbG9jYWxseS5cblxuICAgICAgICBAcHJvcGVydHkgc2VuZCBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICdhdXRvJ1xuICAgICAgICAqKi8gICAgICAgICAgXG4gICAgICAgIHNlbmQ6ICdhdXRvJywgXG4gICAgICAgIC8qKlxuICAgICAgICBGdW5jdGlvbiBmb3IgY2xpZW50LXNpZGUgdmFsaWRhdGlvbi4gSWYgcmV0dXJucyBzdHJpbmcgLSBtZWFucyB2YWxpZGF0aW9uIG5vdCBwYXNzZWQgYW5kIHN0cmluZyBzaG93ZWQgYXMgZXJyb3IuXG4gICAgICAgIFNpbmNlIDEuNS4xIHlvdSBjYW4gbW9kaWZ5IHN1Ym1pdHRlZCB2YWx1ZSBieSByZXR1cm5pbmcgb2JqZWN0IGZyb20gYHZhbGlkYXRlYDogXG4gICAgICAgIGB7bmV3VmFsdWU6ICcuLi4nfWAgb3IgYHtuZXdWYWx1ZTogJy4uLicsIG1zZzogJy4uLid9YFxuXG4gICAgICAgIEBwcm9wZXJ0eSB2YWxpZGF0ZSBcbiAgICAgICAgQHR5cGUgZnVuY3Rpb25cbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICBAZXhhbXBsZVxuICAgICAgICB2YWxpZGF0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmKCQudHJpbSh2YWx1ZSkgPT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1RoaXMgZmllbGQgaXMgcmVxdWlyZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB2YWxpZGF0ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIFN1Y2Nlc3MgY2FsbGJhY2suIENhbGxlZCB3aGVuIHZhbHVlIHN1Y2Nlc3NmdWxseSBzZW50IG9uIHNlcnZlciBhbmQgKipyZXNwb25zZSBzdGF0dXMgPSAyMDAqKi4gIFxuICAgICAgICBVc2VmdWxsIHRvIHdvcmsgd2l0aCBqc29uIHJlc3BvbnNlLiBGb3IgZXhhbXBsZSwgaWYgeW91ciBiYWNrZW5kIHJlc3BvbnNlIGNhbiBiZSA8Y29kZT57c3VjY2VzczogdHJ1ZX08L2NvZGU+XG4gICAgICAgIG9yIDxjb2RlPntzdWNjZXNzOiBmYWxzZSwgbXNnOiBcInNlcnZlciBlcnJvclwifTwvY29kZT4geW91IGNhbiBjaGVjayBpdCBpbnNpZGUgdGhpcyBjYWxsYmFjay4gIFxuICAgICAgICBJZiBpdCByZXR1cm5zICoqc3RyaW5nKiogLSBtZWFucyBlcnJvciBvY2N1cmVkIGFuZCBzdHJpbmcgaXMgc2hvd24gYXMgZXJyb3IgbWVzc2FnZS4gIFxuICAgICAgICBJZiBpdCByZXR1cm5zICoqb2JqZWN0IGxpa2UqKiA8Y29kZT57bmV3VmFsdWU6ICZsdDtzb21ldGhpbmcmZ3Q7fTwvY29kZT4gLSBpdCBvdmVyd3JpdGVzIHZhbHVlLCBzdWJtaXR0ZWQgYnkgdXNlci4gIFxuICAgICAgICBPdGhlcndpc2UgbmV3VmFsdWUgc2ltcGx5IHJlbmRlcmVkIGludG8gZWxlbWVudC5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBzdWNjZXNzIFxuICAgICAgICBAdHlwZSBmdW5jdGlvblxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHJlc3BvbnNlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYoIXJlc3BvbnNlLnN1Y2Nlc3MpIHJldHVybiByZXNwb25zZS5tc2c7XG4gICAgICAgIH1cbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICBzdWNjZXNzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgRXJyb3IgY2FsbGJhY2suIENhbGxlZCB3aGVuIHJlcXVlc3QgZmFpbGVkIChyZXNwb25zZSBzdGF0dXMgIT0gMjAwKS4gIFxuICAgICAgICBVc2VmdWxsIHdoZW4geW91IHdhbnQgdG8gcGFyc2UgZXJyb3IgcmVzcG9uc2UgYW5kIGRpc3BsYXkgYSBjdXN0b20gbWVzc2FnZS5cbiAgICAgICAgTXVzdCByZXR1cm4gKipzdHJpbmcqKiAtIHRoZSBtZXNzYWdlIHRvIGJlIGRpc3BsYXllZCBpbiB0aGUgZXJyb3IgYmxvY2suXG4gICAgICAgICAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBlcnJvciBcbiAgICAgICAgQHR5cGUgZnVuY3Rpb25cbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICBAc2luY2UgMS40LjRcbiAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKHJlc3BvbnNlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYocmVzcG9uc2Uuc3RhdHVzID09PSA1MDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1NlcnZpY2UgdW5hdmFpbGFibGUuIFBsZWFzZSB0cnkgbGF0ZXIuJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAqKi8gICAgICAgICAgXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgQWRkaXRpb25hbCBvcHRpb25zIGZvciBzdWJtaXQgYWpheCByZXF1ZXN0LlxuICAgICAgICBMaXN0IG9mIHZhbHVlczogaHR0cDovL2FwaS5qcXVlcnkuY29tL2pRdWVyeS5hamF4XG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgYWpheE9wdGlvbnMgXG4gICAgICAgIEB0eXBlIG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBzaW5jZSAxLjEuMSAgICAgICAgXG4gICAgICAgIEBleGFtcGxlIFxuICAgICAgICBhamF4T3B0aW9uczoge1xuICAgICAgICAgICAgdHlwZTogJ3B1dCcsXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nXG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBhamF4T3B0aW9uczogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZXJlIHRvIHNob3cgYnV0dG9uczogbGVmdCh0cnVlKXxib3R0b218ZmFsc2UgIFxuICAgICAgICBGb3JtIHdpdGhvdXQgYnV0dG9ucyBpcyBhdXRvLXN1Ym1pdHRlZC5cblxuICAgICAgICBAcHJvcGVydHkgc2hvd2J1dHRvbnMgXG4gICAgICAgIEB0eXBlIGJvb2xlYW58c3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IHRydWVcbiAgICAgICAgQHNpbmNlIDEuMS4xXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBzaG93YnV0dG9uczogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgIFNjb3BlIGZvciBjYWxsYmFjayBtZXRob2RzIChzdWNjZXNzLCB2YWxpZGF0ZSkuICBcbiAgICAgICAgSWYgPGNvZGU+bnVsbDwvY29kZT4gbWVhbnMgZWRpdGFibGVmb3JtIGluc3RhbmNlIGl0c2VsZi4gXG5cbiAgICAgICAgQHByb3BlcnR5IHNjb3BlIFxuICAgICAgICBAdHlwZSBET01FbGVtZW50fG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBzaW5jZSAxLjIuMFxuICAgICAgICBAcHJpdmF0ZVxuICAgICAgICAqKi8gICAgICAgICAgICBcbiAgICAgICAgc2NvcGU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBXaGV0aGVyIHRvIHNhdmUgb3IgY2FuY2VsIHZhbHVlIHdoZW4gaXQgd2FzIG5vdCBjaGFuZ2VkIGJ1dCBmb3JtIHdhcyBzdWJtaXR0ZWRcblxuICAgICAgICBAcHJvcGVydHkgc2F2ZW5vY2hhbmdlIFxuICAgICAgICBAdHlwZSBib29sZWFuXG4gICAgICAgIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgIEBzaW5jZSAxLjIuMFxuICAgICAgICAqKi9cbiAgICAgICAgc2F2ZW5vY2hhbmdlOiBmYWxzZVxuICAgIH07ICAgXG5cbiAgICAvKlxuICAgIE5vdGU6IGZvbGxvd2luZyBwYXJhbXMgY291bGQgcmVkZWZpbmVkIGluIGVuZ2luZTogYm9vdHN0cmFwIG9yIGpxdWVyeXVpOlxuICAgIENsYXNzZXMgJ2NvbnRyb2wtZ3JvdXAnIGFuZCAnZWRpdGFibGUtZXJyb3ItYmxvY2snIG11c3QgYWx3YXlzIHByZXNlbnQhXG4gICAgKi8gICAgICBcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS50ZW1wbGF0ZSA9ICc8Zm9ybSBjbGFzcz1cImZvcm0taW5saW5lIGVkaXRhYmxlZm9ybVwiPicrXG4gICAgJzxkaXYgY2xhc3M9XCJjb250cm9sLWdyb3VwXCI+JyArIFxuICAgICc8ZGl2PjxkaXYgY2xhc3M9XCJlZGl0YWJsZS1pbnB1dFwiPjwvZGl2PjxkaXYgY2xhc3M9XCJlZGl0YWJsZS1idXR0b25zXCI+PC9kaXY+PC9kaXY+JytcbiAgICAnPGRpdiBjbGFzcz1cImVkaXRhYmxlLWVycm9yLWJsb2NrXCI+PC9kaXY+JyArIFxuICAgICc8L2Rpdj4nICsgXG4gICAgJzwvZm9ybT4nO1xuXG4gICAgLy9sb2FkaW5nIGRpdlxuICAgICQuZm4uZWRpdGFibGVmb3JtLmxvYWRpbmcgPSAnPGRpdiBjbGFzcz1cImVkaXRhYmxlZm9ybS1sb2FkaW5nXCI+PC9kaXY+JztcblxuICAgIC8vYnV0dG9uc1xuICAgICQuZm4uZWRpdGFibGVmb3JtLmJ1dHRvbnMgPSAnPGJ1dHRvbiB0eXBlPVwic3VibWl0XCIgY2xhc3M9XCJlZGl0YWJsZS1zdWJtaXRcIj5vazwvYnV0dG9uPicrXG4gICAgJzxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiZWRpdGFibGUtY2FuY2VsXCI+Y2FuY2VsPC9idXR0b24+JzsgICAgICBcblxuICAgIC8vZXJyb3IgY2xhc3MgYXR0YWNoZWQgdG8gY29udHJvbC1ncm91cFxuICAgICQuZm4uZWRpdGFibGVmb3JtLmVycm9yR3JvdXBDbGFzcyA9IG51bGw7ICBcblxuICAgIC8vZXJyb3IgY2xhc3MgYXR0YWNoZWQgdG8gZWRpdGFibGUtZXJyb3ItYmxvY2tcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckJsb2NrQ2xhc3MgPSAnZWRpdGFibGUtZXJyb3InO1xuICAgIFxuICAgIC8vZW5naW5lXG4gICAgJC5mbi5lZGl0YWJsZWZvcm0uZW5naW5lID0gJ2pxdWVyeSc7XG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG4qIEVkaXRhYmxlRm9ybSB1dGlsaXRlc1xuKi9cbihmdW5jdGlvbiAoJCkge1xuXG4gICAgLy91dGlsc1xuICAgICQuZm4uZWRpdGFibGV1dGlscyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgICogY2xhc3NpYyBKUyBpbmhlcml0YW5jZSBmdW5jdGlvblxuICAgICAgICAqLyAgXG4gICAgICAgIGluaGVyaXQ6IGZ1bmN0aW9uIChDaGlsZCwgUGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgRiA9IGZ1bmN0aW9uKCkgeyB9O1xuICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBQYXJlbnQucHJvdG90eXBlO1xuICAgICAgICAgICAgQ2hpbGQucHJvdG90eXBlID0gbmV3IEYoKTtcbiAgICAgICAgICAgIENoaWxkLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENoaWxkO1xuICAgICAgICAgICAgQ2hpbGQuc3VwZXJjbGFzcyA9IFBhcmVudC5wcm90b3R5cGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogc2V0IGNhcmV0IHBvc2l0aW9uIGluIGlucHV0XG4gICAgICAgICogc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDk5MTI2L2pxdWVyeS1zZXQtY3Vyc29yLXBvc2l0aW9uLWluLXRleHQtYXJlYVxuICAgICAgICAqLyAgICAgICAgXG4gICAgICAgIHNldEN1cnNvclBvc2l0aW9uOiBmdW5jdGlvbihlbGVtLCBwb3MpIHtcbiAgICAgICAgICAgIGlmIChlbGVtLnNldFNlbGVjdGlvblJhbmdlKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5zZXRTZWxlY3Rpb25SYW5nZShwb3MsIHBvcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVsZW0uY3JlYXRlVGV4dFJhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gZWxlbS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgICAgICByYW5nZS5tb3ZlRW5kKCdjaGFyYWN0ZXInLCBwb3MpO1xuICAgICAgICAgICAgICAgIHJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgcG9zKTtcbiAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgKiBmdW5jdGlvbiB0byBwYXJzZSBKU09OIGluICpzaW5nbGUqIHF1b3Rlcy4gKGpxdWVyeSBhdXRvbWF0aWNhbGx5IHBhcnNlIG9ubHkgZG91YmxlIHF1b3RlcylcbiAgICAgICAgKiBUaGF0IGFsbG93cyBzdWNoIGNvZGUgYXM6IDxhIGRhdGEtc291cmNlPVwieydhJzogJ2InLCAnYyc6ICdkJ31cIj5cbiAgICAgICAgKiBzYWZlID0gdHJ1ZSAtLT4gbWVhbnMgbm8gZXhjZXB0aW9uIHdpbGwgYmUgdGhyb3duXG4gICAgICAgICogZm9yIGRldGFpbHMgc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzQxMDM0OC9ob3ctdG8tc2V0LWpzb24tZm9ybWF0LXRvLWh0bWw1LWRhdGEtYXR0cmlidXRlcy1pbi10aGUtanF1ZXJ5XG4gICAgICAgICovXG4gICAgICAgIHRyeVBhcnNlSnNvbjogZnVuY3Rpb24ocywgc2FmZSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzID09PSAnc3RyaW5nJyAmJiBzLmxlbmd0aCAmJiBzLm1hdGNoKC9eW1xce1xcW10uKltcXH1cXF1dJC8pKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhZmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGV2aWw6IHRydWUqL1xuICAgICAgICAgICAgICAgICAgICAgICAgcyA9IChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgcykpKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKmpzbGludCBldmlsOiBmYWxzZSovXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKmpzbGludCBldmlsOiB0cnVlKi9cbiAgICAgICAgICAgICAgICAgICAgcyA9IChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgcykpKCk7XG4gICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGV2aWw6IGZhbHNlKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgKiBzbGljZSBvYmplY3QgYnkgc3BlY2lmaWVkIGtleXNcbiAgICAgICAgKi9cbiAgICAgICAgc2xpY2VPYmo6IGZ1bmN0aW9uKG9iaiwga2V5cywgY2FzZVNlbnNpdGl2ZSAvKiBkZWZhdWx0OiBmYWxzZSAqLykge1xuICAgICAgICAgICAgdmFyIGtleSwga2V5TG93ZXIsIG5ld09iaiA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoISQuaXNBcnJheShrZXlzKSB8fCAha2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGNhc2VTZW5zaXRpdmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy93aGVuIGdldHRpbmcgZGF0YS0qIGF0dHJpYnV0ZXMgdmlhICQuZGF0YSgpIGl0J3MgY29udmVydGVkIHRvIGxvd2VyY2FzZS5cbiAgICAgICAgICAgICAgICAvL2RldGFpbHM6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzYwMjU2NS91c2luZy1kYXRhLWF0dHJpYnV0ZXMtd2l0aC1qcXVlcnlcbiAgICAgICAgICAgICAgICAvL3dvcmthcm91bmQgaXMgY29kZSBiZWxvdy5cbiAgICAgICAgICAgICAgICBrZXlMb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5TG93ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld09ialtrZXldID0gb2JqW2tleUxvd2VyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgZXhjbHVkZSBjb21wbGV4IG9iamVjdHMgZnJvbSAkLmRhdGEoKSBiZWZvcmUgcGFzcyB0byBjb25maWdcbiAgICAgICAgKi9cbiAgICAgICAgZ2V0Q29uZmlnRGF0YTogZnVuY3Rpb24oJGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgICAgICAkLmVhY2goJGVsZW1lbnQuZGF0YSgpLCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIHYgIT09ICdvYmplY3QnIHx8ICh2ICYmIHR5cGVvZiB2ID09PSAnb2JqZWN0JyAmJiAodi5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0IHx8IHYuY29uc3RydWN0b3IgPT09IEFycmF5KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICAgcmV0dXJucyBrZXlzIG9mIG9iamVjdFxuICAgICAgICAqL1xuICAgICAgICBvYmplY3RLZXlzOiBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobyk7ICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG8gIT09IE9iamVjdChvKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBrPVtdLCBwO1xuICAgICAgICAgICAgICAgIGZvciAocCBpbiBvKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobyxwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgay5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgIC8qKlxuICAgICAgICBtZXRob2QgdG8gZXNjYXBlIGh0bWwuXG4gICAgICAgKiovXG4gICAgICAgZXNjYXBlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgcmV0dXJuICQoJzxkaXY+JykudGV4dChzdHIpLmh0bWwoKTtcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qXG4gICAgICAgIHJldHVybnMgYXJyYXkgaXRlbXMgZnJvbSBzb3VyY2VEYXRhIGhhdmluZyB2YWx1ZSBwcm9wZXJ0eSBlcXVhbCBvciBpbkFycmF5IG9mICd2YWx1ZSdcbiAgICAgICAqL1xuICAgICAgIGl0ZW1zQnlWYWx1ZTogZnVuY3Rpb24odmFsdWUsIHNvdXJjZURhdGEsIHZhbHVlUHJvcCkge1xuICAgICAgICAgICBpZighc291cmNlRGF0YSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIFxuICAgICAgICAgICBpZiAodHlwZW9mKHZhbHVlUHJvcCkgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgdmFyIGlkS2V5ID0gdmFsdWVQcm9wIHx8ICd2YWx1ZSc7XG4gICAgICAgICAgICAgICB2YWx1ZVByb3AgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZVtpZEtleV07IH07XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgdmFyIGlzVmFsQXJyYXkgPSAkLmlzQXJyYXkodmFsdWUpLFxuICAgICAgICAgICByZXN1bHQgPSBbXSwgXG4gICAgICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICQuZWFjaChzb3VyY2VEYXRhLCBmdW5jdGlvbihpLCBvKSB7XG4gICAgICAgICAgICAgICBpZihvLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGF0Lml0ZW1zQnlWYWx1ZSh2YWx1ZSwgby5jaGlsZHJlbiwgdmFsdWVQcm9wKSk7XG4gICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGVxZXE6IHRydWUqL1xuICAgICAgICAgICAgICAgICAgIGlmKGlzVmFsQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgaWYoJC5ncmVwKHZhbHVlLCBmdW5jdGlvbih2KXsgIHJldHVybiB2ID09IChvICYmIHR5cGVvZiBvID09PSAnb2JqZWN0JyA/IHZhbHVlUHJvcChvKSA6IG8pOyB9KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG8pOyBcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtVmFsdWUgPSAobyAmJiAodHlwZW9mIG8gPT09ICdvYmplY3QnKSkgPyB2YWx1ZVByb3AobykgOiBvO1xuICAgICAgICAgICAgICAgICAgICAgICBpZih2YWx1ZSA9PSBpdGVtVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG8pOyBcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAvKmpzbGludCBlcWVxOiBmYWxzZSovXG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH0pO1xuICAgICAgICAgICBcbiAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qXG4gICAgICAgUmV0dXJucyBpbnB1dCBieSBvcHRpb25zOiB0eXBlLCBtb2RlLiBcbiAgICAgICAqL1xuICAgICAgIGNyZWF0ZUlucHV0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgIHZhciBUeXBlQ29uc3RydWN0b3IsIHR5cGVPcHRpb25zLCBpbnB1dCxcbiAgICAgICAgICAgdHlwZSA9IG9wdGlvbnMudHlwZTtcblxuICAgICAgICAgICAvL2BkYXRlYCBpcyBzb21lIGtpbmQgb2YgdmlydHVhbCB0eXBlIHRoYXQgaXMgdHJhbnNmb3JtZWQgdG8gb25lIG9mIGV4YWN0IHR5cGVzXG4gICAgICAgICAgIC8vZGVwZW5kaW5nIG9uIG1vZGUgYW5kIGNvcmUgbGliXG4gICAgICAgICAgIGlmKHR5cGUgPT09ICdkYXRlJykge1xuICAgICAgICAgICAgICAgLy9pbmxpbmVcbiAgICAgICAgICAgICAgIGlmKG9wdGlvbnMubW9kZSA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICAgICAgICBpZigkLmZuLmVkaXRhYmxldHlwZXMuZGF0ZWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnZGF0ZWZpZWxkJztcbiAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGV1aWZpZWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSAnZGF0ZXVpZmllbGQnO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIC8vcG9wdXBcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgaWYoJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdkYXRlJztcbiAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGV1aSkge1xuICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2RhdGV1aSc7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAvL2lmIHR5cGUgc3RpbGwgYGRhdGVgIGFuZCBub3QgZXhpc3QgaW4gdHlwZXMsIHJlcGxhY2Ugd2l0aCBgY29tYm9kYXRlYCB0aGF0IGlzIGJhc2UgaW5wdXRcbiAgICAgICAgICAgICAgIGlmKHR5cGUgPT09ICdkYXRlJyAmJiAhJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICB0eXBlID0gJ2NvbWJvZGF0ZSc7XG4gICAgICAgICAgICAgICB9IFxuICAgICAgICAgICB9XG4gICAgICAgICAgIFxuICAgICAgICAgICAvL2BkYXRldGltZWAgc2hvdWxkIGJlIGRhdGV0aW1lZmllbGQgaW4gJ2lubGluZScgbW9kZVxuICAgICAgICAgICBpZih0eXBlID09PSAnZGF0ZXRpbWUnICYmIG9wdGlvbnMubW9kZSA9PT0gJ2lubGluZScpIHtcbiAgICAgICAgICAgICB0eXBlID0gJ2RhdGV0aW1lZmllbGQnOyAgXG4gICAgICAgICAgIH0gICAgICAgICAgIFxuXG4gICAgICAgICAgIC8vY2hhbmdlIHd5c2lodG1sNSB0byB0ZXh0YXJlYSBmb3IganF1ZXJ5IFVJIGFuZCBwbGFpbiB2ZXJzaW9uc1xuICAgICAgICAgICBpZih0eXBlID09PSAnd3lzaWh0bWw1JyAmJiAhJC5mbi5lZGl0YWJsZXR5cGVzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICB0eXBlID0gJ3RleHRhcmVhJztcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vY3JlYXRlIGlucHV0IG9mIHNwZWNpZmllZCB0eXBlLiBJbnB1dCB3aWxsIGJlIHVzZWQgZm9yIGNvbnZlcnRpbmcgdmFsdWUsIG5vdCBpbiBmb3JtXG4gICAgICAgICAgIGlmKHR5cGVvZiAkLmZuLmVkaXRhYmxldHlwZXNbdHlwZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgIFR5cGVDb25zdHJ1Y3RvciA9ICQuZm4uZWRpdGFibGV0eXBlc1t0eXBlXTtcbiAgICAgICAgICAgICAgIHR5cGVPcHRpb25zID0gdGhpcy5zbGljZU9iaihvcHRpb25zLCB0aGlzLm9iamVjdEtleXMoVHlwZUNvbnN0cnVjdG9yLmRlZmF1bHRzKSk7XG4gICAgICAgICAgICAgICBpbnB1dCA9IG5ldyBUeXBlQ29uc3RydWN0b3IodHlwZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgJC5lcnJvcignVW5rbm93biB0eXBlOiAnKyB0eXBlKTtcbiAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgXG4gICAgICAgICAgIH0gIFxuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgLy9zZWUgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MjY0ODk5L2RldGVjdC1jc3MtdHJhbnNpdGlvbnMtdXNpbmctamF2YXNjcmlwdC1hbmQtd2l0aG91dC1tb2Rlcm5penJcbiAgICAgICBzdXBwb3J0c1RyYW5zaXRpb25zOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgIHZhciBiID0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICBzID0gYi5zdHlsZSxcbiAgICAgICAgICAgICAgIHAgPSAndHJhbnNpdGlvbicsXG4gICAgICAgICAgICAgICB2ID0gWydNb3onLCAnV2Via2l0JywgJ0todG1sJywgJ08nLCAnbXMnXTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICBpZih0eXBlb2Ygc1twXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyBcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vIFRlc3RzIGZvciB2ZW5kb3Igc3BlY2lmaWMgcHJvcFxuICAgICAgICAgICBwID0gcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHAuc3Vic3RyKDEpO1xuICAgICAgICAgICBmb3IodmFyIGk9MDsgaTx2Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICBpZih0eXBlb2Ygc1t2W2ldICsgcF0gPT09ICdzdHJpbmcnKSB7IFxuICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOyBcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgfSAgICAgICAgICAgIFxuICAgICAgIFxuICAgIH07ICAgICAgXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5BdHRhY2hlcyBzdGFuZC1hbG9uZSBjb250YWluZXIgd2l0aCBlZGl0YWJsZS1mb3JtIHRvIEhUTUwgZWxlbWVudC4gRWxlbWVudCBpcyB1c2VkIG9ubHkgZm9yIHBvc2l0aW9uaW5nLCB2YWx1ZSBpcyBub3Qgc3RvcmVkIGFueXdoZXJlLjxicj5cblRoaXMgbWV0aG9kIGFwcGxpZWQgaW50ZXJuYWxseSBpbiA8Y29kZT4kKCkuZWRpdGFibGUoKTwvY29kZT4uIFlvdSBzaG91bGQgc3Vic2NyaWJlIG9uIGl0J3MgZXZlbnRzIChzYXZlIC8gY2FuY2VsKSB0byBnZXQgcHJvZml0IG9mIGl0Ljxicj5cbkZpbmFsIHJlYWxpemF0aW9uIGNhbiBiZSBkaWZmZXJlbnQ6IGJvb3RzdHJhcC1wb3BvdmVyLCBqcXVlcnl1aS10b29sdGlwLCBwb3NoeXRpcCwgaW5saW5lLWRpdi4gSXQgZGVwZW5kcyBvbiB3aGljaCBqcyBmaWxlIHlvdSBpbmNsdWRlLjxicj5cbkFwcGxpZWQgYXMgalF1ZXJ5IG1ldGhvZC5cblxuQGNsYXNzIGVkaXRhYmxlQ29udGFpbmVyXG5AdXNlcyBlZGl0YWJsZWZvcm1cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG5cbiAgICB2YXIgUG9wdXAgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgSW5saW5lID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgIH07ICAgIFxuXG4gICAgLy9tZXRob2RzXG4gICAgUG9wdXAucHJvdG90eXBlID0ge1xuICAgICAgICBjb250YWluZXJOYW1lOiBudWxsLCAvL21ldGhvZCB0byBjYWxsIGNvbnRhaW5lciBvbiBlbGVtZW50XG4gICAgICAgIGNvbnRhaW5lckRhdGFOYW1lOiBudWxsLCAvL29iamVjdCBuYW1lIGluIGVsZW1lbnQncyAuZGF0YSgpXG4gICAgICAgIGlubmVyQ3NzOiBudWxsLCAvL3RiZCBpbiBjaGlsZCBjbGFzc1xuICAgICAgICBjb250YWluZXJDbGFzczogJ2VkaXRhYmxlLWNvbnRhaW5lciBlZGl0YWJsZS1wb3B1cCcsIC8vY3NzIGNsYXNzIGFwcGxpZWQgdG8gY29udGFpbmVyIGVsZW1lbnRcbiAgICAgICAgZGVmYXVsdHM6IHt9LCAvL2NvbnRhaW5lciBpdHNlbGYgZGVmYXVsdHNcbiAgICAgICAgXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xuICAgICAgICAgICAgLy9zaW5jZSAxLjQuMSBjb250YWluZXIgZG8gbm90IHVzZSBkYXRhLSogZGlyZWN0bHkgYXMgdGhleSBhbHJlYWR5IG1lcmdlZCBpbnRvIG9wdGlvbnMuXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZUNvbnRhaW5lci5kZWZhdWx0cywgb3B0aW9ucyk7ICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnNwbGl0T3B0aW9ucygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3NldCBzY29wZSBvZiBmb3JtIGNhbGxiYWNrcyB0byBlbGVtZW50XG4gICAgICAgICAgICB0aGlzLmZvcm1PcHRpb25zLnNjb3BlID0gdGhpcy4kZWxlbWVudFswXTsgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuaW5pdENvbnRhaW5lcigpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2ZsYWcgdG8gaGlkZSBjb250YWluZXIsIHdoZW4gc2F2aW5nIHZhbHVlIHdpbGwgZmluaXNoXG4gICAgICAgICAgICB0aGlzLmRlbGF5ZWRIaWRlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIC8vYmluZCAnZGVzdHJveWVkJyBsaXN0ZW5lciB0byBkZXN0cm95IGNvbnRhaW5lciB3aGVuIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIGRvbVxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5vbignZGVzdHJveWVkJywgJC5wcm94eShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgfSwgdGhpcykpOyBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9hdHRhY2ggZG9jdW1lbnQgaGFuZGxlciB0byBjbG9zZSBjb250YWluZXJzIG9uIGNsaWNrIC8gZXNjYXBlXG4gICAgICAgICAgICBpZighJChkb2N1bWVudCkuZGF0YSgnZWRpdGFibGUtaGFuZGxlcnMtYXR0YWNoZWQnKSkge1xuICAgICAgICAgICAgICAgIC8vY2xvc2UgYWxsIG9uIGVzY2FwZVxuICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKCdrZXl1cC5lZGl0YWJsZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAyNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgJCgnLmVkaXRhYmxlLW9wZW4nKS5lZGl0YWJsZUNvbnRhaW5lcignaGlkZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy90b2RvOiByZXR1cm4gZm9jdXMgb24gZWxlbWVudCBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9jbG9zZSBjb250YWluZXJzIHdoZW4gY2xpY2sgb3V0c2lkZSBcbiAgICAgICAgICAgICAgICAvLyhtb3VzZWRvd24gY291bGQgYmUgYmV0dGVyIHRoYW4gY2xpY2ssIGl0IGNsb3NlcyBldmVyeXRoaW5nIGFsc28gb24gZHJhZyBkcm9wKVxuICAgICAgICAgICAgICAgICQoZG9jdW1lbnQpLm9uKCdjbGljay5lZGl0YWJsZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICR0YXJnZXQgPSAkKGUudGFyZ2V0KSwgaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVfY2xhc3NlcyA9IFsnLmVkaXRhYmxlLWNvbnRhaW5lcicsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcudWktZGF0ZXBpY2tlci1oZWFkZXInLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLmRhdGVwaWNrZXInLCAvL2luIGlubGluZSBtb2RlIGRhdGVwaWNrZXIgaXMgcmVuZGVyZWQgaW50byBib2R5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy5tb2RhbC1iYWNrZHJvcCcsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcuYm9vdHN0cmFwLXd5c2lodG1sNS1pbnNlcnQtaW1hZ2UtbW9kYWwnLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLmJvb3RzdHJhcC13eXNpaHRtbDUtaW5zZXJ0LWxpbmstbW9kYWwnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgaWYgZWxlbWVudCBpcyBkZXRhY2hlZC4gSXQgb2NjdXJzIHdoZW4gY2xpY2tpbmcgaW4gYm9vdHN0cmFwIGRhdGVwaWNrZXJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkLmNvbnRhaW5zKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9mb3Igc29tZSByZWFzb24gRkYgMjAgZ2VuZXJhdGVzIGV4dHJhIGV2ZW50IChjbGljaykgaW4gc2VsZWN0MiB3aWRnZXQgd2l0aCBlLnRhcmdldCA9IGRvY3VtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vd2UgbmVlZCB0byBmaWx0ZXIgaXQgdmlhIGNvbnN0cnVjdGlvbiBiZWxvdy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRhbGV0cy94LWVkaXRhYmxlL2lzc3Vlcy8xOTlcbiAgICAgICAgICAgICAgICAgICAgLy9Qb3NzaWJseSByZWxhdGVkIHRvIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTAxMTk3OTMvd2h5LWRvZXMtZmlyZWZveC1yZWFjdC1kaWZmZXJlbnRseS1mcm9tLXdlYmtpdC1hbmQtaWUtdG8tY2xpY2stZXZlbnQtb24tc2VsZWNcbiAgICAgICAgICAgICAgICAgICAgaWYoJHRhcmdldC5pcyhkb2N1bWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9pZiBjbGljayBpbnNpZGUgb25lIG9mIGV4Y2x1ZGUgY2xhc3NlcyAtLT4gbm8gbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICBmb3IoaT0wOyBpPGV4Y2x1ZGVfY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCR0YXJnZXQuaXMoZXhjbHVkZV9jbGFzc2VzW2ldKSB8fCAkdGFyZ2V0LnBhcmVudHMoZXhjbHVkZV9jbGFzc2VzW2ldKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL2Nsb3NlIGFsbCBvcGVuIGNvbnRhaW5lcnMgKGV4Y2VwdCBvbmUgLSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgICAgIFBvcHVwLnByb3RvdHlwZS5jbG9zZU90aGVycyhlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgJChkb2N1bWVudCkuZGF0YSgnZWRpdGFibGUtaGFuZGxlcnMtYXR0YWNoZWQnLCB0cnVlKTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfSxcblxuICAgICAgICAvL3NwbGl0IG9wdGlvbnMgb24gY29udGFpbmVyT3B0aW9ucyBhbmQgZm9ybU9wdGlvbnNcbiAgICAgICAgc3BsaXRPcHRpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5mb3JtT3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZighJC5mblt0aGlzLmNvbnRhaW5lck5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRoaXMuY29udGFpbmVyTmFtZSArICcgbm90IGZvdW5kLiBIYXZlIHlvdSBpbmNsdWRlZCBjb3JyZXNwb25kaW5nIGpzIGZpbGU/Jyk7ICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8va2V5cyBkZWZpbmVkIGluIGNvbnRhaW5lciBkZWZhdWx0cyBnbyB0byBjb250YWluZXIsIG90aGVycyBnbyB0byBmb3JtXG4gICAgICAgICAgICBmb3IodmFyIGsgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICAgIGlmKGsgaW4gdGhpcy5kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lck9wdGlvbnNba10gPSB0aGlzLm9wdGlvbnNba107XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgIHRoaXMuZm9ybU9wdGlvbnNba10gPSB0aGlzLm9wdGlvbnNba107XG4gICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBSZXR1cm5zIGpxdWVyeSBvYmplY3Qgb2YgY29udGFpbmVyXG4gICAgICAgIEBtZXRob2QgdGlwKClcbiAgICAgICAgKi8gICAgICAgICBcbiAgICAgICAgdGlwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcigpID8gdGhpcy5jb250YWluZXIoKS4kdGlwIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKiByZXR1cm5zIGNvbnRhaW5lciBvYmplY3QgKi9cbiAgICAgICAgY29udGFpbmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXI7XG4gICAgICAgICAgICAvL2ZpcnN0LCB0cnkgZ2V0IGl0IGJ5IGBjb250YWluZXJEYXRhTmFtZWBcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbmVyRGF0YU5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZihjb250YWluZXIgPSB0aGlzLiRlbGVtZW50LmRhdGEodGhpcy5jb250YWluZXJEYXRhTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3NlY29uZCwgdHJ5IGBjb250YWluZXJOYW1lYFxuICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy4kZWxlbWVudC5kYXRhKHRoaXMuY29udGFpbmVyTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qIGNhbGwgbmF0aXZlIG1ldGhvZCBvZiB1bmRlcmx5aW5nIGNvbnRhaW5lciwgZS5nLiB0aGlzLiRlbGVtZW50LnBvcG92ZXIoJ21ldGhvZCcpICovIFxuICAgICAgICBjYWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnRbdGhpcy5jb250YWluZXJOYW1lXS5hcHBseSh0aGlzLiRlbGVtZW50LCBhcmd1bWVudHMpOyBcbiAgICAgICAgfSwgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaW5pdENvbnRhaW5lcjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuY2FsbCh0aGlzLmNvbnRhaW5lck9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlckZvcm06IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kZm9ybVxuICAgICAgICAgICAgLmVkaXRhYmxlZm9ybSh0aGlzLmZvcm1PcHRpb25zKVxuICAgICAgICAgICAgLm9uKHtcbiAgICAgICAgICAgICAgICBzYXZlOiAkLnByb3h5KHRoaXMuc2F2ZSwgdGhpcyksIC8vY2xpY2sgb24gc3VibWl0IGJ1dHRvbiAodmFsdWUgY2hhbmdlZClcbiAgICAgICAgICAgICAgICBub2NoYW5nZTogJC5wcm94eShmdW5jdGlvbigpeyB0aGlzLmhpZGUoJ25vY2hhbmdlJyk7IH0sIHRoaXMpLCAvL2NsaWNrIG9uIHN1Ym1pdCBidXR0b24gKHZhbHVlIE5PVCBjaGFuZ2VkKSAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjYW5jZWw6ICQucHJveHkoZnVuY3Rpb24oKXsgdGhpcy5oaWRlKCdjYW5jZWwnKTsgfSwgdGhpcyksIC8vY2xpY2sgb24gY2FsY2VsIGJ1dHRvblxuICAgICAgICAgICAgICAgIHNob3c6ICQucHJveHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZGVsYXllZEhpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZSh0aGlzLmRlbGF5ZWRIaWRlLnJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGF5ZWRIaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKSwgLy9yZS1wb3NpdGlvbiBjb250YWluZXIgZXZlcnkgdGltZSBmb3JtIGlzIHNob3duIChvY2N1cnMgZWFjaCB0aW1lIGFmdGVyIGxvYWRpbmcgc3RhdGUpXG4gICAgICAgICAgICAgICAgcmVuZGVyaW5nOiAkLnByb3h5KHRoaXMuc2V0UG9zaXRpb24sIHRoaXMpLCAvL3RoaXMgYWxsb3dzIHRvIHBsYWNlIGNvbnRhaW5lciBjb3JyZWN0bHkgd2hlbiBsb2FkaW5nIHNob3duXG4gICAgICAgICAgICAgICAgcmVzaXplOiAkLnByb3h5KHRoaXMuc2V0UG9zaXRpb24sIHRoaXMpLCAvL3RoaXMgYWxsb3dzIHRvIHJlLXBvc2l0aW9uIGNvbnRhaW5lciB3aGVuIGZvcm0gc2l6ZSBpcyBjaGFuZ2VkIFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiAkLnByb3h5KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIEZpcmVkIHdoZW4gY29udGFpbmVyIGlzIHNob3duIGFuZCBmb3JtIGlzIHJlbmRlcmVkIChmb3Igc2VsZWN0IHdpbGwgd2FpdCBmb3IgbG9hZGluZyBkcm9wZG93biBvcHRpb25zKS4gIFxuICAgICAgICAgICAgICAgICAgICAqKk5vdGU6KiogQm9vdHN0cmFwIHBvcG92ZXIgaGFzIG93biBgc2hvd25gIGV2ZW50IHRoYXQgbm93IGNhbm5vdCBiZSBzZXBhcmF0ZWQgZnJvbSB4LWVkaXRhYmxlJ3Mgb25lLlxuICAgICAgICAgICAgICAgICAgICBUaGUgd29ya2Fyb3VuZCBpcyB0byBjaGVjayBgYXJndW1lbnRzLmxlbmd0aGAgdGhhdCBpcyBhbHdheXMgYDJgIGZvciB4LWVkaXRhYmxlLiAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgQGV2ZW50IHNob3duIFxuICAgICAgICAgICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICQoJyN1c2VybmFtZScpLm9uKCdzaG93bicsIGZ1bmN0aW9uKGUsIGVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5pbnB1dC4kaW5wdXQudmFsKCdvdmVyd3JpdGluZyB2YWx1ZSBvZiBpbnB1dC4uJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pOyAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAqKi8gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICBUT0RPOiBhZGRlZCBzZWNvbmQgcGFyYW0gbWFpbmx5IHRvIGRpc3Rpbmd1aXNoIGZyb20gYm9vdHN0cmFwJ3Mgc2hvd24gZXZlbnQuIEl0J3MgYSBob3RmaXggdGhhdCB3aWxsIGJlIHNvbHZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgdmlhIG5hbWVzcGFjZWQgZXZlbnRzLiAgXG4gICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlckhhbmRsZXIoJ3Nob3duJywgJCh0aGlzLm9wdGlvbnMuc2NvcGUpLmRhdGEoJ2VkaXRhYmxlJykpOyBcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuZWRpdGFibGVmb3JtKCdyZW5kZXInKTtcbiAgICAgICAgfSwgICAgICAgIFxuXG4gICAgICAgIC8qKlxuICAgICAgICBTaG93cyBjb250YWluZXIgd2l0aCBmb3JtXG4gICAgICAgIEBtZXRob2Qgc2hvdygpXG4gICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gY2xvc2VBbGwgV2hldGhlciB0byBjbG9zZSBhbGwgb3RoZXIgZWRpdGFibGUgY29udGFpbmVycyB3aGVuIHNob3dpbmcgdGhpcyBvbmUuIERlZmF1bHQgdHJ1ZS5cbiAgICAgICAgKiovXG4gICAgICAgIC8qIE5vdGU6IHBvc2h5dGlwIG93ZXJ3cml0ZXMgdGhpcyBtZXRob2QgdG90YWxseSEgKi8gICAgICAgICAgXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uIChjbG9zZUFsbCkge1xuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZWRpdGFibGUtb3BlbicpO1xuICAgICAgICAgICAgaWYoY2xvc2VBbGwgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy9jbG9zZSBhbGwgb3BlbiBjb250YWluZXJzIChleGNlcHQgdGhpcylcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlT3RoZXJzKHRoaXMuJGVsZW1lbnRbMF0pOyAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vc2hvdyBjb250YWluZXIgaXRzZWxmXG4gICAgICAgICAgICB0aGlzLmlubmVyU2hvdygpO1xuICAgICAgICAgICAgdGhpcy50aXAoKS5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lckNsYXNzKTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIEN1cnJlbnRseSwgZm9ybSBpcyByZS1yZW5kZXJlZCBvbiBldmVyeSBzaG93LiBcbiAgICAgICAgICAgIFRoZSBtYWluIHJlYXNvbiBpcyB0aGF0IHdlIGRvbnQga25vdywgd2hhdCB3aWxsIGNvbnRhaW5lciBkbyB3aXRoIGNvbnRlbnQgd2hlbiBjbG9zZWQ6XG4gICAgICAgICAgICByZW1vdmUoKSwgZGV0YWNoKCkgb3IganVzdCBoaWRlKCkgLSBpdCBkZXBlbmRzIG9uIGNvbnRhaW5lci5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgRGV0YWNoaW5nIGZvcm0gaXRzZWxmIGJlZm9yZSBoaWRlIGFuZCByZS1pbnNlcnQgYmVmb3JlIHNob3cgaXMgZ29vZCBzb2x1dGlvbiwgXG4gICAgICAgICAgICBidXQgdmlzdWFsbHkgaXQgbG9va3MgdWdseSAtLT4gY29udGFpbmVyIGNoYW5nZXMgc2l6ZSBiZWZvcmUgaGlkZS4gIFxuICAgICAgICAgICAgKi8gICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaWYgZm9ybSBhbHJlYWR5IGV4aXN0IC0gZGVsZXRlIHByZXZpb3VzIGRhdGEgXG4gICAgICAgICAgICBpZih0aGlzLiRmb3JtKSB7XG4gICAgICAgICAgICAgICAgLy90b2RvOiBkZXN0cm95IHByZXYgZGF0YSFcbiAgICAgICAgICAgICAgICAvL3RoaXMuJGZvcm0uZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRmb3JtID0gJCgnPGRpdj4nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pbnNlcnQgZm9ybSBpbnRvIGNvbnRhaW5lciBib2R5XG4gICAgICAgICAgICBpZih0aGlzLnRpcCgpLmlzKHRoaXMuaW5uZXJDc3MpKSB7XG4gICAgICAgICAgICAgICAgLy9mb3IgaW5saW5lIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgIHRoaXMudGlwKCkuYXBwZW5kKHRoaXMuJGZvcm0pOyBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aXAoKS5maW5kKHRoaXMuaW5uZXJDc3MpLmFwcGVuZCh0aGlzLiRmb3JtKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vcmVuZGVyIGZvcm1cbiAgICAgICAgICAgIHRoaXMucmVuZGVyRm9ybSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICBIaWRlcyBjb250YWluZXIgd2l0aCBmb3JtXG4gICAgICAgIEBtZXRob2QgaGlkZSgpXG4gICAgICAgIEBwYXJhbSB7c3RyaW5nfSByZWFzb24gUmVhc29uIGNhdXNlZCBoaWRpbmcuIENhbiBiZSA8Y29kZT5zYXZlfGNhbmNlbHxvbmJsdXJ8bm9jaGFuZ2V8dW5kZWZpbmVkICg9bWFudWFsKTwvY29kZT5cbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uKHJlYXNvbikgeyAgXG4gICAgICAgICAgICBpZighdGhpcy50aXAoKSB8fCAhdGhpcy50aXAoKS5pcygnOnZpc2libGUnKSB8fCAhdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZWRpdGFibGUtb3BlbicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2lmIGZvcm0gaXMgc2F2aW5nIHZhbHVlLCBzY2hlZHVsZSBoaWRlXG4gICAgICAgICAgICBpZih0aGlzLiRmb3JtLmRhdGEoJ2VkaXRhYmxlZm9ybScpLmlzU2F2aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheWVkSGlkZSA9IHtyZWFzb246IHJlYXNvbn07XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAgICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheWVkSGlkZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdlZGl0YWJsZS1vcGVuJyk7ICAgXG4gICAgICAgICAgICB0aGlzLmlubmVySGlkZSgpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgIEZpcmVkIHdoZW4gY29udGFpbmVyIHdhcyBoaWRkZW4uIEl0IG9jY3VycyBvbiBib3RoIHNhdmUgb3IgY2FuY2VsLiAgXG4gICAgICAgICAgICAqKk5vdGU6KiogQm9vdHN0cmFwIHBvcG92ZXIgaGFzIG93biBgaGlkZGVuYCBldmVudCB0aGF0IG5vdyBjYW5ub3QgYmUgc2VwYXJhdGVkIGZyb20geC1lZGl0YWJsZSdzIG9uZS5cbiAgICAgICAgICAgIFRoZSB3b3JrYXJvdW5kIGlzIHRvIGNoZWNrIGBhcmd1bWVudHMubGVuZ3RoYCB0aGF0IGlzIGFsd2F5cyBgMmAgZm9yIHgtZWRpdGFibGUuIFxuXG4gICAgICAgICAgICBAZXZlbnQgaGlkZGVuIFxuICAgICAgICAgICAgQHBhcmFtIHtvYmplY3R9IGV2ZW50IGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHJlYXNvbiBSZWFzb24gY2F1c2VkIGhpZGluZy4gQ2FuIGJlIDxjb2RlPnNhdmV8Y2FuY2VsfG9uYmx1cnxub2NoYW5nZXxtYW51YWw8L2NvZGU+XG4gICAgICAgICAgICBAZXhhbXBsZVxuICAgICAgICAgICAgJCgnI3VzZXJuYW1lJykub24oJ2hpZGRlbicsIGZ1bmN0aW9uKGUsIHJlYXNvbikge1xuICAgICAgICAgICAgICAgIGlmKHJlYXNvbiA9PT0gJ3NhdmUnIHx8IHJlYXNvbiA9PT0gJ2NhbmNlbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9hdXRvLW9wZW4gbmV4dCBlZGl0YWJsZVxuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ3RyJykubmV4dCgpLmZpbmQoJy5lZGl0YWJsZScpLmVkaXRhYmxlKCdzaG93Jyk7XG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKiovXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXJIYW5kbGVyKCdoaWRkZW4nLCByZWFzb24gfHwgJ21hbnVhbCcpOyAgIFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qIGludGVybmFsIHNob3cgbWV0aG9kLiBUbyBiZSBvdmVyd3JpdHRlbiBpbiBjaGlsZCBjbGFzc2VzICovXG4gICAgICAgIGlubmVyU2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgIFxuICAgICAgICB9LCAgICAgICAgXG5cbiAgICAgICAgLyogaW50ZXJuYWwgaGlkZSBtZXRob2QuIFRvIGJlIG92ZXJ3cml0dGVuIGluIGNoaWxkIGNsYXNzZXMgKi9cbiAgICAgICAgaW5uZXJIaWRlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBUb2dnbGVzIGNvbnRhaW5lciB2aXNpYmlsaXR5IChzaG93IC8gaGlkZSlcbiAgICAgICAgQG1ldGhvZCB0b2dnbGUoKVxuICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IGNsb3NlQWxsIFdoZXRoZXIgdG8gY2xvc2UgYWxsIG90aGVyIGVkaXRhYmxlIGNvbnRhaW5lcnMgd2hlbiBzaG93aW5nIHRoaXMgb25lLiBEZWZhdWx0IHRydWUuXG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbihjbG9zZUFsbCkge1xuICAgICAgICAgICAgaWYodGhpcy5jb250YWluZXIoKSAmJiB0aGlzLnRpcCgpICYmIHRoaXMudGlwKCkuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93KGNsb3NlQWxsKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgY29udGFpbmVyIHdoZW4gY29udGVudCBjaGFuZ2VkLlxuICAgICAgICBAbWV0aG9kIHNldFBvc2l0aW9uKClcbiAgICAgICAgKi8gICAgICAgXG4gICAgICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vdGJkIGluIGNoaWxkIGNsYXNzXG4gICAgICAgIH0sXG5cbiAgICAgICAgc2F2ZTogZnVuY3Rpb24oZSwgcGFyYW1zKSB7XG4gICAgICAgICAgICAvKiogICAgICAgIFxuICAgICAgICAgICAgRmlyZWQgd2hlbiBuZXcgdmFsdWUgd2FzIHN1Ym1pdHRlZC4gWW91IGNhbiB1c2UgPGNvZGU+JCh0aGlzKS5kYXRhKCdlZGl0YWJsZUNvbnRhaW5lcicpPC9jb2RlPiBpbnNpZGUgaGFuZGxlciB0byBhY2Nlc3MgdG8gZWRpdGFibGVDb250YWluZXIgaW5zdGFuY2VcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgQGV2ZW50IHNhdmUgXG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gZXZlbnQgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gcGFyYW1zIGFkZGl0aW9uYWwgcGFyYW1zXG4gICAgICAgICAgICBAcGFyYW0ge21peGVkfSBwYXJhbXMubmV3VmFsdWUgc3VibWl0dGVkIHZhbHVlXG4gICAgICAgICAgICBAcGFyYW0ge09iamVjdH0gcGFyYW1zLnJlc3BvbnNlIGFqYXggcmVzcG9uc2VcbiAgICAgICAgICAgIEBleGFtcGxlXG4gICAgICAgICAgICAkKCcjdXNlcm5hbWUnKS5vbignc2F2ZScsIGZ1bmN0aW9uKGUsIHBhcmFtcykge1xuICAgICAgICAgICAgICAgIC8vYXNzdW1pbmcgc2VydmVyIHJlc3BvbnNlOiAne3N1Y2Nlc3M6IHRydWV9J1xuICAgICAgICAgICAgICAgIHZhciBwayA9ICQodGhpcykuZGF0YSgnZWRpdGFibGVDb250YWluZXInKS5vcHRpb25zLnBrO1xuICAgICAgICAgICAgICAgIGlmKHBhcmFtcy5yZXNwb25zZSAmJiBwYXJhbXMucmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICBhbGVydCgndmFsdWU6ICcgKyBwYXJhbXMubmV3VmFsdWUgKyAnIHdpdGggcGs6ICcgKyBwayArICcgc2F2ZWQhJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ2Vycm9yIScpOyBcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAqKi8gICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXJIYW5kbGVyKCdzYXZlJywgcGFyYW1zKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9oaWRlIG11c3QgYmUgYWZ0ZXIgdHJpZ2dlciwgYXMgc2F2aW5nIHZhbHVlIG1heSByZXF1aXJlIG1ldGhvZHMgb2YgcGx1Z2luLCBhcHBsaWVkIHRvIGlucHV0XG4gICAgICAgICAgICB0aGlzLmhpZGUoJ3NhdmUnKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgU2V0cyBuZXcgb3B0aW9uXG4gICAgICAgIFxuICAgICAgICBAbWV0aG9kIG9wdGlvbihrZXksIHZhbHVlKVxuICAgICAgICBAcGFyYW0ge3N0cmluZ30ga2V5IFxuICAgICAgICBAcGFyYW0ge21peGVkfSB2YWx1ZSBcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIG9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmKGtleSBpbiB0aGlzLmNvbnRhaW5lck9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lck9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29udGFpbmVyT3B0aW9uKGtleSwgdmFsdWUpOyBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JtT3B0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYodGhpcy4kZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRmb3JtLmVkaXRhYmxlZm9ybSgnb3B0aW9uJywga2V5LCB2YWx1ZSk7ICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBzZXRDb250YWluZXJPcHRpb246IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbCgnb3B0aW9uJywga2V5LCB2YWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgIERlc3Ryb3lzIHRoZSBjb250YWluZXIgaW5zdGFuY2VcbiAgICAgICAgQG1ldGhvZCBkZXN0cm95KClcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignZGVzdHJveWVkJyk7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZURhdGEoJ2VkaXRhYmxlQ29udGFpbmVyJyk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKiB0byBiZSBvdmVyd3JpdHRlbiBpbiBjaGlsZCBjbGFzc2VzICovXG4gICAgICAgIGlubmVyRGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgfSwgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBDbG9zZXMgb3RoZXIgY29udGFpbmVycyBleGNlcHQgb25lIHJlbGF0ZWQgdG8gcGFzc2VkIGVsZW1lbnQuIFxuICAgICAgICBPdGhlciBjb250YWluZXJzIGNhbiBiZSBjYW5jZWxsZWQgb3Igc3VibWl0dGVkIChkZXBlbmRzIG9uIG9uYmx1ciBvcHRpb24pXG4gICAgICAgICovXG4gICAgICAgIGNsb3NlT3RoZXJzOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAkKCcuZWRpdGFibGUtb3BlbicpLmVhY2goZnVuY3Rpb24oaSwgZWwpe1xuICAgICAgICAgICAgICAgIC8vZG8gbm90aGluZyB3aXRoIHBhc3NlZCBlbGVtZW50IGFuZCBpdCdzIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgaWYoZWwgPT09IGVsZW1lbnQgfHwgJChlbCkuZmluZChlbGVtZW50KS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGNhbmNlbCBvciBzdWJtaXQgYWxsIG9wZW4gY29udGFpbmVycyBcbiAgICAgICAgICAgICAgICB2YXIgJGVsID0gJChlbCksXG4gICAgICAgICAgICAgICAgZWMgPSAkZWwuZGF0YSgnZWRpdGFibGVDb250YWluZXInKTtcblxuICAgICAgICAgICAgICAgIGlmKCFlYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47ICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoZWMub3B0aW9ucy5vbmJsdXIgPT09ICdjYW5jZWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICRlbC5kYXRhKCdlZGl0YWJsZUNvbnRhaW5lcicpLmhpZGUoJ29uYmx1cicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZihlYy5vcHRpb25zLm9uYmx1ciA9PT0gJ3N1Ym1pdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgJGVsLmRhdGEoJ2VkaXRhYmxlQ29udGFpbmVyJykudGlwKCkuZmluZCgnZm9ybScpLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgQWN0aXZhdGVzIGlucHV0IG9mIHZpc2libGUgY29udGFpbmVyIChlLmcuIHNldCBmb2N1cylcbiAgICAgICAgQG1ldGhvZCBhY3RpdmF0ZSgpXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLnRpcCAmJiB0aGlzLnRpcCgpLmlzKCc6dmlzaWJsZScpICYmIHRoaXMuJGZvcm0pIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGZvcm0uZGF0YSgnZWRpdGFibGVmb3JtJykuaW5wdXQuYWN0aXZhdGUoKTsgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgalF1ZXJ5IG1ldGhvZCB0byBpbml0aWFsaXplIGVkaXRhYmxlQ29udGFpbmVyLlxuICAgIFxuICAgIEBtZXRob2QgJCgpLmVkaXRhYmxlQ29udGFpbmVyKG9wdGlvbnMpXG4gICAgQHBhcmFtcyB7T2JqZWN0fSBvcHRpb25zXG4gICAgQGV4YW1wbGVcbiAgICAkKCcjZWRpdCcpLmVkaXRhYmxlQ29udGFpbmVyKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgIHBrOiAxLFxuICAgICAgICB2YWx1ZTogJ2hlbGxvJ1xuICAgIH0pO1xuICAgICoqLyAgXG4gICAgJC5mbi5lZGl0YWJsZUNvbnRhaW5lciA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcbiAgICAgICAgICAgIGRhdGFLZXkgPSAnZWRpdGFibGVDb250YWluZXInLCBcbiAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKGRhdGFLZXkpLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT09ICdvYmplY3QnICYmIG9wdGlvbixcbiAgICAgICAgICAgIENvbnN0cnVjdG9yID0gKG9wdGlvbnMubW9kZSA9PT0gJ2lubGluZScpID8gSW5saW5lIDogUG9wdXA7ICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKGRhdGFLZXksIChkYXRhID0gbmV3IENvbnN0cnVjdG9yKHRoaXMsIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJykgeyAvL2NhbGwgbWV0aG9kIFxuICAgICAgICAgICAgICAgIGRhdGFbb3B0aW9uXS5hcHBseShkYXRhLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG4gICAgICAgIH0pO1xuICAgIH07ICAgICBcblxuICAgIC8vc3RvcmUgY29uc3RydWN0b3JzXG4gICAgJC5mbi5lZGl0YWJsZUNvbnRhaW5lci5Qb3B1cCA9IFBvcHVwO1xuICAgICQuZm4uZWRpdGFibGVDb250YWluZXIuSW5saW5lID0gSW5saW5lO1xuXG4gICAgLy9kZWZhdWx0c1xuICAgICQuZm4uZWRpdGFibGVDb250YWluZXIuZGVmYXVsdHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICBJbml0aWFsIHZhbHVlIG9mIGZvcm0gaW5wdXRcblxuICAgICAgICBAcHJvcGVydHkgdmFsdWUgXG4gICAgICAgIEB0eXBlIG1peGVkXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgQHByaXZhdGVcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBQbGFjZW1lbnQgb2YgY29udGFpbmVyIHJlbGF0aXZlIHRvIGVsZW1lbnQuIENhbiBiZSA8Y29kZT50b3B8cmlnaHR8Ym90dG9tfGxlZnQ8L2NvZGU+LiBOb3QgdXNlZCBmb3IgaW5saW5lIGNvbnRhaW5lci5cblxuICAgICAgICBAcHJvcGVydHkgcGxhY2VtZW50IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJ3RvcCdcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgcGxhY2VtZW50OiAndG9wJyxcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZXRoZXIgdG8gaGlkZSBjb250YWluZXIgb24gc2F2ZS9jYW5jZWwuXG5cbiAgICAgICAgQHByb3BlcnR5IGF1dG9oaWRlIFxuICAgICAgICBAdHlwZSBib29sZWFuXG4gICAgICAgIEBkZWZhdWx0IHRydWVcbiAgICAgICAgQHByaXZhdGUgXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIGF1dG9oaWRlOiB0cnVlLFxuICAgICAgICAvKipcbiAgICAgICAgQWN0aW9uIHdoZW4gdXNlciBjbGlja3Mgb3V0c2lkZSB0aGUgY29udGFpbmVyLiBDYW4gYmUgPGNvZGU+Y2FuY2VsfHN1Ym1pdHxpZ25vcmU8L2NvZGU+LiAgXG4gICAgICAgIFNldHRpbmcgPGNvZGU+aWdub3JlPC9jb2RlPiBhbGxvd3MgdG8gaGF2ZSBzZXZlcmFsIGNvbnRhaW5lcnMgb3Blbi4gXG5cbiAgICAgICAgQHByb3BlcnR5IG9uYmx1ciBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICdjYW5jZWwnXG4gICAgICAgIEBzaW5jZSAxLjEuMVxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBvbmJsdXI6ICdjYW5jZWwnLFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIEFuaW1hdGlvbiBzcGVlZCAoaW5saW5lIG1vZGUgb25seSlcbiAgICAgICAgQHByb3BlcnR5IGFuaW0gXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBhbmltOiBmYWxzZSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBNb2RlIG9mIGVkaXRhYmxlLCBjYW4gYmUgYHBvcHVwYCBvciBgaW5saW5lYCBcbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBtb2RlIFxuICAgICAgICBAdHlwZSBzdHJpbmcgICAgICAgICBcbiAgICAgICAgQGRlZmF1bHQgJ3BvcHVwJ1xuICAgICAgICBAc2luY2UgMS40LjAgICAgICAgIFxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBtb2RlOiAncG9wdXAnICAgICAgICBcbiAgICB9O1xuXG4gICAgLyogXG4gICAgKiB3b3JrYXJvdW5kIHRvIGhhdmUgJ2Rlc3Ryb3llZCcgZXZlbnQgdG8gZGVzdHJveSBwb3BvdmVyIHdoZW4gZWxlbWVudCBpcyBkZXN0cm95ZWRcbiAgICAqIHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIyMDA0OTQvanF1ZXJ5LXRyaWdnZXItZXZlbnQtd2hlbi1hbi1lbGVtZW50LWlzLXJlbW92ZWQtZnJvbS10aGUtZG9tXG4gICAgKi9cbiAgICBqUXVlcnkuZXZlbnQuc3BlY2lhbC5kZXN0cm95ZWQgPSB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24obykge1xuICAgICAgICAgICAgaWYgKG8uaGFuZGxlcikge1xuICAgICAgICAgICAgICAgIG8uaGFuZGxlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTsgICAgXG5cbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcbiogRWRpdGFibGUgSW5saW5lIFxuKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiovXG4oZnVuY3Rpb24gKCQpIHtcblxuICAgIC8vY29weSBwcm90b3R5cGUgZnJvbSBFZGl0YWJsZUNvbnRhaW5lclxuICAgIC8vZXh0ZW5kIG1ldGhvZHNcbiAgICAkLmV4dGVuZCgkLmZuLmVkaXRhYmxlQ29udGFpbmVyLklubGluZS5wcm90b3R5cGUsICQuZm4uZWRpdGFibGVDb250YWluZXIuUG9wdXAucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnRhaW5lck5hbWU6ICdlZGl0YWJsZWZvcm0nLFxuICAgICAgICBpbm5lckNzczogJy5lZGl0YWJsZS1pbmxpbmUnLFxuICAgICAgICBjb250YWluZXJDbGFzczogJ2VkaXRhYmxlLWNvbnRhaW5lciBlZGl0YWJsZS1pbmxpbmUnLCAvL2NzcyBjbGFzcyBhcHBsaWVkIHRvIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICAgICAgICAgICAgIFxuICAgICAgICBpbml0Q29udGFpbmVyOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy9jb250YWluZXIgaXMgPHNwYW4+IGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuJHRpcCA9ICQoJzxzcGFuPjwvc3Bhbj4nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9jb252ZXJ0IGFuaW0gdG8gbWlsaXNlY29uZHMgKGludClcbiAgICAgICAgICAgIGlmKCF0aGlzLm9wdGlvbnMuYW5pbSkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hbmltID0gMDtcbiAgICAgICAgICAgIH0gICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHNwbGl0T3B0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvL2FsbCBvcHRpb25zIGFyZSBwYXNzZWQgdG8gZm9ybVxuICAgICAgICAgICAgdGhpcy5jb250YWluZXJPcHRpb25zID0ge307XG4gICAgICAgICAgICB0aGlzLmZvcm1PcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgdGlwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuJHRpcDsgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBpbm5lclNob3c6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpO1xuICAgICAgICAgICAgdGhpcy50aXAoKS5pbnNlcnRBZnRlcih0aGlzLiRlbGVtZW50KS5zaG93KCk7XG4gICAgICAgIH0sIFxuICAgICAgICBcbiAgICAgICAgaW5uZXJIaWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLiR0aXAuaGlkZSh0aGlzLm9wdGlvbnMuYW5pbSwgJC5wcm94eShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnNob3coKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlubmVyRGVzdHJveSgpO1xuICAgICAgICAgICAgfSwgdGhpcykpOyBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGlubmVyRGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLnRpcCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aXAoKS5lbXB0eSgpLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IFxuICAgIH0pO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcbi8qKlxuTWFrZXMgZWRpdGFibGUgYW55IEhUTUwgZWxlbWVudCBvbiB0aGUgcGFnZS4gQXBwbGllZCBhcyBqUXVlcnkgbWV0aG9kLlxuXG5AY2xhc3MgZWRpdGFibGVcbkB1c2VzIGVkaXRhYmxlQ29udGFpbmVyXG4qKi9cbihmdW5jdGlvbiAoJCkge1xuXG4gICAgdmFyIEVkaXRhYmxlID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICAgIC8vZGF0YS0qIGhhcyBtb3JlIHByaW9yaXR5IG92ZXIganMgb3B0aW9uczogYmVjYXVzZSBkeW5hbWljYWxseSBjcmVhdGVkIGVsZW1lbnRzIG1heSBjaGFuZ2UgZGF0YS0qIFxuICAgICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZS5kZWZhdWx0cywgb3B0aW9ucywgJC5mbi5lZGl0YWJsZXV0aWxzLmdldENvbmZpZ0RhdGEodGhpcy4kZWxlbWVudCkpOyAgXG4gICAgICAgIGlmKHRoaXMub3B0aW9ucy5zZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5pbml0TGl2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vY2hlY2sgZm9yIHRyYW5zaXRpb24gc3VwcG9ydFxuICAgICAgICBpZih0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ICYmICEkLmZuLmVkaXRhYmxldXRpbHMuc3VwcG9ydHNUcmFuc2l0aW9ucygpKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgRWRpdGFibGUucHJvdG90eXBlID0ge1xuICAgICAgICBjb25zdHJ1Y3RvcjogRWRpdGFibGUsIFxuICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXNWYWx1ZUJ5VGV4dCA9IGZhbHNlLCBcbiAgICAgICAgICAgICAgICBkb0F1dG90ZXh0LCBmaW5hbGl6ZTtcblxuICAgICAgICAgICAgLy9uYW1lXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMubmFtZSA9IHRoaXMub3B0aW9ucy5uYW1lIHx8IHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKTtcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vY3JlYXRlIGlucHV0IG9mIHNwZWNpZmllZCB0eXBlLiBJbnB1dCBuZWVkZWQgYWxyZWFkeSBoZXJlIHRvIGNvbnZlcnQgdmFsdWUgZm9yIGluaXRpYWwgZGlzcGxheSAoZS5nLiBzaG93IHRleHQgYnkgaWQgZm9yIHNlbGVjdClcbiAgICAgICAgICAgIC8vYWxzbyB3ZSBzZXQgc2NvcGUgb3B0aW9uIHRvIGhhdmUgYWNjZXNzIHRvIGVsZW1lbnQgaW5zaWRlIGlucHV0IHNwZWNpZmljIGNhbGxiYWNrcyAoZS4gZy4gc291cmNlIGFzIGZ1bmN0aW9uKVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnNjb3BlID0gdGhpcy4kZWxlbWVudFswXTsgXG4gICAgICAgICAgICB0aGlzLmlucHV0ID0gJC5mbi5lZGl0YWJsZXV0aWxzLmNyZWF0ZUlucHV0KHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICBpZighdGhpcy5pbnB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgXG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIC8vc2V0IHZhbHVlIGZyb20gc2V0dGluZ3Mgb3IgYnkgZWxlbWVudCdzIHRleHRcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLm9wdGlvbnMudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5pbnB1dC5odG1sMnZhbHVlKCQudHJpbSh0aGlzLiRlbGVtZW50Lmh0bWwoKSkpO1xuICAgICAgICAgICAgICAgIGlzVmFsdWVCeVRleHQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgdmFsdWUgY2FuIGJlIHN0cmluZyB3aGVuIHJlY2VpdmVkIGZyb20gJ2RhdGEtdmFsdWUnIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgZm9yIGNvbXBsZXh0IG9iamVjdHMgdmFsdWUgY2FuIGJlIHNldCBhcyBqc29uIHN0cmluZyBpbiBkYXRhLXZhbHVlIGF0dHJpYnV0ZSwgXG4gICAgICAgICAgICAgICAgICBlLmcuIGRhdGEtdmFsdWU9XCJ7Y2l0eTogJ01vc2NvdycsIHN0cmVldDogJ0xlbmluYSd9XCJcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy52YWx1ZSA9ICQuZm4uZWRpdGFibGV1dGlscy50cnlQYXJzZUpzb24odGhpcy5vcHRpb25zLnZhbHVlLCB0cnVlKTsgXG4gICAgICAgICAgICAgICAgaWYodHlwZW9mIHRoaXMub3B0aW9ucy52YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuaW5wdXQuc3RyMnZhbHVlKHRoaXMub3B0aW9ucy52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMub3B0aW9ucy52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vYWRkICdlZGl0YWJsZScgY2xhc3MgdG8gZXZlcnkgZWRpdGFibGUgZWxlbWVudFxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZWRpdGFibGUnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9zcGVjaWZpY2FsbHkgZm9yIFwidGV4dGFyZWFcIiBhZGQgY2xhc3MgLmVkaXRhYmxlLXByZS13cmFwcGVkIHRvIGtlZXAgbGluZWJyZWFrc1xuICAgICAgICAgICAgaWYodGhpcy5pbnB1dC50eXBlID09PSAndGV4dGFyZWEnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZWRpdGFibGUtcHJlLXdyYXBwZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9hdHRhY2ggaGFuZGxlciBhY3RpdmF0aW5nIGVkaXRhYmxlLiBJbiBkaXNhYmxlZCBtb2RlIGl0IGp1c3QgcHJldmVudCBkZWZhdWx0IGFjdGlvbiAodXNlZnVsIGZvciBsaW5rcylcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy50b2dnbGUgIT09ICdtYW51YWwnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnZWRpdGFibGUtY2xpY2snKTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKHRoaXMub3B0aW9ucy50b2dnbGUgKyAnLmVkaXRhYmxlJywgJC5wcm94eShmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICAgICAgLy9wcmV2ZW50IGZvbGxvd2luZyBsaW5rIGlmIGVkaXRhYmxlIGVuYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgaWYoIXRoaXMub3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL3N0b3AgcHJvcGFnYXRpb24gbm90IHJlcXVpcmVkIGJlY2F1c2UgaW4gZG9jdW1lbnQgY2xpY2sgaGFuZGxlciBpdCBjaGVja3MgZXZlbnQgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgIC8vZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy50b2dnbGUgPT09ICdtb3VzZWVudGVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9mb3IgaG92ZXIgb25seSBzaG93IGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3doZW4gdG9nZ2xlPSdjbGljaycgd2Ugc2hvdWxkIG5vdCBjbG9zZSBhbGwgb3RoZXIgY29udGFpbmVycyBhcyB0aGV5IHdpbGwgYmUgY2xvc2VkIGF1dG9tYXRpY2FsbHkgaW4gZG9jdW1lbnQgY2xpY2sgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9zZUFsbCA9ICh0aGlzLm9wdGlvbnMudG9nZ2xlICE9PSAnY2xpY2snKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlKGNsb3NlQWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcsIC0xKTsgLy9kbyBub3Qgc3RvcCBmb2N1cyBvbiBlbGVtZW50IHdoZW4gdG9nZ2xlZCBtYW51YWxseVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2lmIGRpc3BsYXkgaXMgZnVuY3Rpb24gaXQncyBmYXIgbW9yZSBjb252aW5pZW50IHRvIGhhdmUgYXV0b3RleHQgPSBhbHdheXMgdG8gcmVuZGVyIGNvcnJlY3RseSBvbiBpbml0XG4gICAgICAgICAgICAvL3NlZSBodHRwczovL2dpdGh1Yi5jb20vdml0YWxldHMveC1lZGl0YWJsZS15aWkvaXNzdWVzLzM0XG4gICAgICAgICAgICBpZih0eXBlb2YgdGhpcy5vcHRpb25zLmRpc3BsYXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuYXV0b3RleHQgPSAnYWx3YXlzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9jaGVjayBjb25kaXRpb25zIGZvciBhdXRvdGV4dDpcbiAgICAgICAgICAgIHN3aXRjaCh0aGlzLm9wdGlvbnMuYXV0b3RleHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAnYWx3YXlzJzpcbiAgICAgICAgICAgICAgIGRvQXV0b3RleHQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnYXV0byc6XG4gICAgICAgICAgICAgICAgLy9pZiBlbGVtZW50IHRleHQgaXMgZW1wdHkgYW5kIHZhbHVlIGlzIGRlZmluZWQgYW5kIHZhbHVlIG5vdCBnZW5lcmF0ZWQgYnkgdGV4dCAtLT4gcnVuIGF1dG90ZXh0XG4gICAgICAgICAgICAgICAgZG9BdXRvdGV4dCA9ICEkLnRyaW0odGhpcy4kZWxlbWVudC50ZXh0KCkpLmxlbmd0aCAmJiB0aGlzLnZhbHVlICE9PSBudWxsICYmIHRoaXMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhaXNWYWx1ZUJ5VGV4dDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICBkb0F1dG90ZXh0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vZGVwZW5kaW5nIG9uIGF1dG90ZXh0IHJ1biByZW5kZXIoKSBvciBqdXN0IGZpbmlsaXplIGluaXRcbiAgICAgICAgICAgICQud2hlbihkb0F1dG90ZXh0ID8gdGhpcy5yZW5kZXIoKSA6IHRydWUpLnRoZW4oJC5wcm94eShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmFibGUoKTsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgLyoqICAgICAgICBcbiAgICAgICAgICAgICAgIEZpcmVkIHdoZW4gZWxlbWVudCB3YXMgaW5pdGlhbGl6ZWQgYnkgYCQoKS5lZGl0YWJsZSgpYCBtZXRob2QuIFxuICAgICAgICAgICAgICAgUGxlYXNlIG5vdGUgdGhhdCB5b3Ugc2hvdWxkIHNldHVwIGBpbml0YCBoYW5kbGVyICoqYmVmb3JlKiogYXBwbHlpbmcgYGVkaXRhYmxlYC4gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgIEBldmVudCBpbml0IFxuICAgICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGV2ZW50IGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgICAgQHBhcmFtIHtPYmplY3R9IGVkaXRhYmxlIGVkaXRhYmxlIGluc3RhbmNlIChhcyBoZXJlIGl0IGNhbm5vdCBhY2Nlc3NlZCB2aWEgZGF0YSgnZWRpdGFibGUnKSlcbiAgICAgICAgICAgICAgIEBzaW5jZSAxLjIuMFxuICAgICAgICAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgICAgICAgICQoJyN1c2VybmFtZScpLm9uKCdpbml0JywgZnVuY3Rpb24oZSwgZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICBhbGVydCgnaW5pdGlhbGl6ZWQgJyArIGVkaXRhYmxlLm9wdGlvbnMubmFtZSk7XG4gICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICQoJyN1c2VybmFtZScpLmVkaXRhYmxlKCk7XG4gICAgICAgICAgICAgICAqKi8gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXJIYW5kbGVyKCdpbml0JywgdGhpcyk7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgIEluaXRpYWxpemVzIHBhcmVudCBlbGVtZW50IGZvciBsaXZlIGVkaXRhYmxlcyBcbiAgICAgICAgKi9cbiAgICAgICAgaW5pdExpdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAvL3N0b3JlIHNlbGVjdG9yIFxuICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLm9wdGlvbnMuc2VsZWN0b3I7XG4gICAgICAgICAgIC8vbW9kaWZ5IG9wdGlvbnMgZm9yIGNoaWxkIGVsZW1lbnRzXG4gICAgICAgICAgIHRoaXMub3B0aW9ucy5zZWxlY3RvciA9IGZhbHNlOyBcbiAgICAgICAgICAgdGhpcy5vcHRpb25zLmF1dG90ZXh0ID0gJ25ldmVyJztcbiAgICAgICAgICAgLy9saXN0ZW4gdG9nZ2xlIGV2ZW50c1xuICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKHRoaXMub3B0aW9ucy50b2dnbGUgKyAnLmVkaXRhYmxlJywgc2VsZWN0b3IsICQucHJveHkoZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICB2YXIgJHRhcmdldCA9ICQoZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgaWYoISR0YXJnZXQuZGF0YSgnZWRpdGFibGUnKSkge1xuICAgICAgICAgICAgICAgICAgIC8vaWYgZGVsZWdhdGVkIGVsZW1lbnQgaW5pdGlhbGx5IGVtcHR5LCB3ZSBuZWVkIHRvIGNsZWFyIGl0J3MgdGV4dCAodGhhdCB3YXMgbWFudWFsbHkgc2V0IHRvIGBlbXB0eWAgYnkgdXNlcilcbiAgICAgICAgICAgICAgICAgICAvL3NlZSBodHRwczovL2dpdGh1Yi5jb20vdml0YWxldHMveC1lZGl0YWJsZS9pc3N1ZXMvMTM3IFxuICAgICAgICAgICAgICAgICAgIGlmKCR0YXJnZXQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmVtcHR5Y2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHRhcmdldC5lbXB0eSgpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAkdGFyZ2V0LmVkaXRhYmxlKHRoaXMub3B0aW9ucykudHJpZ2dlcihlKTtcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfSwgdGhpcykpOyBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgIFJlbmRlcnMgdmFsdWUgaW50byBlbGVtZW50J3MgdGV4dC5cbiAgICAgICAgQ2FuIGNhbGwgY3VzdG9tIGRpc3BsYXkgbWV0aG9kIGZyb20gb3B0aW9ucy5cbiAgICAgICAgQ2FuIHJldHVybiBkZWZlcnJlZCBvYmplY3QuXG4gICAgICAgIEBtZXRob2QgcmVuZGVyKClcbiAgICAgICAgQHBhcmFtIHttaXhlZH0gcmVzcG9uc2Ugc2VydmVyIHJlc3BvbnNlIChpZiBleGlzdCkgdG8gcGFzcyBpbnRvIGRpc3BsYXkgZnVuY3Rpb25cbiAgICAgICAgKi8gICAgICAgICAgXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8vZG8gbm90IGRpc3BsYXkgYW55dGhpbmdcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5kaXNwbGF5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9pZiBpbnB1dCBoYXMgYHZhbHVlMmh0bWxGaW5hbGAgbWV0aG9kLCB3ZSBwYXNzIGNhbGxiYWNrIGluIHRoaXJkIHBhcmFtIHRvIGJlIGNhbGxlZCB3aGVuIHNvdXJjZSBpcyBsb2FkZWRcbiAgICAgICAgICAgIGlmKHRoaXMuaW5wdXQudmFsdWUyaHRtbEZpbmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXQudmFsdWUyaHRtbCh0aGlzLnZhbHVlLCB0aGlzLiRlbGVtZW50WzBdLCB0aGlzLm9wdGlvbnMuZGlzcGxheSwgcmVzcG9uc2UpOyBcbiAgICAgICAgICAgIC8vaWYgZGlzcGxheSBtZXRob2QgZGVmaW5lZCAtLT4gdXNlIGl0ICAgIFxuICAgICAgICAgICAgfSBlbHNlIGlmKHR5cGVvZiB0aGlzLm9wdGlvbnMuZGlzcGxheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZGlzcGxheS5jYWxsKHRoaXMuJGVsZW1lbnRbMF0sIHRoaXMudmFsdWUsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgIC8vZWxzZSB1c2UgaW5wdXQncyBvcmlnaW5hbCB2YWx1ZTJodG1sKCkgbWV0aG9kICAgIFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC52YWx1ZTJodG1sKHRoaXMudmFsdWUsIHRoaXMuJGVsZW1lbnRbMF0pOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBFbmFibGVzIGVkaXRhYmxlXG4gICAgICAgIEBtZXRob2QgZW5hYmxlKClcbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICBlbmFibGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdlZGl0YWJsZS1kaXNhYmxlZCcpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFbXB0eSh0aGlzLmlzRW1wdHkpO1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnRvZ2dsZSAhPT0gJ21hbnVhbCcpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLiRlbGVtZW50LmF0dHIoJ3RhYmluZGV4JykgPT09ICctMScpIHsgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQXR0cigndGFiaW5kZXgnKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBEaXNhYmxlcyBlZGl0YWJsZVxuICAgICAgICBAbWV0aG9kIGRpc2FibGUoKVxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgZGlzYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgPSB0cnVlOyBcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpOyAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCdlZGl0YWJsZS1kaXNhYmxlZCcpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFbXB0eSh0aGlzLmlzRW1wdHkpO1xuICAgICAgICAgICAgLy9kbyBub3Qgc3RvcCBmb2N1cyBvbiB0aGlzIGVsZW1lbnRcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cigndGFiaW5kZXgnLCAtMSk7ICAgICAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFRvZ2dsZXMgZW5hYmxlZCAvIGRpc2FibGVkIHN0YXRlIG9mIGVkaXRhYmxlIGVsZW1lbnRcbiAgICAgICAgQG1ldGhvZCB0b2dnbGVEaXNhYmxlZCgpXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB0b2dnbGVEaXNhYmxlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHsgXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCk7IFxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAgXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgU2V0cyBuZXcgb3B0aW9uXG4gICAgICAgIFxuICAgICAgICBAbWV0aG9kIG9wdGlvbihrZXksIHZhbHVlKVxuICAgICAgICBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGtleSBvcHRpb24gbmFtZSBvciBvYmplY3Qgd2l0aCBzZXZlcmFsIG9wdGlvbnNcbiAgICAgICAgQHBhcmFtIHttaXhlZH0gdmFsdWUgb3B0aW9uIG5ldyB2YWx1ZVxuICAgICAgICBAZXhhbXBsZVxuICAgICAgICAkKCcuZWRpdGFibGUnKS5lZGl0YWJsZSgnb3B0aW9uJywgJ3BrJywgMik7XG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgb3B0aW9uOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAvL3NldCBvcHRpb24ocykgYnkgb2JqZWN0XG4gICAgICAgICAgICBpZihrZXkgJiYgdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICQuZWFjaChrZXksICQucHJveHkoZnVuY3Rpb24oaywgdil7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbigkLnRyaW0oayksIHYpOyBcbiAgICAgICAgICAgICAgIH0sIHRoaXMpKTsgXG4gICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vc2V0IG9wdGlvbiBieSBzdHJpbmcgICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZGlzYWJsZWRcbiAgICAgICAgICAgIGlmKGtleSA9PT0gJ2Rpc2FibGVkJykge1xuICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gdGhpcy5kaXNhYmxlKCkgOiB0aGlzLmVuYWJsZSgpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy92YWx1ZVxuICAgICAgICAgICAgaWYoa2V5ID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vdHJhbnNmZXIgbmV3IG9wdGlvbiB0byBjb250YWluZXIhIFxuICAgICAgICAgICAgaWYodGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5vcHRpb24oa2V5LCB2YWx1ZSk7ICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICBcbiAgICAgICAgICAgIC8vcGFzcyBvcHRpb24gdG8gaW5wdXQgZGlyZWN0bHkgKGFzIGl0IHBvaW50cyB0byB0aGUgc2FtZSBpbiBmb3JtKVxuICAgICAgICAgICAgaWYodGhpcy5pbnB1dC5vcHRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0Lm9wdGlvbihrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICB9LCAgICAgICAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAqIHNldCBlbXB0eXRleHQgaWYgZWxlbWVudCBpcyBlbXB0eVxuICAgICAgICAqL1xuICAgICAgICBoYW5kbGVFbXB0eTogZnVuY3Rpb24gKGlzRW1wdHkpIHtcbiAgICAgICAgICAgIC8vZG8gbm90IGhhbmRsZSBlbXB0eSBpZiB3ZSBkbyBub3QgZGlzcGxheSBhbnl0aGluZ1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmRpc3BsYXkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBcbiAgICAgICAgICAgIGlzRW1wdHkgbWF5IGJlIHNldCBkaXJlY3RseSBhcyBwYXJhbSBvZiBtZXRob2QuXG4gICAgICAgICAgICBJdCBpcyByZXF1aXJlZCB3aGVuIHdlIGVuYWJsZS9kaXNhYmxlIGZpZWxkIGFuZCBjYW4ndCByZWx5IG9uIGNvbnRlbnQgXG4gICAgICAgICAgICBhcyBub2RlIGNvbnRlbnQgaXMgdGV4dDogXCJFbXB0eVwiIHRoYXQgaXMgbm90IGVtcHR5ICUpXG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYoaXNFbXB0eSAhPT0gdW5kZWZpbmVkKSB7IFxuICAgICAgICAgICAgICAgIHRoaXMuaXNFbXB0eSA9IGlzRW1wdHk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vZGV0ZWN0IGVtcHR5XG4gICAgICAgICAgICAgICAgLy9mb3Igc29tZSBpbnB1dHMgd2UgbmVlZCBtb3JlIHNtYXJ0IGNoZWNrXG4gICAgICAgICAgICAgICAgLy9lLmcuIHd5c2lodG1sNSBtYXkgaGF2ZSA8YnI+LCA8cD48L3A+LCA8aW1nPlxuICAgICAgICAgICAgICAgIGlmKHR5cGVvZih0aGlzLmlucHV0LmlzRW1wdHkpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNFbXB0eSA9IHRoaXMuaW5wdXQuaXNFbXB0eSh0aGlzLiRlbGVtZW50KTsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNFbXB0eSA9ICQudHJpbSh0aGlzLiRlbGVtZW50Lmh0bWwoKSkgPT09ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2VtcHR5dGV4dCBzaG93biBvbmx5IGZvciBlbmFibGVkXG4gICAgICAgICAgICBpZighdGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50Lmh0bWwodGhpcy5vcHRpb25zLmVtcHR5dGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5lbXB0eWNsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5lbXB0eWNsYXNzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLm9wdGlvbnMuZW1wdHljbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5lbXB0eWNsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vYmVsb3cgcmVxdWlyZWQgaWYgZWxlbWVudCBkaXNhYmxlIHByb3BlcnR5IHdhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgaWYodGhpcy5pc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuZW1wdHkoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmVtcHR5Y2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmVtcHR5Y2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCAgICAgICAgXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgU2hvd3MgY29udGFpbmVyIHdpdGggZm9ybVxuICAgICAgICBAbWV0aG9kIHNob3coKVxuICAgICAgICBAcGFyYW0ge2Jvb2xlYW59IGNsb3NlQWxsIFdoZXRoZXIgdG8gY2xvc2UgYWxsIG90aGVyIGVkaXRhYmxlIGNvbnRhaW5lcnMgd2hlbiBzaG93aW5nIHRoaXMgb25lLiBEZWZhdWx0IHRydWUuXG4gICAgICAgICoqLyAgXG4gICAgICAgIHNob3c6IGZ1bmN0aW9uIChjbG9zZUFsbCkge1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2luaXQgZWRpdGFibGVDb250YWluZXI6IHBvcG92ZXIsIHRvb2x0aXAsIGlubGluZSwgZXRjLi5cbiAgICAgICAgICAgIGlmKCF0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHZhciBjb250YWluZXJPcHRpb25zID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMuaW5wdXQgLy9wYXNzIGlucHV0IHRvIGZvcm0gKGFzIGl0IGlzIGFscmVhZHkgY3JlYXRlZClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LmVkaXRhYmxlQ29udGFpbmVyKGNvbnRhaW5lck9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIC8vbGlzdGVuIGBzYXZlYCBldmVudCBcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKFwic2F2ZS5pbnRlcm5hbFwiLCAkLnByb3h5KHRoaXMuc2F2ZSwgdGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy4kZWxlbWVudC5kYXRhKCdlZGl0YWJsZUNvbnRhaW5lcicpOyBcbiAgICAgICAgICAgIH0gZWxzZSBpZih0aGlzLmNvbnRhaW5lci50aXAoKS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9zaG93IGNvbnRhaW5lclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc2hvdyhjbG9zZUFsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgSGlkZXMgY29udGFpbmVyIHdpdGggZm9ybVxuICAgICAgICBAbWV0aG9kIGhpZGUoKVxuICAgICAgICAqKi8gICAgICAgXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHsgICBcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbmVyKSB7ICBcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgVG9nZ2xlcyBjb250YWluZXIgdmlzaWJpbGl0eSAoc2hvdyAvIGhpZGUpXG4gICAgICAgIEBtZXRob2QgdG9nZ2xlKClcbiAgICAgICAgQHBhcmFtIHtib29sZWFufSBjbG9zZUFsbCBXaGV0aGVyIHRvIGNsb3NlIGFsbCBvdGhlciBlZGl0YWJsZSBjb250YWluZXJzIHdoZW4gc2hvd2luZyB0aGlzIG9uZS4gRGVmYXVsdCB0cnVlLlxuICAgICAgICAqKi8gIFxuICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uKGNsb3NlQWxsKSB7XG4gICAgICAgICAgICBpZih0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci50aXAoKS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3coY2xvc2VBbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgKiBjYWxsZWQgd2hlbiBmb3JtIHdhcyBzdWJtaXR0ZWRcbiAgICAgICAgKi8gICAgICAgICAgXG4gICAgICAgIHNhdmU6IGZ1bmN0aW9uKGUsIHBhcmFtcykge1xuICAgICAgICAgICAgLy9tYXJrIGVsZW1lbnQgd2l0aCB1bnNhdmVkIGNsYXNzIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnVuc2F2ZWRjbGFzcykge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgIEFkZCB1bnNhdmVkIGNzcyB0byBlbGVtZW50IGlmOlxuICAgICAgICAgICAgICAgICAgLSB1cmwgaXMgbm90IHVzZXIncyBmdW5jdGlvbiBcbiAgICAgICAgICAgICAgICAgIC0gdmFsdWUgd2FzIG5vdCBzZW50IHRvIHNlcnZlclxuICAgICAgICAgICAgICAgICAgLSBwYXJhbXMucmVzcG9uc2UgPT09IHVuZGVmaW5lZCwgdGhhdCBtZWFucyBkYXRhIHdhcyBub3Qgc2VudFxuICAgICAgICAgICAgICAgICAgLSB2YWx1ZSBjaGFuZ2VkIFxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHNlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzZW50ID0gc2VudCB8fCB0eXBlb2YgdGhpcy5vcHRpb25zLnVybCA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgICAgICAgICAgICBzZW50ID0gc2VudCB8fCB0aGlzLm9wdGlvbnMuZGlzcGxheSA9PT0gZmFsc2U7IFxuICAgICAgICAgICAgICAgIHNlbnQgPSBzZW50IHx8IHBhcmFtcy5yZXNwb25zZSAhPT0gdW5kZWZpbmVkOyBcbiAgICAgICAgICAgICAgICBzZW50ID0gc2VudCB8fCAodGhpcy5pbnB1dC52YWx1ZTJzdHIodGhpcy52YWx1ZSkgIT09IHRoaXMuaW5wdXQudmFsdWUyc3RyKHBhcmFtcy5uZXdWYWx1ZSkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMudW5zYXZlZGNsYXNzKTsgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMudW5zYXZlZGNsYXNzKTsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9oaWdobGlnaHQgd2hlbiBzYXZpbmdcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgJGUgPSB0aGlzLiRlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBiZ0NvbG9yID0gJGUuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJyk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICRlLmNzcygnYmFja2dyb3VuZC1jb2xvcicsIHRoaXMub3B0aW9ucy5oaWdobGlnaHQpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoYmdDb2xvciA9PT0gJ3RyYW5zcGFyZW50Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmdDb2xvciA9ICcnOyBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkZS5jc3MoJ2JhY2tncm91bmQtY29sb3InLCBiZ0NvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgJGUuYWRkQ2xhc3MoJ2VkaXRhYmxlLWJnLXRyYW5zaXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAkZS5yZW1vdmVDbGFzcygnZWRpdGFibGUtYmctdHJhbnNpdGlvbicpOyAgXG4gICAgICAgICAgICAgICAgICAgIH0sIDE3MDApO1xuICAgICAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9zZXQgbmV3IHZhbHVlXG4gICAgICAgICAgICB0aGlzLnNldFZhbHVlKHBhcmFtcy5uZXdWYWx1ZSwgZmFsc2UsIHBhcmFtcy5yZXNwb25zZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8qKiAgICAgICAgXG4gICAgICAgICAgICBGaXJlZCB3aGVuIG5ldyB2YWx1ZSB3YXMgc3VibWl0dGVkLiBZb3UgY2FuIHVzZSA8Y29kZT4kKHRoaXMpLmRhdGEoJ2VkaXRhYmxlJyk8L2NvZGU+IHRvIGFjY2VzcyB0byBlZGl0YWJsZSBpbnN0YW5jZVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBAZXZlbnQgc2F2ZSBcbiAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBldmVudCBldmVudCBvYmplY3RcbiAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgYWRkaXRpb25hbCBwYXJhbXNcbiAgICAgICAgICAgIEBwYXJhbSB7bWl4ZWR9IHBhcmFtcy5uZXdWYWx1ZSBzdWJtaXR0ZWQgdmFsdWVcbiAgICAgICAgICAgIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMucmVzcG9uc2UgYWpheCByZXNwb25zZVxuICAgICAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgICAgICQoJyN1c2VybmFtZScpLm9uKCdzYXZlJywgZnVuY3Rpb24oZSwgcGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgYWxlcnQoJ1NhdmVkIHZhbHVlOiAnICsgcGFyYW1zLm5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgKiovXG4gICAgICAgICAgICAvL2V2ZW50IGl0c2VsZiBpcyB0cmlnZ2VyZWQgYnkgZWRpdGFibGVDb250YWluZXIuIERlc2NyaXB0aW9uIGhlcmUgaXMgb25seSBmb3IgZG9jdW1lbnRhdGlvbiAgICAgICAgICAgICAgXG4gICAgICAgIH0sXG5cbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLnZhbGlkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy52YWxpZGF0ZS5jYWxsKHRoaXMsIHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFNldHMgbmV3IHZhbHVlIG9mIGVkaXRhYmxlXG4gICAgICAgIEBtZXRob2Qgc2V0VmFsdWUodmFsdWUsIGNvbnZlcnRTdHIpXG4gICAgICAgIEBwYXJhbSB7bWl4ZWR9IHZhbHVlIG5ldyB2YWx1ZSBcbiAgICAgICAgQHBhcmFtIHtib29sZWFufSBjb252ZXJ0U3RyIHdoZXRoZXIgdG8gY29udmVydCB2YWx1ZSBmcm9tIHN0cmluZyB0byBpbnRlcm5hbCBmb3JtYXRcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHNldFZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgY29udmVydFN0ciwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmKGNvbnZlcnRTdHIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5pbnB1dC5zdHIydmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLm9wdGlvbigndmFsdWUnLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQud2hlbih0aGlzLnJlbmRlcihyZXNwb25zZSkpXG4gICAgICAgICAgICAudGhlbigkLnByb3h5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRW1wdHkoKTtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBBY3RpdmF0ZXMgaW5wdXQgb2YgdmlzaWJsZSBjb250YWluZXIgKGUuZy4gc2V0IGZvY3VzKVxuICAgICAgICBAbWV0aG9kIGFjdGl2YXRlKClcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hY3RpdmF0ZSgpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBSZW1vdmVzIGVkaXRhYmxlIGZlYXR1cmUgZnJvbSBlbGVtZW50XG4gICAgICAgIEBtZXRob2QgZGVzdHJveSgpXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5kZXN0cm95KCk7IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmlucHV0LmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnRvZ2dsZSAhPT0gJ21hbnVhbCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdlZGl0YWJsZS1jbGljaycpO1xuICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKHRoaXMub3B0aW9ucy50b2dnbGUgKyAnLmVkaXRhYmxlJyk7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZihcInNhdmUuaW50ZXJuYWxcIik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2VkaXRhYmxlIGVkaXRhYmxlLW9wZW4gZWRpdGFibGUtZGlzYWJsZWQnKTtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YSgnZWRpdGFibGUnKTtcbiAgICAgICAgfSAgICAgICAgXG4gICAgfTtcblxuICAgIC8qIEVESVRBQkxFIFBMVUdJTiBERUZJTklUSU9OXG4gICAgKiA9PT09PT09PT09PT09PT09PT09PT09PSAqL1xuXG4gICAgLyoqXG4gICAgalF1ZXJ5IG1ldGhvZCB0byBpbml0aWFsaXplIGVkaXRhYmxlIGVsZW1lbnQuXG4gICAgXG4gICAgQG1ldGhvZCAkKCkuZWRpdGFibGUob3B0aW9ucylcbiAgICBAcGFyYW1zIHtPYmplY3R9IG9wdGlvbnNcbiAgICBAZXhhbXBsZVxuICAgICQoJyN1c2VybmFtZScpLmVkaXRhYmxlKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgIHBrOiAxXG4gICAgfSk7XG4gICAgKiovXG4gICAgJC5mbi5lZGl0YWJsZSA9IGZ1bmN0aW9uIChvcHRpb24pIHtcbiAgICAgICAgLy9zcGVjaWFsIEFQSSBtZXRob2RzIHJldHVybmluZyBub24tanF1ZXJ5IG9iamVjdFxuICAgICAgICB2YXIgcmVzdWx0ID0ge30sIGFyZ3MgPSBhcmd1bWVudHMsIGRhdGFrZXkgPSAnZWRpdGFibGUnO1xuICAgICAgICBzd2l0Y2ggKG9wdGlvbikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICBSdW5zIGNsaWVudC1zaWRlIHZhbGlkYXRpb24gZm9yIGFsbCBtYXRjaGVkIGVkaXRhYmxlc1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBAbWV0aG9kIHZhbGlkYXRlKClcbiAgICAgICAgICAgIEByZXR1cm5zIHtPYmplY3R9IHZhbGlkYXRpb24gZXJyb3JzIG1hcFxuICAgICAgICAgICAgQGV4YW1wbGVcbiAgICAgICAgICAgICQoJyN1c2VybmFtZSwgI2Z1bGxuYW1lJykuZWRpdGFibGUoJ3ZhbGlkYXRlJyk7XG4gICAgICAgICAgICAvLyBwb3NzaWJsZSByZXN1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHVzZXJuYW1lOiBcInVzZXJuYW1lIGlzIHJlcXVpcmVkXCIsXG4gICAgICAgICAgICAgIGZ1bGxuYW1lOiBcImZ1bGxuYW1lIHNob3VsZCBiZSBtaW5pbXVtIDMgbGV0dGVycyBsZW5ndGhcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKiovXG4gICAgICAgICAgICBjYXNlICd2YWxpZGF0ZSc6XG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSwgZGF0YSA9ICR0aGlzLmRhdGEoZGF0YWtleSksIGVycm9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiAoZXJyb3IgPSBkYXRhLnZhbGlkYXRlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbZGF0YS5vcHRpb25zLm5hbWVdID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgUmV0dXJucyBjdXJyZW50IHZhbHVlcyBvZiBlZGl0YWJsZSBlbGVtZW50cy4gICBcbiAgICAgICAgICAgIE5vdGUgdGhhdCBpdCByZXR1cm5zIGFuICoqb2JqZWN0Kiogd2l0aCBuYW1lLXZhbHVlIHBhaXJzLCBub3QgYSB2YWx1ZSBpdHNlbGYuIEl0IGFsbG93cyB0byBnZXQgZGF0YSBmcm9tIHNldmVyYWwgZWxlbWVudHMuICAgIFxuICAgICAgICAgICAgSWYgdmFsdWUgb2Ygc29tZSBlZGl0YWJsZSBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgaXQgaXMgZXhjbHVkZWQgZnJvbSByZXN1bHQgb2JqZWN0LlxuICAgICAgICAgICAgV2hlbiBwYXJhbSBgaXNTaW5nbGVgIGlzIHNldCB0byAqKnRydWUqKiAtIGl0IGlzIHN1cHBvc2VkIHlvdSBoYXZlIHNpbmdsZSBlbGVtZW50IGFuZCB3aWxsIHJldHVybiB2YWx1ZSBvZiBlZGl0YWJsZSBpbnN0ZWFkIG9mIG9iamVjdC4gICBcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgIEBtZXRob2QgZ2V0VmFsdWUoKVxuICAgICAgICAgICAgQHBhcmFtIHtib29sfSBpc1NpbmdsZSB3aGV0aGVyIHRvIHJldHVybiBqdXN0IHZhbHVlIG9mIHNpbmdsZSBlbGVtZW50XG4gICAgICAgICAgICBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3Qgb2YgZWxlbWVudCBuYW1lcyBhbmQgdmFsdWVzXG4gICAgICAgICAgICBAZXhhbXBsZVxuICAgICAgICAgICAgJCgnI3VzZXJuYW1lLCAjZnVsbG5hbWUnKS5lZGl0YWJsZSgnZ2V0VmFsdWUnKTtcbiAgICAgICAgICAgIC8vcmVzdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgdXNlcm5hbWU6IFwic3VwZXJ1c2VyXCIsXG4gICAgICAgICAgICBmdWxsbmFtZTogXCJKb2huXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vaXNTaW5nbGUgPSB0cnVlXG4gICAgICAgICAgICAkKCcjdXNlcm5hbWUnKS5lZGl0YWJsZSgnZ2V0VmFsdWUnLCB0cnVlKTtcbiAgICAgICAgICAgIC8vcmVzdWx0IFwic3VwZXJ1c2VyXCIgXG4gICAgICAgICAgICAqKi9cbiAgICAgICAgICAgIGNhc2UgJ2dldFZhbHVlJzpcbiAgICAgICAgICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIGFyZ3VtZW50c1sxXSA9PT0gdHJ1ZSkgeyAvL2lzU2luZ2xlID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmVxKDApLmRhdGEoZGF0YWtleSkudmFsdWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksIGRhdGEgPSAkdGhpcy5kYXRhKGRhdGFrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgZGF0YS52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGRhdGEudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbZGF0YS5vcHRpb25zLm5hbWVdID0gZGF0YS5pbnB1dC52YWx1ZTJzdWJtaXQoZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgVGhpcyBtZXRob2QgY29sbGVjdHMgdmFsdWVzIGZyb20gc2V2ZXJhbCBlZGl0YWJsZSBlbGVtZW50cyBhbmQgc3VibWl0IHRoZW0gYWxsIHRvIHNlcnZlci4gICBcbiAgICAgICAgICAgIEludGVybmFsbHkgaXQgcnVucyBjbGllbnQtc2lkZSB2YWxpZGF0aW9uIGZvciBhbGwgZmllbGRzIGFuZCBzdWJtaXRzIG9ubHkgaW4gY2FzZSBvZiBzdWNjZXNzLiAgXG4gICAgICAgICAgICBTZWUgPGEgaHJlZj1cIiNuZXdyZWNvcmRcIj5jcmVhdGluZyBuZXcgcmVjb3JkczwvYT4gZm9yIGRldGFpbHMuICBcbiAgICAgICAgICAgIFNpbmNlIDEuNS4xIGBzdWJtaXRgIGNhbiBiZSBhcHBsaWVkIHRvIHNpbmdsZSBlbGVtZW50IHRvIHNlbmQgZGF0YSBwcm9ncmFtbWF0aWNhbGx5LiBJbiB0aGF0IGNhc2VcbiAgICAgICAgICAgIGB1cmxgLCBgc3VjY2Vzc2AgYW5kIGBlcnJvcmAgaXMgdGFrZW4gZnJvbSBpbml0aWFsIG9wdGlvbnMgYW5kIHlvdSBjYW4ganVzdCBjYWxsIGAkKCcjdXNlcm5hbWUnKS5lZGl0YWJsZSgnc3VibWl0JylgLiBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgQG1ldGhvZCBzdWJtaXQob3B0aW9ucylcbiAgICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIFxuICAgICAgICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMudXJsIHVybCB0byBzdWJtaXQgZGF0YSBcbiAgICAgICAgICAgIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLmRhdGEgYWRkaXRpb25hbCBkYXRhIHRvIHN1Ym1pdFxuICAgICAgICAgICAgQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuYWpheE9wdGlvbnMgYWRkaXRpb25hbCBhamF4IG9wdGlvbnNcbiAgICAgICAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuZXJyb3Iob2JqKSBlcnJvciBoYW5kbGVyIFxuICAgICAgICAgICAgQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5zdWNjZXNzKG9iaixjb25maWcpIHN1Y2Nlc3MgaGFuZGxlclxuICAgICAgICAgICAgQHJldHVybnMge09iamVjdH0galF1ZXJ5IG9iamVjdFxuICAgICAgICAgICAgKiovXG4gICAgICAgICAgICBjYXNlICdzdWJtaXQnOiAgLy9jb2xsZWN0cyB2YWx1ZSwgdmFsaWRhdGUgYW5kIHN1Ym1pdCB0byBzZXJ2ZXIgZm9yIGNyZWF0aW5nIG5ldyByZWNvcmRcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gYXJndW1lbnRzWzFdIHx8IHt9LFxuICAgICAgICAgICAgICAgICRlbGVtcyA9IHRoaXMsXG4gICAgICAgICAgICAgICAgZXJyb3JzID0gdGhpcy5lZGl0YWJsZSgndmFsaWRhdGUnKTtcblxuICAgICAgICAgICAgICAgIC8vIHZhbGlkYXRpb24gb2tcbiAgICAgICAgICAgICAgICBpZigkLmlzRW1wdHlPYmplY3QoZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWpheE9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBmb3Igc2luZ2xlIGVsZW1lbnQgdXNlIHVybCwgc3VjY2VzcyBldGMgZnJvbSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGlmKCRlbGVtcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZGl0YWJsZSA9ICRlbGVtcy5kYXRhKCdlZGl0YWJsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9zdGFuZGFyZCBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZWRpdGFibGUub3B0aW9ucy5uYW1lIHx8ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlZGl0YWJsZS5pbnB1dC52YWx1ZTJzdWJtaXQoZWRpdGFibGUudmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrOiAodHlwZW9mIGVkaXRhYmxlLm9wdGlvbnMucGsgPT09ICdmdW5jdGlvbicpID8gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRhYmxlLm9wdGlvbnMucGsuY2FsbChlZGl0YWJsZS5vcHRpb25zLnNjb3BlKSA6IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZS5vcHRpb25zLnBrIFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9hZGRpdGlvbmFsIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGVkaXRhYmxlLm9wdGlvbnMucGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gZWRpdGFibGUub3B0aW9ucy5wYXJhbXMuY2FsbChlZGl0YWJsZS5vcHRpb25zLnNjb3BlLCBwYXJhbXMpOyAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdHJ5IHBhcnNlIGpzb24gaW4gc2luZ2xlIHF1b3RlcyAoZnJvbSBkYXRhLXBhcmFtcyBhdHRyaWJ1dGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdGFibGUub3B0aW9ucy5wYXJhbXMgPSAkLmZuLmVkaXRhYmxldXRpbHMudHJ5UGFyc2VKc29uKGVkaXRhYmxlLm9wdGlvbnMucGFyYW1zLCB0cnVlKTsgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChwYXJhbXMsIGVkaXRhYmxlLm9wdGlvbnMucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgYWpheE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBlZGl0YWJsZS5vcHRpb25zLnVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1BPU1QnICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBzdWNjZXNzIC8gZXJyb3IgZnJvbSBvcHRpb25zIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN1Y2Nlc3MgPSBjb25maWcuc3VjY2VzcyB8fCBlZGl0YWJsZS5vcHRpb25zLnN1Y2Nlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZXJyb3IgPSBjb25maWcuZXJyb3IgfHwgZWRpdGFibGUub3B0aW9ucy5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBtdWx0aXBsZSBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuZWRpdGFibGUoJ2dldFZhbHVlJyk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBhamF4T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGNvbmZpZy51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogdmFsdWVzLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUE9TVCdcbiAgICAgICAgICAgICAgICAgICAgICAgIH07ICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFqYXggc3VjY2VzcyBjYWxsYWJjayAocmVzcG9uc2UgMjAwIE9LKVxuICAgICAgICAgICAgICAgICAgICBhamF4T3B0aW9ucy5zdWNjZXNzID0gdHlwZW9mIGNvbmZpZy5zdWNjZXNzID09PSAnZnVuY3Rpb24nID8gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc3VjY2Vzcy5jYWxsKCRlbGVtcywgcmVzcG9uc2UsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IDogJC5ub29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvLyBhamF4IGVycm9yIGNhbGxhYmNrXG4gICAgICAgICAgICAgICAgICAgIGFqYXhPcHRpb25zLmVycm9yID0gdHlwZW9mIGNvbmZpZy5lcnJvciA9PT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZXJyb3IuYXBwbHkoJGVsZW1zLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSA6ICQubm9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4dGVuZCBhamF4T3B0aW9ucyAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoY29uZmlnLmFqYXhPcHRpb25zKSB7IFxuICAgICAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQoYWpheE9wdGlvbnMsIGNvbmZpZy5hamF4T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4dHJhIGRhdGEgXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvbmZpZy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZChhamF4T3B0aW9ucy5kYXRhLCBjb25maWcuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vIHBlcmZvcm0gYWpheCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICQuYWpheChhamF4T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy9jbGllbnQtc2lkZSB2YWxpZGF0aW9uIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGlmKHR5cGVvZiBjb25maWcuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5lcnJvci5jYWxsKCRlbGVtcywgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9yZXR1cm4ganF1ZXJ5IG9iamVjdFxuICAgICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksIFxuICAgICAgICAgICAgICAgIGRhdGEgPSAkdGhpcy5kYXRhKGRhdGFrZXkpLCBcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIG9wdGlvbiA9PT0gJ29iamVjdCcgJiYgb3B0aW9uO1xuXG4gICAgICAgICAgICAvL2ZvciBkZWxlZ2F0ZWQgdGFyZ2V0cyBkbyBub3Qgc3RvcmUgYGVkaXRhYmxlYCBvYmplY3QgZm9yIGVsZW1lbnRcbiAgICAgICAgICAgIC8vaXQncyBhbGxvd3Mgc2V2ZXJhbCBkaWZmZXJlbnQgc2VsZWN0b3JzLlxuICAgICAgICAgICAgLy9zZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS92aXRhbGV0cy94LWVkaXRhYmxlL2lzc3Vlcy8zMTIgICAgXG4gICAgICAgICAgICBpZihvcHRpb25zICYmIG9wdGlvbnMuc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gbmV3IEVkaXRhYmxlKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgXG4gICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5kYXRhKGRhdGFrZXksIChkYXRhID0gbmV3IEVkaXRhYmxlKHRoaXMsIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJykgeyAvL2NhbGwgbWV0aG9kIFxuICAgICAgICAgICAgICAgIGRhdGFbb3B0aW9uXS5hcHBseShkYXRhLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG4gICAgICAgICAgICB9IFxuICAgICAgICB9KTtcbiAgICB9OyAgICBcbiAgICAgICAgICAgIFxuXG4gICAgJC5mbi5lZGl0YWJsZS5kZWZhdWx0cyA9IHtcbiAgICAgICAgLyoqXG4gICAgICAgIFR5cGUgb2YgaW5wdXQuIENhbiBiZSA8Y29kZT50ZXh0fHRleHRhcmVhfHNlbGVjdHxkYXRlfGNoZWNrbGlzdDwvY29kZT4gYW5kIG1vcmVcblxuICAgICAgICBAcHJvcGVydHkgdHlwZSBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICd0ZXh0J1xuICAgICAgICAqKi9cbiAgICAgICAgdHlwZTogJ3RleHQnLCAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBTZXRzIGRpc2FibGVkIHN0YXRlIG9mIGVkaXRhYmxlXG5cbiAgICAgICAgQHByb3BlcnR5IGRpc2FibGVkIFxuICAgICAgICBAdHlwZSBib29sZWFuXG4gICAgICAgIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICAgIC8qKlxuICAgICAgICBIb3cgdG8gdG9nZ2xlIGVkaXRhYmxlLiBDYW4gYmUgPGNvZGU+Y2xpY2t8ZGJsY2xpY2t8bW91c2VlbnRlcnxtYW51YWw8L2NvZGU+LiAgIFxuICAgICAgICBXaGVuIHNldCB0byA8Y29kZT5tYW51YWw8L2NvZGU+IHlvdSBzaG91bGQgbWFudWFsbHkgY2FsbCA8Y29kZT5zaG93L2hpZGU8L2NvZGU+IG1ldGhvZHMgb2YgZWRpdGFibGUuICAgIFxuICAgICAgICAqKk5vdGUqKjogaWYgeW91IGNhbGwgPGNvZGU+c2hvdzwvY29kZT4gb3IgPGNvZGU+dG9nZ2xlPC9jb2RlPiBpbnNpZGUgKipjbGljayoqIGhhbmRsZXIgb2Ygc29tZSBET00gZWxlbWVudCwgXG4gICAgICAgIHlvdSBuZWVkIHRvIGFwcGx5IDxjb2RlPmUuc3RvcFByb3BhZ2F0aW9uKCk8L2NvZGU+IGJlY2F1c2UgY29udGFpbmVycyBhcmUgYmVpbmcgY2xvc2VkIG9uIGFueSBjbGljayBvbiBkb2N1bWVudC5cbiAgICAgICAgXG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgICQoJyNlZGl0LWJ1dHRvbicpLmNsaWNrKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAkKCcjdXNlcm5hbWUnKS5lZGl0YWJsZSgndG9nZ2xlJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIEBwcm9wZXJ0eSB0b2dnbGUgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAnY2xpY2snXG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgdG9nZ2xlOiAnY2xpY2snLFxuICAgICAgICAvKipcbiAgICAgICAgVGV4dCBzaG93biB3aGVuIGVsZW1lbnQgaXMgZW1wdHkuXG5cbiAgICAgICAgQHByb3BlcnR5IGVtcHR5dGV4dCBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICdFbXB0eSdcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGVtcHR5dGV4dDogJ0VtcHR5JyxcbiAgICAgICAgLyoqXG4gICAgICAgIEFsbG93cyB0byBhdXRvbWF0aWNhbGx5IHNldCBlbGVtZW50J3MgdGV4dCBiYXNlZCBvbiBpdCdzIHZhbHVlLiBDYW4gYmUgPGNvZGU+YXV0b3xhbHdheXN8bmV2ZXI8L2NvZGU+LiBVc2VmdWwgZm9yIHNlbGVjdCBhbmQgZGF0ZS5cbiAgICAgICAgRm9yIGV4YW1wbGUsIGlmIGRyb3Bkb3duIGxpc3QgaXMgPGNvZGU+ezE6ICdhJywgMjogJ2InfTwvY29kZT4gYW5kIGVsZW1lbnQncyB2YWx1ZSBzZXQgdG8gPGNvZGU+MTwvY29kZT4sIGl0J3MgaHRtbCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIDxjb2RlPidhJzwvY29kZT4uICBcbiAgICAgICAgPGNvZGU+YXV0bzwvY29kZT4gLSB0ZXh0IHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQgb25seSBpZiBlbGVtZW50IGlzIGVtcHR5LiAgXG4gICAgICAgIDxjb2RlPmFsd2F5c3xuZXZlcjwvY29kZT4gLSBhbHdheXMobmV2ZXIpIHRyeSB0byBzZXQgZWxlbWVudCdzIHRleHQuXG5cbiAgICAgICAgQHByb3BlcnR5IGF1dG90ZXh0IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJ2F1dG8nXG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgYXV0b3RleHQ6ICdhdXRvJywgXG4gICAgICAgIC8qKlxuICAgICAgICBJbml0aWFsIHZhbHVlIG9mIGlucHV0LiBJZiBub3Qgc2V0LCB0YWtlbiBmcm9tIGVsZW1lbnQncyB0ZXh0LiAgXG4gICAgICAgIE5vdGUsIHRoYXQgaWYgZWxlbWVudCdzIHRleHQgaXMgZW1wdHkgLSB0ZXh0IGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGZyb20gdmFsdWUgYW5kIGNhbiBiZSBjdXN0b21pemVkIChzZWUgYGF1dG90ZXh0YCBvcHRpb24pLiAgXG4gICAgICAgIEZvciBleGFtcGxlLCB0byBkaXNwbGF5IGN1cnJlbmN5IHNpZ246XG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgIDxhIGlkPVwicHJpY2VcIiBkYXRhLXR5cGU9XCJ0ZXh0XCIgZGF0YS12YWx1ZT1cIjEwMFwiPjwvYT5cbiAgICAgICAgPHNjcmlwdD5cbiAgICAgICAgJCgnI3ByaWNlJykuZWRpdGFibGUoe1xuICAgICAgICAgICAgLi4uXG4gICAgICAgICAgICBkaXNwbGF5OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAkKHRoaXMpLnRleHQodmFsdWUgKyAnJCcpO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSkgXG4gICAgICAgIDwvc2NyaXB0PlxuICAgICAgICAgICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgdmFsdWUgXG4gICAgICAgIEB0eXBlIG1peGVkXG4gICAgICAgIEBkZWZhdWx0IGVsZW1lbnQncyB0ZXh0XG4gICAgICAgICoqL1xuICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIENhbGxiYWNrIHRvIHBlcmZvcm0gY3VzdG9tIGRpc3BsYXlpbmcgb2YgdmFsdWUgaW4gZWxlbWVudCdzIHRleHQuICBcbiAgICAgICAgSWYgYG51bGxgLCBkZWZhdWx0IGlucHV0J3MgZGlzcGxheSB1c2VkLiAgXG4gICAgICAgIElmIGBmYWxzZWAsIG5vIGRpc3BsYXlpbmcgbWV0aG9kcyB3aWxsIGJlIGNhbGxlZCwgZWxlbWVudCdzIHRleHQgd2lsbCBuZXZlciBjaGFuZ2UuICBcbiAgICAgICAgUnVucyB1bmRlciBlbGVtZW50J3Mgc2NvcGUuICBcbiAgICAgICAgXyoqUGFyYW1ldGVyczoqKl8gIFxuICAgICAgICBcbiAgICAgICAgKiBgdmFsdWVgIGN1cnJlbnQgdmFsdWUgdG8gYmUgZGlzcGxheWVkXG4gICAgICAgICogYHJlc3BvbnNlYCBzZXJ2ZXIgcmVzcG9uc2UgKGlmIGRpc3BsYXkgY2FsbGVkIGFmdGVyIGFqYXggc3VibWl0KSwgc2luY2UgMS40LjBcbiAgICAgICAgIFxuICAgICAgICBGb3IgX2lucHV0cyB3aXRoIHNvdXJjZV8gKHNlbGVjdCwgY2hlY2tsaXN0KSBwYXJhbWV0ZXJzIGFyZSBkaWZmZXJlbnQ6ICBcbiAgICAgICAgICBcbiAgICAgICAgKiBgdmFsdWVgIGN1cnJlbnQgdmFsdWUgdG8gYmUgZGlzcGxheWVkXG4gICAgICAgICogYHNvdXJjZURhdGFgIGFycmF5IG9mIGl0ZW1zIGZvciBjdXJyZW50IGlucHV0IChlLmcuIGRyb3Bkb3duIGl0ZW1zKSBcbiAgICAgICAgKiBgcmVzcG9uc2VgIHNlcnZlciByZXNwb25zZSAoaWYgZGlzcGxheSBjYWxsZWQgYWZ0ZXIgYWpheCBzdWJtaXQpLCBzaW5jZSAxLjQuMFxuICAgICAgICAgICAgICAgICAgXG4gICAgICAgIFRvIGdldCBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbXMgdXNlIGAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCBzb3VyY2VEYXRhKWAuXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgZGlzcGxheSBcbiAgICAgICAgQHR5cGUgZnVuY3Rpb258Ym9vbGVhblxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBzaW5jZSAxLjIuMFxuICAgICAgICBAZXhhbXBsZVxuICAgICAgICBkaXNwbGF5OiBmdW5jdGlvbih2YWx1ZSwgc291cmNlRGF0YSkge1xuICAgICAgICAgICAvL2Rpc3BsYXkgY2hlY2tsaXN0IGFzIGNvbW1hLXNlcGFyYXRlZCB2YWx1ZXNcbiAgICAgICAgICAgdmFyIGh0bWwgPSBbXSxcbiAgICAgICAgICAgICAgIGNoZWNrZWQgPSAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCBzb3VyY2VEYXRhKTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICBpZihjaGVja2VkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgJC5lYWNoKGNoZWNrZWQsIGZ1bmN0aW9uKGksIHYpIHsgaHRtbC5wdXNoKCQuZm4uZWRpdGFibGV1dGlscy5lc2NhcGUodi50ZXh0KSk7IH0pO1xuICAgICAgICAgICAgICAgJCh0aGlzKS5odG1sKGh0bWwuam9pbignLCAnKSk7XG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAkKHRoaXMpLmVtcHR5KCk7IFxuICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICBkaXNwbGF5OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgQ3NzIGNsYXNzIGFwcGxpZWQgd2hlbiBlZGl0YWJsZSB0ZXh0IGlzIGVtcHR5LlxuXG4gICAgICAgIEBwcm9wZXJ0eSBlbXB0eWNsYXNzIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQHNpbmNlIDEuNC4xICAgICAgICBcbiAgICAgICAgQGRlZmF1bHQgZWRpdGFibGUtZW1wdHlcbiAgICAgICAgKiovICAgICAgICBcbiAgICAgICAgZW1wdHljbGFzczogJ2VkaXRhYmxlLWVtcHR5JyxcbiAgICAgICAgLyoqXG4gICAgICAgIENzcyBjbGFzcyBhcHBsaWVkIHdoZW4gdmFsdWUgd2FzIHN0b3JlZCBidXQgbm90IHNlbnQgdG8gc2VydmVyIChgcGtgIGlzIGVtcHR5IG9yIGBzZW5kID0gJ25ldmVyJ2ApLiAgXG4gICAgICAgIFlvdSBtYXkgc2V0IGl0IHRvIGBudWxsYCBpZiB5b3Ugd29yayB3aXRoIGVkaXRhYmxlcyBsb2NhbGx5IGFuZCBzdWJtaXQgdGhlbSB0b2dldGhlci4gIFxuXG4gICAgICAgIEBwcm9wZXJ0eSB1bnNhdmVkY2xhc3MgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAc2luY2UgMS40LjEgICAgICAgIFxuICAgICAgICBAZGVmYXVsdCBlZGl0YWJsZS11bnNhdmVkXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHVuc2F2ZWRjbGFzczogJ2VkaXRhYmxlLXVuc2F2ZWQnLFxuICAgICAgICAvKipcbiAgICAgICAgSWYgc2VsZWN0b3IgaXMgcHJvdmlkZWQsIGVkaXRhYmxlIHdpbGwgYmUgZGVsZWdhdGVkIHRvIHRoZSBzcGVjaWZpZWQgdGFyZ2V0cy4gIFxuICAgICAgICBVc2VmdWxsIGZvciBkeW5hbWljYWxseSBnZW5lcmF0ZWQgRE9NIGVsZW1lbnRzLiAgXG4gICAgICAgICoqUGxlYXNlIG5vdGUqKiwgdGhhdCBkZWxlZ2F0ZWQgdGFyZ2V0cyBjYW4ndCBiZSBpbml0aWFsaXplZCB3aXRoIGBlbXB0eXRleHRgIGFuZCBgYXV0b3RleHRgIG9wdGlvbnMsIFxuICAgICAgICBhcyB0aGV5IGFjdHVhbGx5IGJlY29tZSBlZGl0YWJsZSBvbmx5IGFmdGVyIGZpcnN0IGNsaWNrLiAgXG4gICAgICAgIFlvdSBzaG91bGQgbWFudWFsbHkgc2V0IGNsYXNzIGBlZGl0YWJsZS1jbGlja2AgdG8gdGhlc2UgZWxlbWVudHMuICBcbiAgICAgICAgQWxzbywgaWYgZWxlbWVudCBvcmlnaW5hbGx5IGVtcHR5IHlvdSBzaG91bGQgYWRkIGNsYXNzIGBlZGl0YWJsZS1lbXB0eWAsIHNldCBgZGF0YS12YWx1ZT1cIlwiYCBhbmQgd3JpdGUgZW1wdHl0ZXh0IGludG8gZWxlbWVudDpcblxuICAgICAgICBAcHJvcGVydHkgc2VsZWN0b3IgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAc2luY2UgMS40LjEgICAgICAgIFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgIEBleGFtcGxlXG4gICAgICAgIDxkaXYgaWQ9XCJ1c2VyXCI+XG4gICAgICAgICAgPCEtLSBlbXB0eSAtLT5cbiAgICAgICAgICA8YSBocmVmPVwiI1wiIGRhdGEtbmFtZT1cInVzZXJuYW1lXCIgZGF0YS10eXBlPVwidGV4dFwiIGNsYXNzPVwiZWRpdGFibGUtY2xpY2sgZWRpdGFibGUtZW1wdHlcIiBkYXRhLXZhbHVlPVwiXCIgdGl0bGU9XCJVc2VybmFtZVwiPkVtcHR5PC9hPlxuICAgICAgICAgIDwhLS0gbm9uLWVtcHR5IC0tPlxuICAgICAgICAgIDxhIGhyZWY9XCIjXCIgZGF0YS1uYW1lPVwiZ3JvdXBcIiBkYXRhLXR5cGU9XCJzZWxlY3RcIiBkYXRhLXNvdXJjZT1cIi9ncm91cHNcIiBkYXRhLXZhbHVlPVwiMVwiIGNsYXNzPVwiZWRpdGFibGUtY2xpY2tcIiB0aXRsZT1cIkdyb3VwXCI+T3BlcmF0b3I8L2E+XG4gICAgICAgIDwvZGl2PiAgICAgXG4gICAgICAgIFxuICAgICAgICA8c2NyaXB0PlxuICAgICAgICAkKCcjdXNlcicpLmVkaXRhYmxlKHtcbiAgICAgICAgICAgIHNlbGVjdG9yOiAnYScsXG4gICAgICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgICAgICBwazogMVxuICAgICAgICB9KTtcbiAgICAgICAgPC9zY3JpcHQ+XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBzZWxlY3RvcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIENvbG9yIHVzZWQgdG8gaGlnaGxpZ2h0IGVsZW1lbnQgYWZ0ZXIgdXBkYXRlLiBJbXBsZW1lbnRlZCB2aWEgQ1NTMyB0cmFuc2l0aW9uLCB3b3JrcyBpbiBtb2Rlcm4gYnJvd3NlcnMuXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgaGlnaGxpZ2h0IFxuICAgICAgICBAdHlwZSBzdHJpbmd8Ym9vbGVhblxuICAgICAgICBAc2luY2UgMS40LjUgICAgICAgIFxuICAgICAgICBAZGVmYXVsdCAjRkZGRjgwIFxuICAgICAgICAqKi9cbiAgICAgICAgaGlnaGxpZ2h0OiAnI0ZGRkY4MCdcbiAgICB9O1xuICAgIFxufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qKlxuQWJzdHJhY3RJbnB1dCAtIGJhc2UgY2xhc3MgZm9yIGFsbCBlZGl0YWJsZSBpbnB1dHMuXG5JdCBkZWZpbmVzIGludGVyZmFjZSB0byBiZSBpbXBsZW1lbnRlZCBieSBhbnkgaW5wdXQgdHlwZS5cblRvIGNyZWF0ZSB5b3VyIG93biBpbnB1dCB5b3UgY2FuIGluaGVyaXQgZnJvbSB0aGlzIGNsYXNzLlxuXG5AY2xhc3MgYWJzdHJhY3RpbnB1dFxuKiovXG4oZnVuY3Rpb24gKCQpIHtcblxuICAgIC8vdHlwZXNcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMgPSB7fTtcblxuICAgIHZhciBBYnN0cmFjdElucHV0ID0gZnVuY3Rpb24gKCkgeyB9O1xuXG4gICAgQWJzdHJhY3RJbnB1dC5wcm90b3R5cGUgPSB7XG4gICAgICAgLyoqXG4gICAgICAgIEluaXRpYWxpemVzIGlucHV0XG5cbiAgICAgICAgQG1ldGhvZCBpbml0KCkgXG4gICAgICAgICoqL1xuICAgICAgIGluaXQ6IGZ1bmN0aW9uKHR5cGUsIG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgfSxcblxuICAgICAgIC8qXG4gICAgICAgdGhpcyBtZXRob2QgY2FsbGVkIGJlZm9yZSByZW5kZXIgdG8gaW5pdCAkdHBsIHRoYXQgaXMgaW5zZXJ0ZWQgaW4gRE9NXG4gICAgICAgKi9cbiAgICAgICBwcmVyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICB0aGlzLiR0cGwgPSAkKHRoaXMub3B0aW9ucy50cGwpOyAvL3dob2xlIHRwbCBhcyBqcXVlcnkgb2JqZWN0ICAgIFxuICAgICAgICAgICB0aGlzLiRpbnB1dCA9IHRoaXMuJHRwbDsgICAgICAgICAvL2NvbnRyb2wgaXRzZWxmLCBjYW4gYmUgY2hhbmdlZCBpbiByZW5kZXIgbWV0aG9kXG4gICAgICAgICAgIHRoaXMuJGNsZWFyID0gbnVsbDsgICAgICAgICAgICAgIC8vY2xlYXIgYnV0dG9uXG4gICAgICAgICAgIHRoaXMuZXJyb3IgPSBudWxsOyAgICAgICAgICAgICAgIC8vZXJyb3IgbWVzc2FnZSwgaWYgaW5wdXQgY2Fubm90IGJlIHJlbmRlcmVkICAgICAgICAgICBcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qKlxuICAgICAgICBSZW5kZXJzIGlucHV0IGZyb20gdHBsLiBDYW4gcmV0dXJuIGpRdWVyeSBkZWZlcnJlZCBvYmplY3QuXG4gICAgICAgIENhbiBiZSBvdmVyd3JpdHRlbiBpbiBjaGlsZCBvYmplY3RzXG5cbiAgICAgICAgQG1ldGhvZCByZW5kZXIoKVxuICAgICAgICoqL1xuICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICB9LCBcblxuICAgICAgIC8qKlxuICAgICAgICBTZXRzIGVsZW1lbnQncyBodG1sIGJ5IHZhbHVlLiBcblxuICAgICAgICBAbWV0aG9kIHZhbHVlMmh0bWwodmFsdWUsIGVsZW1lbnQpXG4gICAgICAgIEBwYXJhbSB7bWl4ZWR9IHZhbHVlXG4gICAgICAgIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudFxuICAgICAgICoqL1xuICAgICAgIHZhbHVlMmh0bWw6IGZ1bmN0aW9uKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICQoZWxlbWVudClbdGhpcy5vcHRpb25zLmVzY2FwZSA/ICd0ZXh0JyA6ICdodG1sJ10oJC50cmltKHZhbHVlKSk7XG4gICAgICAgfSxcblxuICAgICAgIC8qKlxuICAgICAgICBDb252ZXJ0cyBlbGVtZW50J3MgaHRtbCB0byB2YWx1ZVxuXG4gICAgICAgIEBtZXRob2QgaHRtbDJ2YWx1ZShodG1sKVxuICAgICAgICBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICAgICAgICBAcmV0dXJucyB7bWl4ZWR9XG4gICAgICAgKiovXG4gICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICByZXR1cm4gJCgnPGRpdj4nKS5odG1sKGh0bWwpLnRleHQoKTtcbiAgICAgICB9LFxuXG4gICAgICAgLyoqXG4gICAgICAgIENvbnZlcnRzIHZhbHVlIHRvIHN0cmluZyAoZm9yIGludGVybmFsIGNvbXBhcmUpLiBGb3Igc3VibWl0dGluZyB0byBzZXJ2ZXIgdXNlZCB2YWx1ZTJzdWJtaXQoKS5cblxuICAgICAgICBAbWV0aG9kIHZhbHVlMnN0cih2YWx1ZSkgXG4gICAgICAgIEBwYXJhbSB7bWl4ZWR9IHZhbHVlXG4gICAgICAgIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgKiovXG4gICAgICAgdmFsdWUyc3RyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgfSwgXG5cbiAgICAgICAvKipcbiAgICAgICAgQ29udmVydHMgc3RyaW5nIHJlY2VpdmVkIGZyb20gc2VydmVyIGludG8gdmFsdWUuIFVzdWFsbHkgZnJvbSBgZGF0YS12YWx1ZWAgYXR0cmlidXRlLlxuXG4gICAgICAgIEBtZXRob2Qgc3RyMnZhbHVlKHN0cilcbiAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAgICBAcmV0dXJucyB7bWl4ZWR9XG4gICAgICAgKiovXG4gICAgICAgc3RyMnZhbHVlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICB9LCBcbiAgICAgICBcbiAgICAgICAvKipcbiAgICAgICAgQ29udmVydHMgdmFsdWUgZm9yIHN1Ym1pdHRpbmcgdG8gc2VydmVyLiBSZXN1bHQgY2FuIGJlIHN0cmluZyBvciBvYmplY3QuXG5cbiAgICAgICAgQG1ldGhvZCB2YWx1ZTJzdWJtaXQodmFsdWUpIFxuICAgICAgICBAcGFyYW0ge21peGVkfSB2YWx1ZVxuICAgICAgICBAcmV0dXJucyB7bWl4ZWR9XG4gICAgICAgKiovXG4gICAgICAgdmFsdWUyc3VibWl0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgfSxcblxuICAgICAgIC8qKlxuICAgICAgICBTZXRzIHZhbHVlIG9mIGlucHV0LlxuXG4gICAgICAgIEBtZXRob2QgdmFsdWUyaW5wdXQodmFsdWUpIFxuICAgICAgICBAcGFyYW0ge21peGVkfSB2YWx1ZVxuICAgICAgICoqL1xuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC52YWwodmFsdWUpO1xuICAgICAgIH0sXG5cbiAgICAgICAvKipcbiAgICAgICAgUmV0dXJucyB2YWx1ZSBvZiBpbnB1dC4gVmFsdWUgY2FuIGJlIG9iamVjdCAoZS5nLiBkYXRlcGlja2VyKVxuXG4gICAgICAgIEBtZXRob2QgaW5wdXQydmFsdWUoKSBcbiAgICAgICAqKi9cbiAgICAgICBpbnB1dDJ2YWx1ZTogZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICByZXR1cm4gdGhpcy4kaW5wdXQudmFsKCk7XG4gICAgICAgfSwgXG5cbiAgICAgICAvKipcbiAgICAgICAgQWN0aXZhdGVzIGlucHV0LiBGb3IgdGV4dCBpdCBzZXRzIGZvY3VzLlxuXG4gICAgICAgIEBtZXRob2QgYWN0aXZhdGUoKSBcbiAgICAgICAqKi9cbiAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIGlmKHRoaXMuJGlucHV0LmlzKCc6dmlzaWJsZScpKSB7XG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5mb2N1cygpO1xuICAgICAgICAgICB9XG4gICAgICAgfSxcblxuICAgICAgIC8qKlxuICAgICAgICBDcmVhdGVzIGlucHV0LlxuXG4gICAgICAgIEBtZXRob2QgY2xlYXIoKSBcbiAgICAgICAqKi8gICAgICAgIFxuICAgICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdGhpcy4kaW5wdXQudmFsKG51bGwpO1xuICAgICAgIH0sXG5cbiAgICAgICAvKipcbiAgICAgICAgbWV0aG9kIHRvIGVzY2FwZSBodG1sLlxuICAgICAgICoqL1xuICAgICAgIGVzY2FwZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgIHJldHVybiAkKCc8ZGl2PicpLnRleHQoc3RyKS5odG1sKCk7XG4gICAgICAgfSxcbiAgICAgICBcbiAgICAgICAvKipcbiAgICAgICAgYXR0YWNoIGhhbmRsZXIgdG8gYXV0b21hdGljYWxseSBzdWJtaXQgZm9ybSB3aGVuIHZhbHVlIGNoYW5nZWQgKHVzZWZ1bCB3aGVuIGJ1dHRvbnMgbm90IHNob3duKVxuICAgICAgICoqL1xuICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qKlxuICAgICAgIEFkZGl0aW9uYWwgYWN0aW9ucyB3aGVuIGRlc3Ryb3lpbmcgZWxlbWVudCBcbiAgICAgICAqKi9cbiAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICB9LFxuXG4gICAgICAgLy8gLS0tLS0tLS0gaGVscGVyIGZ1bmN0aW9ucyAtLS0tLS0tLVxuICAgICAgIHNldENsYXNzOiBmdW5jdGlvbigpIHsgICAgICAgICAgXG4gICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5pbnB1dGNsYXNzKSB7XG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuaW5wdXRjbGFzcyk7IFxuICAgICAgICAgICB9IFxuICAgICAgIH0sXG5cbiAgICAgICBzZXRBdHRyOiBmdW5jdGlvbihhdHRyKSB7XG4gICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnNbYXR0cl0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLm9wdGlvbnNbYXR0cl0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LmF0dHIoYXR0ciwgdGhpcy5vcHRpb25zW2F0dHJdKTtcbiAgICAgICAgICAgfSBcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIG9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICAgICB9XG4gICAgICAgXG4gICAgfTtcbiAgICAgICAgXG4gICAgQWJzdHJhY3RJbnB1dC5kZWZhdWx0cyA9IHsgIFxuICAgICAgICAvKipcbiAgICAgICAgSFRNTCB0ZW1wbGF0ZSBvZiBpbnB1dC4gTm9ybWFsbHkgeW91IHNob3VsZCBub3QgY2hhbmdlIGl0LlxuXG4gICAgICAgIEBwcm9wZXJ0eSB0cGwgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAnJ1xuICAgICAgICAqKi8gICBcbiAgICAgICAgdHBsOiAnJyxcbiAgICAgICAgLyoqXG4gICAgICAgIENTUyBjbGFzcyBhdXRvbWF0aWNhbGx5IGFwcGxpZWQgdG8gaW5wdXRcbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBpbnB1dGNsYXNzIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgaW5wdXRjbGFzczogbnVsbCxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBJZiBgdHJ1ZWAgLSBodG1sIHdpbGwgYmUgZXNjYXBlZCBpbiBjb250ZW50IG9mIGVsZW1lbnQgdmlhICQudGV4dCgpIG1ldGhvZC4gIFxuICAgICAgICBJZiBgZmFsc2VgIC0gaHRtbCB3aWxsIG5vdCBiZSBlc2NhcGVkLCAkLmh0bWwoKSB1c2VkLiAgXG4gICAgICAgIFdoZW4geW91IHVzZSBvd24gYGRpc3BsYXlgIGZ1bmN0aW9uLCB0aGlzIG9wdGlvbiBvYnZpb3NseSBoYXMgbm8gZWZmZWN0LlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IGVzY2FwZSBcbiAgICAgICAgQHR5cGUgYm9vbGVhblxuICAgICAgICBAc2luY2UgMS41LjBcbiAgICAgICAgQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgZXNjYXBlOiB0cnVlLFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAvL3Njb3BlIGZvciBleHRlcm5hbCBtZXRob2RzIChlLmcuIHNvdXJjZSBkZWZpbmVkIGFzIGZ1bmN0aW9uKVxuICAgICAgICAvL2ZvciBpbnRlcm5hbCB1c2Ugb25seVxuICAgICAgICBzY29wZTogbnVsbCxcbiAgICAgICAgXG4gICAgICAgIC8vbmVlZCB0byByZS1kZWNsYXJlIHNob3didXR0b25zIGhlcmUgdG8gZ2V0IGl0J3MgdmFsdWUgZnJvbSBjb21tb24gY29uZmlnIChwYXNzZWQgb25seSBvcHRpb25zIGV4aXN0aW5nIGluIGRlZmF1bHRzKVxuICAgICAgICBzaG93YnV0dG9uczogdHJ1ZSBcbiAgICB9O1xuICAgIFxuICAgICQuZXh0ZW5kKCQuZm4uZWRpdGFibGV0eXBlcywge2Fic3RyYWN0aW5wdXQ6IEFic3RyYWN0SW5wdXR9KTtcbiAgICAgICAgXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5MaXN0IC0gYWJzdHJhY3QgY2xhc3MgZm9yIGlucHV0cyB0aGF0IGhhdmUgc291cmNlIG9wdGlvbiBsb2FkZWQgZnJvbSBqcyBhcnJheSBvciB2aWEgYWpheFxuXG5AY2xhc3MgbGlzdFxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuKiovXG4oZnVuY3Rpb24gKCQpIHtcblxuICAgIHZhciBMaXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICBcbiAgICB9O1xuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoTGlzdCwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQpO1xuXG4gICAgJC5leHRlbmQoTGlzdC5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XG5cbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5vblNvdXJjZVJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckxpc3QoKTtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvciA9IHRoaXMub3B0aW9ucy5zb3VyY2VFcnJvcjtcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBodG1sMnZhbHVlOiBmdW5jdGlvbiAoaHRtbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vY2FuJ3Qgc2V0IHZhbHVlIGJ5IHRleHRcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHZhbHVlMmh0bWw6IGZ1bmN0aW9uICh2YWx1ZSwgZWxlbWVudCwgZGlzcGxheSwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBkZWZlcnJlZCA9ICQuRGVmZXJyZWQoKSxcbiAgICAgICAgICAgICAgICBzdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZih0eXBlb2YgZGlzcGxheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jdXN0b20gZGlzcGxheSBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkuY2FsbChlbGVtZW50LCB2YWx1ZSwgdGhpcy5zb3VyY2VEYXRhLCByZXNwb25zZSk7IFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZTJodG1sRmluYWwodmFsdWUsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vZm9yIG51bGwgdmFsdWUganVzdCBjYWxsIHN1Y2Nlc3Mgd2l0aG91dCBsb2FkaW5nIHNvdXJjZVxuICAgICAgICAgICAgaWYodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgIHN1Y2Nlc3MuY2FsbCh0aGlzKTsgICBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICB0aGlzLm9uU291cmNlUmVhZHkoc3VjY2VzcywgZnVuY3Rpb24gKCkgeyBkZWZlcnJlZC5yZXNvbHZlKCk7IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuICAgICAgICB9LCAgXG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLSBhZGRpdGlvbmFsIGZ1bmN0aW9ucyAtLS0tLS0tLS0tLS1cblxuICAgICAgICBvblNvdXJjZVJlYWR5OiBmdW5jdGlvbiAoc3VjY2VzcywgZXJyb3IpIHtcbiAgICAgICAgICAgIC8vcnVuIHNvdXJjZSBpZiBpdCBmdW5jdGlvblxuICAgICAgICAgICAgdmFyIHNvdXJjZTtcbiAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24odGhpcy5vcHRpb25zLnNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSB0aGlzLm9wdGlvbnMuc291cmNlLmNhbGwodGhpcy5vcHRpb25zLnNjb3BlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZURhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgIC8vbm90ZTogaWYgZnVuY3Rpb24gcmV0dXJucyB0aGUgc2FtZSBzb3VyY2UgYXMgVVJMIC0gc291cmNlRGF0YSB3aWxsIGJlIHRha2VuIGZyb20gY2FoY2UgYW5kIG5vIGV4dHJhIHJlcXVlc3QgcGVyZm9ybWVkXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHRoaXMub3B0aW9ucy5zb3VyY2U7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaWYgYWxscmVhZHkgbG9hZGVkIGp1c3QgY2FsbCBzdWNjZXNzXG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuc291cmNlQ2FjaGUgJiYgJC5pc0FycmF5KHRoaXMuc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy90cnkgcGFyc2UganNvbiBpbiBzaW5nbGUgcXVvdGVzIChmb3IgZG91YmxlIHF1b3RlcyBqcXVlcnkgZG9lcyBhdXRvbWF0aWNhbGx5KVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSAkLmZuLmVkaXRhYmxldXRpbHMudHJ5UGFyc2VKc29uKHNvdXJjZSwgZmFsc2UpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGVycm9yLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL2xvYWRpbmcgZnJvbSB1cmxcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vdHJ5IHRvIGdldCBzb3VyY2VEYXRhIGZyb20gY2FjaGVcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuc291cmNlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhY2hlSUQgPSBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghJChkb2N1bWVudCkuZGF0YShjYWNoZUlEKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJChkb2N1bWVudCkuZGF0YShjYWNoZUlELCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FjaGUgPSAkKGRvY3VtZW50KS5kYXRhKGNhY2hlSUQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9yIGNhY2hlZCBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZS5sb2FkaW5nID09PSBmYWxzZSAmJiBjYWNoZS5zb3VyY2VEYXRhKSB7IC8vdGFrZSBzb3VyY2UgZnJvbSBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gY2FjaGUuc291cmNlRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9QcmVwZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FjaGUubG9hZGluZyA9PT0gdHJ1ZSkgeyAvL2NhY2hlIGlzIGxvYWRpbmcsIHB1dCBjYWxsYmFjayBpbiBzdGFjayB0byBiZSBjYWxsZWQgbGF0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmNhbGxiYWNrcy5wdXNoKCQucHJveHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlRGF0YSA9IGNhY2hlLnNvdXJjZURhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1ByZXBlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYWxzbyBjb2xsZWN0aW5nIGVycm9yIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuZXJyX2NhbGxiYWNrcy5wdXNoKCQucHJveHkoZXJyb3IsIHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgLy9ubyBjYWNoZSB5ZXQsIGFjdGl2YXRlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmNhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUuZXJyX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vYWpheE9wdGlvbnMgZm9yIHNvdXJjZS4gQ2FuIGJlIG92ZXJ3cml0dGVuIGJ0IG9wdGlvbnMuc291cmNlT3B0aW9uc1xuICAgICAgICAgICAgICAgIHZhciBhamF4T3B0aW9ucyA9ICQuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdnZXQnLFxuICAgICAgICAgICAgICAgICAgICBjYWNoZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6ICQucHJveHkoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gdGhpcy5tYWtlQXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZigkLmlzQXJyYXkodGhpcy5zb3VyY2VEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhY2hlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vc3RvcmUgcmVzdWx0IGluIGNhY2hlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLnNvdXJjZURhdGEgPSB0aGlzLnNvdXJjZURhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcnVuIHN1Y2Nlc3MgY2FsbGJhY2tzIGZvciBvdGhlciBmaWVsZHMgd2FpdGluZyBmb3IgdGhpcyBzb3VyY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGNhY2hlLmNhbGxiYWNrcywgZnVuY3Rpb24gKCkgeyB0aGlzLmNhbGwoKTsgfSk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvUHJlcGVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3J1biBlcnJvciBjYWxsYmFja3MgZm9yIG90aGVyIGZpZWxkcyB3YWl0aW5nIGZvciB0aGlzIHNvdXJjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkLmVhY2goY2FjaGUuZXJyX2NhbGxiYWNrcywgZnVuY3Rpb24gKCkgeyB0aGlzLmNhbGwoKTsgfSk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiAkLnByb3h5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjYWNoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcnVuIGVycm9yIGNhbGxiYWNrcyBmb3Igb3RoZXIgZmllbGRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChjYWNoZS5lcnJfY2FsbGJhY2tzLCBmdW5jdGlvbiAoKSB7IHRoaXMuY2FsbCgpOyB9KTsgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLnNvdXJjZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vbG9hZGluZyBzb3VyY2VEYXRhIGZyb20gc2VydmVyXG4gICAgICAgICAgICAgICAgJC5hamF4KGFqYXhPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vb3B0aW9ucyBhcyBqc29uL2FycmF5XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gdGhpcy5tYWtlQXJyYXkoc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoJC5pc0FycmF5KHRoaXMuc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1ByZXBlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzcy5jYWxsKHRoaXMpOyAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGRvUHJlcGVuZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLnByZXBlbmQgPT09IG51bGwgfHwgdGhpcy5vcHRpb25zLnByZXBlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZighJC5pc0FycmF5KHRoaXMucHJlcGVuZERhdGEpKSB7XG4gICAgICAgICAgICAgICAgLy9ydW4gcHJlcGVuZCBpZiBpdCBpcyBmdW5jdGlvbiAob25jZSlcbiAgICAgICAgICAgICAgICBpZiAoJC5pc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5wcmVwZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucHJlcGVuZCA9IHRoaXMub3B0aW9ucy5wcmVwZW5kLmNhbGwodGhpcy5vcHRpb25zLnNjb3BlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vdHJ5IHBhcnNlIGpzb24gaW4gc2luZ2xlIHF1b3Rlc1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wcmVwZW5kID0gJC5mbi5lZGl0YWJsZXV0aWxzLnRyeVBhcnNlSnNvbih0aGlzLm9wdGlvbnMucHJlcGVuZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9jb252ZXJ0IHByZXBlbmQgZnJvbSBzdHJpbmcgdG8gb2JqZWN0XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMucHJlcGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnByZXBlbmQgPSB7Jyc6IHRoaXMub3B0aW9ucy5wcmVwZW5kfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5wcmVwZW5kRGF0YSA9IHRoaXMubWFrZUFycmF5KHRoaXMub3B0aW9ucy5wcmVwZW5kKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoJC5pc0FycmF5KHRoaXMucHJlcGVuZERhdGEpICYmICQuaXNBcnJheSh0aGlzLnNvdXJjZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gdGhpcy5wcmVwZW5kRGF0YS5jb25jYXQodGhpcy5zb3VyY2VEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICAgcmVuZGVycyBpbnB1dCBsaXN0XG4gICAgICAgICovXG4gICAgICAgIHJlbmRlckxpc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gdGhpcyBtZXRob2Qgc2hvdWxkIGJlIG92ZXJ3cml0dGVuIGluIGNoaWxkIGNsYXNzXG4gICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgICAvKlxuICAgICAgICAgc2V0IGVsZW1lbnQncyBodG1sIGJ5IHZhbHVlXG4gICAgICAgICovXG4gICAgICAgIHZhbHVlMmh0bWxGaW5hbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVyd3JpdHRlbiBpbiBjaGlsZCBjbGFzc1xuICAgICAgICB9LCAgICAgICAgXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogY29udmVydCBkYXRhIHRvIGFycmF5IHN1aXRhYmxlIGZvciBzb3VyY2VEYXRhLCBlLmcuIFt7dmFsdWU6IDEsIHRleHQ6ICdhYmMnfSwgey4uLn1dXG4gICAgICAgICovXG4gICAgICAgIG1ha2VBcnJheTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGNvdW50LCBvYmosIHJlc3VsdCA9IFtdLCBpdGVtLCBpdGVyYXRlSXRlbTtcbiAgICAgICAgICAgIGlmKCFkYXRhIHx8IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoJC5pc0FycmF5KGRhdGEpKSB7IC8vYXJyYXlcbiAgICAgICAgICAgICAgICAvKiBcbiAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB0byBpdGVyYXRlIGluc2lkZSBpdGVtIG9mIGFycmF5IGlmIGl0ZW0gaXMgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAgIENhY2x1bGF0ZXMgY291bnQgb2Yga2V5cyBpbiBpdGVtIGFuZCBzdG9yZSBpbiBvYmouIFxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaXRlcmF0ZUl0ZW0gPSBmdW5jdGlvbiAoaywgdikge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSB7dmFsdWU6IGssIHRleHQ6IHZ9O1xuICAgICAgICAgICAgICAgICAgICBpZihjb3VudCsrID49IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsvLyBleGl0IGZyb20gYGVhY2hgIGlmIGl0ZW0gaGFzIG1vcmUgdGhhbiBvbmUga2V5LlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBkYXRhW2ldOyBcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGl0ZW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDA7IC8vY291bnQgb2Yga2V5cyBpbnNpZGUgaXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGl0ZW0sIGl0ZXJhdGVJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vY2FzZTogW3t2YWwxOiAndGV4dDEnfSwge3ZhbDI6ICd0ZXh0Mn0gLi4uXVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY291bnQgPT09IDEpIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gob2JqKTsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jYXNlOiBbe3ZhbHVlOiAxLCB0ZXh0OiAndGV4dDEnfSwge3ZhbHVlOiAyLCB0ZXh0OiAndGV4dDInfSwgLi4uXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKGNvdW50ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmVtb3ZlZCBjaGVjayBvZiBleGlzdGFuY2U6IGl0ZW0uaGFzT3duUHJvcGVydHkoJ3ZhbHVlJykgJiYgaXRlbS5oYXNPd25Qcm9wZXJ0eSgndGV4dCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLmNoaWxkcmVuID0gdGhpcy5tYWtlQXJyYXkoaXRlbS5jaGlsZHJlbik7ICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jYXNlOiBbJ3RleHQxJywgJ3RleHQyJyAuLi5dXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7dmFsdWU6IGl0ZW0sIHRleHQ6IGl0ZW19KTsgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgeyAgLy9jYXNlOiB7dmFsMTogJ3RleHQxJywgdmFsMjogJ3RleHQyLCAuLi59XG4gICAgICAgICAgICAgICAgJC5lYWNoKGRhdGEsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHt2YWx1ZTogaywgdGV4dDogdn0pO1xuICAgICAgICAgICAgICAgIH0pOyAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgb3B0aW9uOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgaWYoa2V5ID09PSAnc291cmNlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlRGF0YSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihrZXkgPT09ICdwcmVwZW5kJykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJlcGVuZERhdGEgPSBudWxsO1xuICAgICAgICAgICAgfSAgICAgICAgICAgIFxuICAgICAgICB9ICAgICAgICBcblxuICAgIH0pOyAgICAgIFxuXG4gICAgTGlzdC5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dC5kZWZhdWx0cywge1xuICAgICAgICAvKipcbiAgICAgICAgU291cmNlIGRhdGEgZm9yIGxpc3QuICBcbiAgICAgICAgSWYgKiphcnJheSoqIC0gaXQgc2hvdWxkIGJlIGluIGZvcm1hdDogYFt7dmFsdWU6IDEsIHRleHQ6IFwidGV4dDFcIn0sIHt2YWx1ZTogMiwgdGV4dDogXCJ0ZXh0MlwifSwgLi4uXWAgIFxuICAgICAgICBGb3IgY29tcGFiaWxpdHksIG9iamVjdCBmb3JtYXQgaXMgYWxzbyBzdXBwb3J0ZWQ6IGB7XCIxXCI6IFwidGV4dDFcIiwgXCIyXCI6IFwidGV4dDJcIiAuLi59YCBidXQgaXQgZG9lcyBub3QgZ3VhcmFudGVlIGVsZW1lbnRzIG9yZGVyLlxuICAgICAgICBcbiAgICAgICAgSWYgKipzdHJpbmcqKiAtIGNvbnNpZGVyZWQgYWpheCB1cmwgdG8gbG9hZCBpdGVtcy4gSW4gdGhhdCBjYXNlIHJlc3VsdHMgd2lsbCBiZSBjYWNoZWQgZm9yIGZpZWxkcyB3aXRoIHRoZSBzYW1lIHNvdXJjZSBhbmQgbmFtZS4gU2VlIGFsc28gYHNvdXJjZUNhY2hlYCBvcHRpb24uXG4gICAgICAgICAgXG4gICAgICAgIElmICoqZnVuY3Rpb24qKiwgaXQgc2hvdWxkIHJldHVybiBkYXRhIGluIGZvcm1hdCBhYm92ZSAoc2luY2UgMS40LjApLlxuICAgICAgICBcbiAgICAgICAgU2luY2UgMS40LjEga2V5IGBjaGlsZHJlbmAgc3VwcG9ydGVkIHRvIHJlbmRlciBPUFRHUk9VUCAoZm9yICoqc2VsZWN0KiogaW5wdXQgb25seSkuICBcbiAgICAgICAgYFt7dGV4dDogXCJncm91cDFcIiwgY2hpbGRyZW46IFt7dmFsdWU6IDEsIHRleHQ6IFwidGV4dDFcIn0sIHt2YWx1ZTogMiwgdGV4dDogXCJ0ZXh0MlwifV19LCAuLi5dYCBcblxuXHRcdFxuICAgICAgICBAcHJvcGVydHkgc291cmNlIFxuICAgICAgICBAdHlwZSBzdHJpbmcgfCBhcnJheSB8IG9iamVjdCB8IGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHNvdXJjZTogbnVsbCwgXG4gICAgICAgIC8qKlxuICAgICAgICBEYXRhIGF1dG9tYXRpY2FsbHkgcHJlcGVuZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgZHJvcGRvd24gbGlzdC5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBwcmVwZW5kIFxuICAgICAgICBAdHlwZSBzdHJpbmcgfCBhcnJheSB8IG9iamVjdCB8IGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBwcmVwZW5kOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgIEVycm9yIG1lc3NhZ2Ugd2hlbiBsaXN0IGNhbm5vdCBiZSBsb2FkZWQgKGUuZy4gYWpheCBlcnJvcilcbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBzb3VyY2VFcnJvciBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IEVycm9yIHdoZW4gbG9hZGluZyBsaXN0XG4gICAgICAgICoqLyAgICAgICAgICBcbiAgICAgICAgc291cmNlRXJyb3I6ICdFcnJvciB3aGVuIGxvYWRpbmcgbGlzdCcsXG4gICAgICAgIC8qKlxuICAgICAgICBpZiA8Y29kZT50cnVlPC9jb2RlPiBhbmQgc291cmNlIGlzICoqc3RyaW5nIHVybCoqIC0gcmVzdWx0cyB3aWxsIGJlIGNhY2hlZCBmb3IgZmllbGRzIHdpdGggdGhlIHNhbWUgc291cmNlLiAgICBcbiAgICAgICAgVXNlZnVsbCBmb3IgZWRpdGFibGUgY29sdW1uIGluIGdyaWQgdG8gcHJldmVudCBleHRyYSByZXF1ZXN0cy5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBzb3VyY2VDYWNoZSBcbiAgICAgICAgQHR5cGUgYm9vbGVhblxuICAgICAgICBAZGVmYXVsdCB0cnVlXG4gICAgICAgIEBzaW5jZSAxLjIuMFxuICAgICAgICAqKi8gICAgICAgIFxuICAgICAgICBzb3VyY2VDYWNoZTogdHJ1ZSxcbiAgICAgICAgLyoqXG4gICAgICAgIEFkZGl0aW9uYWwgYWpheCBvcHRpb25zIHRvIGJlIHVzZWQgaW4gJC5hamF4KCkgd2hlbiBsb2FkaW5nIGxpc3QgZnJvbSBzZXJ2ZXIuXG4gICAgICAgIFVzZWZ1bCB0byBzZW5kIGV4dHJhIHBhcmFtZXRlcnMgKGBkYXRhYCBrZXkpIG9yIGNoYW5nZSByZXF1ZXN0IG1ldGhvZCAoYHR5cGVgIGtleSkuXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgc291cmNlT3B0aW9ucyBcbiAgICAgICAgQHR5cGUgb2JqZWN0fGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgQHNpbmNlIDEuNS4wXG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHNvdXJjZU9wdGlvbnM6IG51bGxcbiAgICB9KTtcblxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5saXN0ID0gTGlzdDsgICAgICBcblxufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qKlxuVGV4dCBpbnB1dFxuXG5AY2xhc3MgdGV4dFxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuQGZpbmFsXG5AZXhhbXBsZVxuPGEgaHJlZj1cIiNcIiBpZD1cInVzZXJuYW1lXCIgZGF0YS10eXBlPVwidGV4dFwiIGRhdGEtcGs9XCIxXCI+YXdlc29tZTwvYT5cbjxzY3JpcHQ+XG4kKGZ1bmN0aW9uKCl7XG4gICAgJCgnI3VzZXJuYW1lJykuZWRpdGFibGUoe1xuICAgICAgICB1cmw6ICcvcG9zdCcsXG4gICAgICAgIHRpdGxlOiAnRW50ZXIgdXNlcm5hbWUnXG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG4oZnVuY3Rpb24gKCQpIHtcblxuICAgIHZhciBUZXh0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCd0ZXh0Jywgb3B0aW9ucywgVGV4dC5kZWZhdWx0cyk7XG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KFRleHQsICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0KTtcblxuICAgICQuZXh0ZW5kKFRleHQucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIHRoaXMucmVuZGVyQ2xlYXIoKTtcbiAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3BsYWNlaG9sZGVyJyk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLiRpbnB1dC5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgJC5mbi5lZGl0YWJsZXV0aWxzLnNldEN1cnNvclBvc2l0aW9uKHRoaXMuJGlucHV0LmdldCgwKSwgdGhpcy4kaW5wdXQudmFsKCkubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZih0aGlzLnRvZ2dsZUNsZWFyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9nZ2xlQ2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvL3JlbmRlciBjbGVhciBidXR0b25cbiAgICAgICAgcmVuZGVyQ2xlYXI6ICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbGVhcikge1xuICAgICAgICAgICAgICAgdGhpcy4kY2xlYXIgPSAkKCc8c3BhbiBjbGFzcz1cImVkaXRhYmxlLWNsZWFyLXhcIj48L3NwYW4+Jyk7XG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5hZnRlcih0aGlzLiRjbGVhcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcygncGFkZGluZy1yaWdodCcsIDI0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAua2V5dXAoJC5wcm94eShmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2Fycm93cywgZW50ZXIsIHRhYiwgZXRjXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih+JC5pbkFycmF5KGUua2V5Q29kZSwgWzQwLDM4LDksMTMsMjddKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQudG9nZ2xlQ2xlYXIoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAucGFyZW50KCkuY3NzKCdwb3NpdGlvbicsICdyZWxhdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyLmNsaWNrKCQucHJveHkodGhpcy5jbGVhciwgdGhpcykpOyAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHBvc3RyZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIC8vbm93IGBjbGVhcmAgaXMgcG9zaXRpb25lZCB2aWEgY3NzXG4gICAgICAgICAgICBpZih0aGlzLiRjbGVhcikge1xuICAgICAgICAgICAgICAgIC8vY2FuIHBvc2l0aW9uIGNsZWFyIGJ1dHRvbiBvbmx5IGhlcmUsIHdoZW4gZm9ybSBpcyBzaG93biBhbmQgaGVpZ2h0IGNhbiBiZSBjYWxjdWxhdGVkXG4vLyAgICAgICAgICAgICAgICB2YXIgaCA9IHRoaXMuJGlucHV0Lm91dGVySGVpZ2h0KHRydWUpIHx8IDIwLFxuICAgICAgICAgICAgICAgIHZhciBoID0gdGhpcy4kY2xlYXIucGFyZW50KCkuaGVpZ2h0KCksXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gKGggLSB0aGlzLiRjbGVhci5oZWlnaHQoKSkgLyAyO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL3RoaXMuJGNsZWFyLmNzcyh7Ym90dG9tOiBkZWx0YSwgcmlnaHQ6IGRlbHRhfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAqLyBcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8vc2hvdyAvIGhpZGUgY2xlYXIgYnV0dG9uXG4gICAgICAgIHRvZ2dsZUNsZWFyOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZighdGhpcy4kY2xlYXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBsZW4gPSB0aGlzLiRpbnB1dC52YWwoKS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdmlzaWJsZSA9IHRoaXMuJGNsZWFyLmlzKCc6dmlzaWJsZScpO1xuICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGxlbiAmJiAhdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyLnNob3coKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCFsZW4gJiYgdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyLmhpZGUoKTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIHRoaXMuJGNsZWFyLmhpZGUoKTtcbiAgICAgICAgICAgdGhpcy4kaW5wdXQudmFsKCcnKS5mb2N1cygpO1xuICAgICAgICB9ICAgICAgICAgIFxuICAgIH0pO1xuXG4gICAgVGV4dC5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dC5kZWZhdWx0cywge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IHRwbCBcbiAgICAgICAgQGRlZmF1bHQgPGlucHV0IHR5cGU9XCJ0ZXh0XCI+XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB0cGw6ICc8aW5wdXQgdHlwZT1cInRleHRcIj4nLFxuICAgICAgICAvKipcbiAgICAgICAgUGxhY2Vob2xkZXIgYXR0cmlidXRlIG9mIGlucHV0LiBTaG93biB3aGVuIGlucHV0IGlzIGVtcHR5LlxuXG4gICAgICAgIEBwcm9wZXJ0eSBwbGFjZWhvbGRlciBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovICAgICAgICAgICAgIFxuICAgICAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICBXaGV0aGVyIHRvIHNob3cgYGNsZWFyYCBidXR0b24gXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgY2xlYXIgXG4gICAgICAgIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgQGRlZmF1bHQgdHJ1ZSAgICAgICAgXG4gICAgICAgICoqL1xuICAgICAgICBjbGVhcjogdHJ1ZVxuICAgIH0pO1xuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQgPSBUZXh0O1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5UZXh0YXJlYSBpbnB1dFxuXG5AY2xhc3MgdGV4dGFyZWFcbkBleHRlbmRzIGFic3RyYWN0aW5wdXRcbkBmaW5hbFxuQGV4YW1wbGVcbjxhIGhyZWY9XCIjXCIgaWQ9XCJjb21tZW50c1wiIGRhdGEtdHlwZT1cInRleHRhcmVhXCIgZGF0YS1waz1cIjFcIj5hd2Vzb21lIGNvbW1lbnQhPC9hPlxuPHNjcmlwdD5cbiQoZnVuY3Rpb24oKXtcbiAgICAkKCcjY29tbWVudHMnKS5lZGl0YWJsZSh7XG4gICAgICAgIHVybDogJy9wb3N0JyxcbiAgICAgICAgdGl0bGU6ICdFbnRlciBjb21tZW50cycsXG4gICAgICAgIHJvd3M6IDEwXG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG4oZnVuY3Rpb24gKCQpIHtcblxuICAgIHZhciBUZXh0YXJlYSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdCgndGV4dGFyZWEnLCBvcHRpb25zLCBUZXh0YXJlYS5kZWZhdWx0cyk7XG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KFRleHRhcmVhLCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dCk7XG5cbiAgICAkLmV4dGVuZChUZXh0YXJlYS5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNldENsYXNzKCk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3BsYWNlaG9sZGVyJyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3Jvd3MnKTsgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9jdHJsICsgZW50ZXJcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmtleWRvd24oZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5jdHJsS2V5ICYmIGUud2hpY2ggPT09IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgnZm9ybScpLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAvL3VzaW5nIGB3aGl0ZS1zcGFjZTogcHJlLXdyYXBgIHNvbHZlcyBcXG4gIDwtLT4gQlIgY29udmVyc2lvbiB2ZXJ5IGVsZWdhbnQhXG4gICAgICAgLyogXG4gICAgICAgdmFsdWUyaHRtbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBodG1sID0gJycsIGxpbmVzO1xuICAgICAgICAgICAgaWYodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBsaW5lcyA9IHZhbHVlLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZXNbaV0gPSAkKCc8ZGl2PicpLnRleHQobGluZXNbaV0pLmh0bWwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaHRtbCA9IGxpbmVzLmpvaW4oJzxicj4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICQoZWxlbWVudCkuaHRtbChodG1sKTtcbiAgICAgICAgfSxcbiAgICAgICBcbiAgICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICAgaWYoIWh0bWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoU3RyaW5nLmZyb21DaGFyQ29kZSgxMCksICdnJyk7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBodG1sLnNwbGl0KC88YnJcXHMqXFwvPz4vaSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSAkKCc8ZGl2PicpLmh0bWwobGluZXNbaV0pLnRleHQoKTtcblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBuZXdsaW5lIGNoYXJhY3RlcnMgKFxcbikgdG8gYXZvaWQgdGhlbSBiZWluZyBjb252ZXJ0ZWQgYnkgdmFsdWUyaHRtbCgpIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHRodXMgYWRkaW5nIGV4dHJhIDxicj4gdGFnc1xuICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UocmVnZXgsICcnKTtcblxuICAgICAgICAgICAgICAgIGxpbmVzW2ldID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xuICAgICAgICB9LFxuICAgICAgICAgKi9cbiAgICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQucHJvdG90eXBlLmFjdGl2YXRlLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFRleHRhcmVhLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0LmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsXG4gICAgICAgIEBkZWZhdWx0IDx0ZXh0YXJlYT48L3RleHRhcmVhPlxuICAgICAgICAqKi9cbiAgICAgICAgdHBsOic8dGV4dGFyZWE+PC90ZXh0YXJlYT4nLFxuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IGlucHV0Y2xhc3NcbiAgICAgICAgQGRlZmF1bHQgaW5wdXQtbGFyZ2VcbiAgICAgICAgKiovXG4gICAgICAgIGlucHV0Y2xhc3M6ICdpbnB1dC1sYXJnZScsXG4gICAgICAgIC8qKlxuICAgICAgICBQbGFjZWhvbGRlciBhdHRyaWJ1dGUgb2YgaW5wdXQuIFNob3duIHdoZW4gaW5wdXQgaXMgZW1wdHkuXG5cbiAgICAgICAgQHByb3BlcnR5IHBsYWNlaG9sZGVyXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICAgICAgLyoqXG4gICAgICAgIE51bWJlciBvZiByb3dzIGluIHRleHRhcmVhXG5cbiAgICAgICAgQHByb3BlcnR5IHJvd3NcbiAgICAgICAgQHR5cGUgaW50ZWdlclxuICAgICAgICBAZGVmYXVsdCA3XG4gICAgICAgICoqLyAgICAgICAgXG4gICAgICAgIHJvd3M6IDcgICAgICAgIFxuICAgIH0pO1xuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHRhcmVhID0gVGV4dGFyZWE7XG5cbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcblNlbGVjdCAoZHJvcGRvd24pXG5cbkBjbGFzcyBzZWxlY3RcbkBleHRlbmRzIGxpc3RcbkBmaW5hbFxuQGV4YW1wbGVcbjxhIGhyZWY9XCIjXCIgaWQ9XCJzdGF0dXNcIiBkYXRhLXR5cGU9XCJzZWxlY3RcIiBkYXRhLXBrPVwiMVwiIGRhdGEtdXJsPVwiL3Bvc3RcIiBkYXRhLXRpdGxlPVwiU2VsZWN0IHN0YXR1c1wiPjwvYT5cbjxzY3JpcHQ+XG4kKGZ1bmN0aW9uKCl7XG4gICAgJCgnI3N0YXR1cycpLmVkaXRhYmxlKHtcbiAgICAgICAgdmFsdWU6IDIsICAgIFxuICAgICAgICBzb3VyY2U6IFtcbiAgICAgICAgICAgICAge3ZhbHVlOiAxLCB0ZXh0OiAnQWN0aXZlJ30sXG4gICAgICAgICAgICAgIHt2YWx1ZTogMiwgdGV4dDogJ0Jsb2NrZWQnfSxcbiAgICAgICAgICAgICAge3ZhbHVlOiAzLCB0ZXh0OiAnRGVsZXRlZCd9XG4gICAgICAgICAgIF1cbiAgICB9KTtcbn0pO1xuPC9zY3JpcHQ+XG4qKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcbiAgICBcbiAgICB2YXIgU2VsZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdzZWxlY3QnLCBvcHRpb25zLCBTZWxlY3QuZGVmYXVsdHMpO1xuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChTZWxlY3QsICQuZm4uZWRpdGFibGV0eXBlcy5saXN0KTtcblxuICAgICQuZXh0ZW5kKFNlbGVjdC5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyTGlzdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5lbXB0eSgpO1xuXG4gICAgICAgICAgICB2YXIgZmlsbEl0ZW1zID0gZnVuY3Rpb24oJGVsLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHI7XG4gICAgICAgICAgICAgICAgaWYoJC5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGRhdGFbaV0uY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmxhYmVsID0gZGF0YVtpXS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRlbC5hcHBlbmQoZmlsbEl0ZW1zKCQoJzxvcHRncm91cD4nLCBhdHRyKSwgZGF0YVtpXS5jaGlsZHJlbikpOyBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci52YWx1ZSA9IGRhdGFbaV0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZGF0YVtpXS5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGVsLmFwcGVuZCgkKCc8b3B0aW9uPicsIGF0dHIpLnRleHQoZGF0YVtpXS50ZXh0KSk7IFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAkZWw7XG4gICAgICAgICAgICB9OyAgICAgICAgXG5cbiAgICAgICAgICAgIGZpbGxJdGVtcyh0aGlzLiRpbnB1dCwgdGhpcy5zb3VyY2VEYXRhKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2VudGVyIHN1Ym1pdFxuICAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ2tleWRvd24uZWRpdGFibGUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAxMykge1xuICAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKS5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTsgICAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICBcbiAgICAgICAgdmFsdWUyaHRtbEZpbmFsOiBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHRleHQgPSAnJywgXG4gICAgICAgICAgICAgICAgaXRlbXMgPSAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCB0aGlzLnNvdXJjZURhdGEpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IGl0ZW1zWzBdLnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vJChlbGVtZW50KS50ZXh0KHRleHQpO1xuICAgICAgICAgICAgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQucHJvdG90eXBlLnZhbHVlMmh0bWwuY2FsbCh0aGlzLCB0ZXh0LCBlbGVtZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQub2ZmKCdrZXlkb3duLmVkaXRhYmxlJykub24oJ2NoYW5nZS5lZGl0YWJsZScsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCdmb3JtJykuc3VibWl0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pOyAgICAgIFxuXG4gICAgU2VsZWN0LmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5saXN0LmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsIFxuICAgICAgICBAZGVmYXVsdCA8c2VsZWN0Pjwvc2VsZWN0PlxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgdHBsOic8c2VsZWN0Pjwvc2VsZWN0PidcbiAgICB9KTtcblxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5zZWxlY3QgPSBTZWxlY3Q7ICAgICAgXG5cbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKipcbkxpc3Qgb2YgY2hlY2tib3hlcy4gXG5JbnRlcm5hbGx5IHZhbHVlIHN0b3JlZCBhcyBqYXZhc2NyaXB0IGFycmF5IG9mIHZhbHVlcy5cblxuQGNsYXNzIGNoZWNrbGlzdFxuQGV4dGVuZHMgbGlzdFxuQGZpbmFsXG5AZXhhbXBsZVxuPGEgaHJlZj1cIiNcIiBpZD1cIm9wdGlvbnNcIiBkYXRhLXR5cGU9XCJjaGVja2xpc3RcIiBkYXRhLXBrPVwiMVwiIGRhdGEtdXJsPVwiL3Bvc3RcIiBkYXRhLXRpdGxlPVwiU2VsZWN0IG9wdGlvbnNcIj48L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNvcHRpb25zJykuZWRpdGFibGUoe1xuICAgICAgICB2YWx1ZTogWzIsIDNdLCAgICBcbiAgICAgICAgc291cmNlOiBbXG4gICAgICAgICAgICAgIHt2YWx1ZTogMSwgdGV4dDogJ29wdGlvbjEnfSxcbiAgICAgICAgICAgICAge3ZhbHVlOiAyLCB0ZXh0OiAnb3B0aW9uMid9LFxuICAgICAgICAgICAgICB7dmFsdWU6IDMsIHRleHQ6ICdvcHRpb24zJ31cbiAgICAgICAgICAgXVxuICAgIH0pO1xufSk7XG48L3NjcmlwdD5cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgO1xuICAgIFxuICAgIHZhciBDaGVja2xpc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2NoZWNrbGlzdCcsIG9wdGlvbnMsIENoZWNrbGlzdC5kZWZhdWx0cyk7XG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KENoZWNrbGlzdCwgJC5mbi5lZGl0YWJsZXR5cGVzLmxpc3QpO1xuXG4gICAgJC5leHRlbmQoQ2hlY2tsaXN0LnByb3RvdHlwZSwge1xuICAgICAgICByZW5kZXJMaXN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciAkbGFiZWwsICRkaXY7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJHRwbC5lbXB0eSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZighJC5pc0FycmF5KHRoaXMuc291cmNlRGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuc291cmNlRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICRsYWJlbCA9ICQoJzxsYWJlbD4nKS5hcHBlbmQoJCgnPGlucHV0PicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNvdXJjZURhdGFbaV0udmFsdWUgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8c3Bhbj4nKS50ZXh0KCcgJyt0aGlzLnNvdXJjZURhdGFbaV0udGV4dCkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICQoJzxkaXY+JykuYXBwZW5kKCRsYWJlbCkuYXBwZW5kVG8odGhpcy4kdHBsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kaW5wdXQgPSB0aGlzLiR0cGwuZmluZCgnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJyk7XG4gICAgICAgICAgICB0aGlzLnNldENsYXNzKCk7XG4gICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgdmFsdWUyc3RyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICByZXR1cm4gJC5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNvcnQoKS5qb2luKCQudHJpbSh0aGlzLm9wdGlvbnMuc2VwYXJhdG9yKSkgOiAnJztcbiAgICAgICB9LCAgXG4gICAgICAgXG4gICAgICAgLy9wYXJzZSBzZXBhcmF0ZWQgc3RyaW5nXG4gICAgICAgIHN0cjJ2YWx1ZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgIHZhciByZWcsIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgaWYodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgcmVnID0gbmV3IFJlZ0V4cCgnXFxcXHMqJyskLnRyaW0odGhpcy5vcHRpb25zLnNlcGFyYXRvcikrJ1xcXFxzKicpO1xuICAgICAgICAgICAgICAgdmFsdWUgPSBzdHIuc3BsaXQocmVnKTtcbiAgICAgICAgICAgfSBlbHNlIGlmKCQuaXNBcnJheShzdHIpKSB7XG4gICAgICAgICAgICAgICB2YWx1ZSA9IHN0cjsgXG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICB2YWx1ZSA9IFtzdHJdO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSwgICAgICAgXG4gICAgICAgXG4gICAgICAgLy9zZXQgY2hlY2tlZCBvbiByZXF1aXJlZCBjaGVja2JveGVzXG4gICAgICAgdmFsdWUyaW5wdXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5wcm9wKCdjaGVja2VkJywgZmFsc2UpO1xuICAgICAgICAgICAgaWYoJC5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LmVhY2goZnVuY3Rpb24oaSwgZWwpIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgJGVsID0gJChlbCk7XG4gICAgICAgICAgICAgICAgICAgLy8gY2Fubm90IHVzZSAkLmluQXJyYXkgYXMgaXQgcGVyZm9ybXMgc3RyaWN0IGNvbXBhcmlzb25cbiAgICAgICAgICAgICAgICAgICAkLmVhY2godmFsdWUsIGZ1bmN0aW9uKGosIHZhbCl7XG4gICAgICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGVxZXE6IHRydWUqL1xuICAgICAgICAgICAgICAgICAgICAgICBpZigkZWwudmFsKCkgPT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIC8qanNsaW50IGVxZXE6IGZhbHNlKi8gICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICRlbC5wcm9wKCdjaGVja2VkJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgIH0pOyBcbiAgICAgICAgICAgIH0gIFxuICAgICAgICB9LCAgXG4gICAgICAgIFxuICAgICAgIGlucHV0MnZhbHVlOiBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgIHZhciBjaGVja2VkID0gW107XG4gICAgICAgICAgIHRoaXMuJGlucHV0LmZpbHRlcignOmNoZWNrZWQnKS5lYWNoKGZ1bmN0aW9uKGksIGVsKSB7XG4gICAgICAgICAgICAgICBjaGVja2VkLnB1c2goJChlbCkudmFsKCkpO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgICAgcmV0dXJuIGNoZWNrZWQ7XG4gICAgICAgfSwgICAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAvL2NvbGxlY3QgdGV4dCBvZiBjaGVja2VkIGJveGVzXG4gICAgICAgIHZhbHVlMmh0bWxGaW5hbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgdmFyIGh0bWwgPSBbXSxcbiAgICAgICAgICAgICAgIGNoZWNrZWQgPSAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCB0aGlzLnNvdXJjZURhdGEpLFxuICAgICAgICAgICAgICAgZXNjYXBlID0gdGhpcy5vcHRpb25zLmVzY2FwZTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICBpZihjaGVja2VkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgJC5lYWNoKGNoZWNrZWQsIGZ1bmN0aW9uKGksIHYpIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGVzY2FwZSA/ICQuZm4uZWRpdGFibGV1dGlscy5lc2NhcGUodi50ZXh0KSA6IHYudGV4dDsgXG4gICAgICAgICAgICAgICAgICAgaHRtbC5wdXNoKHRleHQpOyBcbiAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgJChlbGVtZW50KS5odG1sKGh0bWwuam9pbignPGJyPicpKTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICQoZWxlbWVudCkuZW1wdHkoKTsgXG4gICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC5maXJzdCgpLmZvY3VzKCk7XG4gICAgICAgfSxcbiAgICAgICBcbiAgICAgICBhdXRvc3VibWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ2tleWRvd24nLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAxMykge1xuICAgICAgICAgICAgICAgICAgICQodGhpcykuY2xvc2VzdCgnZm9ybScpLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICB9KTtcbiAgICAgICB9XG4gICAgfSk7ICAgICAgXG5cbiAgICBDaGVja2xpc3QuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLmxpc3QuZGVmYXVsdHMsIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSB0cGwgXG4gICAgICAgIEBkZWZhdWx0IDxkaXY+PC9kaXY+XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB0cGw6JzxkaXYgY2xhc3M9XCJlZGl0YWJsZS1jaGVja2xpc3RcIj48L2Rpdj4nLFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBpbnB1dGNsYXNzIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgaW5wdXRjbGFzczogbnVsbCwgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFNlcGFyYXRvciBvZiB2YWx1ZXMgd2hlbiByZWFkaW5nIGZyb20gYGRhdGEtdmFsdWVgIGF0dHJpYnV0ZVxuXG4gICAgICAgIEBwcm9wZXJ0eSBzZXBhcmF0b3IgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAnLCdcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHNlcGFyYXRvcjogJywnXG4gICAgfSk7XG5cbiAgICAkLmZuLmVkaXRhYmxldHlwZXMuY2hlY2tsaXN0ID0gQ2hlY2tsaXN0OyAgICAgIFxuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5IVE1MNSBpbnB1dCB0eXBlcy5cbkZvbGxvd2luZyB0eXBlcyBhcmUgc3VwcG9ydGVkOlxuXG4qIHBhc3N3b3JkXG4qIGVtYWlsXG4qIHVybFxuKiB0ZWxcbiogbnVtYmVyXG4qIHJhbmdlXG4qIHRpbWVcblxuTGVhcm4gbW9yZSBhYm91dCBodG1sNSBpbnB1dHM6ICBcbmh0dHA6Ly93d3cudzMub3JnL3dpa2kvSFRNTDVfZm9ybV9hZGRpdGlvbnMgIFxuVG8gY2hlY2sgYnJvd3NlciBjb21wYXRpYmlsaXR5IHBsZWFzZSBzZWU6ICBcbmh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSFRNTC9FbGVtZW50L0lucHV0XG4gICAgICAgICAgICBcbkBjbGFzcyBodG1sNXR5cGVzIFxuQGV4dGVuZHMgdGV4dFxuQGZpbmFsXG5Ac2luY2UgMS4zLjBcbkBleGFtcGxlXG48YSBocmVmPVwiI1wiIGlkPVwiZW1haWxcIiBkYXRhLXR5cGU9XCJlbWFpbFwiIGRhdGEtcGs9XCIxXCI+YWRtaW5AZXhhbXBsZS5jb208L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNlbWFpbCcpLmVkaXRhYmxlKHtcbiAgICAgICAgdXJsOiAnL3Bvc3QnLFxuICAgICAgICB0aXRsZTogJ0VudGVyIGVtYWlsJ1xuICAgIH0pO1xufSk7XG48L3NjcmlwdD5cbioqL1xuXG4vKipcbkBwcm9wZXJ0eSB0cGwgXG5AZGVmYXVsdCBkZXBlbmRzIG9uIHR5cGVcbioqLyBcblxuLypcblBhc3N3b3JkXG4qL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgO1xuICAgIFxuICAgIHZhciBQYXNzd29yZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdCgncGFzc3dvcmQnLCBvcHRpb25zLCBQYXNzd29yZC5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChQYXNzd29yZCwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQpO1xuICAgICQuZXh0ZW5kKFBhc3N3b3JkLnByb3RvdHlwZSwge1xuICAgICAgIC8vZG8gbm90IGRpc3BsYXkgcGFzc3dvcmQsIHNob3cgJ1toaWRkZW5dJyBpbnN0ZWFkXG4gICAgICAgdmFsdWUyaHRtbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgaWYodmFsdWUpIHtcbiAgICAgICAgICAgICAgICQoZWxlbWVudCkudGV4dCgnW2hpZGRlbl0nKTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICQoZWxlbWVudCkuZW1wdHkoKTsgXG4gICAgICAgICAgIH1cbiAgICAgICB9LFxuICAgICAgIC8vYXMgcGFzc3dvcmQgbm90IGRpc3BsYXllZCwgc2hvdWxkIG5vdCBzZXQgdmFsdWUgYnkgaHRtbFxuICAgICAgIGh0bWwydmFsdWU6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgfSAgICAgICBcbiAgICB9KTsgICAgXG4gICAgUGFzc3dvcmQuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQuZGVmYXVsdHMsIHtcbiAgICAgICAgdHBsOiAnPGlucHV0IHR5cGU9XCJwYXNzd29yZFwiPidcbiAgICB9KTtcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMucGFzc3dvcmQgPSBQYXNzd29yZDtcbn0od2luZG93LmpRdWVyeSkpO1xuXG5cbi8qXG5FbWFpbFxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcbiAgICBcbiAgICB2YXIgRW1haWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2VtYWlsJywgb3B0aW9ucywgRW1haWwuZGVmYXVsdHMpO1xuICAgIH07XG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoRW1haWwsICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0KTtcbiAgICBFbWFpbC5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmVkaXRhYmxldHlwZXMudGV4dC5kZWZhdWx0cywge1xuICAgICAgICB0cGw6ICc8aW5wdXQgdHlwZT1cImVtYWlsXCI+J1xuICAgIH0pO1xuICAgICQuZm4uZWRpdGFibGV0eXBlcy5lbWFpbCA9IEVtYWlsO1xufSh3aW5kb3cualF1ZXJ5KSk7XG5cblxuLypcblVybFxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcbiAgICBcbiAgICB2YXIgVXJsID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCd1cmwnLCBvcHRpb25zLCBVcmwuZGVmYXVsdHMpO1xuICAgIH07XG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoVXJsLCAkLmZuLmVkaXRhYmxldHlwZXMudGV4dCk7XG4gICAgVXJsLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0LmRlZmF1bHRzLCB7XG4gICAgICAgIHRwbDogJzxpbnB1dCB0eXBlPVwidXJsXCI+J1xuICAgIH0pO1xuICAgICQuZm4uZWRpdGFibGV0eXBlcy51cmwgPSBVcmw7XG59KHdpbmRvdy5qUXVlcnkpKTtcblxuXG4vKlxuVGVsXG4qL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgO1xuICAgIFxuICAgIHZhciBUZWwgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ3RlbCcsIG9wdGlvbnMsIFRlbC5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChUZWwsICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0KTtcbiAgICBUZWwuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQuZGVmYXVsdHMsIHtcbiAgICAgICAgdHBsOiAnPGlucHV0IHR5cGU9XCJ0ZWxcIj4nXG4gICAgfSk7XG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLnRlbCA9IFRlbDtcbn0od2luZG93LmpRdWVyeSkpO1xuXG5cbi8qXG5OdW1iZXJcbiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICA7XG4gICAgXG4gICAgdmFyIE51bWJlcklucHV0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdudW1iZXInLCBvcHRpb25zLCBOdW1iZXJJbnB1dC5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChOdW1iZXJJbnB1dCwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQpO1xuICAgICQuZXh0ZW5kKE51bWJlcklucHV0LnByb3RvdHlwZSwge1xuICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBOdW1iZXJJbnB1dC5zdXBlcmNsYXNzLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdtaW4nKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignbWF4Jyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3N0ZXAnKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9zdHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzLiRjbGVhcikge1xuICAgICAgICAgICAgICAgIC8vaW5jcmVhc2UgcmlnaHQgZmZzZXQgIGZvciB1cC9kb3duIGFycm93c1xuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyLmNzcyh7cmlnaHQ6IDI0fSk7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAvL2NhbiBwb3NpdGlvbiBjbGVhciBidXR0b24gb25seSBoZXJlLCB3aGVuIGZvcm0gaXMgc2hvd24gYW5kIGhlaWdodCBjYW4gYmUgY2FsY3VsYXRlZFxuICAgICAgICAgICAgICAgIHZhciBoID0gdGhpcy4kaW5wdXQub3V0ZXJIZWlnaHQodHJ1ZSkgfHwgMjAsXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gKGggLSB0aGlzLiRjbGVhci5oZWlnaHQoKSkgLyAyO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vYWRkIDEycHggdG8gb2Zmc2V0IHJpZ2h0IGZvciB1cC9kb3duIGFycm93cyAgICBcbiAgICAgICAgICAgICAgICB0aGlzLiRjbGVhci5jc3Moe3RvcDogZGVsdGEsIHJpZ2h0OiBkZWx0YSArIDE2fSk7XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0gICAgICAgIFxuICAgIH0pOyAgICAgXG4gICAgTnVtYmVySW5wdXQuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLnRleHQuZGVmYXVsdHMsIHtcbiAgICAgICAgdHBsOiAnPGlucHV0IHR5cGU9XCJudW1iZXJcIj4nLFxuICAgICAgICBpbnB1dGNsYXNzOiAnaW5wdXQtbWluaScsXG4gICAgICAgIG1pbjogbnVsbCxcbiAgICAgICAgbWF4OiBudWxsLFxuICAgICAgICBzdGVwOiBudWxsXG4gICAgfSk7XG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLm51bWJlciA9IE51bWJlcklucHV0O1xufSh3aW5kb3cualF1ZXJ5KSk7XG5cblxuLypcblJhbmdlIChpbmhlcml0IGZyb20gbnVtYmVyKVxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcbiAgICBcbiAgICB2YXIgUmFuZ2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ3JhbmdlJywgb3B0aW9ucywgUmFuZ2UuZGVmYXVsdHMpO1xuICAgIH07XG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoUmFuZ2UsICQuZm4uZWRpdGFibGV0eXBlcy5udW1iZXIpO1xuICAgICQuZXh0ZW5kKFJhbmdlLnByb3RvdHlwZSwge1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0ID0gdGhpcy4kdHBsLmZpbHRlcignaW5wdXQnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyKCdtaW4nKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cignbWF4Jyk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHIoJ3N0ZXAnKTsgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5vbignaW5wdXQnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICQodGhpcykuc2libGluZ3MoJ291dHB1dCcpLnRleHQoJCh0aGlzKS52YWwoKSk7IFxuICAgICAgICAgICAgfSk7ICBcbiAgICAgICAgfSxcbiAgICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgfSAgICAgICAgIFxuICAgIH0pO1xuICAgIFJhbmdlLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5udW1iZXIuZGVmYXVsdHMsIHtcbiAgICAgICAgdHBsOiAnPGlucHV0IHR5cGU9XCJyYW5nZVwiPjxvdXRwdXQgc3R5bGU9XCJ3aWR0aDogMzBweDsgZGlzcGxheTogaW5saW5lLWJsb2NrXCI+PC9vdXRwdXQ+JyxcbiAgICAgICAgaW5wdXRjbGFzczogJ2lucHV0LW1lZGl1bSdcbiAgICB9KTtcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMucmFuZ2UgPSBSYW5nZTtcbn0od2luZG93LmpRdWVyeSkpO1xuXG4vKlxuVGltZVxuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcblxuICAgIHZhciBUaW1lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCd0aW1lJywgb3B0aW9ucywgVGltZS5kZWZhdWx0cyk7XG4gICAgfTtcbiAgICAvL2luaGVyaXQgZnJvbSBhYnN0cmFjdCwgYXMgaW5oZXJpdGFuY2UgZnJvbSB0ZXh0IGdpdmVzIHNlbGVjdGlvbiBlcnJvci5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChUaW1lLCAkLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dCk7XG4gICAgJC5leHRlbmQoVGltZS5wcm90b3R5cGUsIHtcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuICAgICAgICB9ICAgICAgICBcbiAgICB9KTtcbiAgICBUaW1lLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0LmRlZmF1bHRzLCB7XG4gICAgICAgIHRwbDogJzxpbnB1dCB0eXBlPVwidGltZVwiPidcbiAgICB9KTtcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMudGltZSA9IFRpbWU7XG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG5TZWxlY3QyIGlucHV0LiBCYXNlZCBvbiBhbWF6aW5nIHdvcmsgb2YgSWdvciBWYXluYmVyZyBodHRwczovL2dpdGh1Yi5jb20vaXZheW5iZXJnL3NlbGVjdDIuICBcblBsZWFzZSBzZWUgW29yaWdpbmFsIHNlbGVjdDIgZG9jc10oaHR0cDovL2l2YXluYmVyZy5naXRodWIuY29tL3NlbGVjdDIpIGZvciBkZXRhaWxlZCBkZXNjcmlwdGlvbiBhbmQgb3B0aW9ucy4gIFxuIFxuWW91IHNob3VsZCBtYW51YWxseSBkb3dubG9hZCBhbmQgaW5jbHVkZSBzZWxlY3QyIGRpc3RyaWJ1dGl2ZTogIFxuXG4gICAgPGxpbmsgaHJlZj1cInNlbGVjdDIvc2VsZWN0Mi5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCIgdHlwZT1cInRleHQvY3NzXCI+PC9saW5rPiAgXG4gICAgPHNjcmlwdCBzcmM9XCJzZWxlY3QyL3NlbGVjdDIuanNcIj48L3NjcmlwdD4gIFxuICAgIFxuVG8gbWFrZSBpdCAqKmJvb3RzdHJhcC1zdHlsZWQqKiB5b3UgY2FuIHVzZSBjc3MgZnJvbSBbaGVyZV0oaHR0cHM6Ly9naXRodWIuY29tL3QwbS9zZWxlY3QyLWJvb3RzdHJhcC1jc3MpOiBcblxuICAgIDxsaW5rIGhyZWY9XCJzZWxlY3QyLWJvb3RzdHJhcC5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCIgdHlwZT1cInRleHQvY3NzXCI+PC9saW5rPiAgICBcbiAgICBcbioqTm90ZToqKiBjdXJyZW50bHkgYGF1dG90ZXh0YCBmZWF0dXJlIGRvZXMgbm90IHdvcmsgZm9yIHNlbGVjdDIgd2l0aCBgYWpheGAgcmVtb3RlIHNvdXJjZS4gICAgXG5Zb3UgbmVlZCBpbml0aWFsbHkgcHV0IGJvdGggYGRhdGEtdmFsdWVgIGFuZCBlbGVtZW50J3MgdGV4dCB5b3VzZWxmOiAgICBcblxuICAgIDxhIGhyZWY9XCIjXCIgZGF0YS10eXBlPVwic2VsZWN0MlwiIGRhdGEtdmFsdWU9XCIxXCI+VGV4dDE8L2E+XG4gICAgXG4gICAgXG5AY2xhc3Mgc2VsZWN0MlxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuQHNpbmNlIDEuNC4xXG5AZmluYWxcbkBleGFtcGxlXG48YSBocmVmPVwiI1wiIGlkPVwiY291bnRyeVwiIGRhdGEtdHlwZT1cInNlbGVjdDJcIiBkYXRhLXBrPVwiMVwiIGRhdGEtdmFsdWU9XCJydVwiIGRhdGEtdXJsPVwiL3Bvc3RcIiBkYXRhLXRpdGxlPVwiU2VsZWN0IGNvdW50cnlcIj48L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgIC8vbG9jYWwgc291cmNlXG4gICAgJCgnI2NvdW50cnknKS5lZGl0YWJsZSh7XG4gICAgICAgIHNvdXJjZTogW1xuICAgICAgICAgICAgICB7aWQ6ICdnYicsIHRleHQ6ICdHcmVhdCBCcml0YWluJ30sXG4gICAgICAgICAgICAgIHtpZDogJ3VzJywgdGV4dDogJ1VuaXRlZCBTdGF0ZXMnfSxcbiAgICAgICAgICAgICAge2lkOiAncnUnLCB0ZXh0OiAnUnVzc2lhJ31cbiAgICAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0Mjoge1xuICAgICAgICAgICBtdWx0aXBsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy9yZW1vdGUgc291cmNlIChzaW1wbGUpXG4gICAgJCgnI2NvdW50cnknKS5lZGl0YWJsZSh7XG4gICAgICAgIHNvdXJjZTogJy9nZXRDb3VudHJpZXMnLFxuICAgICAgICBzZWxlY3QyOiB7XG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogJ1NlbGVjdCBDb3VudHJ5JyxcbiAgICAgICAgICAgIG1pbmltdW1JbnB1dExlbmd0aDogMVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy9yZW1vdGUgc291cmNlIChhZHZhbmNlZClcbiAgICAkKCcjY291bnRyeScpLmVkaXRhYmxlKHtcbiAgICAgICAgc2VsZWN0Mjoge1xuICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdTZWxlY3QgQ291bnRyeScsXG4gICAgICAgICAgICBhbGxvd0NsZWFyOiB0cnVlLFxuICAgICAgICAgICAgbWluaW11bUlucHV0TGVuZ3RoOiAzLFxuICAgICAgICAgICAgaWQ6IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uQ291bnRyeUlkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFqYXg6IHtcbiAgICAgICAgICAgICAgICB1cmw6ICcvZ2V0Q291bnRyaWVzJyxcbiAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgIGRhdGE6IGZ1bmN0aW9uICh0ZXJtLCBwYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHF1ZXJ5OiB0ZXJtIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByZXN1bHRzOiBmdW5jdGlvbiAoZGF0YSwgcGFnZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHRzOiBkYXRhIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcm1hdFJlc3VsdDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5Db3VudHJ5TmFtZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmb3JtYXRTZWxlY3Rpb246IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uQ291bnRyeU5hbWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5pdFNlbGVjdGlvbjogZnVuY3Rpb24gKGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICQuZ2V0KCcvZ2V0Q291bnRyeUJ5SWQnLCB7IHF1ZXJ5OiBlbGVtZW50LnZhbCgpIH0sIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgfSAgXG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICA7XG4gICAgXG4gICAgdmFyIENvbnN0cnVjdG9yID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdzZWxlY3QyJywgb3B0aW9ucywgQ29uc3RydWN0b3IuZGVmYXVsdHMpO1xuXG4gICAgICAgIG9wdGlvbnMuc2VsZWN0MiA9IG9wdGlvbnMuc2VsZWN0MiB8fCB7fTtcblxuICAgICAgICB0aGlzLnNvdXJjZURhdGEgPSBudWxsO1xuICAgICAgICBcbiAgICAgICAgLy9wbGFjZWhvbGRlclxuICAgICAgICBpZihvcHRpb25zLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICBvcHRpb25zLnNlbGVjdDIucGxhY2Vob2xkZXIgPSBvcHRpb25zLnBsYWNlaG9sZGVyO1xuICAgICAgICB9XG4gICAgICAgXG4gICAgICAgIC8vaWYgbm90IGB0YWdzYCBtb2RlLCB1c2Ugc291cmNlXG4gICAgICAgIGlmKCFvcHRpb25zLnNlbGVjdDIudGFncyAmJiBvcHRpb25zLnNvdXJjZSkge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IG9wdGlvbnMuc291cmNlO1xuICAgICAgICAgICAgLy9pZiBzb3VyY2UgaXMgZnVuY3Rpb24sIGNhbGwgaXQgKG9uY2UhKVxuICAgICAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihvcHRpb25zLnNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZS5jYWxsKG9wdGlvbnMuc2NvcGUpO1xuICAgICAgICAgICAgfSAgICAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNlbGVjdDIuYWpheCA9IG9wdGlvbnMuc2VsZWN0Mi5hamF4IHx8IHt9O1xuICAgICAgICAgICAgICAgIC8vc29tZSBkZWZhdWx0IGFqYXggcGFyYW1zXG4gICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuc2VsZWN0Mi5hamF4LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZWxlY3QyLmFqYXguZGF0YSA9IGZ1bmN0aW9uKHRlcm0pIHtyZXR1cm4geyBxdWVyeTp0ZXJtIH07fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoIW9wdGlvbnMuc2VsZWN0Mi5hamF4LnJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zZWxlY3QyLmFqYXgucmVzdWx0cyA9IGZ1bmN0aW9uKGRhdGEpIHsgcmV0dXJuIHtyZXN1bHRzOmRhdGEgfTt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zLnNlbGVjdDIuYWpheC51cmwgPSBzb3VyY2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vY2hlY2sgZm9ybWF0IGFuZCBjb252ZXJ0IHgtZWRpdGFibGUgZm9ybWF0IHRvIHNlbGVjdDIgZm9ybWF0IChpZiBuZWVkZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gdGhpcy5jb252ZXJ0U291cmNlKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zZWxlY3QyLmRhdGEgPSB0aGlzLnNvdXJjZURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gXG5cbiAgICAgICAgLy9vdmVycmlkaW5nIG9iamVjdHMgaW4gY29uZmlnIChhcyBieSBkZWZhdWx0IGpRdWVyeSBleHRlbmQoKSBpcyBub3QgcmVjdXJzaXZlKVxuICAgICAgICB0aGlzLm9wdGlvbnMuc2VsZWN0MiA9ICQuZXh0ZW5kKHt9LCBDb25zdHJ1Y3Rvci5kZWZhdWx0cy5zZWxlY3QyLCBvcHRpb25zLnNlbGVjdDIpO1xuXG4gICAgICAgIC8vZGV0ZWN0IHdoZXRoZXIgaXQgaXMgbXVsdGktdmFsdWVkXG4gICAgICAgIHRoaXMuaXNNdWx0aXBsZSA9IHRoaXMub3B0aW9ucy5zZWxlY3QyLnRhZ3MgfHwgdGhpcy5vcHRpb25zLnNlbGVjdDIubXVsdGlwbGU7XG4gICAgICAgIHRoaXMuaXNSZW1vdGUgPSAoJ2FqYXgnIGluIHRoaXMub3B0aW9ucy5zZWxlY3QyKTtcblxuICAgICAgICAvL3N0b3JlIGZ1bmN0aW9uIHJldHVybmluZyBJRCBvZiBpdGVtXG4gICAgICAgIC8vc2hvdWxkIGJlIGhlcmUgYXMgdXNlZCBpbmF1dG90ZXh0IGZvciBsb2NhbCBzb3VyY2VcbiAgICAgICAgdGhpcy5pZEZ1bmMgPSB0aGlzLm9wdGlvbnMuc2VsZWN0Mi5pZDtcbiAgICAgICAgaWYgKHR5cGVvZih0aGlzLmlkRnVuYykgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFyIGlkS2V5ID0gdGhpcy5pZEZ1bmMgfHwgJ2lkJztcbiAgICAgICAgICAgIHRoaXMuaWRGdW5jID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGVbaWRLZXldOyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy9zdG9yZSBmdW5jdGlvbiB0aGF0IHJlbmRlcnMgdGV4dCBpbiBzZWxlY3QyXG4gICAgICAgIHRoaXMuZm9ybWF0U2VsZWN0aW9uID0gdGhpcy5vcHRpb25zLnNlbGVjdDIuZm9ybWF0U2VsZWN0aW9uO1xuICAgICAgICBpZiAodHlwZW9mKHRoaXMuZm9ybWF0U2VsZWN0aW9uKSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRleHQ7IH07XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoQ29uc3RydWN0b3IsICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0KTtcblxuICAgICQuZXh0ZW5kKENvbnN0cnVjdG9yLnByb3RvdHlwZSwge1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRDbGFzcygpO1xuXG4gICAgICAgICAgICAvL2NhbiBub3QgYXBwbHkgc2VsZWN0MiBoZXJlIGFzIGl0IGNhbGxzIGluaXRTZWxlY3Rpb24gXG4gICAgICAgICAgICAvL292ZXIgaW5wdXQgdGhhdCBkb2VzIG5vdCBoYXZlIGNvcnJlY3QgdmFsdWUgeWV0LlxuICAgICAgICAgICAgLy9hcHBseSBzZWxlY3QyIG9ubHkgaW4gdmFsdWUyaW5wdXRcbiAgICAgICAgICAgIC8vdGhpcy4kaW5wdXQuc2VsZWN0Mih0aGlzLm9wdGlvbnMuc2VsZWN0Mik7XG5cbiAgICAgICAgICAgIC8vd2hlbiBkYXRhIGlzIGxvYWRlZCB2aWEgYWpheCwgd2UgbmVlZCB0byBrbm93IHdoZW4gaXQncyBkb25lIHRvIHBvcHVsYXRlIGxpc3REYXRhXG4gICAgICAgICAgICBpZih0aGlzLmlzUmVtb3RlKSB7XG4gICAgICAgICAgICAgICAgLy9saXN0ZW4gdG8gbG9hZGVkIGV2ZW50IHRvIHBvcHVsYXRlIGRhdGFcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5vbignc2VsZWN0Mi1sb2FkZWQnLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VEYXRhID0gZS5pdGVtcy5yZXN1bHRzO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy90cmlnZ2VyIHJlc2l6ZSBvZiBlZGl0YWJsZWZvcm0gdG8gcmUtcG9zaXRpb24gY29udGFpbmVyIGluIG11bHRpLXZhbHVlZCBtb2RlXG4gICAgICAgICAgICBpZih0aGlzLmlzTXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKS5wYXJlbnQoKS50cmlnZ2VySGFuZGxlcigncmVzaXplJyk7XG4gICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICB9LFxuXG4gICAgICAgdmFsdWUyaHRtbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgdmFyIHRleHQgPSAnJywgZGF0YSxcbiAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5zZWxlY3QyLnRhZ3MpIHsgLy9pbiB0YWdzIG1vZGUganVzdCBhc3NpZ24gdmFsdWVcbiAgICAgICAgICAgICAgZGF0YSA9IHZhbHVlOyBcbiAgICAgICAgICAgICAgLy9kYXRhID0gJC5mbi5lZGl0YWJsZXV0aWxzLml0ZW1zQnlWYWx1ZSh2YWx1ZSwgdGhpcy5vcHRpb25zLnNlbGVjdDIudGFncywgdGhpcy5pZEZ1bmMpO1xuICAgICAgICAgICB9IGVsc2UgaWYodGhpcy5zb3VyY2VEYXRhKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSAkLmZuLmVkaXRhYmxldXRpbHMuaXRlbXNCeVZhbHVlKHZhbHVlLCB0aGlzLnNvdXJjZURhdGEsIHRoaXMuaWRGdW5jKTsgXG4gICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vY2FuIG5vdCBnZXQgbGlzdCBvZiBwb3NzaWJsZSB2YWx1ZXMgXG4gICAgICAgICAgICAgIC8vKGUuZy4gYXV0b3RleHQgZm9yIHNlbGVjdDIgd2l0aCBhamF4IHNvdXJjZSlcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vZGF0YSBtYXkgYmUgYXJyYXkgKHdoZW4gbXVsdGlwbGUgdmFsdWVzIGFsbG93ZWQpXG4gICAgICAgICAgIGlmKCQuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgLy9jb2xsZWN0IHNlbGVjdGVkIGRhdGEgYW5kIHNob3cgd2l0aCBzZXBhcmF0b3JcbiAgICAgICAgICAgICAgIHRleHQgPSBbXTtcbiAgICAgICAgICAgICAgICQuZWFjaChkYXRhLCBmdW5jdGlvbihrLCB2KXtcbiAgICAgICAgICAgICAgICAgICB0ZXh0LnB1c2godiAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcgPyB0aGF0LmZvcm1hdFNlbGVjdGlvbih2KSA6IHYpO1xuICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgIH0gZWxzZSBpZihkYXRhKSB7XG4gICAgICAgICAgICAgICB0ZXh0ID0gdGhhdC5mb3JtYXRTZWxlY3Rpb24oZGF0YSk7XG4gICAgICAgICAgIH1cblxuICAgICAgICAgICB0ZXh0ID0gJC5pc0FycmF5KHRleHQpID8gdGV4dC5qb2luKHRoaXMub3B0aW9ucy52aWV3c2VwYXJhdG9yKSA6IHRleHQ7XG5cbiAgICAgICAgICAgLy8kKGVsZW1lbnQpLnRleHQodGV4dCk7XG4gICAgICAgICAgIENvbnN0cnVjdG9yLnN1cGVyY2xhc3MudmFsdWUyaHRtbC5jYWxsKHRoaXMsIHRleHQsIGVsZW1lbnQpOyBcbiAgICAgICB9LFxuXG4gICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnNlbGVjdDIudGFncyA/IHRoaXMuc3RyMnZhbHVlKGh0bWwsIHRoaXMub3B0aW9ucy52aWV3c2VwYXJhdG9yKSA6IG51bGw7XG4gICAgICAgfSxcblxuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAvLyBpZiB2YWx1ZSBhcnJheSA9PiBqb2luIGl0IGFueXdheVxuICAgICAgICAgICBpZigkLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuam9pbih0aGlzLmdldFNlcGFyYXRvcigpKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vZm9yIHJlbW90ZSBzb3VyY2UganVzdCBzZXQgdmFsdWUsIHRleHQgaXMgdXBkYXRlZCBieSBpbml0U2VsZWN0aW9uXG4gICAgICAgICAgIGlmKCF0aGlzLiRpbnB1dC5kYXRhKCdzZWxlY3QyJykpIHtcbiAgICAgICAgICAgICAgIHRoaXMuJGlucHV0LnZhbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5zZWxlY3QyKHRoaXMub3B0aW9ucy5zZWxlY3QyKTtcbiAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIC8vc2Vjb25kIGFyZ3VtZW50IG5lZWRlZCB0byBzZXBhcmF0ZSBpbml0aWFsIGNoYW5nZSBmcm9tIHVzZXIncyBjbGljayAoZm9yIGF1dG9zdWJtaXQpICAgXG4gICAgICAgICAgICAgICB0aGlzLiRpbnB1dC52YWwodmFsdWUpLnRyaWdnZXIoJ2NoYW5nZScsIHRydWUpOyBcblxuICAgICAgICAgICAgICAgLy9VbmNhdWdodCBFcnJvcjogY2Fubm90IGNhbGwgdmFsKCkgaWYgaW5pdFNlbGVjdGlvbigpIGlzIG5vdCBkZWZpbmVkXG4gICAgICAgICAgICAgICAvL3RoaXMuJGlucHV0LnNlbGVjdDIoJ3ZhbCcsIHZhbHVlKTtcbiAgICAgICAgICAgfVxuXG4gICAgICAgICAgIC8vIGlmIGRlZmluZWQgcmVtb3RlIHNvdXJjZSBBTkQgbm8gbXVsdGlwbGUgbW9kZSBBTkQgbm8gdXNlcidzIGluaXRTZWxlY3Rpb24gcHJvdmlkZWQgLS0+IFxuICAgICAgICAgICAvLyB3ZSBzaG91bGQgc29tZWhvdyBnZXQgdGV4dCBmb3IgcHJvdmlkZWQgaWQuXG4gICAgICAgICAgIC8vIFRoZSBzb2x1dGlvbiBpcyB0byB1c2UgZWxlbWVudCdzIHRleHQgYXMgdGV4dCBmb3IgdGhhdCBpZCAoZXhjbHVkZSBlbXB0eSlcbiAgICAgICAgICAgaWYodGhpcy5pc1JlbW90ZSAmJiAhdGhpcy5pc011bHRpcGxlICYmICF0aGlzLm9wdGlvbnMuc2VsZWN0Mi5pbml0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAvLyBjdXN0b21JZCBhbmQgY3VzdG9tVGV4dCBhcmUgbWV0aG9kcyB0byBleHRyYWN0IGBpZGAgYW5kIGB0ZXh0YCBmcm9tIGRhdGEgb2JqZWN0XG4gICAgICAgICAgICAgICAvLyB3ZSBjYW4gdXNlIHRoaXMgd29ya2Fyb3VuZCBvbmx5IGlmIHVzZXIgZGlkIG5vdCBkZWZpbmUgdGhlc2UgbWV0aG9kc1xuICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGNhbnQgY29uc3RydWN0IGRhdGEgb2JqZWN0XG4gICAgICAgICAgICAgICB2YXIgY3VzdG9tSWQgPSB0aGlzLm9wdGlvbnMuc2VsZWN0Mi5pZCxcbiAgICAgICAgICAgICAgICAgICBjdXN0b21UZXh0ID0gdGhpcy5vcHRpb25zLnNlbGVjdDIuZm9ybWF0U2VsZWN0aW9uO1xuXG4gICAgICAgICAgICAgICBpZighY3VzdG9tSWQgJiYgIWN1c3RvbVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICB2YXIgJGVsID0gJCh0aGlzLm9wdGlvbnMuc2NvcGUpO1xuICAgICAgICAgICAgICAgICAgIGlmICghJGVsLmRhdGEoJ2VkaXRhYmxlJykuaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHtpZDogdmFsdWUsIHRleHQ6ICRlbC50ZXh0KCl9O1xuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5zZWxlY3QyKCdkYXRhJywgZGF0YSk7IFxuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgaW5wdXQydmFsdWU6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0LnNlbGVjdDIoJ3ZhbCcpO1xuICAgICAgIH0sXG5cbiAgICAgICBzdHIydmFsdWU6IGZ1bmN0aW9uKHN0ciwgc2VwYXJhdG9yKSB7XG4gICAgICAgICAgICBpZih0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJyB8fCAhdGhpcy5pc011bHRpcGxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VwYXJhdG9yID0gc2VwYXJhdG9yIHx8IHRoaXMuZ2V0U2VwYXJhdG9yKCk7XG5cbiAgICAgICAgICAgIHZhciB2YWwsIGksIGw7XG5cbiAgICAgICAgICAgIGlmIChzdHIgPT09IG51bGwgfHwgc3RyLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbCA9IHN0ci5zcGxpdChzZXBhcmF0b3IpO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpID0gaSArIDEpIHtcbiAgICAgICAgICAgICAgICB2YWxbaV0gPSAkLnRyaW0odmFsW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICB9LFxuXG4gICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ2NoYW5nZScsIGZ1bmN0aW9uKGUsIGlzSW5pdGlhbCl7XG4gICAgICAgICAgICAgICAgaWYoIWlzSW5pdGlhbCkge1xuICAgICAgICAgICAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCdmb3JtJykuc3VibWl0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0U2VwYXJhdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2VsZWN0Mi5zZXBhcmF0b3IgfHwgJC5mbi5zZWxlY3QyLmRlZmF1bHRzLnNlcGFyYXRvcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKlxuICAgICAgICBDb252ZXJ0cyBzb3VyY2UgZnJvbSB4LWVkaXRhYmxlIGZvcm1hdDoge3ZhbHVlOiAxLCB0ZXh0OiBcIjFcIn0gdG9cbiAgICAgICAgc2VsZWN0MiBmb3JtYXQ6IHtpZDogMSwgdGV4dDogXCIxXCJ9XG4gICAgICAgICovXG4gICAgICAgIGNvbnZlcnRTb3VyY2U6IGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgICAgICAgaWYoJC5pc0FycmF5KHNvdXJjZSkgJiYgc291cmNlLmxlbmd0aCAmJiBzb3VyY2VbMF0udmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGk8c291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHNvdXJjZVtpXS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VbaV0uaWQgPSBzb3VyY2VbaV0udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc291cmNlW2ldLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYodGhpcy4kaW5wdXQuZGF0YSgnc2VsZWN0MicpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQuc2VsZWN0MignZGVzdHJveScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0pO1xuXG4gICAgQ29uc3RydWN0b3IuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQuZGVmYXVsdHMsIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSB0cGwgXG4gICAgICAgIEBkZWZhdWx0IDxpbnB1dCB0eXBlPVwiaGlkZGVuXCI+XG4gICAgICAgICoqL1xuICAgICAgICB0cGw6JzxpbnB1dCB0eXBlPVwiaGlkZGVuXCI+JyxcbiAgICAgICAgLyoqXG4gICAgICAgIENvbmZpZ3VyYXRpb24gb2Ygc2VsZWN0Mi4gW0Z1bGwgbGlzdCBvZiBvcHRpb25zXShodHRwOi8vaXZheW5iZXJnLmdpdGh1Yi5jb20vc2VsZWN0MikuXG5cbiAgICAgICAgQHByb3BlcnR5IHNlbGVjdDIgXG4gICAgICAgIEB0eXBlIG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICBzZWxlY3QyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgUGxhY2Vob2xkZXIgYXR0cmlidXRlIG9mIHNlbGVjdFxuXG4gICAgICAgIEBwcm9wZXJ0eSBwbGFjZWhvbGRlciBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovXG4gICAgICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgU291cmNlIGRhdGEgZm9yIHNlbGVjdC4gSXQgd2lsbCBiZSBhc3NpZ25lZCB0byBzZWxlY3QyIGBkYXRhYCBwcm9wZXJ0eSBhbmQga2VwdCBoZXJlIGp1c3QgZm9yIGNvbnZlbmllbmNlLlxuICAgICAgICBQbGVhc2Ugbm90ZSwgdGhhdCBmb3JtYXQgaXMgZGlmZmVyZW50IGZyb20gc2ltcGxlIGBzZWxlY3RgIGlucHV0OiB1c2UgJ2lkJyBpbnN0ZWFkIG9mICd2YWx1ZScuXG4gICAgICAgIEUuZy4gYFt7aWQ6IDEsIHRleHQ6IFwidGV4dDFcIn0sIHtpZDogMiwgdGV4dDogXCJ0ZXh0MlwifSwgLi4uXWAuXG5cbiAgICAgICAgQHByb3BlcnR5IHNvdXJjZSBcbiAgICAgICAgQHR5cGUgYXJyYXl8c3RyaW5nfGZ1bmN0aW9uXG4gICAgICAgIEBkZWZhdWx0IG51bGwgICAgICAgIFxuICAgICAgICAqKi9cbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgU2VwYXJhdG9yIHVzZWQgdG8gZGlzcGxheSB0YWdzLlxuXG4gICAgICAgIEBwcm9wZXJ0eSB2aWV3c2VwYXJhdG9yIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJywgJyAgICAgICAgXG4gICAgICAgICoqL1xuICAgICAgICB2aWV3c2VwYXJhdG9yOiAnLCAnXG4gICAgfSk7XG5cbiAgICAkLmZuLmVkaXRhYmxldHlwZXMuc2VsZWN0MiA9IENvbnN0cnVjdG9yO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyoqXG4qIENvbWJvZGF0ZSAtIDEuMC41XG4qIERyb3Bkb3duIGRhdGUgYW5kIHRpbWUgcGlja2VyLlxuKiBDb252ZXJ0cyB0ZXh0IGlucHV0IGludG8gZHJvcGRvd25zIHRvIHBpY2sgZGF5LCBtb250aCwgeWVhciwgaG91ciwgbWludXRlIGFuZCBzZWNvbmQuXG4qIFVzZXMgbW9tZW50anMgYXMgZGF0ZXRpbWUgbGlicmFyeSBodHRwOi8vbW9tZW50anMuY29tLlxuKiBGb3IgaTE4biBpbmNsdWRlIGNvcnJlc3BvbmRpbmcgZmlsZSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1yd29vZC9tb21lbnQvdHJlZS9tYXN0ZXIvbGFuZyBcbipcbiogQ29uZnVzaW9uIGF0IG5vb24gYW5kIG1pZG5pZ2h0IC0gc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvMTItaG91cl9jbG9jayNDb25mdXNpb25fYXRfbm9vbl9hbmRfbWlkbmlnaHRcbiogSW4gY29tYm9kYXRlOiBcbiogMTI6MDAgcG0gLS0+IDEyOjAwICgyNC1oIGZvcm1hdCwgbWlkZGF5KVxuKiAxMjowMCBhbSAtLT4gMDA6MDAgKDI0LWggZm9ybWF0LCBtaWRuaWdodCwgc3RhcnQgb2YgZGF5KVxuKiBcbiogRGlmZmVycyBmcm9tIG1vbWVudGpzIHBhcnNlIHJ1bGVzOlxuKiAwMDowMCBwbSwgMTI6MDAgcG0gLS0+IDEyOjAwICgyNC1oIGZvcm1hdCwgZGF5IG5vdCBjaGFuZ2UpXG4qIDAwOjAwIGFtLCAxMjowMCBhbSAtLT4gMDA6MDAgKDI0LWggZm9ybWF0LCBkYXkgbm90IGNoYW5nZSlcbiogXG4qIFxuKiBBdXRob3I6IFZpdGFsaXkgUG90YXBvdlxuKiBQcm9qZWN0IHBhZ2U6IGh0dHA6Ly9naXRodWIuY29tL3ZpdGFsZXRzL2NvbWJvZGF0ZVxuKiBDb3B5cmlnaHQgKGMpIDIwMTIgVml0YWxpeSBQb3RhcG92LiBSZWxlYXNlZCB1bmRlciBNSVQgTGljZW5zZS5cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG5cbiAgICB2YXIgQ29tYm9kYXRlID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XG4gICAgICAgIGlmKCF0aGlzLiRlbGVtZW50LmlzKCdpbnB1dCcpKSB7XG4gICAgICAgICAgICAkLmVycm9yKCdDb21ib2RhdGUgc2hvdWxkIGJlIGFwcGxpZWQgdG8gSU5QVVQgZWxlbWVudCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCAkLmZuLmNvbWJvZGF0ZS5kZWZhdWx0cywgb3B0aW9ucywgdGhpcy4kZWxlbWVudC5kYXRhKCkpO1xuICAgICAgICB0aGlzLmluaXQoKTsgIFxuICAgICB9O1xuXG4gICAgQ29tYm9kYXRlLnByb3RvdHlwZSA9IHtcbiAgICAgICAgY29uc3RydWN0b3I6IENvbWJvZGF0ZSwgXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMubWFwID0ge1xuICAgICAgICAgICAgICAgIC8va2V5ICAgcmVnZXhwICAgIG1vbWVudC5tZXRob2RcbiAgICAgICAgICAgICAgICBkYXk6ICAgIFsnRCcsICAgICdkYXRlJ10sIFxuICAgICAgICAgICAgICAgIG1vbnRoOiAgWydNJywgICAgJ21vbnRoJ10sIFxuICAgICAgICAgICAgICAgIHllYXI6ICAgWydZJywgICAgJ3llYXInXSwgXG4gICAgICAgICAgICAgICAgaG91cjogICBbJ1tIaF0nLCAnaG91cnMnXSxcbiAgICAgICAgICAgICAgICBtaW51dGU6IFsnbScsICAgICdtaW51dGVzJ10sIFxuICAgICAgICAgICAgICAgIHNlY29uZDogWydzJywgICAgJ3NlY29uZHMnXSxcbiAgICAgICAgICAgICAgICBhbXBtOiAgIFsnW0FhXScsICcnXSBcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJHdpZGdldCA9ICQoJzxzcGFuIGNsYXNzPVwiY29tYm9kYXRlXCI+PC9zcGFuPicpLmh0bWwodGhpcy5nZXRUZW1wbGF0ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuaW5pdENvbWJvcygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL3VwZGF0ZSBvcmlnaW5hbCBpbnB1dCBvbiBjaGFuZ2UgXG4gICAgICAgICAgICB0aGlzLiR3aWRnZXQub24oJ2NoYW5nZScsICdzZWxlY3QnLCAkLnByb3h5KGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnZhbCh0aGlzLmdldFZhbHVlKCkpLmNoYW5nZSgpO1xuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBkYXlzIGNvdW50IGlmIG1vbnRoIG9yIHllYXIgY2hhbmdlc1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21hcnREYXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkKGUudGFyZ2V0KS5pcygnLm1vbnRoJykgfHwgJChlLnRhcmdldCkuaXMoJy55ZWFyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsbENvbWJvKCdkYXknKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kd2lkZ2V0LmZpbmQoJ3NlbGVjdCcpLmNzcygnd2lkdGgnLCAnYXV0bycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBoaWRlIG9yaWdpbmFsIGlucHV0IGFuZCBpbnNlcnQgd2lkZ2V0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmhpZGUoKS5hZnRlcih0aGlzLiR3aWRnZXQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBzZXQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLiRlbGVtZW50LnZhbCgpIHx8IHRoaXMub3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICAgUmVwbGFjZSB0b2tlbnMgaW4gdGVtcGxhdGUgd2l0aCA8c2VsZWN0PiBlbGVtZW50cyBcbiAgICAgICAgKi8gICAgICAgICBcbiAgICAgICAgZ2V0VGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRwbCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZTtcblxuICAgICAgICAgICAgLy9maXJzdCBwYXNzXG4gICAgICAgICAgICAkLmVhY2godGhpcy5tYXAsIGZ1bmN0aW9uKGssIHYpIHtcbiAgICAgICAgICAgICAgICB2ID0gdlswXTsgXG4gICAgICAgICAgICAgICAgdmFyIHIgPSBuZXcgUmVnRXhwKHYrJysnKSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB2Lmxlbmd0aCA+IDEgPyB2LnN1YnN0cmluZygxLCAyKSA6IHY7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKHIsICd7Jyt0b2tlbisnfScpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vcmVwbGFjZSBzcGFjZXMgd2l0aCAmbmJzcDtcbiAgICAgICAgICAgIHRwbCA9IHRwbC5yZXBsYWNlKC8gL2csICcmbmJzcDsnKTtcblxuICAgICAgICAgICAgLy9zZWNvbmQgcGFzc1xuICAgICAgICAgICAgJC5lYWNoKHRoaXMubWFwLCBmdW5jdGlvbihrLCB2KSB7XG4gICAgICAgICAgICAgICAgdiA9IHZbMF07XG4gICAgICAgICAgICAgICAgdmFyIHRva2VuID0gdi5sZW5ndGggPiAxID8gdi5zdWJzdHJpbmcoMSwgMikgOiB2O1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0cGwgPSB0cGwucmVwbGFjZSgneycrdG9rZW4rJ30nLCAnPHNlbGVjdCBjbGFzcz1cIicraysnXCI+PC9zZWxlY3Q+Jyk7XG4gICAgICAgICAgICB9KTsgICBcblxuICAgICAgICAgICAgcmV0dXJuIHRwbDtcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgICBJbml0aWFsaXplIGNvbWJvcyB0aGF0IHByZXNlbnRzIGluIHRlbXBsYXRlIFxuICAgICAgICAqLyAgICAgICAgXG4gICAgICAgIGluaXRDb21ib3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgICAgIHZhciAkYyA9IHRoaXMuJHdpZGdldC5maW5kKCcuJytrKTtcbiAgICAgICAgICAgICAgICAvLyBzZXQgcHJvcGVydGllcyBsaWtlIHRoaXMuJGRheSwgdGhpcy4kbW9udGggZXRjLlxuICAgICAgICAgICAgICAgIHRoaXNbJyQnK2tdID0gJGMubGVuZ3RoID8gJGMgOiBudWxsO1xuICAgICAgICAgICAgICAgIC8vIGZpbGwgd2l0aCBpdGVtc1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsbENvbWJvKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qXG4gICAgICAgICBGaWxsIGNvbWJvIHdpdGggaXRlbXMgXG4gICAgICAgICovICAgICAgICBcbiAgICAgICAgZmlsbENvbWJvOiBmdW5jdGlvbihrKSB7XG4gICAgICAgICAgICB2YXIgJGNvbWJvID0gdGhpc1snJCcra107XG4gICAgICAgICAgICBpZiAoISRjb21ibykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGVmaW5lIG1ldGhvZCBuYW1lIHRvIGZpbGwgaXRlbXMsIGUuZyBgZmlsbERheXNgXG4gICAgICAgICAgICB2YXIgZiA9ICdmaWxsJyArIGsuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrLnNsaWNlKDEpOyBcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHRoaXNbZl0oKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9ICRjb21iby52YWwoKTtcblxuICAgICAgICAgICAgJGNvbWJvLmVtcHR5KCk7XG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICRjb21iby5hcHBlbmQoJzxvcHRpb24gdmFsdWU9XCInK2l0ZW1zW2ldWzBdKydcIj4nK2l0ZW1zW2ldWzFdKyc8L29wdGlvbj4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJGNvbWJvLnZhbCh2YWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgIEluaXRpYWxpemUgaXRlbXMgb2YgY29tYm9zLiBIYW5kbGVzIGBmaXJzdEl0ZW1gIG9wdGlvbiBcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbENvbW1vbjogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWVzID0gW10sXG4gICAgICAgICAgICAgICAgcmVsVGltZTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5maXJzdEl0ZW0gPT09ICduYW1lJykge1xuICAgICAgICAgICAgICAgIC8vbmVlZCBib3RoIHRvIHN1cHBvcnQgbW9tZW50IHZlciA8IDIgYW5kICA+PSAyXG4gICAgICAgICAgICAgICAgcmVsVGltZSA9IG1vbWVudC5yZWxhdGl2ZVRpbWUgfHwgbW9tZW50LmxhbmdEYXRhKCkuX3JlbGF0aXZlVGltZTsgXG4gICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IHR5cGVvZiByZWxUaW1lW2tleV0gPT09ICdmdW5jdGlvbicgPyByZWxUaW1lW2tleV0oMSwgdHJ1ZSwga2V5LCBmYWxzZSkgOiByZWxUaW1lW2tleV07XG4gICAgICAgICAgICAgICAgLy90YWtlIGxhc3QgZW50cnkgKHNlZSBtb21lbnRqcyBsYW5nIGZpbGVzIHN0cnVjdHVyZSkgXG4gICAgICAgICAgICAgICAgaGVhZGVyID0gaGVhZGVyLnNwbGl0KCcgJykucmV2ZXJzZSgpWzBdOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChbJycsIGhlYWRlcl0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmKHRoaXMub3B0aW9ucy5maXJzdEl0ZW0gPT09ICdlbXB0eScpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChbJycsICcnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgICB9LCAgXG5cblxuICAgICAgICAvKlxuICAgICAgICBmaWxsIGRheVxuICAgICAgICAqL1xuICAgICAgICBmaWxsRGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBpdGVtcyA9IHRoaXMuZmlsbENvbW1vbignZCcpLCBuYW1lLCBpLFxuICAgICAgICAgICAgICAgIHR3b0RpZ2l0ID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ0REJykgIT09IC0xLFxuICAgICAgICAgICAgICAgIGRheXNDb3VudCA9IDMxO1xuXG4gICAgICAgICAgICAvLyBkZXRlY3QgZGF5cyBjb3VudCAoZGVwZW5kcyBvbiBtb250aCBhbmQgeWVhcilcbiAgICAgICAgICAgIC8vIG9yaWdpbmFsbHkgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGFsZXRzL2NvbWJvZGF0ZS9wdWxsLzdcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc21hcnREYXlzICYmIHRoaXMuJG1vbnRoICYmIHRoaXMuJHllYXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9udGggPSBwYXJzZUludCh0aGlzLiRtb250aC52YWwoKSwgMTApO1xuICAgICAgICAgICAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQodGhpcy4keWVhci52YWwoKSwgMTApO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihtb250aCkgJiYgIWlzTmFOKHllYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRheXNDb3VudCA9IG1vbWVudChbeWVhciwgbW9udGhdKS5kYXlzSW5Nb250aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMTsgaSA8PSBkYXlzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIG5hbWUgPSB0d29EaWdpdCA/IHRoaXMubGVhZFplcm8oaSkgOiBpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goW2ksIG5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpdGVtczsgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgZmlsbCBtb250aFxuICAgICAgICAqL1xuICAgICAgICBmaWxsTW9udGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5maWxsQ29tbW9uKCdNJyksIG5hbWUsIGksIFxuICAgICAgICAgICAgICAgIGxvbmdOYW1lcyA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdNTU1NJykgIT09IC0xLFxuICAgICAgICAgICAgICAgIHNob3J0TmFtZXMgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUuaW5kZXhPZignTU1NJykgIT09IC0xLFxuICAgICAgICAgICAgICAgIHR3b0RpZ2l0ID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ01NJykgIT09IC0xO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKGk9MDsgaTw9MTE7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmKGxvbmdOYW1lcykge1xuICAgICAgICAgICAgICAgICAgICAvL3NlZSBodHRwczovL2dpdGh1Yi5jb20vdGltcndvb2QvbW9tZW50anMuY29tL3B1bGwvMzZcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG1vbWVudCgpLmRhdGUoMSkubW9udGgoaSkuZm9ybWF0KCdNTU1NJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmKHNob3J0TmFtZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG1vbWVudCgpLmRhdGUoMSkubW9udGgoaSkuZm9ybWF0KCdNTU0nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYodHdvRGlnaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IHRoaXMubGVhZFplcm8oaSsxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gaSsxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKFtpLCBuYW1lXSk7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICB9LCAgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBmaWxsIHllYXJcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbFllYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gW10sIG5hbWUsIGksIFxuICAgICAgICAgICAgICAgIGxvbmdOYW1lcyA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdZWVlZJykgIT09IC0xO1xuICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcihpPXRoaXMub3B0aW9ucy5tYXhZZWFyOyBpPj10aGlzLm9wdGlvbnMubWluWWVhcjsgaS0tKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IGxvbmdOYW1lcyA/IGkgOiAoaSsnJykuc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgICAgIGl0ZW1zW3RoaXMub3B0aW9ucy55ZWFyRGVzY2VuZGluZyA/ICdwdXNoJyA6ICd1bnNoaWZ0J10oW2ksIG5hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaXRlbXMgPSB0aGlzLmZpbGxDb21tb24oJ3knKS5jb25jYXQoaXRlbXMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7ICAgICAgICAgICAgICBcbiAgICAgICAgfSwgICAgXG4gICAgICAgIFxuICAgICAgICAvKlxuICAgICAgICBmaWxsIGhvdXJcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbEhvdXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5maWxsQ29tbW9uKCdoJyksIG5hbWUsIGksXG4gICAgICAgICAgICAgICAgaDEyID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ2gnKSAhPT0gLTEsXG4gICAgICAgICAgICAgICAgaDI0ID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ0gnKSAhPT0gLTEsXG4gICAgICAgICAgICAgICAgdHdvRGlnaXQgPSB0aGlzLm9wdGlvbnMudGVtcGxhdGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdoaCcpICE9PSAtMSxcbiAgICAgICAgICAgICAgICBtaW4gPSBoMTIgPyAxIDogMCwgXG4gICAgICAgICAgICAgICAgbWF4ID0gaDEyID8gMTIgOiAyMztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcihpPW1pbjsgaTw9bWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gdHdvRGlnaXQgPyB0aGlzLmxlYWRaZXJvKGkpIDogaTtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKFtpLCBuYW1lXSk7XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zOyAgICAgICAgICAgICAgICAgXG4gICAgICAgIH0sICAgIFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgZmlsbCBtaW51dGVcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbE1pbnV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLmZpbGxDb21tb24oJ20nKSwgbmFtZSwgaSxcbiAgICAgICAgICAgICAgICB0d29EaWdpdCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdtbScpICE9PSAtMTtcblxuICAgICAgICAgICAgZm9yKGk9MDsgaTw9NTk7IGkrPSB0aGlzLm9wdGlvbnMubWludXRlU3RlcCkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSB0d29EaWdpdCA/IHRoaXMubGVhZFplcm8oaSkgOiBpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goW2ksIG5hbWVdKTtcbiAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7ICAgICAgICAgICAgICBcbiAgICAgICAgfSwgIFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgZmlsbCBzZWNvbmRcbiAgICAgICAgKi9cbiAgICAgICAgZmlsbFNlY29uZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaXRlbXMgPSB0aGlzLmZpbGxDb21tb24oJ3MnKSwgbmFtZSwgaSxcbiAgICAgICAgICAgICAgICB0d29EaWdpdCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdzcycpICE9PSAtMTtcblxuICAgICAgICAgICAgZm9yKGk9MDsgaTw9NTk7IGkrPSB0aGlzLm9wdGlvbnMuc2Vjb25kU3RlcCkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSB0d29EaWdpdCA/IHRoaXMubGVhZFplcm8oaSkgOiBpO1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goW2ksIG5hbWVdKTtcbiAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICByZXR1cm4gaXRlbXM7ICAgICAgICAgICAgICBcbiAgICAgICAgfSwgIFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgZmlsbCBhbXBtXG4gICAgICAgICovXG4gICAgICAgIGZpbGxBbXBtOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhbXBtTCA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5pbmRleE9mKCdhJykgIT09IC0xLFxuICAgICAgICAgICAgICAgIGFtcG1VID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlLmluZGV4T2YoJ0EnKSAhPT0gLTEsICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaXRlbXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIFsnYW0nLCBhbXBtTCA/ICdhbScgOiAnQU0nXSxcbiAgICAgICAgICAgICAgICAgICAgWydwbScsIGFtcG1MID8gJ3BtJyA6ICdQTSddXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiBpdGVtczsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfSwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcblxuICAgICAgICAvKlxuICAgICAgICAgUmV0dXJucyBjdXJyZW50IGRhdGUgdmFsdWUgZnJvbSBjb21ib3MuIFxuICAgICAgICAgSWYgZm9ybWF0IG5vdCBzcGVjaWZpZWQgLSBgb3B0aW9ucy5mb3JtYXRgIHVzZWQuXG4gICAgICAgICBJZiBmb3JtYXQgPSBgbnVsbGAgLSBNb21lbnQgb2JqZWN0IHJldHVybmVkLlxuICAgICAgICAqL1xuICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgICAgICB2YXIgZHQsIHZhbHVlcyA9IHt9LCBcbiAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICBub3RTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9nZXR0aW5nIHNlbGVjdGVkIHZhbHVlcyAgICBcbiAgICAgICAgICAgICQuZWFjaCh0aGlzLm1hcCwgZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgICAgICAgIGlmKGsgPT09ICdhbXBtJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkZWYgPSBrID09PSAnZGF5JyA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFsdWVzW2tdID0gdGhhdFsnJCcra10gPyBwYXJzZUludCh0aGF0WyckJytrXS52YWwoKSwgMTApIDogZGVmOyBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihpc05hTih2YWx1ZXNba10pKSB7XG4gICAgICAgICAgICAgICAgICAgbm90U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vaWYgYXQgbGVhc3Qgb25lIHZpc2libGUgY29tYm8gbm90IHNlbGVjdGVkIC0gcmV0dXJuIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgaWYobm90U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9jb252ZXJ0IGhvdXJzIDEyaCAtLT4gMjRoIFxuICAgICAgICAgICAgaWYodGhpcy4kYW1wbSkge1xuICAgICAgICAgICAgICAgIC8vMTI6MDAgcG0gLS0+IDEyOjAwICgyNC1oIGZvcm1hdCwgbWlkZGF5KSwgMTI6MDAgYW0gLS0+IDAwOjAwICgyNC1oIGZvcm1hdCwgbWlkbmlnaHQsIHN0YXJ0IG9mIGRheSlcbiAgICAgICAgICAgICAgICBpZih2YWx1ZXMuaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmhvdXIgPSB0aGlzLiRhbXBtLnZhbCgpID09PSAnYW0nID8gMCA6IDEyOyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmhvdXIgPSB0aGlzLiRhbXBtLnZhbCgpID09PSAnYW0nID8gdmFsdWVzLmhvdXIgOiB2YWx1ZXMuaG91cisxMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBkdCA9IG1vbWVudChbdmFsdWVzLnllYXIsIHZhbHVlcy5tb250aCwgdmFsdWVzLmRheSwgdmFsdWVzLmhvdXIsIHZhbHVlcy5taW51dGUsIHZhbHVlcy5zZWNvbmRdKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9oaWdobGlnaHQgaW52YWxpZCBkYXRlXG4gICAgICAgICAgICB0aGlzLmhpZ2hsaWdodChkdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCA9PT0gdW5kZWZpbmVkID8gdGhpcy5vcHRpb25zLmZvcm1hdCA6IGZvcm1hdDtcbiAgICAgICAgICAgIGlmKGZvcm1hdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgcmV0dXJuIGR0LmlzVmFsaWQoKSA/IGR0IDogbnVsbDsgXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgcmV0dXJuIGR0LmlzVmFsaWQoKSA/IGR0LmZvcm1hdChmb3JtYXQpIDogJyc7IFxuICAgICAgICAgICAgfSAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGR0ID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IG1vbWVudCh2YWx1ZSwgdGhpcy5vcHRpb25zLmZvcm1hdCkgOiBtb21lbnQodmFsdWUpLFxuICAgICAgICAgICAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgICAgICAgICAgIHZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2Z1bmN0aW9uIHRvIGZpbmQgbmVhcmVzdCB2YWx1ZSBpbiBzZWxlY3Qgb3B0aW9uc1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0TmVhcmVzdCgkc2VsZWN0LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IHt9O1xuICAgICAgICAgICAgICAgICRzZWxlY3QuY2hpbGRyZW4oJ29wdGlvbicpLmVhY2goZnVuY3Rpb24oaSwgb3B0KXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wdFZhbHVlID0gJChvcHQpLmF0dHIoJ3ZhbHVlJyksXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKG9wdFZhbHVlID09PSAnJykgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguYWJzKG9wdFZhbHVlIC0gdmFsdWUpOyBcbiAgICAgICAgICAgICAgICAgICAgaWYodHlwZW9mIGRlbHRhLmRpc3RhbmNlID09PSAndW5kZWZpbmVkJyB8fCBkaXN0YW5jZSA8IGRlbHRhLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IHt2YWx1ZTogb3B0VmFsdWUsIGRpc3RhbmNlOiBkaXN0YW5jZX07XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgfSk7IFxuICAgICAgICAgICAgICAgIHJldHVybiBkZWx0YS52YWx1ZTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGR0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIC8vcmVhZCB2YWx1ZXMgZnJvbSBkYXRlIG9iamVjdFxuICAgICAgICAgICAgICAgICQuZWFjaCh0aGlzLm1hcCwgZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgICAgICAgICAgICBpZihrID09PSAnYW1wbScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNba10gPSBkdFt2WzFdXSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodGhpcy4kYW1wbSkge1xuICAgICAgICAgICAgICAgICAgICAvLzEyOjAwIHBtIC0tPiAxMjowMCAoMjQtaCBmb3JtYXQsIG1pZGRheSksIDEyOjAwIGFtIC0tPiAwMDowMCAoMjQtaCBmb3JtYXQsIG1pZG5pZ2h0LCBzdGFydCBvZiBkYXkpXG4gICAgICAgICAgICAgICAgICAgIGlmKHZhbHVlcy5ob3VyID49IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuYW1wbSA9ICdwbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih2YWx1ZXMuaG91ciA+IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmhvdXIgLT0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuYW1wbSA9ICdhbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih2YWx1ZXMuaG91ciA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5ob3VyID0gMTI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgJC5lYWNoKHZhbHVlcywgZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgICAgICAgICAgICAvL2NhbGwgdmFsKCkgZm9yIGVhY2ggZXhpc3RpbmcgY29tYm8sIGUuZy4gdGhpcy4kaG91ci52YWwoKVxuICAgICAgICAgICAgICAgICAgICBpZih0aGF0WyckJytrXSkge1xuICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGsgPT09ICdtaW51dGUnICYmIHRoYXQub3B0aW9ucy5taW51dGVTdGVwID4gMSAmJiB0aGF0Lm9wdGlvbnMucm91bmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gZ2V0TmVhcmVzdCh0aGF0WyckJytrXSwgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoayA9PT0gJ3NlY29uZCcgJiYgdGhhdC5vcHRpb25zLnNlY29uZFN0ZXAgPiAxICYmIHRoYXQub3B0aW9ucy5yb3VuZFRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBnZXROZWFyZXN0KHRoYXRbJyQnK2tdLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXRbJyQnK2tdLnZhbCh2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGRheXMgY291bnRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNtYXJ0RGF5cykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGxDb21ibygnZGF5Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnZhbChkdC5mb3JtYXQodGhpcy5vcHRpb25zLmZvcm1hdCkpLmNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgLypcbiAgICAgICAgIGhpZ2hsaWdodCBjb21ib3MgaWYgZGF0ZSBpcyBpbnZhbGlkXG4gICAgICAgICovXG4gICAgICAgIGhpZ2hsaWdodDogZnVuY3Rpb24oZHQpIHtcbiAgICAgICAgICAgIGlmKCFkdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR3aWRnZXQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmVycm9yQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vc3RvcmUgb3JpZ2luYWwgYm9yZGVyIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgIGlmKCF0aGlzLmJvcmRlckNvbG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJvcmRlckNvbG9yID0gdGhpcy4kd2lkZ2V0LmZpbmQoJ3NlbGVjdCcpLmNzcygnYm9yZGVyLWNvbG9yJyk7IFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHdpZGdldC5maW5kKCdzZWxlY3QnKS5jc3MoJ2JvcmRlci1jb2xvcicsICdyZWQnKTtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuZXJyb3JDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiR3aWRnZXQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmVycm9yQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHdpZGdldC5maW5kKCdzZWxlY3QnKS5jc3MoJ2JvcmRlci1jb2xvcicsIHRoaXMuYm9yZGVyQ29sb3IpO1xuICAgICAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgbGVhZFplcm86IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHJldHVybiB2IDw9IDkgPyAnMCcgKyB2IDogdjsgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJHdpZGdldC5yZW1vdmUoKTtcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YSgnY29tYm9kYXRlJykuc2hvdygpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvL3RvZG86IGNsZWFyIG1ldGhvZCAgICAgICAgXG4gICAgfTtcblxuICAgICQuZm4uY29tYm9kYXRlID0gZnVuY3Rpb24gKCBvcHRpb24gKSB7XG4gICAgICAgIHZhciBkLCBhcmdzID0gQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgYXJncy5zaGlmdCgpO1xuXG4gICAgICAgIC8vZ2V0VmFsdWUgcmV0dXJucyBkYXRlIGFzIHN0cmluZyAvIG9iamVjdCAobm90IGpRdWVyeSBvYmplY3QpXG4gICAgICAgIGlmKG9wdGlvbiA9PT0gJ2dldFZhbHVlJyAmJiB0aGlzLmxlbmd0aCAmJiAoZCA9IHRoaXMuZXEoMCkuZGF0YSgnY29tYm9kYXRlJykpKSB7XG4gICAgICAgICAgcmV0dXJuIGQuZ2V0VmFsdWUuYXBwbHkoZCwgYXJncyk7XG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLFxuICAgICAgICAgICAgZGF0YSA9ICR0aGlzLmRhdGEoJ2NvbWJvZGF0ZScpLFxuICAgICAgICAgICAgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uO1xuICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuZGF0YSgnY29tYm9kYXRlJywgKGRhdGEgPSBuZXcgQ29tYm9kYXRlKHRoaXMsIG9wdGlvbnMpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZGF0YVtvcHRpb25dID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBkYXRhW29wdGlvbl0uYXBwbHkoZGF0YSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07ICBcbiAgICBcbiAgICAkLmZuLmNvbWJvZGF0ZS5kZWZhdWx0cyA9IHtcbiAgICAgICAgIC8vaW4gdGhpcyBmb3JtYXQgdmFsdWUgc3RvcmVkIGluIG9yaWdpbmFsIGlucHV0XG4gICAgICAgIGZvcm1hdDogJ0RELU1NLVlZWVkgSEg6bW0nLCAgICAgIFxuICAgICAgICAvL2luIHRoaXMgZm9ybWF0IGl0ZW1zIGluIGRyb3Bkb3ducyBhcmUgZGlzcGxheWVkXG4gICAgICAgIHRlbXBsYXRlOiAnRCAvIE1NTSAvIFlZWVkgICBIIDogbW0nLFxuICAgICAgICAvL2luaXRpYWwgdmFsdWUsIGNhbiBiZSBgbmV3IERhdGUoKWAgICAgXG4gICAgICAgIHZhbHVlOiBudWxsLCAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIG1pblllYXI6IDE5NzAsXG4gICAgICAgIG1heFllYXI6IDIwMTUsXG4gICAgICAgIHllYXJEZXNjZW5kaW5nOiB0cnVlLFxuICAgICAgICBtaW51dGVTdGVwOiA1LFxuICAgICAgICBzZWNvbmRTdGVwOiAxLFxuICAgICAgICBmaXJzdEl0ZW06ICdlbXB0eScsIC8vJ25hbWUnLCAnZW1wdHknLCAnbm9uZSdcbiAgICAgICAgZXJyb3JDbGFzczogbnVsbCxcbiAgICAgICAgcm91bmRUaW1lOiB0cnVlLCAvLyB3aGV0aGVyIHRvIHJvdW5kIG1pbnV0ZXMgYW5kIHNlY29uZHMgaWYgc3RlcCA+IDFcbiAgICAgICAgc21hcnREYXlzOiBmYWxzZSAvLyB3aGV0aGVyIGRheXMgaW4gY29tYm8gZGVwZW5kIG9uIHNlbGVjdGVkIG1vbnRoOiAzMSwgMzAsIDI4XG4gICAgfTtcblxufSh3aW5kb3cualF1ZXJ5KSk7XG4vKipcbkNvbWJvZGF0ZSBpbnB1dCAtIGRyb3Bkb3duIGRhdGUgYW5kIHRpbWUgcGlja2VyLiAgICBcbkJhc2VkIG9uIFtjb21ib2RhdGVdKGh0dHA6Ly92aXRhbGV0cy5naXRodWIuY29tL2NvbWJvZGF0ZSkgcGx1Z2luIChpbmNsdWRlZCkuIFRvIHVzZSBpdCB5b3Ugc2hvdWxkIG1hbnVhbGx5IGluY2x1ZGUgW21vbWVudGpzXShodHRwOi8vbW9tZW50anMuY29tKS5cblxuICAgIDxzY3JpcHQgc3JjPVwianMvbW9tZW50Lm1pbi5qc1wiPjwvc2NyaXB0PlxuICAgXG5BbGxvd3MgdG8gaW5wdXQ6XG5cbiogb25seSBkYXRlXG4qIG9ubHkgdGltZSBcbiogYm90aCBkYXRlIGFuZCB0aW1lICBcblxuUGxlYXNlIG5vdGUsIHRoYXQgZm9ybWF0IGlzIHRha2VuIGZyb20gbW9tZW50anMgYW5kICoqbm90IGNvbXBhdGlibGUqKiB3aXRoIGJvb3RzdHJhcC1kYXRlcGlja2VyIC8ganF1ZXJ5IFVJIGRhdGVwaWNrZXIuICBcbkludGVybmFsbHkgdmFsdWUgc3RvcmVkIGFzIGBtb21lbnRqc2Agb2JqZWN0LiBcblxuQGNsYXNzIGNvbWJvZGF0ZVxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuQGZpbmFsXG5Ac2luY2UgMS40LjBcbkBleGFtcGxlXG48YSBocmVmPVwiI1wiIGlkPVwiZG9iXCIgZGF0YS10eXBlPVwiY29tYm9kYXRlXCIgZGF0YS1waz1cIjFcIiBkYXRhLXVybD1cIi9wb3N0XCIgZGF0YS12YWx1ZT1cIjE5ODQtMDUtMTVcIiBkYXRhLXRpdGxlPVwiU2VsZWN0IGRhdGVcIj48L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNkb2InKS5lZGl0YWJsZSh7XG4gICAgICAgIGZvcm1hdDogJ1lZWVktTU0tREQnLCAgICBcbiAgICAgICAgdmlld2Zvcm1hdDogJ0RELk1NLllZWVknLCAgICBcbiAgICAgICAgdGVtcGxhdGU6ICdEIC8gTU1NTSAvIFlZWVknLCAgICBcbiAgICAgICAgY29tYm9kYXRlOiB7XG4gICAgICAgICAgICAgICAgbWluWWVhcjogMjAwMCxcbiAgICAgICAgICAgICAgICBtYXhZZWFyOiAyMDE1LFxuICAgICAgICAgICAgICAgIG1pbnV0ZVN0ZXA6IDFcbiAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG5cbi8qZ2xvYmFsIG1vbWVudCovXG5cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcbiAgICBcbiAgICB2YXIgQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2NvbWJvZGF0ZScsIG9wdGlvbnMsIENvbnN0cnVjdG9yLmRlZmF1bHRzKTtcbiAgICAgICAgXG4gICAgICAgIC8vYnkgZGVmYXVsdCB2aWV3Zm9ybWF0IGVxdWFscyB0byBmb3JtYXRcbiAgICAgICAgaWYoIXRoaXMub3B0aW9ucy52aWV3Zm9ybWF0KSB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCA9IHRoaXMub3B0aW9ucy5mb3JtYXQ7XG4gICAgICAgIH0gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLy90cnkgcGFyc2UgY29tYm9kYXRlIGNvbmZpZyBkZWZpbmVkIGFzIGpzb24gc3RyaW5nIGluIGRhdGEtY29tYm9kYXRlXG4gICAgICAgIG9wdGlvbnMuY29tYm9kYXRlID0gJC5mbi5lZGl0YWJsZXV0aWxzLnRyeVBhcnNlSnNvbihvcHRpb25zLmNvbWJvZGF0ZSwgdHJ1ZSk7XG5cbiAgICAgICAgLy9vdmVycmlkaW5nIGNvbWJvZGF0ZSBjb25maWcgKGFzIGJ5IGRlZmF1bHQgalF1ZXJ5IGV4dGVuZCgpIGlzIG5vdCByZWN1cnNpdmUpXG4gICAgICAgIHRoaXMub3B0aW9ucy5jb21ib2RhdGUgPSAkLmV4dGVuZCh7fSwgQ29uc3RydWN0b3IuZGVmYXVsdHMuY29tYm9kYXRlLCBvcHRpb25zLmNvbWJvZGF0ZSwge1xuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLm9wdGlvbnMuZm9ybWF0LFxuICAgICAgICAgICAgdGVtcGxhdGU6IHRoaXMub3B0aW9ucy50ZW1wbGF0ZVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoQ29uc3RydWN0b3IsICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0KTsgICAgXG4gICAgXG4gICAgJC5leHRlbmQoQ29uc3RydWN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuY29tYm9kYXRlKHRoaXMub3B0aW9ucy5jb21ib2RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCQuZm4uZWRpdGFibGVmb3JtLmVuZ2luZSA9PT0gJ2JzMycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5zaWJsaW5ncygpLmZpbmQoJ3NlbGVjdCcpLmFkZENsYXNzKCdmb3JtLWNvbnRyb2wnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmlucHV0Y2xhc3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRpbnB1dC5zaWJsaW5ncygpLmZpbmQoJ3NlbGVjdCcpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5pbnB1dGNsYXNzKTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vXCJjbGVhclwiIGxpbmtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBpZih0aGlzLm9wdGlvbnMuY2xlYXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiRjbGVhciA9ICQoJzxhIGhyZWY9XCIjXCI+PC9hPicpLmh0bWwodGhpcy5vcHRpb25zLmNsZWFyKS5jbGljaygkLnByb3h5KGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy4kdHBsLnBhcmVudCgpLmFwcGVuZCgkKCc8ZGl2IGNsYXNzPVwiZWRpdGFibGUtY2xlYXJcIj4nKS5hcHBlbmQodGhpcy4kY2xlYXIpKTsgIFxuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICovICAgICAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICB2YWx1ZTJodG1sOiBmdW5jdGlvbih2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHRleHQgPSB2YWx1ZSA/IHZhbHVlLmZvcm1hdCh0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCkgOiAnJztcbiAgICAgICAgICAgIC8vJChlbGVtZW50KS50ZXh0KHRleHQpO1xuICAgICAgICAgICAgQ29uc3RydWN0b3Iuc3VwZXJjbGFzcy52YWx1ZTJodG1sLmNhbGwodGhpcywgdGV4dCwgZWxlbWVudCk7ICBcbiAgICAgICAgfSxcblxuICAgICAgICBodG1sMnZhbHVlOiBmdW5jdGlvbihodG1sKSB7XG4gICAgICAgICAgICByZXR1cm4gaHRtbCA/IG1vbWVudChodG1sLCB0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCkgOiBudWxsO1xuICAgICAgICB9LCAgIFxuICAgICAgICBcbiAgICAgICAgdmFsdWUyc3RyOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gdmFsdWUuZm9ybWF0KHRoaXMub3B0aW9ucy5mb3JtYXQpIDogJyc7XG4gICAgICAgfSwgXG4gICAgICAgXG4gICAgICAgc3RyMnZhbHVlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgcmV0dXJuIHN0ciA/IG1vbWVudChzdHIsIHRoaXMub3B0aW9ucy5mb3JtYXQpIDogbnVsbDtcbiAgICAgICB9LCBcbiAgICAgICBcbiAgICAgICB2YWx1ZTJzdWJtaXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlMnN0cih2YWx1ZSk7XG4gICAgICAgfSwgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgdmFsdWUyaW5wdXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgIHRoaXMuJGlucHV0LmNvbWJvZGF0ZSgnc2V0VmFsdWUnLCB2YWx1ZSk7XG4gICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgaW5wdXQydmFsdWU6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0LmNvbWJvZGF0ZSgnZ2V0VmFsdWUnLCBudWxsKTtcbiAgICAgICB9LCAgICAgICBcbiAgICAgICBcbiAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIHRoaXMuJGlucHV0LnNpYmxpbmdzKCcuY29tYm9kYXRlJykuZmluZCgnc2VsZWN0JykuZXEoMCkuZm9jdXMoKTtcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qXG4gICAgICAgY2xlYXI6ICBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLiRpbnB1dC5kYXRhKCdkYXRlcGlja2VyJykuZGF0ZSA9IG51bGw7XG4gICAgICAgICAgdGhpcy4kaW5wdXQuZmluZCgnLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICAgICB9LFxuICAgICAgICovXG4gICAgICAgXG4gICAgICAgYXV0b3N1Ym1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgIFxuICAgICAgIH1cblxuICAgIH0pO1xuICAgIFxuICAgIENvbnN0cnVjdG9yLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0LmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsIFxuICAgICAgICBAZGVmYXVsdCA8aW5wdXQgdHlwZT1cInRleHRcIj5cbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHRwbDonPGlucHV0IHR5cGU9XCJ0ZXh0XCI+JyxcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBpbnB1dGNsYXNzIFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBpbnB1dGNsYXNzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgRm9ybWF0IHVzZWQgZm9yIHNlbmRpbmcgdmFsdWUgdG8gc2VydmVyLiBBbHNvIGFwcGxpZWQgd2hlbiBjb252ZXJ0aW5nIGRhdGUgZnJvbSA8Y29kZT5kYXRhLXZhbHVlPC9jb2RlPiBhdHRyaWJ1dGUuPGJyPlxuICAgICAgICBTZWUgbGlzdCBvZiB0b2tlbnMgaW4gW21vbWVudGpzIGRvY3NdKGh0dHA6Ly9tb21lbnRqcy5jb20vZG9jcy8jL3BhcnNpbmcvc3RyaW5nLWZvcm1hdCkgIFxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IGZvcm1hdCBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IFlZWVktTU0tRERcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIGZvcm1hdDonWVlZWS1NTS1ERCcsXG4gICAgICAgIC8qKlxuICAgICAgICBGb3JtYXQgdXNlZCBmb3IgZGlzcGxheWluZyBkYXRlLiBBbHNvIGFwcGxpZWQgd2hlbiBjb252ZXJ0aW5nIGRhdGUgZnJvbSBlbGVtZW50J3MgdGV4dCBvbiBpbml0LiAgIFxuICAgICAgICBJZiBub3Qgc3BlY2lmaWVkIGVxdWFscyB0byBgZm9ybWF0YC5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSB2aWV3Zm9ybWF0IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAqKi8gICAgICAgICAgXG4gICAgICAgIHZpZXdmb3JtYXQ6IG51bGwsICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgIFRlbXBsYXRlIHVzZWQgZm9yIGRpc3BsYXlpbmcgZHJvcGRvd25zLlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IHRlbXBsYXRlIFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgRCAvIE1NTSAvIFlZWVlcbiAgICAgICAgKiovICAgICAgICAgIFxuICAgICAgICB0ZW1wbGF0ZTogJ0QgLyBNTU0gLyBZWVlZJywgIFxuICAgICAgICAvKipcbiAgICAgICAgQ29uZmlndXJhdGlvbiBvZiBjb21ib2RhdGUuXG4gICAgICAgIEZ1bGwgbGlzdCBvZiBvcHRpb25zOiBodHRwOi8vdml0YWxldHMuZ2l0aHViLmNvbS9jb21ib2RhdGUvI2RvY3NcbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBjb21ib2RhdGUgXG4gICAgICAgIEB0eXBlIG9iamVjdFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICBjb21ib2RhdGU6IG51bGxcbiAgICAgICAgXG4gICAgICAgIC8qXG4gICAgICAgIChub3QgaW1wbGVtZW50ZWQgeWV0KVxuICAgICAgICBUZXh0IHNob3duIGFzIGNsZWFyIGRhdGUgYnV0dG9uLiBcbiAgICAgICAgSWYgPGNvZGU+ZmFsc2U8L2NvZGU+IGNsZWFyIGJ1dHRvbiB3aWxsIG5vdCBiZSByZW5kZXJlZC5cbiAgICAgICAgXG4gICAgICAgIEBwcm9wZXJ0eSBjbGVhciBcbiAgICAgICAgQHR5cGUgYm9vbGVhbnxzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgJ3ggY2xlYXInICAgICAgICAgXG4gICAgICAgICovXG4gICAgICAgIC8vY2xlYXI6ICcmdGltZXM7IGNsZWFyJ1xuICAgIH0pOyAgIFxuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLmNvbWJvZGF0ZSA9IENvbnN0cnVjdG9yO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLypcbkVkaXRhYmxlZm9ybSBiYXNlZCBvbiBUd2l0dGVyIEJvb3RzdHJhcCAzXG4qL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgO1xuICAgIFxuICAgIC8vc3RvcmUgcGFyZW50IG1ldGhvZHNcbiAgICB2YXIgcEluaXRJbnB1dCA9ICQuZm4uZWRpdGFibGVmb3JtLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5pbml0SW5wdXQ7XG4gICAgXG4gICAgJC5leHRlbmQoJC5mbi5lZGl0YWJsZWZvcm0uQ29uc3RydWN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGluaXRUZW1wbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRmb3JtID0gJCgkLmZuLmVkaXRhYmxlZm9ybS50ZW1wbGF0ZSk7IFxuICAgICAgICAgICAgdGhpcy4kZm9ybS5maW5kKCcuY29udHJvbC1ncm91cCcpLmFkZENsYXNzKCdmb3JtLWdyb3VwJyk7XG4gICAgICAgICAgICB0aGlzLiRmb3JtLmZpbmQoJy5lZGl0YWJsZS1lcnJvci1ibG9jaycpLmFkZENsYXNzKCdoZWxwLWJsb2NrJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGluaXRJbnB1dDogZnVuY3Rpb24oKSB7ICBcbiAgICAgICAgICAgIHBJbml0SW5wdXQuYXBwbHkodGhpcyk7XG5cbiAgICAgICAgICAgIC8vZm9yIGJzMyBzZXQgZGVmYXVsdCBjbGFzcyBgaW5wdXQtc21gIHRvIHN0YW5kYXJkIGlucHV0c1xuICAgICAgICAgICAgdmFyIGVtcHR5SW5wdXRDbGFzcyA9IHRoaXMuaW5wdXQub3B0aW9ucy5pbnB1dGNsYXNzID09PSBudWxsIHx8IHRoaXMuaW5wdXQub3B0aW9ucy5pbnB1dGNsYXNzID09PSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0Q2xhc3MgPSAnaW5wdXQtc20nO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2JzMyBhZGQgYGZvcm0tY29udHJvbGAgY2xhc3MgdG8gc3RhbmRhcmQgaW5wdXRzXG4gICAgICAgICAgICB2YXIgc3RkdHlwZXMgPSAndGV4dCxzZWxlY3QsdGV4dGFyZWEscGFzc3dvcmQsZW1haWwsdXJsLHRlbCxudW1iZXIscmFuZ2UsdGltZSx0eXBlYWhlYWRqcycuc3BsaXQoJywnKTsgXG4gICAgICAgICAgICBpZih+JC5pbkFycmF5KHRoaXMuaW5wdXQudHlwZSwgc3RkdHlwZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dC4kaW5wdXQuYWRkQ2xhc3MoJ2Zvcm0tY29udHJvbCcpO1xuICAgICAgICAgICAgICAgIGlmKGVtcHR5SW5wdXRDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0Lm9wdGlvbnMuaW5wdXRjbGFzcyA9IGRlZmF1bHRDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dC4kaW5wdXQuYWRkQ2xhc3MoZGVmYXVsdENsYXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgICAgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgICAgIC8vYXBwbHkgYnMzIHNpemUgY2xhc3MgYWxzbyB0byBidXR0b25zICh0byBmaXQgc2l6ZSBvZiBjb250cm9sKVxuICAgICAgICAgICAgdmFyICRidG4gPSB0aGlzLiRmb3JtLmZpbmQoJy5lZGl0YWJsZS1idXR0b25zJyk7XG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IGVtcHR5SW5wdXRDbGFzcyA/IFtkZWZhdWx0Q2xhc3NdIDogdGhpcy5pbnB1dC5vcHRpb25zLmlucHV0Y2xhc3Muc3BsaXQoJyAnKTtcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBgYnRuLXNtYCBpcyBkZWZhdWx0IG5vd1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgaWYoY2xhc3Nlc1tpXS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQtc20nKSB7IFxuICAgICAgICAgICAgICAgICAgICAkYnRuLmZpbmQoJ2J1dHRvbicpLmFkZENsYXNzKCdidG4tc20nKTsgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmKGNsYXNzZXNbaV0udG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0LWxnJykge1xuICAgICAgICAgICAgICAgICAgICAkYnRuLmZpbmQoJ2J1dHRvbicpLnJlbW92ZUNsYXNzKCdidG4tc20nKS5hZGRDbGFzcygnYnRuLWxnJyk7IFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pOyAgICBcbiAgICBcbiAgICAvL2J1dHRvbnNcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5idXR0b25zID0gXG4gICAgICAnPGJ1dHRvbiB0eXBlPVwic3VibWl0XCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgYnRuLXNtIGVkaXRhYmxlLXN1Ym1pdFwiPicrXG4gICAgICAgICc8aSBjbGFzcz1cImZhIGZhLW9rXCI+PC9pPicrXG4gICAgICAnPC9idXR0b24+JytcbiAgICAgICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCBidG4tc20gZWRpdGFibGUtY2FuY2VsXCI+JytcbiAgICAgICAgJzxpIGNsYXNzPVwiZmEgZmEtcmVtb3ZlXCI+PC9pPicrXG4gICAgICAnPC9idXR0b24+JzsgICAgICAgICBcbiAgICBcbiAgICAvL2Vycm9yIGNsYXNzZXNcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckdyb3VwQ2xhc3MgPSAnaGFzLWVycm9yJztcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5lcnJvckJsb2NrQ2xhc3MgPSBudWxsOyAgXG4gICAgLy9lbmdpbmVcbiAgICAkLmZuLmVkaXRhYmxlZm9ybS5lbmdpbmUgPSAnYnMzJzsgIFxufSh3aW5kb3cualF1ZXJ5KSk7XG4vKipcbiogRWRpdGFibGUgUG9wb3ZlcjMgKGZvciBCb290c3RyYXAgMykgXG4qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuKiByZXF1aXJlcyBib290c3RyYXAtcG9wb3Zlci5qc1xuKi9cbihmdW5jdGlvbiAoJCkge1xuICAgIDtcblxuICAgIC8vZXh0ZW5kIG1ldGhvZHNcbiAgICAkLmV4dGVuZCgkLmZuLmVkaXRhYmxlQ29udGFpbmVyLlBvcHVwLnByb3RvdHlwZSwge1xuICAgICAgICBjb250YWluZXJOYW1lOiAncG9wb3ZlcicsXG4gICAgICAgIGNvbnRhaW5lckRhdGFOYW1lOiAnYnMucG9wb3ZlcicsXG4gICAgICAgIGlubmVyQ3NzOiAnLnBvcG92ZXItY29udGVudCcsXG4gICAgICAgIGRlZmF1bHRzOiAkLmZuLnBvcG92ZXIuQ29uc3RydWN0b3IuREVGQVVMVFMsXG5cbiAgICAgICAgaW5pdENvbnRhaW5lcjogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICQuZXh0ZW5kKHRoaXMuY29udGFpbmVyT3B0aW9ucywge1xuICAgICAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgICAgIHNlbGVjdG9yOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiAnICcsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IHRoaXMuZGVmYXVsdHMudGVtcGxhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2FzIHRlbXBsYXRlIHByb3BlcnR5IGlzIHVzZWQgaW4gaW5wdXRzLCBoaWRlIGl0IGZyb20gcG9wb3ZlclxuICAgICAgICAgICAgdmFyIHQ7XG4gICAgICAgICAgICBpZih0aGlzLiRlbGVtZW50LmRhdGEoJ3RlbXBsYXRlJykpIHtcbiAgICAgICAgICAgICAgIHQgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ3RlbXBsYXRlJyk7XG4gICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZURhdGEoJ3RlbXBsYXRlJyk7ICBcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuY2FsbCh0aGlzLmNvbnRhaW5lck9wdGlvbnMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZih0KSB7XG4gICAgICAgICAgICAgICAvL3Jlc3RvcmUgZGF0YSgndGVtcGxhdGUnKVxuICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5kYXRhKCd0ZW1wbGF0ZScsIHQpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgXG4gICAgICAgIFxuICAgICAgICAvKiBzaG93ICovXG4gICAgICAgIGlubmVyU2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsKCdzaG93Jyk7ICAgICAgICAgICAgICAgIFxuICAgICAgICB9LCAgXG4gICAgICAgIFxuICAgICAgICAvKiBoaWRlICovXG4gICAgICAgIGlubmVySGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsKCdoaWRlJyk7ICAgICAgIFxuICAgICAgICB9LCBcbiAgICAgICAgXG4gICAgICAgIC8qIGRlc3Ryb3kgKi9cbiAgICAgICAgaW5uZXJEZXN0cm95OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbCgnZGVzdHJveScpO1xuICAgICAgICB9LCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHNldENvbnRhaW5lck9wdGlvbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIoKS5vcHRpb25zW2tleV0gPSB2YWx1ZTsgXG4gICAgICAgIH0sICAgICAgICAgICAgICAgXG5cbiAgICAgICAgLyoqXG4gICAgICAgICogbW92ZSBwb3BvdmVyIHRvIG5ldyBwb3NpdGlvbi4gVGhpcyBmdW5jdGlvbiBtYWlubHkgY29waWVkIGZyb20gYm9vdHN0cmFwLXBvcG92ZXIuXG4gICAgICAgICovXG4gICAgICAgIC8qanNoaW50IGxheGNvbW1hOiB0cnVlLCBlcWVxZXE6IGZhbHNlKi9cbiAgICAgICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHsgXG5cbiAgICAgICAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8qICAgIFxuICAgICAgICAgICAgICAgIHZhciAkdGlwID0gdGhpcy50aXAoKVxuICAgICAgICAgICAgICAgICwgaW5zaWRlXG4gICAgICAgICAgICAgICAgLCBwb3NcbiAgICAgICAgICAgICAgICAsIGFjdHVhbFdpZHRoXG4gICAgICAgICAgICAgICAgLCBhY3R1YWxIZWlnaHRcbiAgICAgICAgICAgICAgICAsIHBsYWNlbWVudFxuICAgICAgICAgICAgICAgICwgdHBcbiAgICAgICAgICAgICAgICAsIHRwdFxuICAgICAgICAgICAgICAgICwgdHBiXG4gICAgICAgICAgICAgICAgLCB0cGxcbiAgICAgICAgICAgICAgICAsIHRwcjtcblxuICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMucGxhY2VtZW50ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucGxhY2VtZW50LmNhbGwodGhpcywgJHRpcFswXSwgdGhpcy4kZWxlbWVudFswXSkgOlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICBpbnNpZGUgPSAvaW4vLnRlc3QocGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICR0aXBcbiAgICAgICAgICAgICAgLy8gIC5kZXRhY2goKVxuICAgICAgICAgICAgICAvL3ZpdGFsZXRzOiByZW1vdmUgYW55IHBsYWNlbWVudCBjbGFzcyBiZWNhdXNlIG90aGVyd2lzZSB0aGV5IGRvbnQgaW5mbHVlbmNlIG9uIHJlLXBvc2l0aW9uaW5nIG9mIHZpc2libGUgcG9wb3ZlclxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygndG9wIHJpZ2h0IGJvdHRvbSBsZWZ0JylcbiAgICAgICAgICAgICAgICAuY3NzKHsgdG9wOiAwLCBsZWZ0OiAwLCBkaXNwbGF5OiAnYmxvY2snIH0pO1xuICAgICAgICAgICAgICAvLyAgLmluc2VydEFmdGVyKHRoaXMuJGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcG9zID0gdGhpcy5nZXRQb3NpdGlvbihpbnNpZGUpO1xuXG4gICAgICAgICAgICAgICAgYWN0dWFsV2lkdGggPSAkdGlwWzBdLm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgIGFjdHVhbEhlaWdodCA9ICR0aXBbMF0ub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gaW5zaWRlID8gcGxhY2VtZW50LnNwbGl0KCcgJylbMV0gOiBwbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICB0cGIgPSB7dG9wOiBwb3MudG9wICsgcG9zLmhlaWdodCwgbGVmdDogcG9zLmxlZnQgKyBwb3Mud2lkdGggLyAyIC0gYWN0dWFsV2lkdGggLyAyfTtcbiAgICAgICAgICAgICAgICB0cHQgPSB7dG9wOiBwb3MudG9wIC0gYWN0dWFsSGVpZ2h0LCBsZWZ0OiBwb3MubGVmdCArIHBvcy53aWR0aCAvIDIgLSBhY3R1YWxXaWR0aCAvIDJ9O1xuICAgICAgICAgICAgICAgIHRwbCA9IHt0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0IC8gMiAtIGFjdHVhbEhlaWdodCAvIDIsIGxlZnQ6IHBvcy5sZWZ0IC0gYWN0dWFsV2lkdGh9O1xuICAgICAgICAgICAgICAgIHRwciA9IHt0b3A6IHBvcy50b3AgKyBwb3MuaGVpZ2h0IC8gMiAtIGFjdHVhbEhlaWdodCAvIDIsIGxlZnQ6IHBvcy5sZWZ0ICsgcG9zLndpZHRofTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAocGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRwYi50b3AgKyBhY3R1YWxIZWlnaHQpID4gKCQod2luZG93KS5zY3JvbGxUb3AoKSArICQod2luZG93KS5oZWlnaHQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHB0LnRvcCA+ICQod2luZG93KS5zY3JvbGxUb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0cHIubGVmdCArIGFjdHVhbFdpZHRoKSA8ICgkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgJCh3aW5kb3cpLndpZHRoKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0cGwubGVmdCA+ICQod2luZG93KS5zY3JvbGxMZWZ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHB0LnRvcCA8ICQod2luZG93KS5zY3JvbGxUb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHBiLnRvcCArIGFjdHVhbEhlaWdodCkgPCAoJCh3aW5kb3cpLnNjcm9sbFRvcCgpICsgJCh3aW5kb3cpLmhlaWdodCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAnYm90dG9tJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCh0cHIubGVmdCArIGFjdHVhbFdpZHRoKSA8ICgkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgJCh3aW5kb3cpLndpZHRoKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0cGwubGVmdCA+ICQod2luZG93KS5zY3JvbGxMZWZ0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRwbC5sZWZ0IDwgJCh3aW5kb3cpLnNjcm9sbExlZnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodHByLmxlZnQgKyBhY3R1YWxXaWR0aCkgPCAoJCh3aW5kb3cpLnNjcm9sbExlZnQoKSArICQod2luZG93KS53aWR0aCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHB0LnRvcCA+ICQod2luZG93KS5zY3JvbGxUb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAndG9wJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRwdC50b3AgPiAkKHdpbmRvdykuc2Nyb2xsVG9wKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ2JvdHRvbSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID0gJ3JpZ2h0JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCh0cHIubGVmdCArIGFjdHVhbFdpZHRoKSA+ICgkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgJCh3aW5kb3cpLndpZHRoKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRwbC5sZWZ0ID4gJCh3aW5kb3cpLnNjcm9sbExlZnQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0cHQudG9wID4gJCh3aW5kb3cpLnNjcm9sbFRvcCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9ICd0b3AnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHB0LnRvcCA+ICQod2luZG93KS5zY3JvbGxUb3AoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSAnYm90dG9tJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHAgPSB0cGI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRwID0gdHB0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHAgPSB0cGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHAgPSB0cHI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAkdGlwXG4gICAgICAgICAgICAgICAgLm9mZnNldCh0cClcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3MocGxhY2VtZW50KVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnaW4nKTtcbiAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciAkdGlwID0gdGhpcy50aXAoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLm9wdGlvbnMucGxhY2VtZW50ID09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQuY2FsbCh0aGlzLCAkdGlwWzBdLCB0aGlzLiRlbGVtZW50WzBdKSA6XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBsYWNlbWVudDsgICAgICAgICAgICBcblxuICAgICAgICAgICAgdmFyIGF1dG9Ub2tlbiA9IC9cXHM/YXV0bz9cXHM/L2k7XG4gICAgICAgICAgICB2YXIgYXV0b1BsYWNlID0gYXV0b1Rva2VuLnRlc3QocGxhY2VtZW50KTtcbiAgICAgICAgICAgIGlmIChhdXRvUGxhY2UpIHtcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQucmVwbGFjZShhdXRvVG9rZW4sICcnKSB8fCAndG9wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRQb3NpdGlvbigpO1xuICAgICAgICAgICAgdmFyIGFjdHVhbFdpZHRoID0gJHRpcFswXS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgIHZhciBhY3R1YWxIZWlnaHQgPSAkdGlwWzBdLm9mZnNldEhlaWdodDtcblxuICAgICAgICAgICAgaWYgKGF1dG9QbGFjZSkge1xuICAgICAgICAgICAgICAgIHZhciAkcGFyZW50ID0gdGhpcy4kZWxlbWVudC5wYXJlbnQoKTtcblxuICAgICAgICAgICAgICAgIHZhciBvcmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGRvY1Njcm9sbCAgICA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFdpZHRoICA9IHRoaXMub3B0aW9ucy5jb250YWluZXIgPT0gJ2JvZHknID8gd2luZG93LmlubmVyV2lkdGggIDogJHBhcmVudC5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEhlaWdodCA9IHRoaXMub3B0aW9ucy5jb250YWluZXIgPT0gJ2JvZHknID8gd2luZG93LmlubmVySGVpZ2h0IDogJHBhcmVudC5vdXRlckhlaWdodCgpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRMZWZ0ICAgPSB0aGlzLm9wdGlvbnMuY29udGFpbmVyID09ICdib2R5JyA/IDAgOiAkcGFyZW50Lm9mZnNldCgpLmxlZnQ7XG5cbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQgPT0gJ2JvdHRvbScgJiYgcG9zLnRvcCAgICsgcG9zLmhlaWdodCAgKyBhY3R1YWxIZWlnaHQgLSBkb2NTY3JvbGwgPiBwYXJlbnRIZWlnaHQgID8gJ3RvcCcgICAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudCA9PSAndG9wJyAgICAmJiBwb3MudG9wICAgLSBkb2NTY3JvbGwgICAtIGFjdHVhbEhlaWdodCA8IDAgICAgICAgICAgICAgICAgICAgICAgICAgPyAnYm90dG9tJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50ID09ICdyaWdodCcgICYmIHBvcy5yaWdodCArIGFjdHVhbFdpZHRoID4gcGFyZW50V2lkdGggICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICdsZWZ0JyAgIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnQgPT0gJ2xlZnQnICAgJiYgcG9zLmxlZnQgIC0gYWN0dWFsV2lkdGggPCBwYXJlbnRMZWZ0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gJ3JpZ2h0JyAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudDtcblxuICAgICAgICAgICAgICAgICR0aXBcbiAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhvcmdQbGFjZW1lbnQpXG4gICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MocGxhY2VtZW50KTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB2YXIgY2FsY3VsYXRlZE9mZnNldCA9IHRoaXMuZ2V0Q2FsY3VsYXRlZE9mZnNldChwbGFjZW1lbnQsIHBvcywgYWN0dWFsV2lkdGgsIGFjdHVhbEhlaWdodCk7XG5cbiAgICAgICAgICAgIHRoaXMuYXBwbHlQbGFjZW1lbnQoY2FsY3VsYXRlZE9mZnNldCwgcGxhY2VtZW50KTsgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSkuY2FsbCh0aGlzLmNvbnRhaW5lcigpKTtcbiAgICAgICAgICAvKmpzaGludCBsYXhjb21tYTogZmFsc2UsIGVxZXFlcTogdHJ1ZSovICBcbiAgICAgICAgfSAgICAgICAgICAgIFxuICAgIH0pO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBib290c3RyYXAtZGF0ZXBpY2tlci5qc1xuICogaHR0cDovL3d3dy5leWVjb24ucm8vYm9vdHN0cmFwLWRhdGVwaWNrZXJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weXJpZ2h0IDIwMTIgU3RlZmFuIFBldHJlXG4gKiBJbXByb3ZlbWVudHMgYnkgQW5kcmV3IFJvd2xzXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cblxuKGZ1bmN0aW9uKCAkICkge1xuXG5cdGZ1bmN0aW9uIFVUQ0RhdGUoKXtcblx0XHRyZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkoRGF0ZSwgYXJndW1lbnRzKSk7XG5cdH1cblx0ZnVuY3Rpb24gVVRDVG9kYXkoKXtcblx0XHR2YXIgdG9kYXkgPSBuZXcgRGF0ZSgpO1xuXHRcdHJldHVybiBVVENEYXRlKHRvZGF5LmdldFVUQ0Z1bGxZZWFyKCksIHRvZGF5LmdldFVUQ01vbnRoKCksIHRvZGF5LmdldFVUQ0RhdGUoKSk7XG5cdH1cblxuXHQvLyBQaWNrZXIgb2JqZWN0XG5cblx0dmFyIERhdGVwaWNrZXIgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5fcHJvY2Vzc19vcHRpb25zKG9wdGlvbnMpO1xuXG5cdFx0dGhpcy5lbGVtZW50ID0gJChlbGVtZW50KTtcblx0XHR0aGlzLmlzSW5saW5lID0gZmFsc2U7XG5cdFx0dGhpcy5pc0lucHV0ID0gdGhpcy5lbGVtZW50LmlzKCdpbnB1dCcpO1xuXHRcdHRoaXMuY29tcG9uZW50ID0gdGhpcy5lbGVtZW50LmlzKCcuZGF0ZScpID8gdGhpcy5lbGVtZW50LmZpbmQoJy5hZGQtb24sIC5idG4nKSA6IGZhbHNlO1xuXHRcdHRoaXMuaGFzSW5wdXQgPSB0aGlzLmNvbXBvbmVudCAmJiB0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKS5sZW5ndGg7XG5cdFx0aWYodGhpcy5jb21wb25lbnQgJiYgdGhpcy5jb21wb25lbnQubGVuZ3RoID09PSAwKVxuXHRcdFx0dGhpcy5jb21wb25lbnQgPSBmYWxzZTtcblxuXHRcdHRoaXMucGlja2VyID0gJChEUEdsb2JhbC50ZW1wbGF0ZSk7XG5cdFx0dGhpcy5fYnVpbGRFdmVudHMoKTtcblx0XHR0aGlzLl9hdHRhY2hFdmVudHMoKTtcblxuXHRcdGlmKHRoaXMuaXNJbmxpbmUpIHtcblx0XHRcdHRoaXMucGlja2VyLmFkZENsYXNzKCdkYXRlcGlja2VyLWlubGluZScpLmFwcGVuZFRvKHRoaXMuZWxlbWVudCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucGlja2VyLmFkZENsYXNzKCdkYXRlcGlja2VyLWRyb3Bkb3duIGRyb3Bkb3duLW1lbnUnKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vLnJ0bCl7XG5cdFx0XHR0aGlzLnBpY2tlci5hZGRDbGFzcygnZGF0ZXBpY2tlci1ydGwnKTtcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5wcmV2IGksIC5uZXh0IGknKVxuXHRcdFx0XHRcdFx0LnRvZ2dsZUNsYXNzKCdpY29uLWFycm93LWxlZnQgaWNvbi1hcnJvdy1yaWdodCcpO1xuXHRcdH1cblxuXG5cdFx0dGhpcy52aWV3TW9kZSA9IHRoaXMuby5zdGFydFZpZXc7XG5cblx0XHRpZiAodGhpcy5vLmNhbGVuZGFyV2Vla3MpXG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCd0Zm9vdCB0aC50b2RheScpXG5cdFx0XHRcdFx0XHQuYXR0cignY29sc3BhbicsIGZ1bmN0aW9uKGksIHZhbCl7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBwYXJzZUludCh2YWwpICsgMTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0dGhpcy5fYWxsb3dfdXBkYXRlID0gZmFsc2U7XG5cblx0XHR0aGlzLnNldFN0YXJ0RGF0ZSh0aGlzLm8uc3RhcnREYXRlKTtcblx0XHR0aGlzLnNldEVuZERhdGUodGhpcy5vLmVuZERhdGUpO1xuXHRcdHRoaXMuc2V0RGF5c09mV2Vla0Rpc2FibGVkKHRoaXMuby5kYXlzT2ZXZWVrRGlzYWJsZWQpO1xuXG5cdFx0dGhpcy5maWxsRG93KCk7XG5cdFx0dGhpcy5maWxsTW9udGhzKCk7XG5cblx0XHR0aGlzLl9hbGxvd191cGRhdGUgPSB0cnVlO1xuXG5cdFx0dGhpcy51cGRhdGUoKTtcblx0XHR0aGlzLnNob3dNb2RlKCk7XG5cblx0XHRpZih0aGlzLmlzSW5saW5lKSB7XG5cdFx0XHR0aGlzLnNob3coKTtcblx0XHR9XG5cdH07XG5cblx0RGF0ZXBpY2tlci5wcm90b3R5cGUgPSB7XG5cdFx0Y29uc3RydWN0b3I6IERhdGVwaWNrZXIsXG5cblx0XHRfcHJvY2Vzc19vcHRpb25zOiBmdW5jdGlvbihvcHRzKXtcblx0XHRcdC8vIFN0b3JlIHJhdyBvcHRpb25zIGZvciByZWZlcmVuY2Vcblx0XHRcdHRoaXMuX28gPSAkLmV4dGVuZCh7fSwgdGhpcy5fbywgb3B0cyk7XG5cdFx0XHQvLyBQcm9jZXNzZWQgb3B0aW9uc1xuXHRcdFx0dmFyIG8gPSB0aGlzLm8gPSAkLmV4dGVuZCh7fSwgdGhpcy5fbyk7XG5cblx0XHRcdC8vIENoZWNrIGlmIFwiZGUtREVcIiBzdHlsZSBkYXRlIGlzIGF2YWlsYWJsZSwgaWYgbm90IGxhbmd1YWdlIHNob3VsZFxuXHRcdFx0Ly8gZmFsbGJhY2sgdG8gMiBsZXR0ZXIgY29kZSBlZyBcImRlXCJcblx0XHRcdHZhciBsYW5nID0gby5sYW5ndWFnZTtcblx0XHRcdGlmICghZGF0ZXNbbGFuZ10pIHtcblx0XHRcdFx0bGFuZyA9IGxhbmcuc3BsaXQoJy0nKVswXTtcblx0XHRcdFx0aWYgKCFkYXRlc1tsYW5nXSlcblx0XHRcdFx0XHRsYW5nID0gZGVmYXVsdHMubGFuZ3VhZ2U7XG5cdFx0XHR9XG5cdFx0XHRvLmxhbmd1YWdlID0gbGFuZztcblxuXHRcdFx0c3dpdGNoKG8uc3RhcnRWaWV3KXtcblx0XHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHRjYXNlICdkZWNhZGUnOlxuXHRcdFx0XHRcdG8uc3RhcnRWaWV3ID0gMjtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRjYXNlICd5ZWFyJzpcblx0XHRcdFx0XHRvLnN0YXJ0VmlldyA9IDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0by5zdGFydFZpZXcgPSAwO1xuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKG8ubWluVmlld01vZGUpIHtcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRjYXNlICdtb250aHMnOlxuXHRcdFx0XHRcdG8ubWluVmlld01vZGUgPSAxO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdGNhc2UgJ3llYXJzJzpcblx0XHRcdFx0XHRvLm1pblZpZXdNb2RlID0gMjtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRvLm1pblZpZXdNb2RlID0gMDtcblx0XHRcdH1cblxuXHRcdFx0by5zdGFydFZpZXcgPSBNYXRoLm1heChvLnN0YXJ0Vmlldywgby5taW5WaWV3TW9kZSk7XG5cblx0XHRcdG8ud2Vla1N0YXJ0ICU9IDc7XG5cdFx0XHRvLndlZWtFbmQgPSAoKG8ud2Vla1N0YXJ0ICsgNikgJSA3KTtcblxuXHRcdFx0dmFyIGZvcm1hdCA9IERQR2xvYmFsLnBhcnNlRm9ybWF0KG8uZm9ybWF0KVxuXHRcdFx0aWYgKG8uc3RhcnREYXRlICE9PSAtSW5maW5pdHkpIHtcblx0XHRcdFx0by5zdGFydERhdGUgPSBEUEdsb2JhbC5wYXJzZURhdGUoby5zdGFydERhdGUsIGZvcm1hdCwgby5sYW5ndWFnZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoby5lbmREYXRlICE9PSBJbmZpbml0eSkge1xuXHRcdFx0XHRvLmVuZERhdGUgPSBEUEdsb2JhbC5wYXJzZURhdGUoby5lbmREYXRlLCBmb3JtYXQsIG8ubGFuZ3VhZ2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRvLmRheXNPZldlZWtEaXNhYmxlZCA9IG8uZGF5c09mV2Vla0Rpc2FibGVkfHxbXTtcblx0XHRcdGlmICghJC5pc0FycmF5KG8uZGF5c09mV2Vla0Rpc2FibGVkKSlcblx0XHRcdFx0by5kYXlzT2ZXZWVrRGlzYWJsZWQgPSBvLmRheXNPZldlZWtEaXNhYmxlZC5zcGxpdCgvWyxcXHNdKi8pO1xuXHRcdFx0by5kYXlzT2ZXZWVrRGlzYWJsZWQgPSAkLm1hcChvLmRheXNPZldlZWtEaXNhYmxlZCwgZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KGQsIDEwKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0X2V2ZW50czogW10sXG5cdFx0X3NlY29uZGFyeUV2ZW50czogW10sXG5cdFx0X2FwcGx5RXZlbnRzOiBmdW5jdGlvbihldnMpe1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBlbCwgZXY7IGk8ZXZzLmxlbmd0aDsgaSsrKXtcblx0XHRcdFx0ZWwgPSBldnNbaV1bMF07XG5cdFx0XHRcdGV2ID0gZXZzW2ldWzFdO1xuXHRcdFx0XHRlbC5vbihldik7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRfdW5hcHBseUV2ZW50czogZnVuY3Rpb24oZXZzKXtcblx0XHRcdGZvciAodmFyIGk9MCwgZWwsIGV2OyBpPGV2cy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdGVsID0gZXZzW2ldWzBdO1xuXHRcdFx0XHRldiA9IGV2c1tpXVsxXTtcblx0XHRcdFx0ZWwub2ZmKGV2KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdF9idWlsZEV2ZW50czogZnVuY3Rpb24oKXtcblx0XHRcdGlmICh0aGlzLmlzSW5wdXQpIHsgLy8gc2luZ2xlIGlucHV0XG5cdFx0XHRcdHRoaXMuX2V2ZW50cyA9IFtcblx0XHRcdFx0XHRbdGhpcy5lbGVtZW50LCB7XG5cdFx0XHRcdFx0XHRmb2N1czogJC5wcm94eSh0aGlzLnNob3csIHRoaXMpLFxuXHRcdFx0XHRcdFx0a2V5dXA6ICQucHJveHkodGhpcy51cGRhdGUsIHRoaXMpLFxuXHRcdFx0XHRcdFx0a2V5ZG93bjogJC5wcm94eSh0aGlzLmtleWRvd24sIHRoaXMpXG5cdFx0XHRcdFx0fV1cblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKHRoaXMuY29tcG9uZW50ICYmIHRoaXMuaGFzSW5wdXQpeyAvLyBjb21wb25lbnQ6IGlucHV0ICsgYnV0dG9uXG5cdFx0XHRcdHRoaXMuX2V2ZW50cyA9IFtcblx0XHRcdFx0XHQvLyBGb3IgY29tcG9uZW50cyB0aGF0IGFyZSBub3QgcmVhZG9ubHksIGFsbG93IGtleWJvYXJkIG5hdlxuXHRcdFx0XHRcdFt0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKSwge1xuXHRcdFx0XHRcdFx0Zm9jdXM6ICQucHJveHkodGhpcy5zaG93LCB0aGlzKSxcblx0XHRcdFx0XHRcdGtleXVwOiAkLnByb3h5KHRoaXMudXBkYXRlLCB0aGlzKSxcblx0XHRcdFx0XHRcdGtleWRvd246ICQucHJveHkodGhpcy5rZXlkb3duLCB0aGlzKVxuXHRcdFx0XHRcdH1dLFxuXHRcdFx0XHRcdFt0aGlzLmNvbXBvbmVudCwge1xuXHRcdFx0XHRcdFx0Y2xpY2s6ICQucHJveHkodGhpcy5zaG93LCB0aGlzKVxuXHRcdFx0XHRcdH1dXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICh0aGlzLmVsZW1lbnQuaXMoJ2RpdicpKSB7ICAvLyBpbmxpbmUgZGF0ZXBpY2tlclxuXHRcdFx0XHR0aGlzLmlzSW5saW5lID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9ldmVudHMgPSBbXG5cdFx0XHRcdFx0W3RoaXMuZWxlbWVudCwge1xuXHRcdFx0XHRcdFx0Y2xpY2s6ICQucHJveHkodGhpcy5zaG93LCB0aGlzKVxuXHRcdFx0XHRcdH1dXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX3NlY29uZGFyeUV2ZW50cyA9IFtcblx0XHRcdFx0W3RoaXMucGlja2VyLCB7XG5cdFx0XHRcdFx0Y2xpY2s6ICQucHJveHkodGhpcy5jbGljaywgdGhpcylcblx0XHRcdFx0fV0sXG5cdFx0XHRcdFskKHdpbmRvdyksIHtcblx0XHRcdFx0XHRyZXNpemU6ICQucHJveHkodGhpcy5wbGFjZSwgdGhpcylcblx0XHRcdFx0fV0sXG5cdFx0XHRcdFskKGRvY3VtZW50KSwge1xuXHRcdFx0XHRcdG1vdXNlZG93bjogJC5wcm94eShmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRcdFx0Ly8gQ2xpY2tlZCBvdXRzaWRlIHRoZSBkYXRlcGlja2VyLCBoaWRlIGl0XG5cdFx0XHRcdFx0XHRpZiAoIShcblx0XHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmlzKGUudGFyZ2V0KSB8fFxuXHRcdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuZmluZChlLnRhcmdldCkuc2l6ZSgpIHx8XG5cdFx0XHRcdFx0XHRcdHRoaXMucGlja2VyLmlzKGUudGFyZ2V0KSB8fFxuXHRcdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKGUudGFyZ2V0KS5zaXplKClcblx0XHRcdFx0XHRcdCkpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgdGhpcylcblx0XHRcdFx0fV1cblx0XHRcdF07XG5cdFx0fSxcblx0XHRfYXR0YWNoRXZlbnRzOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5fZGV0YWNoRXZlbnRzKCk7XG5cdFx0XHR0aGlzLl9hcHBseUV2ZW50cyh0aGlzLl9ldmVudHMpO1xuXHRcdH0sXG5cdFx0X2RldGFjaEV2ZW50czogZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMuX3VuYXBwbHlFdmVudHModGhpcy5fZXZlbnRzKTtcblx0XHR9LFxuXHRcdF9hdHRhY2hTZWNvbmRhcnlFdmVudHM6IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLl9kZXRhY2hTZWNvbmRhcnlFdmVudHMoKTtcblx0XHRcdHRoaXMuX2FwcGx5RXZlbnRzKHRoaXMuX3NlY29uZGFyeUV2ZW50cyk7XG5cdFx0fSxcblx0XHRfZGV0YWNoU2Vjb25kYXJ5RXZlbnRzOiBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5fdW5hcHBseUV2ZW50cyh0aGlzLl9zZWNvbmRhcnlFdmVudHMpO1xuXHRcdH0sXG5cdFx0X3RyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50LCBhbHRkYXRlKXtcblx0XHRcdHZhciBkYXRlID0gYWx0ZGF0ZSB8fCB0aGlzLmRhdGUsXG5cdFx0XHRcdGxvY2FsX2RhdGUgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSArIChkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkqNjAwMDApKTtcblxuXHRcdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoe1xuXHRcdFx0XHR0eXBlOiBldmVudCxcblx0XHRcdFx0ZGF0ZTogbG9jYWxfZGF0ZSxcblx0XHRcdFx0Zm9ybWF0OiAkLnByb3h5KGZ1bmN0aW9uKGFsdGZvcm1hdCl7XG5cdFx0XHRcdFx0dmFyIGZvcm1hdCA9IGFsdGZvcm1hdCB8fCB0aGlzLm8uZm9ybWF0O1xuXHRcdFx0XHRcdHJldHVybiBEUEdsb2JhbC5mb3JtYXREYXRlKGRhdGUsIGZvcm1hdCwgdGhpcy5vLmxhbmd1YWdlKTtcblx0XHRcdFx0fSwgdGhpcylcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRzaG93OiBmdW5jdGlvbihlKSB7XG5cdFx0XHRpZiAoIXRoaXMuaXNJbmxpbmUpXG5cdFx0XHRcdHRoaXMucGlja2VyLmFwcGVuZFRvKCdib2R5Jyk7XG5cdFx0XHR0aGlzLnBpY2tlci5zaG93KCk7XG5cdFx0XHR0aGlzLmhlaWdodCA9IHRoaXMuY29tcG9uZW50ID8gdGhpcy5jb21wb25lbnQub3V0ZXJIZWlnaHQoKSA6IHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCgpO1xuXHRcdFx0dGhpcy5wbGFjZSgpO1xuXHRcdFx0dGhpcy5fYXR0YWNoU2Vjb25kYXJ5RXZlbnRzKCk7XG5cdFx0XHRpZiAoZSkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCdzaG93Jyk7XG5cdFx0fSxcblxuXHRcdGhpZGU6IGZ1bmN0aW9uKGUpe1xuXHRcdFx0aWYodGhpcy5pc0lubGluZSkgcmV0dXJuO1xuXHRcdFx0aWYgKCF0aGlzLnBpY2tlci5pcygnOnZpc2libGUnKSkgcmV0dXJuO1xuXHRcdFx0dGhpcy5waWNrZXIuaGlkZSgpLmRldGFjaCgpO1xuXHRcdFx0dGhpcy5fZGV0YWNoU2Vjb25kYXJ5RXZlbnRzKCk7XG5cdFx0XHR0aGlzLnZpZXdNb2RlID0gdGhpcy5vLnN0YXJ0Vmlldztcblx0XHRcdHRoaXMuc2hvd01vZGUoKTtcblxuXHRcdFx0aWYgKFxuXHRcdFx0XHR0aGlzLm8uZm9yY2VQYXJzZSAmJlxuXHRcdFx0XHQoXG5cdFx0XHRcdFx0dGhpcy5pc0lucHV0ICYmIHRoaXMuZWxlbWVudC52YWwoKSB8fFxuXHRcdFx0XHRcdHRoaXMuaGFzSW5wdXQgJiYgdGhpcy5lbGVtZW50LmZpbmQoJ2lucHV0JykudmFsKClcblx0XHRcdFx0KVxuXHRcdFx0KVxuXHRcdFx0XHR0aGlzLnNldFZhbHVlKCk7XG5cdFx0XHR0aGlzLl90cmlnZ2VyKCdoaWRlJyk7XG5cdFx0fSxcblxuXHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdHRoaXMuX2RldGFjaEV2ZW50cygpO1xuXHRcdFx0dGhpcy5fZGV0YWNoU2Vjb25kYXJ5RXZlbnRzKCk7XG5cdFx0XHR0aGlzLnBpY2tlci5yZW1vdmUoKTtcblx0XHRcdGRlbGV0ZSB0aGlzLmVsZW1lbnQuZGF0YSgpLmRhdGVwaWNrZXI7XG5cdFx0XHRpZiAoIXRoaXMuaXNJbnB1dCkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5lbGVtZW50LmRhdGEoKS5kYXRlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXREYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkID0gdGhpcy5nZXRVVENEYXRlKCk7XG5cdFx0XHRyZXR1cm4gbmV3IERhdGUoZC5nZXRUaW1lKCkgKyAoZC5nZXRUaW1lem9uZU9mZnNldCgpKjYwMDAwKSk7XG5cdFx0fSxcblxuXHRcdGdldFVUQ0RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGF0ZTtcblx0XHR9LFxuXG5cdFx0c2V0RGF0ZTogZnVuY3Rpb24oZCkge1xuXHRcdFx0dGhpcy5zZXRVVENEYXRlKG5ldyBEYXRlKGQuZ2V0VGltZSgpIC0gKGQuZ2V0VGltZXpvbmVPZmZzZXQoKSo2MDAwMCkpKTtcblx0XHR9LFxuXG5cdFx0c2V0VVRDRGF0ZTogZnVuY3Rpb24oZCkge1xuXHRcdFx0dGhpcy5kYXRlID0gZDtcblx0XHRcdHRoaXMuc2V0VmFsdWUoKTtcblx0XHR9LFxuXG5cdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGZvcm1hdHRlZCA9IHRoaXMuZ2V0Rm9ybWF0dGVkRGF0ZSgpO1xuXHRcdFx0aWYgKCF0aGlzLmlzSW5wdXQpIHtcblx0XHRcdFx0aWYgKHRoaXMuY29tcG9uZW50KXtcblx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKS52YWwoZm9ybWF0dGVkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnZhbChmb3JtYXR0ZWQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRGb3JtYXR0ZWREYXRlOiBmdW5jdGlvbihmb3JtYXQpIHtcblx0XHRcdGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0Zm9ybWF0ID0gdGhpcy5vLmZvcm1hdDtcblx0XHRcdHJldHVybiBEUEdsb2JhbC5mb3JtYXREYXRlKHRoaXMuZGF0ZSwgZm9ybWF0LCB0aGlzLm8ubGFuZ3VhZ2UpO1xuXHRcdH0sXG5cblx0XHRzZXRTdGFydERhdGU6IGZ1bmN0aW9uKHN0YXJ0RGF0ZSl7XG5cdFx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMoe3N0YXJ0RGF0ZTogc3RhcnREYXRlfSk7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0dGhpcy51cGRhdGVOYXZBcnJvd3MoKTtcblx0XHR9LFxuXG5cdFx0c2V0RW5kRGF0ZTogZnVuY3Rpb24oZW5kRGF0ZSl7XG5cdFx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMoe2VuZERhdGU6IGVuZERhdGV9KTtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHR0aGlzLnVwZGF0ZU5hdkFycm93cygpO1xuXHRcdH0sXG5cblx0XHRzZXREYXlzT2ZXZWVrRGlzYWJsZWQ6IGZ1bmN0aW9uKGRheXNPZldlZWtEaXNhYmxlZCl7XG5cdFx0XHR0aGlzLl9wcm9jZXNzX29wdGlvbnMoe2RheXNPZldlZWtEaXNhYmxlZDogZGF5c09mV2Vla0Rpc2FibGVkfSk7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0dGhpcy51cGRhdGVOYXZBcnJvd3MoKTtcblx0XHR9LFxuXG5cdFx0cGxhY2U6IGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRpZih0aGlzLmlzSW5saW5lKSByZXR1cm47XG5cdFx0XHR2YXIgekluZGV4ID0gcGFyc2VJbnQodGhpcy5lbGVtZW50LnBhcmVudHMoKS5maWx0ZXIoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiAkKHRoaXMpLmNzcygnei1pbmRleCcpICE9ICdhdXRvJztcblx0XHRcdFx0XHRcdH0pLmZpcnN0KCkuY3NzKCd6LWluZGV4JykpKzEwO1xuXHRcdFx0dmFyIG9mZnNldCA9IHRoaXMuY29tcG9uZW50ID8gdGhpcy5jb21wb25lbnQucGFyZW50KCkub2Zmc2V0KCkgOiB0aGlzLmVsZW1lbnQub2Zmc2V0KCk7XG5cdFx0XHR2YXIgaGVpZ2h0ID0gdGhpcy5jb21wb25lbnQgPyB0aGlzLmNvbXBvbmVudC5vdXRlckhlaWdodCh0cnVlKSA6IHRoaXMuZWxlbWVudC5vdXRlckhlaWdodCh0cnVlKTtcblx0XHRcdHRoaXMucGlja2VyLmNzcyh7XG5cdFx0XHRcdHRvcDogb2Zmc2V0LnRvcCArIGhlaWdodCxcblx0XHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQsXG5cdFx0XHRcdHpJbmRleDogekluZGV4XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0X2FsbG93X3VwZGF0ZTogdHJ1ZSxcblx0XHR1cGRhdGU6IGZ1bmN0aW9uKCl7XG5cdFx0XHRpZiAoIXRoaXMuX2FsbG93X3VwZGF0ZSkgcmV0dXJuO1xuXG5cdFx0XHR2YXIgZGF0ZSwgZnJvbUFyZ3MgPSBmYWxzZTtcblx0XHRcdGlmKGFyZ3VtZW50cyAmJiBhcmd1bWVudHMubGVuZ3RoICYmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJyB8fCBhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBEYXRlKSkge1xuXHRcdFx0XHRkYXRlID0gYXJndW1lbnRzWzBdO1xuXHRcdFx0XHRmcm9tQXJncyA9IHRydWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRlID0gdGhpcy5pc0lucHV0ID8gdGhpcy5lbGVtZW50LnZhbCgpIDogdGhpcy5lbGVtZW50LmRhdGEoJ2RhdGUnKSB8fCB0aGlzLmVsZW1lbnQuZmluZCgnaW5wdXQnKS52YWwoKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuZWxlbWVudC5kYXRhKCkuZGF0ZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5kYXRlID0gRFBHbG9iYWwucGFyc2VEYXRlKGRhdGUsIHRoaXMuby5mb3JtYXQsIHRoaXMuby5sYW5ndWFnZSk7XG5cblx0XHRcdGlmKGZyb21BcmdzKSB0aGlzLnNldFZhbHVlKCk7XG5cblx0XHRcdGlmICh0aGlzLmRhdGUgPCB0aGlzLm8uc3RhcnREYXRlKSB7XG5cdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLm8uc3RhcnREYXRlKTtcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5kYXRlID4gdGhpcy5vLmVuZERhdGUpIHtcblx0XHRcdFx0dGhpcy52aWV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMuby5lbmREYXRlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLmRhdGUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5maWxsKCk7XG5cdFx0fSxcblxuXHRcdGZpbGxEb3c6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgZG93Q250ID0gdGhpcy5vLndlZWtTdGFydCxcblx0XHRcdGh0bWwgPSAnPHRyPic7XG5cdFx0XHRpZih0aGlzLm8uY2FsZW5kYXJXZWVrcyl7XG5cdFx0XHRcdHZhciBjZWxsID0gJzx0aCBjbGFzcz1cImN3XCI+Jm5ic3A7PC90aD4nO1xuXHRcdFx0XHRodG1sICs9IGNlbGw7XG5cdFx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGhlYWQgdHI6Zmlyc3QtY2hpbGQnKS5wcmVwZW5kKGNlbGwpO1xuXHRcdFx0fVxuXHRcdFx0d2hpbGUgKGRvd0NudCA8IHRoaXMuby53ZWVrU3RhcnQgKyA3KSB7XG5cdFx0XHRcdGh0bWwgKz0gJzx0aCBjbGFzcz1cImRvd1wiPicrZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS5kYXlzTWluWyhkb3dDbnQrKyklN10rJzwvdGg+Jztcblx0XHRcdH1cblx0XHRcdGh0bWwgKz0gJzwvdHI+Jztcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGhlYWQnKS5hcHBlbmQoaHRtbCk7XG5cdFx0fSxcblxuXHRcdGZpbGxNb250aHM6IGZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgaHRtbCA9ICcnLFxuXHRcdFx0aSA9IDA7XG5cdFx0XHR3aGlsZSAoaSA8IDEyKSB7XG5cdFx0XHRcdGh0bWwgKz0gJzxzcGFuIGNsYXNzPVwibW9udGhcIj4nK2RhdGVzW3RoaXMuby5sYW5ndWFnZV0ubW9udGhzU2hvcnRbaSsrXSsnPC9zcGFuPic7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBpY2tlci5maW5kKCcuZGF0ZXBpY2tlci1tb250aHMgdGQnKS5odG1sKGh0bWwpO1xuXHRcdH0sXG5cblx0XHRzZXRSYW5nZTogZnVuY3Rpb24ocmFuZ2Upe1xuXHRcdFx0aWYgKCFyYW5nZSB8fCAhcmFuZ2UubGVuZ3RoKVxuXHRcdFx0XHRkZWxldGUgdGhpcy5yYW5nZTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhpcy5yYW5nZSA9ICQubWFwKHJhbmdlLCBmdW5jdGlvbihkKXsgcmV0dXJuIGQudmFsdWVPZigpOyB9KTtcblx0XHRcdHRoaXMuZmlsbCgpO1xuXHRcdH0sXG5cblx0XHRnZXRDbGFzc05hbWVzOiBmdW5jdGlvbihkYXRlKXtcblx0XHRcdHZhciBjbHMgPSBbXSxcblx0XHRcdFx0eWVhciA9IHRoaXMudmlld0RhdGUuZ2V0VVRDRnVsbFllYXIoKSxcblx0XHRcdFx0bW9udGggPSB0aGlzLnZpZXdEYXRlLmdldFVUQ01vbnRoKCksXG5cdFx0XHRcdGN1cnJlbnREYXRlID0gdGhpcy5kYXRlLnZhbHVlT2YoKSxcblx0XHRcdFx0dG9kYXkgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0aWYgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA8IHllYXIgfHwgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA9PSB5ZWFyICYmIGRhdGUuZ2V0VVRDTW9udGgoKSA8IG1vbnRoKSkge1xuXHRcdFx0XHRjbHMucHVzaCgnb2xkJyk7XG5cdFx0XHR9IGVsc2UgaWYgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA+IHllYXIgfHwgKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSA9PSB5ZWFyICYmIGRhdGUuZ2V0VVRDTW9udGgoKSA+IG1vbnRoKSkge1xuXHRcdFx0XHRjbHMucHVzaCgnbmV3Jyk7XG5cdFx0XHR9XG5cdFx0XHQvLyBDb21wYXJlIGludGVybmFsIFVUQyBkYXRlIHdpdGggbG9jYWwgdG9kYXksIG5vdCBVVEMgdG9kYXlcblx0XHRcdGlmICh0aGlzLm8udG9kYXlIaWdobGlnaHQgJiZcblx0XHRcdFx0ZGF0ZS5nZXRVVENGdWxsWWVhcigpID09IHRvZGF5LmdldEZ1bGxZZWFyKCkgJiZcblx0XHRcdFx0ZGF0ZS5nZXRVVENNb250aCgpID09IHRvZGF5LmdldE1vbnRoKCkgJiZcblx0XHRcdFx0ZGF0ZS5nZXRVVENEYXRlKCkgPT0gdG9kYXkuZ2V0RGF0ZSgpKSB7XG5cdFx0XHRcdGNscy5wdXNoKCd0b2RheScpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGN1cnJlbnREYXRlICYmIGRhdGUudmFsdWVPZigpID09IGN1cnJlbnREYXRlKSB7XG5cdFx0XHRcdGNscy5wdXNoKCdhY3RpdmUnKTtcblx0XHRcdH1cblx0XHRcdGlmIChkYXRlLnZhbHVlT2YoKSA8IHRoaXMuby5zdGFydERhdGUgfHwgZGF0ZS52YWx1ZU9mKCkgPiB0aGlzLm8uZW5kRGF0ZSB8fFxuXHRcdFx0XHQkLmluQXJyYXkoZGF0ZS5nZXRVVENEYXkoKSwgdGhpcy5vLmRheXNPZldlZWtEaXNhYmxlZCkgIT09IC0xKSB7XG5cdFx0XHRcdGNscy5wdXNoKCdkaXNhYmxlZCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMucmFuZ2Upe1xuXHRcdFx0XHRpZiAoZGF0ZSA+IHRoaXMucmFuZ2VbMF0gJiYgZGF0ZSA8IHRoaXMucmFuZ2VbdGhpcy5yYW5nZS5sZW5ndGgtMV0pe1xuXHRcdFx0XHRcdGNscy5wdXNoKCdyYW5nZScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICgkLmluQXJyYXkoZGF0ZS52YWx1ZU9mKCksIHRoaXMucmFuZ2UpICE9IC0xKXtcblx0XHRcdFx0XHRjbHMucHVzaCgnc2VsZWN0ZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNscztcblx0XHR9LFxuXG5cdFx0ZmlsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZCA9IG5ldyBEYXRlKHRoaXMudmlld0RhdGUpLFxuXHRcdFx0XHR5ZWFyID0gZC5nZXRVVENGdWxsWWVhcigpLFxuXHRcdFx0XHRtb250aCA9IGQuZ2V0VVRDTW9udGgoKSxcblx0XHRcdFx0c3RhcnRZZWFyID0gdGhpcy5vLnN0YXJ0RGF0ZSAhPT0gLUluZmluaXR5ID8gdGhpcy5vLnN0YXJ0RGF0ZS5nZXRVVENGdWxsWWVhcigpIDogLUluZmluaXR5LFxuXHRcdFx0XHRzdGFydE1vbnRoID0gdGhpcy5vLnN0YXJ0RGF0ZSAhPT0gLUluZmluaXR5ID8gdGhpcy5vLnN0YXJ0RGF0ZS5nZXRVVENNb250aCgpIDogLUluZmluaXR5LFxuXHRcdFx0XHRlbmRZZWFyID0gdGhpcy5vLmVuZERhdGUgIT09IEluZmluaXR5ID8gdGhpcy5vLmVuZERhdGUuZ2V0VVRDRnVsbFllYXIoKSA6IEluZmluaXR5LFxuXHRcdFx0XHRlbmRNb250aCA9IHRoaXMuby5lbmREYXRlICE9PSBJbmZpbml0eSA/IHRoaXMuby5lbmREYXRlLmdldFVUQ01vbnRoKCkgOiBJbmZpbml0eSxcblx0XHRcdFx0Y3VycmVudERhdGUgPSB0aGlzLmRhdGUgJiYgdGhpcy5kYXRlLnZhbHVlT2YoKSxcblx0XHRcdFx0dG9vbHRpcDtcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5kYXRlcGlja2VyLWRheXMgdGhlYWQgdGguZGF0ZXBpY2tlci1zd2l0Y2gnKVxuXHRcdFx0XHRcdFx0LnRleHQoZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS5tb250aHNbbW9udGhdKycgJyt5ZWFyKTtcblx0XHRcdHRoaXMucGlja2VyLmZpbmQoJ3Rmb290IHRoLnRvZGF5Jylcblx0XHRcdFx0XHRcdC50ZXh0KGRhdGVzW3RoaXMuby5sYW5ndWFnZV0udG9kYXkpXG5cdFx0XHRcdFx0XHQudG9nZ2xlKHRoaXMuby50b2RheUJ0biAhPT0gZmFsc2UpO1xuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgndGZvb3QgdGguY2xlYXInKVxuXHRcdFx0XHRcdFx0LnRleHQoZGF0ZXNbdGhpcy5vLmxhbmd1YWdlXS5jbGVhcilcblx0XHRcdFx0XHRcdC50b2dnbGUodGhpcy5vLmNsZWFyQnRuICE9PSBmYWxzZSk7XG5cdFx0XHR0aGlzLnVwZGF0ZU5hdkFycm93cygpO1xuXHRcdFx0dGhpcy5maWxsTW9udGhzKCk7XG5cdFx0XHR2YXIgcHJldk1vbnRoID0gVVRDRGF0ZSh5ZWFyLCBtb250aC0xLCAyOCwwLDAsMCwwKSxcblx0XHRcdFx0ZGF5ID0gRFBHbG9iYWwuZ2V0RGF5c0luTW9udGgocHJldk1vbnRoLmdldFVUQ0Z1bGxZZWFyKCksIHByZXZNb250aC5nZXRVVENNb250aCgpKTtcblx0XHRcdHByZXZNb250aC5zZXRVVENEYXRlKGRheSk7XG5cdFx0XHRwcmV2TW9udGguc2V0VVRDRGF0ZShkYXkgLSAocHJldk1vbnRoLmdldFVUQ0RheSgpIC0gdGhpcy5vLndlZWtTdGFydCArIDcpJTcpO1xuXHRcdFx0dmFyIG5leHRNb250aCA9IG5ldyBEYXRlKHByZXZNb250aCk7XG5cdFx0XHRuZXh0TW9udGguc2V0VVRDRGF0ZShuZXh0TW9udGguZ2V0VVRDRGF0ZSgpICsgNDIpO1xuXHRcdFx0bmV4dE1vbnRoID0gbmV4dE1vbnRoLnZhbHVlT2YoKTtcblx0XHRcdHZhciBodG1sID0gW107XG5cdFx0XHR2YXIgY2xzTmFtZTtcblx0XHRcdHdoaWxlKHByZXZNb250aC52YWx1ZU9mKCkgPCBuZXh0TW9udGgpIHtcblx0XHRcdFx0aWYgKHByZXZNb250aC5nZXRVVENEYXkoKSA9PSB0aGlzLm8ud2Vla1N0YXJ0KSB7XG5cdFx0XHRcdFx0aHRtbC5wdXNoKCc8dHI+Jyk7XG5cdFx0XHRcdFx0aWYodGhpcy5vLmNhbGVuZGFyV2Vla3Mpe1xuXHRcdFx0XHRcdFx0Ly8gSVNPIDg2MDE6IEZpcnN0IHdlZWsgY29udGFpbnMgZmlyc3QgdGh1cnNkYXkuXG5cdFx0XHRcdFx0XHQvLyBJU08gYWxzbyBzdGF0ZXMgd2VlayBzdGFydHMgb24gTW9uZGF5LCBidXQgd2UgY2FuIGJlIG1vcmUgYWJzdHJhY3QgaGVyZS5cblx0XHRcdFx0XHRcdHZhclxuXHRcdFx0XHRcdFx0XHQvLyBTdGFydCBvZiBjdXJyZW50IHdlZWs6IGJhc2VkIG9uIHdlZWtzdGFydC9jdXJyZW50IGRhdGVcblx0XHRcdFx0XHRcdFx0d3MgPSBuZXcgRGF0ZSgrcHJldk1vbnRoICsgKHRoaXMuby53ZWVrU3RhcnQgLSBwcmV2TW9udGguZ2V0VVRDRGF5KCkgLSA3KSAlIDcgKiA4NjRlNSksXG5cdFx0XHRcdFx0XHRcdC8vIFRodXJzZGF5IG9mIHRoaXMgd2Vla1xuXHRcdFx0XHRcdFx0XHR0aCA9IG5ldyBEYXRlKCt3cyArICg3ICsgNCAtIHdzLmdldFVUQ0RheSgpKSAlIDcgKiA4NjRlNSksXG5cdFx0XHRcdFx0XHRcdC8vIEZpcnN0IFRodXJzZGF5IG9mIHllYXIsIHllYXIgZnJvbSB0aHVyc2RheVxuXHRcdFx0XHRcdFx0XHR5dGggPSBuZXcgRGF0ZSgrKHl0aCA9IFVUQ0RhdGUodGguZ2V0VVRDRnVsbFllYXIoKSwgMCwgMSkpICsgKDcgKyA0IC0geXRoLmdldFVUQ0RheSgpKSU3Kjg2NGU1KSxcblx0XHRcdFx0XHRcdFx0Ly8gQ2FsZW5kYXIgd2VlazogbXMgYmV0d2VlbiB0aHVyc2RheXMsIGRpdiBtcyBwZXIgZGF5LCBkaXYgNyBkYXlzXG5cdFx0XHRcdFx0XHRcdGNhbFdlZWsgPSAgKHRoIC0geXRoKSAvIDg2NGU1IC8gNyArIDE7XG5cdFx0XHRcdFx0XHRodG1sLnB1c2goJzx0ZCBjbGFzcz1cImN3XCI+JysgY2FsV2VlayArJzwvdGQ+Jyk7XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2xzTmFtZSA9IHRoaXMuZ2V0Q2xhc3NOYW1lcyhwcmV2TW9udGgpO1xuXHRcdFx0XHRjbHNOYW1lLnB1c2goJ2RheScpO1xuXG5cdFx0XHRcdHZhciBiZWZvcmUgPSB0aGlzLm8uYmVmb3JlU2hvd0RheShwcmV2TW9udGgpO1xuXHRcdFx0XHRpZiAoYmVmb3JlID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0YmVmb3JlID0ge307XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVvZihiZWZvcmUpID09PSAnYm9vbGVhbicpXG5cdFx0XHRcdFx0YmVmb3JlID0ge2VuYWJsZWQ6IGJlZm9yZX07XG5cdFx0XHRcdGVsc2UgaWYgKHR5cGVvZihiZWZvcmUpID09PSAnc3RyaW5nJylcblx0XHRcdFx0XHRiZWZvcmUgPSB7Y2xhc3NlczogYmVmb3JlfTtcblx0XHRcdFx0aWYgKGJlZm9yZS5lbmFibGVkID09PSBmYWxzZSlcblx0XHRcdFx0XHRjbHNOYW1lLnB1c2goJ2Rpc2FibGVkJyk7XG5cdFx0XHRcdGlmIChiZWZvcmUuY2xhc3Nlcylcblx0XHRcdFx0XHRjbHNOYW1lID0gY2xzTmFtZS5jb25jYXQoYmVmb3JlLmNsYXNzZXMuc3BsaXQoL1xccysvKSk7XG5cdFx0XHRcdGlmIChiZWZvcmUudG9vbHRpcClcblx0XHRcdFx0XHR0b29sdGlwID0gYmVmb3JlLnRvb2x0aXA7XG5cblx0XHRcdFx0Y2xzTmFtZSA9ICQudW5pcXVlKGNsc05hbWUpO1xuXHRcdFx0XHRodG1sLnB1c2goJzx0ZCBjbGFzcz1cIicrY2xzTmFtZS5qb2luKCcgJykrJ1wiJyArICh0b29sdGlwID8gJyB0aXRsZT1cIicrdG9vbHRpcCsnXCInIDogJycpICsgJz4nK3ByZXZNb250aC5nZXRVVENEYXRlKCkgKyAnPC90ZD4nKTtcblx0XHRcdFx0aWYgKHByZXZNb250aC5nZXRVVENEYXkoKSA9PSB0aGlzLm8ud2Vla0VuZCkge1xuXHRcdFx0XHRcdGh0bWwucHVzaCgnPC90cj4nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcmV2TW9udGguc2V0VVRDRGF0ZShwcmV2TW9udGguZ2V0VVRDRGF0ZSgpKzEpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXItZGF5cyB0Ym9keScpLmVtcHR5KCkuYXBwZW5kKGh0bWwuam9pbignJykpO1xuXHRcdFx0dmFyIGN1cnJlbnRZZWFyID0gdGhpcy5kYXRlICYmIHRoaXMuZGF0ZS5nZXRVVENGdWxsWWVhcigpO1xuXG5cdFx0XHR2YXIgbW9udGhzID0gdGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXItbW9udGhzJylcblx0XHRcdFx0XHRcdC5maW5kKCd0aDplcSgxKScpXG5cdFx0XHRcdFx0XHRcdC50ZXh0KHllYXIpXG5cdFx0XHRcdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHRcdFx0LmZpbmQoJ3NwYW4nKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG5cdFx0XHRpZiAoY3VycmVudFllYXIgJiYgY3VycmVudFllYXIgPT0geWVhcikge1xuXHRcdFx0XHRtb250aHMuZXEodGhpcy5kYXRlLmdldFVUQ01vbnRoKCkpLmFkZENsYXNzKCdhY3RpdmUnKTtcblx0XHRcdH1cblx0XHRcdGlmICh5ZWFyIDwgc3RhcnRZZWFyIHx8IHllYXIgPiBlbmRZZWFyKSB7XG5cdFx0XHRcdG1vbnRocy5hZGRDbGFzcygnZGlzYWJsZWQnKTtcblx0XHRcdH1cblx0XHRcdGlmICh5ZWFyID09IHN0YXJ0WWVhcikge1xuXHRcdFx0XHRtb250aHMuc2xpY2UoMCwgc3RhcnRNb250aCkuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoeWVhciA9PSBlbmRZZWFyKSB7XG5cdFx0XHRcdG1vbnRocy5zbGljZShlbmRNb250aCsxKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcblx0XHRcdH1cblxuXHRcdFx0aHRtbCA9ICcnO1xuXHRcdFx0eWVhciA9IHBhcnNlSW50KHllYXIvMTAsIDEwKSAqIDEwO1xuXHRcdFx0dmFyIHllYXJDb250ID0gdGhpcy5waWNrZXIuZmluZCgnLmRhdGVwaWNrZXIteWVhcnMnKVxuXHRcdFx0XHRcdFx0XHRcdC5maW5kKCd0aDplcSgxKScpXG5cdFx0XHRcdFx0XHRcdFx0XHQudGV4dCh5ZWFyICsgJy0nICsgKHllYXIgKyA5KSlcblx0XHRcdFx0XHRcdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHRcdFx0XHRcdC5maW5kKCd0ZCcpO1xuXHRcdFx0eWVhciAtPSAxO1xuXHRcdFx0Zm9yICh2YXIgaSA9IC0xOyBpIDwgMTE7IGkrKykge1xuXHRcdFx0XHRodG1sICs9ICc8c3BhbiBjbGFzcz1cInllYXInKyhpID09IC0xID8gJyBvbGQnIDogaSA9PSAxMCA/ICcgbmV3JyA6ICcnKSsoY3VycmVudFllYXIgPT0geWVhciA/ICcgYWN0aXZlJyA6ICcnKSsoeWVhciA8IHN0YXJ0WWVhciB8fCB5ZWFyID4gZW5kWWVhciA/ICcgZGlzYWJsZWQnIDogJycpKydcIj4nK3llYXIrJzwvc3Bhbj4nO1xuXHRcdFx0XHR5ZWFyICs9IDE7XG5cdFx0XHR9XG5cdFx0XHR5ZWFyQ29udC5odG1sKGh0bWwpO1xuXHRcdH0sXG5cblx0XHR1cGRhdGVOYXZBcnJvd3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCF0aGlzLl9hbGxvd191cGRhdGUpIHJldHVybjtcblxuXHRcdFx0dmFyIGQgPSBuZXcgRGF0ZSh0aGlzLnZpZXdEYXRlKSxcblx0XHRcdFx0eWVhciA9IGQuZ2V0VVRDRnVsbFllYXIoKSxcblx0XHRcdFx0bW9udGggPSBkLmdldFVUQ01vbnRoKCk7XG5cdFx0XHRzd2l0Y2ggKHRoaXMudmlld01vZGUpIHtcblx0XHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRcdGlmICh0aGlzLm8uc3RhcnREYXRlICE9PSAtSW5maW5pdHkgJiYgeWVhciA8PSB0aGlzLm8uc3RhcnREYXRlLmdldFVUQ0Z1bGxZZWFyKCkgJiYgbW9udGggPD0gdGhpcy5vLnN0YXJ0RGF0ZS5nZXRVVENNb250aCgpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKCcucHJldicpLmNzcyh7dmlzaWJpbGl0eTogJ2hpZGRlbid9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLnByZXYnKS5jc3Moe3Zpc2liaWxpdHk6ICd2aXNpYmxlJ30pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5vLmVuZERhdGUgIT09IEluZmluaXR5ICYmIHllYXIgPj0gdGhpcy5vLmVuZERhdGUuZ2V0VVRDRnVsbFllYXIoKSAmJiBtb250aCA+PSB0aGlzLm8uZW5kRGF0ZS5nZXRVVENNb250aCgpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKCcubmV4dCcpLmNzcyh7dmlzaWJpbGl0eTogJ2hpZGRlbid9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLm5leHQnKS5jc3Moe3Zpc2liaWxpdHk6ICd2aXNpYmxlJ30pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRjYXNlIDI6XG5cdFx0XHRcdFx0aWYgKHRoaXMuby5zdGFydERhdGUgIT09IC1JbmZpbml0eSAmJiB5ZWFyIDw9IHRoaXMuby5zdGFydERhdGUuZ2V0VVRDRnVsbFllYXIoKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5waWNrZXIuZmluZCgnLnByZXYnKS5jc3Moe3Zpc2liaWxpdHk6ICdoaWRkZW4nfSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5wcmV2JykuY3NzKHt2aXNpYmlsaXR5OiAndmlzaWJsZSd9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuby5lbmREYXRlICE9PSBJbmZpbml0eSAmJiB5ZWFyID49IHRoaXMuby5lbmREYXRlLmdldFVUQ0Z1bGxZZWFyKCkpIHtcblx0XHRcdFx0XHRcdHRoaXMucGlja2VyLmZpbmQoJy5uZXh0JykuY3NzKHt2aXNpYmlsaXR5OiAnaGlkZGVuJ30pO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnBpY2tlci5maW5kKCcubmV4dCcpLmNzcyh7dmlzaWJpbGl0eTogJ3Zpc2libGUnfSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjbGljazogZnVuY3Rpb24oZSkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0dmFyIHRhcmdldCA9ICQoZS50YXJnZXQpLmNsb3Nlc3QoJ3NwYW4sIHRkLCB0aCcpO1xuXHRcdFx0aWYgKHRhcmdldC5sZW5ndGggPT0gMSkge1xuXHRcdFx0XHRzd2l0Y2godGFyZ2V0WzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcblx0XHRcdFx0XHRjYXNlICd0aCc6XG5cdFx0XHRcdFx0XHRzd2l0Y2godGFyZ2V0WzBdLmNsYXNzTmFtZSkge1xuXHRcdFx0XHRcdFx0XHRjYXNlICdkYXRlcGlja2VyLXN3aXRjaCc6XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zaG93TW9kZSgxKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAncHJldic6XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ25leHQnOlxuXHRcdFx0XHRcdFx0XHRcdHZhciBkaXIgPSBEUEdsb2JhbC5tb2Rlc1t0aGlzLnZpZXdNb2RlXS5uYXZTdGVwICogKHRhcmdldFswXS5jbGFzc05hbWUgPT0gJ3ByZXYnID8gLTEgOiAxKTtcblx0XHRcdFx0XHRcdFx0XHRzd2l0Y2godGhpcy52aWV3TW9kZSl7XG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIDA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSB0aGlzLm1vdmVNb250aCh0aGlzLnZpZXdEYXRlLCBkaXIpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgMTpcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgMjpcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy52aWV3RGF0ZSA9IHRoaXMubW92ZVllYXIodGhpcy52aWV3RGF0ZSwgZGlyKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZmlsbCgpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlICd0b2RheSc6XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGUgPSBVVENEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSwgMCwgMCwgMCk7XG5cblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNob3dNb2RlKC0yKTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgd2hpY2ggPSB0aGlzLm8udG9kYXlCdG4gPT0gJ2xpbmtlZCcgPyBudWxsIDogJ3ZpZXcnO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3NldERhdGUoZGF0ZSwgd2hpY2gpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlICdjbGVhcic6XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGVsZW1lbnQ7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuaXNJbnB1dClcblx0XHRcdFx0XHRcdFx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSBpZiAodGhpcy5jb21wb25lbnQpXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50LmZpbmQoJ2lucHV0Jyk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGVsZW1lbnQpXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtZW50LnZhbChcIlwiKS5jaGFuZ2UoKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VEYXRlJyk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5vLmF1dG9jbG9zZSlcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuaGlkZSgpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnc3Bhbic6XG5cdFx0XHRcdFx0XHRpZiAoIXRhcmdldC5pcygnLmRpc2FibGVkJykpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy52aWV3RGF0ZS5zZXRVVENEYXRlKDEpO1xuXHRcdFx0XHRcdFx0XHRpZiAodGFyZ2V0LmlzKCcubW9udGgnKSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBkYXkgPSAxO1xuXHRcdFx0XHRcdFx0XHRcdHZhciBtb250aCA9IHRhcmdldC5wYXJlbnQoKS5maW5kKCdzcGFuJykuaW5kZXgodGFyZ2V0KTtcblx0XHRcdFx0XHRcdFx0XHR2YXIgeWVhciA9IHRoaXMudmlld0RhdGUuZ2V0VVRDRnVsbFllYXIoKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlLnNldFVUQ01vbnRoKG1vbnRoKTtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VNb250aCcsIHRoaXMudmlld0RhdGUpO1xuXHRcdFx0XHRcdFx0XHRcdGlmICh0aGlzLm8ubWluVmlld01vZGUgPT09IDEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX3NldERhdGUoVVRDRGF0ZSh5ZWFyLCBtb250aCwgZGF5LDAsMCwwLDApKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHllYXIgPSBwYXJzZUludCh0YXJnZXQudGV4dCgpLCAxMCl8fDA7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGRheSA9IDE7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIG1vbnRoID0gMDtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlLnNldFVUQ0Z1bGxZZWFyKHllYXIpO1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX3RyaWdnZXIoJ2NoYW5nZVllYXInLCB0aGlzLnZpZXdEYXRlKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGhpcy5vLm1pblZpZXdNb2RlID09PSAyKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9zZXREYXRlKFVUQ0RhdGUoeWVhciwgbW9udGgsIGRheSwwLDAsMCwwKSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMuc2hvd01vZGUoLTEpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLmZpbGwoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdGNhc2UgJ3RkJzpcblx0XHRcdFx0XHRcdGlmICh0YXJnZXQuaXMoJy5kYXknKSAmJiAhdGFyZ2V0LmlzKCcuZGlzYWJsZWQnKSl7XG5cdFx0XHRcdFx0XHRcdHZhciBkYXkgPSBwYXJzZUludCh0YXJnZXQudGV4dCgpLCAxMCl8fDE7XG5cdFx0XHRcdFx0XHRcdHZhciB5ZWFyID0gdGhpcy52aWV3RGF0ZS5nZXRVVENGdWxsWWVhcigpLFxuXHRcdFx0XHRcdFx0XHRcdG1vbnRoID0gdGhpcy52aWV3RGF0ZS5nZXRVVENNb250aCgpO1xuXHRcdFx0XHRcdFx0XHRpZiAodGFyZ2V0LmlzKCcub2xkJykpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAobW9udGggPT09IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1vbnRoID0gMTE7XG5cdFx0XHRcdFx0XHRcdFx0XHR5ZWFyIC09IDE7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1vbnRoIC09IDE7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHRhcmdldC5pcygnLm5ldycpKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG1vbnRoID09IDExKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRtb250aCA9IDA7XG5cdFx0XHRcdFx0XHRcdFx0XHR5ZWFyICs9IDE7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG1vbnRoICs9IDE7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3NldERhdGUoVVRDRGF0ZSh5ZWFyLCBtb250aCwgZGF5LDAsMCwwLDApKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9zZXREYXRlOiBmdW5jdGlvbihkYXRlLCB3aGljaCl7XG5cdFx0XHRpZiAoIXdoaWNoIHx8IHdoaWNoID09ICdkYXRlJylcblx0XHRcdFx0dGhpcy5kYXRlID0gbmV3IERhdGUoZGF0ZSk7XG5cdFx0XHRpZiAoIXdoaWNoIHx8IHdoaWNoICA9PSAndmlldycpXG5cdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXcgRGF0ZShkYXRlKTtcblx0XHRcdHRoaXMuZmlsbCgpO1xuXHRcdFx0dGhpcy5zZXRWYWx1ZSgpO1xuXHRcdFx0dGhpcy5fdHJpZ2dlcignY2hhbmdlRGF0ZScpO1xuXHRcdFx0dmFyIGVsZW1lbnQ7XG5cdFx0XHRpZiAodGhpcy5pc0lucHV0KSB7XG5cdFx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuY29tcG9uZW50KXtcblx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudC5maW5kKCdpbnB1dCcpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdFx0ZWxlbWVudC5jaGFuZ2UoKTtcblx0XHRcdFx0aWYgKHRoaXMuby5hdXRvY2xvc2UgJiYgKCF3aGljaCB8fCB3aGljaCA9PSAnZGF0ZScpKSB7XG5cdFx0XHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0bW92ZU1vbnRoOiBmdW5jdGlvbihkYXRlLCBkaXIpe1xuXHRcdFx0aWYgKCFkaXIpIHJldHVybiBkYXRlO1xuXHRcdFx0dmFyIG5ld19kYXRlID0gbmV3IERhdGUoZGF0ZS52YWx1ZU9mKCkpLFxuXHRcdFx0XHRkYXkgPSBuZXdfZGF0ZS5nZXRVVENEYXRlKCksXG5cdFx0XHRcdG1vbnRoID0gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKSxcblx0XHRcdFx0bWFnID0gTWF0aC5hYnMoZGlyKSxcblx0XHRcdFx0bmV3X21vbnRoLCB0ZXN0O1xuXHRcdFx0ZGlyID0gZGlyID4gMCA/IDEgOiAtMTtcblx0XHRcdGlmIChtYWcgPT0gMSl7XG5cdFx0XHRcdHRlc3QgPSBkaXIgPT0gLTFcblx0XHRcdFx0XHQvLyBJZiBnb2luZyBiYWNrIG9uZSBtb250aCwgbWFrZSBzdXJlIG1vbnRoIGlzIG5vdCBjdXJyZW50IG1vbnRoXG5cdFx0XHRcdFx0Ly8gKGVnLCBNYXIgMzEgLT4gRmViIDMxID09IEZlYiAyOCwgbm90IE1hciAwMilcblx0XHRcdFx0XHQ/IGZ1bmN0aW9uKCl7IHJldHVybiBuZXdfZGF0ZS5nZXRVVENNb250aCgpID09IG1vbnRoOyB9XG5cdFx0XHRcdFx0Ly8gSWYgZ29pbmcgZm9yd2FyZCBvbmUgbW9udGgsIG1ha2Ugc3VyZSBtb250aCBpcyBhcyBleHBlY3RlZFxuXHRcdFx0XHRcdC8vIChlZywgSmFuIDMxIC0+IEZlYiAzMSA9PSBGZWIgMjgsIG5vdCBNYXIgMDIpXG5cdFx0XHRcdFx0OiBmdW5jdGlvbigpeyByZXR1cm4gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKSAhPSBuZXdfbW9udGg7IH07XG5cdFx0XHRcdG5ld19tb250aCA9IG1vbnRoICsgZGlyO1xuXHRcdFx0XHRuZXdfZGF0ZS5zZXRVVENNb250aChuZXdfbW9udGgpO1xuXHRcdFx0XHQvLyBEZWMgLT4gSmFuICgxMikgb3IgSmFuIC0+IERlYyAoLTEpIC0tIGxpbWl0IGV4cGVjdGVkIGRhdGUgdG8gMC0xMVxuXHRcdFx0XHRpZiAobmV3X21vbnRoIDwgMCB8fCBuZXdfbW9udGggPiAxMSlcblx0XHRcdFx0XHRuZXdfbW9udGggPSAobmV3X21vbnRoICsgMTIpICUgMTI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBGb3IgbWFnbml0dWRlcyA+MSwgbW92ZSBvbmUgbW9udGggYXQgYSB0aW1lLi4uXG5cdFx0XHRcdGZvciAodmFyIGk9MDsgaTxtYWc7IGkrKylcblx0XHRcdFx0XHQvLyAuLi53aGljaCBtaWdodCBkZWNyZWFzZSB0aGUgZGF5IChlZywgSmFuIDMxIHRvIEZlYiAyOCwgZXRjKS4uLlxuXHRcdFx0XHRcdG5ld19kYXRlID0gdGhpcy5tb3ZlTW9udGgobmV3X2RhdGUsIGRpcik7XG5cdFx0XHRcdC8vIC4uLnRoZW4gcmVzZXQgdGhlIGRheSwga2VlcGluZyBpdCBpbiB0aGUgbmV3IG1vbnRoXG5cdFx0XHRcdG5ld19tb250aCA9IG5ld19kYXRlLmdldFVUQ01vbnRoKCk7XG5cdFx0XHRcdG5ld19kYXRlLnNldFVUQ0RhdGUoZGF5KTtcblx0XHRcdFx0dGVzdCA9IGZ1bmN0aW9uKCl7IHJldHVybiBuZXdfbW9udGggIT0gbmV3X2RhdGUuZ2V0VVRDTW9udGgoKTsgfTtcblx0XHRcdH1cblx0XHRcdC8vIENvbW1vbiBkYXRlLXJlc2V0dGluZyBsb29wIC0tIGlmIGRhdGUgaXMgYmV5b25kIGVuZCBvZiBtb250aCwgbWFrZSBpdFxuXHRcdFx0Ly8gZW5kIG9mIG1vbnRoXG5cdFx0XHR3aGlsZSAodGVzdCgpKXtcblx0XHRcdFx0bmV3X2RhdGUuc2V0VVRDRGF0ZSgtLWRheSk7XG5cdFx0XHRcdG5ld19kYXRlLnNldFVUQ01vbnRoKG5ld19tb250aCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3X2RhdGU7XG5cdFx0fSxcblxuXHRcdG1vdmVZZWFyOiBmdW5jdGlvbihkYXRlLCBkaXIpe1xuXHRcdFx0cmV0dXJuIHRoaXMubW92ZU1vbnRoKGRhdGUsIGRpcioxMik7XG5cdFx0fSxcblxuXHRcdGRhdGVXaXRoaW5SYW5nZTogZnVuY3Rpb24oZGF0ZSl7XG5cdFx0XHRyZXR1cm4gZGF0ZSA+PSB0aGlzLm8uc3RhcnREYXRlICYmIGRhdGUgPD0gdGhpcy5vLmVuZERhdGU7XG5cdFx0fSxcblxuXHRcdGtleWRvd246IGZ1bmN0aW9uKGUpe1xuXHRcdFx0aWYgKHRoaXMucGlja2VyLmlzKCc6bm90KDp2aXNpYmxlKScpKXtcblx0XHRcdFx0aWYgKGUua2V5Q29kZSA9PSAyNykgLy8gYWxsb3cgZXNjYXBlIHRvIGhpZGUgYW5kIHJlLXNob3cgcGlja2VyXG5cdFx0XHRcdFx0dGhpcy5zaG93KCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciBkYXRlQ2hhbmdlZCA9IGZhbHNlLFxuXHRcdFx0XHRkaXIsIGRheSwgbW9udGgsXG5cdFx0XHRcdG5ld0RhdGUsIG5ld1ZpZXdEYXRlO1xuXHRcdFx0c3dpdGNoKGUua2V5Q29kZSl7XG5cdFx0XHRcdGNhc2UgMjc6IC8vIGVzY2FwZVxuXHRcdFx0XHRcdHRoaXMuaGlkZSgpO1xuXHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAzNzogLy8gbGVmdFxuXHRcdFx0XHRjYXNlIDM5OiAvLyByaWdodFxuXHRcdFx0XHRcdGlmICghdGhpcy5vLmtleWJvYXJkTmF2aWdhdGlvbikgYnJlYWs7XG5cdFx0XHRcdFx0ZGlyID0gZS5rZXlDb2RlID09IDM3ID8gLTEgOiAxO1xuXHRcdFx0XHRcdGlmIChlLmN0cmxLZXkpe1xuXHRcdFx0XHRcdFx0bmV3RGF0ZSA9IHRoaXMubW92ZVllYXIodGhpcy5kYXRlLCBkaXIpO1xuXHRcdFx0XHRcdFx0bmV3Vmlld0RhdGUgPSB0aGlzLm1vdmVZZWFyKHRoaXMudmlld0RhdGUsIGRpcik7XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChlLnNoaWZ0S2V5KXtcblx0XHRcdFx0XHRcdG5ld0RhdGUgPSB0aGlzLm1vdmVNb250aCh0aGlzLmRhdGUsIGRpcik7XG5cdFx0XHRcdFx0XHRuZXdWaWV3RGF0ZSA9IHRoaXMubW92ZU1vbnRoKHRoaXMudmlld0RhdGUsIGRpcik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5ld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLmRhdGUpO1xuXHRcdFx0XHRcdFx0bmV3RGF0ZS5zZXRVVENEYXRlKHRoaXMuZGF0ZS5nZXRVVENEYXRlKCkgKyBkaXIpO1xuXHRcdFx0XHRcdFx0bmV3Vmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLnZpZXdEYXRlKTtcblx0XHRcdFx0XHRcdG5ld1ZpZXdEYXRlLnNldFVUQ0RhdGUodGhpcy52aWV3RGF0ZS5nZXRVVENEYXRlKCkgKyBkaXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAodGhpcy5kYXRlV2l0aGluUmFuZ2UobmV3RGF0ZSkpe1xuXHRcdFx0XHRcdFx0dGhpcy5kYXRlID0gbmV3RGF0ZTtcblx0XHRcdFx0XHRcdHRoaXMudmlld0RhdGUgPSBuZXdWaWV3RGF0ZTtcblx0XHRcdFx0XHRcdHRoaXMuc2V0VmFsdWUoKTtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRkYXRlQ2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIDM4OiAvLyB1cFxuXHRcdFx0XHRjYXNlIDQwOiAvLyBkb3duXG5cdFx0XHRcdFx0aWYgKCF0aGlzLm8ua2V5Ym9hcmROYXZpZ2F0aW9uKSBicmVhaztcblx0XHRcdFx0XHRkaXIgPSBlLmtleUNvZGUgPT0gMzggPyAtMSA6IDE7XG5cdFx0XHRcdFx0aWYgKGUuY3RybEtleSl7XG5cdFx0XHRcdFx0XHRuZXdEYXRlID0gdGhpcy5tb3ZlWWVhcih0aGlzLmRhdGUsIGRpcik7XG5cdFx0XHRcdFx0XHRuZXdWaWV3RGF0ZSA9IHRoaXMubW92ZVllYXIodGhpcy52aWV3RGF0ZSwgZGlyKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKGUuc2hpZnRLZXkpe1xuXHRcdFx0XHRcdFx0bmV3RGF0ZSA9IHRoaXMubW92ZU1vbnRoKHRoaXMuZGF0ZSwgZGlyKTtcblx0XHRcdFx0XHRcdG5ld1ZpZXdEYXRlID0gdGhpcy5tb3ZlTW9udGgodGhpcy52aWV3RGF0ZSwgZGlyKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bmV3RGF0ZSA9IG5ldyBEYXRlKHRoaXMuZGF0ZSk7XG5cdFx0XHRcdFx0XHRuZXdEYXRlLnNldFVUQ0RhdGUodGhpcy5kYXRlLmdldFVUQ0RhdGUoKSArIGRpciAqIDcpO1xuXHRcdFx0XHRcdFx0bmV3Vmlld0RhdGUgPSBuZXcgRGF0ZSh0aGlzLnZpZXdEYXRlKTtcblx0XHRcdFx0XHRcdG5ld1ZpZXdEYXRlLnNldFVUQ0RhdGUodGhpcy52aWV3RGF0ZS5nZXRVVENEYXRlKCkgKyBkaXIgKiA3KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHRoaXMuZGF0ZVdpdGhpblJhbmdlKG5ld0RhdGUpKXtcblx0XHRcdFx0XHRcdHRoaXMuZGF0ZSA9IG5ld0RhdGU7XG5cdFx0XHRcdFx0XHR0aGlzLnZpZXdEYXRlID0gbmV3Vmlld0RhdGU7XG5cdFx0XHRcdFx0XHR0aGlzLnNldFZhbHVlKCk7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0ZGF0ZUNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAxMzogLy8gZW50ZXJcblx0XHRcdFx0XHR0aGlzLmhpZGUoKTtcblx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgOTogLy8gdGFiXG5cdFx0XHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGF0ZUNoYW5nZWQpe1xuXHRcdFx0XHR0aGlzLl90cmlnZ2VyKCdjaGFuZ2VEYXRlJyk7XG5cdFx0XHRcdHZhciBlbGVtZW50O1xuXHRcdFx0XHRpZiAodGhpcy5pc0lucHV0KSB7XG5cdFx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmNvbXBvbmVudCl7XG5cdFx0XHRcdFx0ZWxlbWVudCA9IHRoaXMuZWxlbWVudC5maW5kKCdpbnB1dCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRcdFx0ZWxlbWVudC5jaGFuZ2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzaG93TW9kZTogZnVuY3Rpb24oZGlyKSB7XG5cdFx0XHRpZiAoZGlyKSB7XG5cdFx0XHRcdHRoaXMudmlld01vZGUgPSBNYXRoLm1heCh0aGlzLm8ubWluVmlld01vZGUsIE1hdGgubWluKDIsIHRoaXMudmlld01vZGUgKyBkaXIpKTtcblx0XHRcdH1cblx0XHRcdC8qXG5cdFx0XHRcdHZpdGFsZXRzOiBmaXhpbmcgYnVnIG9mIHZlcnkgc3BlY2lhbCBjb25kaXRpb25zOlxuXHRcdFx0XHRqcXVlcnkgMS43LjEgKyB3ZWJraXQgKyBzaG93IGlubGluZSBkYXRlcGlja2VyIGluIGJvb3RzdHJhcCBwb3BvdmVyLlxuXHRcdFx0XHRNZXRob2Qgc2hvdygpIGRvZXMgbm90IHNldCBkaXNwbGF5IGNzcyBjb3JyZWN0bHkgYW5kIGRhdGVwaWNrZXIgaXMgbm90IHNob3duLlxuXHRcdFx0XHRDaGFuZ2VkIHRvIC5jc3MoJ2Rpc3BsYXknLCAnYmxvY2snKSBzb2x2ZSB0aGUgcHJvYmxlbS5cblx0XHRcdFx0U2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRhbGV0cy94LWVkaXRhYmxlL2lzc3Vlcy8zN1xuXG5cdFx0XHRcdEluIGpxdWVyeSAxLjcuMisgZXZlcnl0aGluZyB3b3JrcyBmaW5lLlxuXHRcdFx0Ki9cblx0XHRcdC8vdGhpcy5waWNrZXIuZmluZCgnPmRpdicpLmhpZGUoKS5maWx0ZXIoJy5kYXRlcGlja2VyLScrRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZSkuc2hvdygpO1xuXHRcdFx0dGhpcy5waWNrZXIuZmluZCgnPmRpdicpLmhpZGUoKS5maWx0ZXIoJy5kYXRlcGlja2VyLScrRFBHbG9iYWwubW9kZXNbdGhpcy52aWV3TW9kZV0uY2xzTmFtZSkuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG5cdFx0XHR0aGlzLnVwZGF0ZU5hdkFycm93cygpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgRGF0ZVJhbmdlUGlja2VyID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucyl7XG5cdFx0dGhpcy5lbGVtZW50ID0gJChlbGVtZW50KTtcblx0XHR0aGlzLmlucHV0cyA9ICQubWFwKG9wdGlvbnMuaW5wdXRzLCBmdW5jdGlvbihpKXsgcmV0dXJuIGkuanF1ZXJ5ID8gaVswXSA6IGk7IH0pO1xuXHRcdGRlbGV0ZSBvcHRpb25zLmlucHV0cztcblxuXHRcdCQodGhpcy5pbnB1dHMpXG5cdFx0XHQuZGF0ZXBpY2tlcihvcHRpb25zKVxuXHRcdFx0LmJpbmQoJ2NoYW5nZURhdGUnLCAkLnByb3h5KHRoaXMuZGF0ZVVwZGF0ZWQsIHRoaXMpKTtcblxuXHRcdHRoaXMucGlja2VycyA9ICQubWFwKHRoaXMuaW5wdXRzLCBmdW5jdGlvbihpKXsgcmV0dXJuICQoaSkuZGF0YSgnZGF0ZXBpY2tlcicpOyB9KTtcblx0XHR0aGlzLnVwZGF0ZURhdGVzKCk7XG5cdH07XG5cdERhdGVSYW5nZVBpY2tlci5wcm90b3R5cGUgPSB7XG5cdFx0dXBkYXRlRGF0ZXM6IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLmRhdGVzID0gJC5tYXAodGhpcy5waWNrZXJzLCBmdW5jdGlvbihpKXsgcmV0dXJuIGkuZGF0ZTsgfSk7XG5cdFx0XHR0aGlzLnVwZGF0ZVJhbmdlcygpO1xuXHRcdH0sXG5cdFx0dXBkYXRlUmFuZ2VzOiBmdW5jdGlvbigpe1xuXHRcdFx0dmFyIHJhbmdlID0gJC5tYXAodGhpcy5kYXRlcywgZnVuY3Rpb24oZCl7IHJldHVybiBkLnZhbHVlT2YoKTsgfSk7XG5cdFx0XHQkLmVhY2godGhpcy5waWNrZXJzLCBmdW5jdGlvbihpLCBwKXtcblx0XHRcdFx0cC5zZXRSYW5nZShyYW5nZSk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXHRcdGRhdGVVcGRhdGVkOiBmdW5jdGlvbihlKXtcblx0XHRcdHZhciBkcCA9ICQoZS50YXJnZXQpLmRhdGEoJ2RhdGVwaWNrZXInKSxcblx0XHRcdFx0bmV3X2RhdGUgPSBkcC5nZXRVVENEYXRlKCksXG5cdFx0XHRcdGkgPSAkLmluQXJyYXkoZS50YXJnZXQsIHRoaXMuaW5wdXRzKSxcblx0XHRcdFx0bCA9IHRoaXMuaW5wdXRzLmxlbmd0aDtcblx0XHRcdGlmIChpID09IC0xKSByZXR1cm47XG5cblx0XHRcdGlmIChuZXdfZGF0ZSA8IHRoaXMuZGF0ZXNbaV0pe1xuXHRcdFx0XHQvLyBEYXRlIGJlaW5nIG1vdmVkIGVhcmxpZXIvbGVmdFxuXHRcdFx0XHR3aGlsZSAoaT49MCAmJiBuZXdfZGF0ZSA8IHRoaXMuZGF0ZXNbaV0pe1xuXHRcdFx0XHRcdHRoaXMucGlja2Vyc1tpLS1dLnNldFVUQ0RhdGUobmV3X2RhdGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChuZXdfZGF0ZSA+IHRoaXMuZGF0ZXNbaV0pe1xuXHRcdFx0XHQvLyBEYXRlIGJlaW5nIG1vdmVkIGxhdGVyL3JpZ2h0XG5cdFx0XHRcdHdoaWxlIChpPGwgJiYgbmV3X2RhdGUgPiB0aGlzLmRhdGVzW2ldKXtcblx0XHRcdFx0XHR0aGlzLnBpY2tlcnNbaSsrXS5zZXRVVENEYXRlKG5ld19kYXRlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy51cGRhdGVEYXRlcygpO1xuXHRcdH0sXG5cdFx0cmVtb3ZlOiBmdW5jdGlvbigpe1xuXHRcdFx0JC5tYXAodGhpcy5waWNrZXJzLCBmdW5jdGlvbihwKXsgcC5yZW1vdmUoKTsgfSk7XG5cdFx0XHRkZWxldGUgdGhpcy5lbGVtZW50LmRhdGEoKS5kYXRlcGlja2VyO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBvcHRzX2Zyb21fZWwoZWwsIHByZWZpeCl7XG5cdFx0Ly8gRGVyaXZlIG9wdGlvbnMgZnJvbSBlbGVtZW50IGRhdGEtYXR0cnNcblx0XHR2YXIgZGF0YSA9ICQoZWwpLmRhdGEoKSxcblx0XHRcdG91dCA9IHt9LCBpbmtleSxcblx0XHRcdHJlcGxhY2UgPSBuZXcgUmVnRXhwKCdeJyArIHByZWZpeC50b0xvd2VyQ2FzZSgpICsgJyhbQS1aXSknKSxcblx0XHRcdHByZWZpeCA9IG5ldyBSZWdFeHAoJ14nICsgcHJlZml4LnRvTG93ZXJDYXNlKCkpO1xuXHRcdGZvciAodmFyIGtleSBpbiBkYXRhKVxuXHRcdFx0aWYgKHByZWZpeC50ZXN0KGtleSkpe1xuXHRcdFx0XHRpbmtleSA9IGtleS5yZXBsYWNlKHJlcGxhY2UsIGZ1bmN0aW9uKF8sYSl7IHJldHVybiBhLnRvTG93ZXJDYXNlKCk7IH0pO1xuXHRcdFx0XHRvdXRbaW5rZXldID0gZGF0YVtrZXldO1xuXHRcdFx0fVxuXHRcdHJldHVybiBvdXQ7XG5cdH1cblxuXHRmdW5jdGlvbiBvcHRzX2Zyb21fbG9jYWxlKGxhbmcpe1xuXHRcdC8vIERlcml2ZSBvcHRpb25zIGZyb20gbG9jYWxlIHBsdWdpbnNcblx0XHR2YXIgb3V0ID0ge307XG5cdFx0Ly8gQ2hlY2sgaWYgXCJkZS1ERVwiIHN0eWxlIGRhdGUgaXMgYXZhaWxhYmxlLCBpZiBub3QgbGFuZ3VhZ2Ugc2hvdWxkXG5cdFx0Ly8gZmFsbGJhY2sgdG8gMiBsZXR0ZXIgY29kZSBlZyBcImRlXCJcblx0XHRpZiAoIWRhdGVzW2xhbmddKSB7XG5cdFx0XHRsYW5nID0gbGFuZy5zcGxpdCgnLScpWzBdXG5cdFx0XHRpZiAoIWRhdGVzW2xhbmddKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBkID0gZGF0ZXNbbGFuZ107XG5cdFx0JC5lYWNoKGxvY2FsZV9vcHRzLCBmdW5jdGlvbihpLGspe1xuXHRcdFx0aWYgKGsgaW4gZClcblx0XHRcdFx0b3V0W2tdID0gZFtrXTtcblx0XHR9KTtcblx0XHRyZXR1cm4gb3V0O1xuXHR9XG5cblx0dmFyIG9sZCA9ICQuZm4uZGF0ZXBpY2tlcjtcblx0dmFyIGRhdGVwaWNrZXIgPSAkLmZuLmRhdGVwaWNrZXIgPSBmdW5jdGlvbiAoIG9wdGlvbiApIHtcblx0XHR2YXIgYXJncyA9IEFycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdFx0YXJncy5zaGlmdCgpO1xuXHRcdHZhciBpbnRlcm5hbF9yZXR1cm4sXG5cdFx0XHR0aGlzX3JldHVybjtcblx0XHR0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyICR0aGlzID0gJCh0aGlzKSxcblx0XHRcdFx0ZGF0YSA9ICR0aGlzLmRhdGEoJ2RhdGVwaWNrZXInKSxcblx0XHRcdFx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uO1xuXHRcdFx0aWYgKCFkYXRhKSB7XG5cdFx0XHRcdHZhciBlbG9wdHMgPSBvcHRzX2Zyb21fZWwodGhpcywgJ2RhdGUnKSxcblx0XHRcdFx0XHQvLyBQcmVsaW1pbmFyeSBvdGlvbnNcblx0XHRcdFx0XHR4b3B0cyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZWxvcHRzLCBvcHRpb25zKSxcblx0XHRcdFx0XHRsb2NvcHRzID0gb3B0c19mcm9tX2xvY2FsZSh4b3B0cy5sYW5ndWFnZSksXG5cdFx0XHRcdFx0Ly8gT3B0aW9ucyBwcmlvcml0eToganMgYXJncywgZGF0YS1hdHRycywgbG9jYWxlcywgZGVmYXVsdHNcblx0XHRcdFx0XHRvcHRzID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLCBsb2NvcHRzLCBlbG9wdHMsIG9wdGlvbnMpO1xuXHRcdFx0XHRpZiAoJHRoaXMuaXMoJy5pbnB1dC1kYXRlcmFuZ2UnKSB8fCBvcHRzLmlucHV0cyl7XG5cdFx0XHRcdFx0dmFyIHJvcHRzID0ge1xuXHRcdFx0XHRcdFx0aW5wdXRzOiBvcHRzLmlucHV0cyB8fCAkdGhpcy5maW5kKCdpbnB1dCcpLnRvQXJyYXkoKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0JHRoaXMuZGF0YSgnZGF0ZXBpY2tlcicsIChkYXRhID0gbmV3IERhdGVSYW5nZVBpY2tlcih0aGlzLCAkLmV4dGVuZChvcHRzLCByb3B0cykpKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZXtcblx0XHRcdFx0XHQkdGhpcy5kYXRhKCdkYXRlcGlja2VyJywgKGRhdGEgPSBuZXcgRGF0ZXBpY2tlcih0aGlzLCBvcHRzKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAodHlwZW9mIG9wdGlvbiA9PSAnc3RyaW5nJyAmJiB0eXBlb2YgZGF0YVtvcHRpb25dID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0aW50ZXJuYWxfcmV0dXJuID0gZGF0YVtvcHRpb25dLmFwcGx5KGRhdGEsIGFyZ3MpO1xuXHRcdFx0XHRpZiAoaW50ZXJuYWxfcmV0dXJuICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlmIChpbnRlcm5hbF9yZXR1cm4gIT09IHVuZGVmaW5lZClcblx0XHRcdHJldHVybiBpbnRlcm5hbF9yZXR1cm47XG5cdFx0ZWxzZVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0dmFyIGRlZmF1bHRzID0gJC5mbi5kYXRlcGlja2VyLmRlZmF1bHRzID0ge1xuXHRcdGF1dG9jbG9zZTogZmFsc2UsXG5cdFx0YmVmb3JlU2hvd0RheTogJC5ub29wLFxuXHRcdGNhbGVuZGFyV2Vla3M6IGZhbHNlLFxuXHRcdGNsZWFyQnRuOiBmYWxzZSxcblx0XHRkYXlzT2ZXZWVrRGlzYWJsZWQ6IFtdLFxuXHRcdGVuZERhdGU6IEluZmluaXR5LFxuXHRcdGZvcmNlUGFyc2U6IHRydWUsXG5cdFx0Zm9ybWF0OiAnbW0vZGQveXl5eScsXG5cdFx0a2V5Ym9hcmROYXZpZ2F0aW9uOiB0cnVlLFxuXHRcdGxhbmd1YWdlOiAnZW4nLFxuXHRcdG1pblZpZXdNb2RlOiAwLFxuXHRcdHJ0bDogZmFsc2UsXG5cdFx0c3RhcnREYXRlOiAtSW5maW5pdHksXG5cdFx0c3RhcnRWaWV3OiAwLFxuXHRcdHRvZGF5QnRuOiBmYWxzZSxcblx0XHR0b2RheUhpZ2hsaWdodDogZmFsc2UsXG5cdFx0d2Vla1N0YXJ0OiAwXG5cdH07XG5cdHZhciBsb2NhbGVfb3B0cyA9ICQuZm4uZGF0ZXBpY2tlci5sb2NhbGVfb3B0cyA9IFtcblx0XHQnZm9ybWF0Jyxcblx0XHQncnRsJyxcblx0XHQnd2Vla1N0YXJ0J1xuXHRdO1xuXHQkLmZuLmRhdGVwaWNrZXIuQ29uc3RydWN0b3IgPSBEYXRlcGlja2VyO1xuXHR2YXIgZGF0ZXMgPSAkLmZuLmRhdGVwaWNrZXIuZGF0ZXMgPSB7XG5cdFx0ZW46IHtcblx0XHRcdGRheXM6IFtcIlN1bmRheVwiLCBcIk1vbmRheVwiLCBcIlR1ZXNkYXlcIiwgXCJXZWRuZXNkYXlcIiwgXCJUaHVyc2RheVwiLCBcIkZyaWRheVwiLCBcIlNhdHVyZGF5XCIsIFwiU3VuZGF5XCJdLFxuXHRcdFx0ZGF5c1Nob3J0OiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIiwgXCJTdW5cIl0sXG5cdFx0XHRkYXlzTWluOiBbXCJTdVwiLCBcIk1vXCIsIFwiVHVcIiwgXCJXZVwiLCBcIlRoXCIsIFwiRnJcIiwgXCJTYVwiLCBcIlN1XCJdLFxuXHRcdFx0bW9udGhzOiBbXCJKYW51YXJ5XCIsIFwiRmVicnVhcnlcIiwgXCJNYXJjaFwiLCBcIkFwcmlsXCIsIFwiTWF5XCIsIFwiSnVuZVwiLCBcIkp1bHlcIiwgXCJBdWd1c3RcIiwgXCJTZXB0ZW1iZXJcIiwgXCJPY3RvYmVyXCIsIFwiTm92ZW1iZXJcIiwgXCJEZWNlbWJlclwiXSxcblx0XHRcdG1vbnRoc1Nob3J0OiBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sXG5cdFx0XHR0b2RheTogXCJUb2RheVwiLFxuXHRcdFx0Y2xlYXI6IFwiQ2xlYXJcIlxuXHRcdH1cblx0fTtcblxuXHR2YXIgRFBHbG9iYWwgPSB7XG5cdFx0bW9kZXM6IFtcblx0XHRcdHtcblx0XHRcdFx0Y2xzTmFtZTogJ2RheXMnLFxuXHRcdFx0XHRuYXZGbmM6ICdNb250aCcsXG5cdFx0XHRcdG5hdlN0ZXA6IDFcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdGNsc05hbWU6ICdtb250aHMnLFxuXHRcdFx0XHRuYXZGbmM6ICdGdWxsWWVhcicsXG5cdFx0XHRcdG5hdlN0ZXA6IDFcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdGNsc05hbWU6ICd5ZWFycycsXG5cdFx0XHRcdG5hdkZuYzogJ0Z1bGxZZWFyJyxcblx0XHRcdFx0bmF2U3RlcDogMTBcblx0XHR9XSxcblx0XHRpc0xlYXBZZWFyOiBmdW5jdGlvbiAoeWVhcikge1xuXHRcdFx0cmV0dXJuICgoKHllYXIgJSA0ID09PSAwKSAmJiAoeWVhciAlIDEwMCAhPT0gMCkpIHx8ICh5ZWFyICUgNDAwID09PSAwKSk7XG5cdFx0fSxcblx0XHRnZXREYXlzSW5Nb250aDogZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG5cdFx0XHRyZXR1cm4gWzMxLCAoRFBHbG9iYWwuaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogMjgpLCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV1bbW9udGhdO1xuXHRcdH0sXG5cdFx0dmFsaWRQYXJ0czogL2RkP3xERD98bW0/fE1NP3x5eSg/Onl5KT8vZyxcblx0XHRub25wdW5jdHVhdGlvbjogL1teIC1cXC86LUBcXFtcXHUzNDAwLVxcdTlmZmYtYHstflxcdFxcblxccl0rL2csXG5cdFx0cGFyc2VGb3JtYXQ6IGZ1bmN0aW9uKGZvcm1hdCl7XG5cdFx0XHQvLyBJRSB0cmVhdHMgXFwwIGFzIGEgc3RyaW5nIGVuZCBpbiBpbnB1dHMgKHRydW5jYXRpbmcgdGhlIHZhbHVlKSxcblx0XHRcdC8vIHNvIGl0J3MgYSBiYWQgZm9ybWF0IGRlbGltaXRlciwgYW55d2F5XG5cdFx0XHR2YXIgc2VwYXJhdG9ycyA9IGZvcm1hdC5yZXBsYWNlKHRoaXMudmFsaWRQYXJ0cywgJ1xcMCcpLnNwbGl0KCdcXDAnKSxcblx0XHRcdFx0cGFydHMgPSBmb3JtYXQubWF0Y2godGhpcy52YWxpZFBhcnRzKTtcblx0XHRcdGlmICghc2VwYXJhdG9ycyB8fCAhc2VwYXJhdG9ycy5sZW5ndGggfHwgIXBhcnRzIHx8IHBhcnRzLmxlbmd0aCA9PT0gMCl7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0ZSBmb3JtYXQuXCIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtzZXBhcmF0b3JzOiBzZXBhcmF0b3JzLCBwYXJ0czogcGFydHN9O1xuXHRcdH0sXG5cdFx0cGFyc2VEYXRlOiBmdW5jdGlvbihkYXRlLCBmb3JtYXQsIGxhbmd1YWdlKSB7XG5cdFx0XHRpZiAoZGF0ZSBpbnN0YW5jZW9mIERhdGUpIHJldHVybiBkYXRlO1xuXHRcdFx0aWYgKHR5cGVvZiBmb3JtYXQgPT09ICdzdHJpbmcnKVxuXHRcdFx0XHRmb3JtYXQgPSBEUEdsb2JhbC5wYXJzZUZvcm1hdChmb3JtYXQpO1xuXHRcdFx0aWYgKC9eW1xcLStdXFxkK1tkbXd5XShbXFxzLF0rW1xcLStdXFxkK1tkbXd5XSkqJC8udGVzdChkYXRlKSkge1xuXHRcdFx0XHR2YXIgcGFydF9yZSA9IC8oW1xcLStdXFxkKykoW2Rtd3ldKS8sXG5cdFx0XHRcdFx0cGFydHMgPSBkYXRlLm1hdGNoKC8oW1xcLStdXFxkKykoW2Rtd3ldKS9nKSxcblx0XHRcdFx0XHRwYXJ0LCBkaXI7XG5cdFx0XHRcdGRhdGUgPSBuZXcgRGF0ZSgpO1xuXHRcdFx0XHRmb3IgKHZhciBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRwYXJ0ID0gcGFydF9yZS5leGVjKHBhcnRzW2ldKTtcblx0XHRcdFx0XHRkaXIgPSBwYXJzZUludChwYXJ0WzFdKTtcblx0XHRcdFx0XHRzd2l0Y2gocGFydFsyXSl7XG5cdFx0XHRcdFx0XHRjYXNlICdkJzpcblx0XHRcdFx0XHRcdFx0ZGF0ZS5zZXRVVENEYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpICsgZGlyKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdtJzpcblx0XHRcdFx0XHRcdFx0ZGF0ZSA9IERhdGVwaWNrZXIucHJvdG90eXBlLm1vdmVNb250aC5jYWxsKERhdGVwaWNrZXIucHJvdG90eXBlLCBkYXRlLCBkaXIpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3cnOlxuXHRcdFx0XHRcdFx0XHRkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBkaXIgKiA3KTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICd5Jzpcblx0XHRcdFx0XHRcdFx0ZGF0ZSA9IERhdGVwaWNrZXIucHJvdG90eXBlLm1vdmVZZWFyLmNhbGwoRGF0ZXBpY2tlci5wcm90b3R5cGUsIGRhdGUsIGRpcik7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gVVRDRGF0ZShkYXRlLmdldFVUQ0Z1bGxZZWFyKCksIGRhdGUuZ2V0VVRDTW9udGgoKSwgZGF0ZS5nZXRVVENEYXRlKCksIDAsIDAsIDApO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHBhcnRzID0gZGF0ZSAmJiBkYXRlLm1hdGNoKHRoaXMubm9ucHVuY3R1YXRpb24pIHx8IFtdLFxuXHRcdFx0XHRkYXRlID0gbmV3IERhdGUoKSxcblx0XHRcdFx0cGFyc2VkID0ge30sXG5cdFx0XHRcdHNldHRlcnNfb3JkZXIgPSBbJ3l5eXknLCAneXknLCAnTScsICdNTScsICdtJywgJ21tJywgJ2QnLCAnZGQnXSxcblx0XHRcdFx0c2V0dGVyc19tYXAgPSB7XG5cdFx0XHRcdFx0eXl5eTogZnVuY3Rpb24oZCx2KXsgcmV0dXJuIGQuc2V0VVRDRnVsbFllYXIodik7IH0sXG5cdFx0XHRcdFx0eXk6IGZ1bmN0aW9uKGQsdil7IHJldHVybiBkLnNldFVUQ0Z1bGxZZWFyKDIwMDArdik7IH0sXG5cdFx0XHRcdFx0bTogZnVuY3Rpb24oZCx2KXtcblx0XHRcdFx0XHRcdHYgLT0gMTtcblx0XHRcdFx0XHRcdHdoaWxlICh2PDApIHYgKz0gMTI7XG5cdFx0XHRcdFx0XHR2ICU9IDEyO1xuXHRcdFx0XHRcdFx0ZC5zZXRVVENNb250aCh2KTtcblx0XHRcdFx0XHRcdHdoaWxlIChkLmdldFVUQ01vbnRoKCkgIT0gdilcblx0XHRcdFx0XHRcdFx0ZC5zZXRVVENEYXRlKGQuZ2V0VVRDRGF0ZSgpLTEpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGQ7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRkOiBmdW5jdGlvbihkLHYpeyByZXR1cm4gZC5zZXRVVENEYXRlKHYpOyB9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHZhbCwgZmlsdGVyZWQsIHBhcnQ7XG5cdFx0XHRzZXR0ZXJzX21hcFsnTSddID0gc2V0dGVyc19tYXBbJ01NJ10gPSBzZXR0ZXJzX21hcFsnbW0nXSA9IHNldHRlcnNfbWFwWydtJ107XG5cdFx0XHRzZXR0ZXJzX21hcFsnZGQnXSA9IHNldHRlcnNfbWFwWydkJ107XG5cdFx0XHRkYXRlID0gVVRDRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCksIDAsIDAsIDApO1xuXHRcdFx0dmFyIGZwYXJ0cyA9IGZvcm1hdC5wYXJ0cy5zbGljZSgpO1xuXHRcdFx0Ly8gUmVtb3ZlIG5vb3AgcGFydHNcblx0XHRcdGlmIChwYXJ0cy5sZW5ndGggIT0gZnBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHRmcGFydHMgPSAkKGZwYXJ0cykuZmlsdGVyKGZ1bmN0aW9uKGkscCl7XG5cdFx0XHRcdFx0cmV0dXJuICQuaW5BcnJheShwLCBzZXR0ZXJzX29yZGVyKSAhPT0gLTE7XG5cdFx0XHRcdH0pLnRvQXJyYXkoKTtcblx0XHRcdH1cblx0XHRcdC8vIFByb2Nlc3MgcmVtYWluZGVyXG5cdFx0XHRpZiAocGFydHMubGVuZ3RoID09IGZwYXJ0cy5sZW5ndGgpIHtcblx0XHRcdFx0Zm9yICh2YXIgaT0wLCBjbnQgPSBmcGFydHMubGVuZ3RoOyBpIDwgY250OyBpKyspIHtcblx0XHRcdFx0XHR2YWwgPSBwYXJzZUludChwYXJ0c1tpXSwgMTApO1xuXHRcdFx0XHRcdHBhcnQgPSBmcGFydHNbaV07XG5cdFx0XHRcdFx0aWYgKGlzTmFOKHZhbCkpIHtcblx0XHRcdFx0XHRcdHN3aXRjaChwYXJ0KSB7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ01NJzpcblx0XHRcdFx0XHRcdFx0XHRmaWx0ZXJlZCA9ICQoZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRocykuZmlsdGVyKGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgbSA9IHRoaXMuc2xpY2UoMCwgcGFydHNbaV0ubGVuZ3RoKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cCA9IHBhcnRzW2ldLnNsaWNlKDAsIG0ubGVuZ3RoKTtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBtID09IHA7XG5cdFx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdFx0dmFsID0gJC5pbkFycmF5KGZpbHRlcmVkWzBdLCBkYXRlc1tsYW5ndWFnZV0ubW9udGhzKSArIDE7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGNhc2UgJ00nOlxuXHRcdFx0XHRcdFx0XHRcdGZpbHRlcmVkID0gJChkYXRlc1tsYW5ndWFnZV0ubW9udGhzU2hvcnQpLmZpbHRlcihmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIG0gPSB0aGlzLnNsaWNlKDAsIHBhcnRzW2ldLmxlbmd0aCksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAgPSBwYXJ0c1tpXS5zbGljZSgwLCBtLmxlbmd0aCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gbSA9PSBwO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdHZhbCA9ICQuaW5BcnJheShmaWx0ZXJlZFswXSwgZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRoc1Nob3J0KSArIDE7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcnNlZFtwYXJ0XSA9IHZhbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKHZhciBpPTAsIHM7IGk8c2V0dGVyc19vcmRlci5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdFx0cyA9IHNldHRlcnNfb3JkZXJbaV07XG5cdFx0XHRcdFx0aWYgKHMgaW4gcGFyc2VkICYmICFpc05hTihwYXJzZWRbc10pKVxuXHRcdFx0XHRcdFx0c2V0dGVyc19tYXBbc10oZGF0ZSwgcGFyc2VkW3NdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRhdGU7XG5cdFx0fSxcblx0XHRmb3JtYXREYXRlOiBmdW5jdGlvbihkYXRlLCBmb3JtYXQsIGxhbmd1YWdlKXtcblx0XHRcdGlmICh0eXBlb2YgZm9ybWF0ID09PSAnc3RyaW5nJylcblx0XHRcdFx0Zm9ybWF0ID0gRFBHbG9iYWwucGFyc2VGb3JtYXQoZm9ybWF0KTtcblx0XHRcdHZhciB2YWwgPSB7XG5cdFx0XHRcdGQ6IGRhdGUuZ2V0VVRDRGF0ZSgpLFxuXHRcdFx0XHREOiBkYXRlc1tsYW5ndWFnZV0uZGF5c1Nob3J0W2RhdGUuZ2V0VVRDRGF5KCldLFxuXHRcdFx0XHRERDogZGF0ZXNbbGFuZ3VhZ2VdLmRheXNbZGF0ZS5nZXRVVENEYXkoKV0sXG5cdFx0XHRcdG06IGRhdGUuZ2V0VVRDTW9udGgoKSArIDEsXG5cdFx0XHRcdE06IGRhdGVzW2xhbmd1YWdlXS5tb250aHNTaG9ydFtkYXRlLmdldFVUQ01vbnRoKCldLFxuXHRcdFx0XHRNTTogZGF0ZXNbbGFuZ3VhZ2VdLm1vbnRoc1tkYXRlLmdldFVUQ01vbnRoKCldLFxuXHRcdFx0XHR5eTogZGF0ZS5nZXRVVENGdWxsWWVhcigpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFxuXHRcdFx0XHR5eXl5OiBkYXRlLmdldFVUQ0Z1bGxZZWFyKClcblx0XHRcdH07XG5cdFx0XHR2YWwuZGQgPSAodmFsLmQgPCAxMCA/ICcwJyA6ICcnKSArIHZhbC5kO1xuXHRcdFx0dmFsLm1tID0gKHZhbC5tIDwgMTAgPyAnMCcgOiAnJykgKyB2YWwubTtcblx0XHRcdHZhciBkYXRlID0gW10sXG5cdFx0XHRcdHNlcHMgPSAkLmV4dGVuZChbXSwgZm9ybWF0LnNlcGFyYXRvcnMpO1xuXHRcdFx0Zm9yICh2YXIgaT0wLCBjbnQgPSBmb3JtYXQucGFydHMubGVuZ3RoOyBpIDw9IGNudDsgaSsrKSB7XG5cdFx0XHRcdGlmIChzZXBzLmxlbmd0aClcblx0XHRcdFx0XHRkYXRlLnB1c2goc2Vwcy5zaGlmdCgpKTtcblx0XHRcdFx0ZGF0ZS5wdXNoKHZhbFtmb3JtYXQucGFydHNbaV1dKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBkYXRlLmpvaW4oJycpO1xuXHRcdH0sXG5cdFx0aGVhZFRlbXBsYXRlOiAnPHRoZWFkPicrXG5cdFx0XHRcdFx0XHRcdCc8dHI+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRoIGNsYXNzPVwicHJldlwiPjxpIGNsYXNzPVwiaWNvbi1hcnJvdy1sZWZ0XCIvPjwvdGg+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRoIGNvbHNwYW49XCI1XCIgY2xhc3M9XCJkYXRlcGlja2VyLXN3aXRjaFwiPjwvdGg+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRoIGNsYXNzPVwibmV4dFwiPjxpIGNsYXNzPVwiaWNvbi1hcnJvdy1yaWdodFwiLz48L3RoPicrXG5cdFx0XHRcdFx0XHRcdCc8L3RyPicrXG5cdFx0XHRcdFx0XHQnPC90aGVhZD4nLFxuXHRcdGNvbnRUZW1wbGF0ZTogJzx0Ym9keT48dHI+PHRkIGNvbHNwYW49XCI3XCI+PC90ZD48L3RyPjwvdGJvZHk+Jyxcblx0XHRmb290VGVtcGxhdGU6ICc8dGZvb3Q+PHRyPjx0aCBjb2xzcGFuPVwiN1wiIGNsYXNzPVwidG9kYXlcIj48L3RoPjwvdHI+PHRyPjx0aCBjb2xzcGFuPVwiN1wiIGNsYXNzPVwiY2xlYXJcIj48L3RoPjwvdHI+PC90Zm9vdD4nXG5cdH07XG5cdERQR2xvYmFsLnRlbXBsYXRlID0gJzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyXCI+Jytcblx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLWRheXNcIj4nK1xuXHRcdFx0XHRcdFx0XHRcdCc8dGFibGUgY2xhc3M9XCIgdGFibGUtY29uZGVuc2VkXCI+Jytcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdCc8dGJvZHk+PC90Ym9keT4nK1xuXHRcdFx0XHRcdFx0XHRcdFx0RFBHbG9iYWwuZm9vdFRlbXBsYXRlK1xuXHRcdFx0XHRcdFx0XHRcdCc8L3RhYmxlPicrXG5cdFx0XHRcdFx0XHRcdCc8L2Rpdj4nK1xuXHRcdFx0XHRcdFx0XHQnPGRpdiBjbGFzcz1cImRhdGVwaWNrZXItbW9udGhzXCI+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+Jytcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmNvbnRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmZvb3RUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHQnPC90YWJsZT4nK1xuXHRcdFx0XHRcdFx0XHQnPC9kaXY+Jytcblx0XHRcdFx0XHRcdFx0JzxkaXYgY2xhc3M9XCJkYXRlcGlja2VyLXllYXJzXCI+Jytcblx0XHRcdFx0XHRcdFx0XHQnPHRhYmxlIGNsYXNzPVwidGFibGUtY29uZGVuc2VkXCI+Jytcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmhlYWRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmNvbnRUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHRcdERQR2xvYmFsLmZvb3RUZW1wbGF0ZStcblx0XHRcdFx0XHRcdFx0XHQnPC90YWJsZT4nK1xuXHRcdFx0XHRcdFx0XHQnPC9kaXY+Jytcblx0XHRcdFx0XHRcdCc8L2Rpdj4nO1xuXG5cdCQuZm4uZGF0ZXBpY2tlci5EUEdsb2JhbCA9IERQR2xvYmFsO1xuXG5cblx0LyogREFURVBJQ0tFUiBOTyBDT05GTElDVFxuXHQqID09PT09PT09PT09PT09PT09PT0gKi9cblxuXHQkLmZuLmRhdGVwaWNrZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uKCl7XG5cdFx0JC5mbi5kYXRlcGlja2VyID0gb2xkO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cblx0LyogREFURVBJQ0tFUiBEQVRBLUFQSVxuXHQqID09PT09PT09PT09PT09PT09PSAqL1xuXG5cdCQoZG9jdW1lbnQpLm9uKFxuXHRcdCdmb2N1cy5kYXRlcGlja2VyLmRhdGEtYXBpIGNsaWNrLmRhdGVwaWNrZXIuZGF0YS1hcGknLFxuXHRcdCdbZGF0YS1wcm92aWRlPVwiZGF0ZXBpY2tlclwiXScsXG5cdFx0ZnVuY3Rpb24oZSl7XG5cdFx0XHR2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXHRcdFx0aWYgKCR0aGlzLmRhdGEoJ2RhdGVwaWNrZXInKSkgcmV0dXJuO1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0Ly8gY29tcG9uZW50IGNsaWNrIHJlcXVpcmVzIHVzIHRvIGV4cGxpY2l0bHkgc2hvdyBpdFxuXHRcdFx0ZGF0ZXBpY2tlci5jYWxsKCR0aGlzLCAnc2hvdycpO1xuXHRcdH1cblx0KTtcblx0JChmdW5jdGlvbigpe1xuXHRcdC8vJCgnW2RhdGEtcHJvdmlkZT1cImRhdGVwaWNrZXItaW5saW5lXCJdJykuZGF0ZXBpY2tlcigpO1xuICAgICAgICAvL3ZpdDogY2hhbmdlZCB0byBzdXBwb3J0IG5vQ29uZmxpY3QoKVxuICAgICAgICBkYXRlcGlja2VyLmNhbGwoJCgnW2RhdGEtcHJvdmlkZT1cImRhdGVwaWNrZXItaW5saW5lXCJdJykpO1xuXHR9KTtcblxufSggd2luZG93LmpRdWVyeSApKTtcblxuLyoqXG5Cb290c3RyYXAtZGF0ZXBpY2tlci4gIFxuRGVzY3JpcHRpb24gYW5kIGV4YW1wbGVzOiBodHRwczovL2dpdGh1Yi5jb20vZXRlcm5pY29kZS9ib290c3RyYXAtZGF0ZXBpY2tlci4gIFxuRm9yICoqaTE4bioqIHlvdSBzaG91bGQgaW5jbHVkZSBqcyBmaWxlIGZyb20gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL2V0ZXJuaWNvZGUvYm9vdHN0cmFwLWRhdGVwaWNrZXIvdHJlZS9tYXN0ZXIvanMvbG9jYWxlc1xuYW5kIHNldCBgbGFuZ3VhZ2VgIG9wdGlvbi4gIFxuU2luY2UgMS40LjAgZGF0ZSBoYXMgZGlmZmVyZW50IGFwcGVhcmFuY2UgaW4gKipwb3B1cCoqIGFuZCAqKmlubGluZSoqIG1vZGVzLiBcblxuQGNsYXNzIGRhdGVcbkBleHRlbmRzIGFic3RyYWN0aW5wdXRcbkBmaW5hbFxuQGV4YW1wbGVcbjxhIGhyZWY9XCIjXCIgaWQ9XCJkb2JcIiBkYXRhLXR5cGU9XCJkYXRlXCIgZGF0YS1waz1cIjFcIiBkYXRhLXVybD1cIi9wb3N0XCIgZGF0YS10aXRsZT1cIlNlbGVjdCBkYXRlXCI+MTUvMDUvMTk4NDwvYT5cbjxzY3JpcHQ+XG4kKGZ1bmN0aW9uKCl7XG4gICAgJCgnI2RvYicpLmVkaXRhYmxlKHtcbiAgICAgICAgZm9ybWF0OiAneXl5eS1tbS1kZCcsICAgIFxuICAgICAgICB2aWV3Zm9ybWF0OiAnZGQvbW0veXl5eScsICAgIFxuICAgICAgICBkYXRlcGlja2VyOiB7XG4gICAgICAgICAgICAgICAgd2Vla1N0YXJ0OiAxXG4gICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG48L3NjcmlwdD5cbioqL1xuKGZ1bmN0aW9uICgkKSB7XG4gICAgO1xuICAgIFxuICAgIC8vc3RvcmUgYm9vdHN0cmFwLWRhdGVwaWNrZXIgYXMgYmRhdGVpY2tlciB0byBleGNsdWRlIGNvbmZsaWN0IHdpdGggalF1ZXJ5IFVJIG9uZVxuICAgICQuZm4uYmRhdGVwaWNrZXIgPSAkLmZuLmRhdGVwaWNrZXIubm9Db25mbGljdCgpO1xuICAgIGlmKCEkLmZuLmRhdGVwaWNrZXIpIHsgLy9pZiB0aGVyZSB3ZXJlIG5vIG90aGVyIGRhdGVwaWNrZXJzLCBrZWVwIGFsc28gb3JpZ2luYWwgbmFtZVxuICAgICAgICAkLmZuLmRhdGVwaWNrZXIgPSAkLmZuLmJkYXRlcGlja2VyOyAgICBcbiAgICB9ICAgIFxuICAgIFxuICAgIHZhciBEYXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0KCdkYXRlJywgb3B0aW9ucywgRGF0ZS5kZWZhdWx0cyk7XG4gICAgICAgIHRoaXMuaW5pdFBpY2tlcihvcHRpb25zLCBEYXRlLmRlZmF1bHRzKTtcbiAgICB9O1xuXG4gICAgJC5mbi5lZGl0YWJsZXV0aWxzLmluaGVyaXQoRGF0ZSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQpOyAgICBcbiAgICBcbiAgICAkLmV4dGVuZChEYXRlLnByb3RvdHlwZSwge1xuICAgICAgICBpbml0UGlja2VyOiBmdW5jdGlvbihvcHRpb25zLCBkZWZhdWx0cykge1xuICAgICAgICAgICAgLy8nZm9ybWF0JyBpcyBzZXQgZGlyZWN0bHkgZnJvbSBzZXR0aW5ncyBvciBkYXRhLSogYXR0cmlidXRlc1xuXG4gICAgICAgICAgICAvL2J5IGRlZmF1bHQgdmlld2Zvcm1hdCBlcXVhbHMgdG8gZm9ybWF0XG4gICAgICAgICAgICBpZighdGhpcy5vcHRpb25zLnZpZXdmb3JtYXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCA9IHRoaXMub3B0aW9ucy5mb3JtYXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vdHJ5IHBhcnNlIGRhdGVwaWNrZXIgY29uZmlnIGRlZmluZWQgYXMganNvbiBzdHJpbmcgaW4gZGF0YS1kYXRlcGlja2VyXG4gICAgICAgICAgICBvcHRpb25zLmRhdGVwaWNrZXIgPSAkLmZuLmVkaXRhYmxldXRpbHMudHJ5UGFyc2VKc29uKG9wdGlvbnMuZGF0ZXBpY2tlciwgdHJ1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vb3ZlcnJpZGluZyBkYXRlcGlja2VyIGNvbmZpZyAoYXMgYnkgZGVmYXVsdCBqUXVlcnkgZXh0ZW5kKCkgaXMgbm90IHJlY3Vyc2l2ZSlcbiAgICAgICAgICAgIC8vc2luY2UgMS40IGRhdGVwaWNrZXIgaW50ZXJuYWxseSB1c2VzIHZpZXdmb3JtYXQgaW5zdGVhZCBvZiBmb3JtYXQuIEZvcm1hdCBpcyBmb3Igc3VibWl0IG9ubHlcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kYXRlcGlja2VyID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLmRhdGVwaWNrZXIsIG9wdGlvbnMuZGF0ZXBpY2tlciwge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogdGhpcy5vcHRpb25zLnZpZXdmb3JtYXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2xhbmd1YWdlXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlci5sYW5ndWFnZSA9IHRoaXMub3B0aW9ucy5kYXRlcGlja2VyLmxhbmd1YWdlIHx8ICdlbic7IFxuXG4gICAgICAgICAgICAvL3N0b3JlIERQZ2xvYmFsXG4gICAgICAgICAgICB0aGlzLmRwZyA9ICQuZm4uYmRhdGVwaWNrZXIuRFBHbG9iYWw7IFxuXG4gICAgICAgICAgICAvL3N0b3JlIHBhcnNlZCBmb3JtYXRzXG4gICAgICAgICAgICB0aGlzLnBhcnNlZEZvcm1hdCA9IHRoaXMuZHBnLnBhcnNlRm9ybWF0KHRoaXMub3B0aW9ucy5mb3JtYXQpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRWaWV3Rm9ybWF0ID0gdGhpcy5kcGcucGFyc2VGb3JtYXQodGhpcy5vcHRpb25zLnZpZXdmb3JtYXQpOyAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5iZGF0ZXBpY2tlcih0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vXCJjbGVhclwiIGxpbmtcbiAgICAgICAgICAgIGlmKHRoaXMub3B0aW9ucy5jbGVhcikge1xuICAgICAgICAgICAgICAgIHRoaXMuJGNsZWFyID0gJCgnPGEgaHJlZj1cIiNcIj48L2E+JykuaHRtbCh0aGlzLm9wdGlvbnMuY2xlYXIpLmNsaWNrKCQucHJveHkoZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLiR0cGwucGFyZW50KCkuYXBwZW5kKCQoJzxkaXYgY2xhc3M9XCJlZGl0YWJsZS1jbGVhclwiPicpLmFwcGVuZCh0aGlzLiRjbGVhcikpOyAgXG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgdmFsdWUyaHRtbDogZnVuY3Rpb24odmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgICAgdmFyIHRleHQgPSB2YWx1ZSA/IHRoaXMuZHBnLmZvcm1hdERhdGUodmFsdWUsIHRoaXMucGFyc2VkVmlld0Zvcm1hdCwgdGhpcy5vcHRpb25zLmRhdGVwaWNrZXIubGFuZ3VhZ2UpIDogJyc7XG4gICAgICAgICAgIERhdGUuc3VwZXJjbGFzcy52YWx1ZTJodG1sLmNhbGwodGhpcywgdGV4dCwgZWxlbWVudCk7IFxuICAgICAgICB9LFxuXG4gICAgICAgIGh0bWwydmFsdWU6IGZ1bmN0aW9uKGh0bWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRGF0ZShodG1sLCB0aGlzLnBhcnNlZFZpZXdGb3JtYXQpO1xuICAgICAgICB9LCAgIFxuXG4gICAgICAgIHZhbHVlMnN0cjogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/IHRoaXMuZHBnLmZvcm1hdERhdGUodmFsdWUsIHRoaXMucGFyc2VkRm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlci5sYW5ndWFnZSkgOiAnJztcbiAgICAgICAgfSwgXG5cbiAgICAgICAgc3RyMnZhbHVlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRGF0ZShzdHIsIHRoaXMucGFyc2VkRm9ybWF0KTtcbiAgICAgICAgfSwgXG5cbiAgICAgICAgdmFsdWUyc3VibWl0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUyc3RyKHZhbHVlKTtcbiAgICAgICAgfSwgICAgICAgICAgICAgICAgICAgIFxuXG4gICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuYmRhdGVwaWNrZXIoJ3VwZGF0ZScsIHZhbHVlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBpbnB1dDJ2YWx1ZTogZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJGlucHV0LmRhdGEoJ2RhdGVwaWNrZXInKS5kYXRlO1xuICAgICAgICB9LCAgICAgICBcblxuICAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXI6ICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmRhdGEoJ2RhdGVwaWNrZXInKS5kYXRlID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0LmZpbmQoJy5hY3RpdmUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XG4gICAgICAgICAgICBpZighdGhpcy5vcHRpb25zLnNob3didXR0b25zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kaW5wdXQuY2xvc2VzdCgnZm9ybScpLnN1Ym1pdCgpOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhdXRvc3VibWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKCdtb3VzZXVwJywgJy5kYXknLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICBpZigkKGUuY3VycmVudFRhcmdldCkuaXMoJy5vbGQnKSB8fCAkKGUuY3VycmVudFRhcmdldCkuaXMoJy5uZXcnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciAkZm9ybSA9ICQodGhpcykuY2xvc2VzdCgnZm9ybScpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICRmb3JtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgLy9jaGFuZ2VkYXRlIGlzIG5vdCBzdWl0YWJsZSBhcyBpdCB0cmlnZ2VyZWQgd2hlbiBzaG93aW5nIGRhdGVwaWNrZXIuIHNlZSAjMTQ5XG4gICAgICAgICAgIC8qXG4gICAgICAgICAgIHRoaXMuJGlucHV0Lm9uKCdjaGFuZ2VEYXRlJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICB2YXIgJGZvcm0gPSAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKTtcbiAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgJGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICB9KTtcbiAgICAgICAgICAgKi9cbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIC8qXG4gICAgICAgIEZvciBpbmNvcnJlY3QgZGF0ZSBib290c3RyYXAtZGF0ZXBpY2tlciByZXR1cm5zIGN1cnJlbnQgZGF0ZSB0aGF0IGlzIG5vdCBzdWl0YWJsZVxuICAgICAgICBmb3IgZGF0ZWZpZWxkLlxuICAgICAgICBUaGlzIGZ1bmN0aW9uIHJldHVybnMgbnVsbCBmb3IgaW5jb3JyZWN0IGRhdGUuICBcbiAgICAgICAqL1xuICAgICAgIHBhcnNlRGF0ZTogZnVuY3Rpb24oc3RyLCBmb3JtYXQpIHtcbiAgICAgICAgICAgdmFyIGRhdGUgPSBudWxsLCBmb3JtYXR0ZWRCYWNrO1xuICAgICAgICAgICBpZihzdHIpIHtcbiAgICAgICAgICAgICAgIGRhdGUgPSB0aGlzLmRwZy5wYXJzZURhdGUoc3RyLCBmb3JtYXQsIHRoaXMub3B0aW9ucy5kYXRlcGlja2VyLmxhbmd1YWdlKTtcbiAgICAgICAgICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkQmFjayA9IHRoaXMuZHBnLmZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlci5sYW5ndWFnZSk7XG4gICAgICAgICAgICAgICAgICAgaWYoc3RyICE9PSBmb3JtYXR0ZWRCYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIGRhdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIERhdGUuZGVmYXVsdHMgPSAkLmV4dGVuZCh7fSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQuZGVmYXVsdHMsIHtcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSB0cGwgXG4gICAgICAgIEBkZWZhdWx0IDxkaXY+PC9kaXY+XG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICB0cGw6JzxkaXYgY2xhc3M9XCJlZGl0YWJsZS1kYXRlIHdlbGxcIj48L2Rpdj4nLFxuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IGlucHV0Y2xhc3MgXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovXG4gICAgICAgIGlucHV0Y2xhc3M6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBGb3JtYXQgdXNlZCBmb3Igc2VuZGluZyB2YWx1ZSB0byBzZXJ2ZXIuIEFsc28gYXBwbGllZCB3aGVuIGNvbnZlcnRpbmcgZGF0ZSBmcm9tIDxjb2RlPmRhdGEtdmFsdWU8L2NvZGU+IGF0dHJpYnV0ZS48YnI+XG4gICAgICAgIFBvc3NpYmxlIHRva2VucyBhcmU6IDxjb2RlPmQsIGRkLCBtLCBtbSwgeXksIHl5eXk8L2NvZGU+ICBcblxuICAgICAgICBAcHJvcGVydHkgZm9ybWF0IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgeXl5eS1tbS1kZFxuICAgICAgICAqKi9cbiAgICAgICAgZm9ybWF0Oid5eXl5LW1tLWRkJyxcbiAgICAgICAgLyoqXG4gICAgICAgIEZvcm1hdCB1c2VkIGZvciBkaXNwbGF5aW5nIGRhdGUuIEFsc28gYXBwbGllZCB3aGVuIGNvbnZlcnRpbmcgZGF0ZSBmcm9tIGVsZW1lbnQncyB0ZXh0IG9uIGluaXQuICAgXG4gICAgICAgIElmIG5vdCBzcGVjaWZpZWQgZXF1YWxzIHRvIDxjb2RlPmZvcm1hdDwvY29kZT5cblxuICAgICAgICBAcHJvcGVydHkgdmlld2Zvcm1hdCBcbiAgICAgICAgQHR5cGUgc3RyaW5nXG4gICAgICAgIEBkZWZhdWx0IG51bGxcbiAgICAgICAgKiovXG4gICAgICAgIHZpZXdmb3JtYXQ6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICBDb25maWd1cmF0aW9uIG9mIGRhdGVwaWNrZXIuXG4gICAgICAgIEZ1bGwgbGlzdCBvZiBvcHRpb25zOiBodHRwOi8vYm9vdHN0cmFwLWRhdGVwaWNrZXIucmVhZHRoZWRvY3Mub3JnL2VuL2xhdGVzdC9vcHRpb25zLmh0bWxcblxuICAgICAgICBAcHJvcGVydHkgZGF0ZXBpY2tlciBcbiAgICAgICAgQHR5cGUgb2JqZWN0XG4gICAgICAgIEBkZWZhdWx0IHtcbiAgICAgICAgICAgIHdlZWtTdGFydDogMCxcbiAgICAgICAgICAgIHN0YXJ0VmlldzogMCxcbiAgICAgICAgICAgIG1pblZpZXdNb2RlOiAwLFxuICAgICAgICAgICAgYXV0b2Nsb3NlOiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgICoqL1xuICAgICAgICBkYXRlcGlja2VyOntcbiAgICAgICAgICAgIHdlZWtTdGFydDogMCxcbiAgICAgICAgICAgIHN0YXJ0VmlldzogMCxcbiAgICAgICAgICAgIG1pblZpZXdNb2RlOiAwLFxuICAgICAgICAgICAgYXV0b2Nsb3NlOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgVGV4dCBzaG93biBhcyBjbGVhciBkYXRlIGJ1dHRvbi4gXG4gICAgICAgIElmIDxjb2RlPmZhbHNlPC9jb2RlPiBjbGVhciBidXR0b24gd2lsbCBub3QgYmUgcmVuZGVyZWQuXG5cbiAgICAgICAgQHByb3BlcnR5IGNsZWFyIFxuICAgICAgICBAdHlwZSBib29sZWFufHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCAneCBjbGVhcidcbiAgICAgICAgKiovXG4gICAgICAgIGNsZWFyOiAnJnRpbWVzOyBjbGVhcidcbiAgICB9KTtcblxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5kYXRlID0gRGF0ZTtcblxufSh3aW5kb3cualF1ZXJ5KSk7XG5cbi8qKlxuQm9vdHN0cmFwIGRhdGVmaWVsZCBpbnB1dCAtIG1vZGlmaWNhdGlvbiBmb3IgaW5saW5lIG1vZGUuXG5TaG93cyBub3JtYWwgPGlucHV0IHR5cGU9XCJ0ZXh0XCI+IGFuZCBiaW5kcyBwb3B1cCBkYXRlcGlja2VyLiAgXG5BdXRvbWF0aWNhbGx5IHNob3duIGluIGlubGluZSBtb2RlLlxuXG5AY2xhc3MgZGF0ZWZpZWxkXG5AZXh0ZW5kcyBkYXRlXG5cbkBzaW5jZSAxLjQuMFxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICA7XG4gICAgXG4gICAgdmFyIERhdGVGaWVsZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaW5pdCgnZGF0ZWZpZWxkJywgb3B0aW9ucywgRGF0ZUZpZWxkLmRlZmF1bHRzKTtcbiAgICAgICAgdGhpcy5pbml0UGlja2VyKG9wdGlvbnMsIERhdGVGaWVsZC5kZWZhdWx0cyk7XG4gICAgfTtcblxuICAgICQuZm4uZWRpdGFibGV1dGlscy5pbmhlcml0KERhdGVGaWVsZCwgJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGUpOyAgICBcbiAgICBcbiAgICAkLmV4dGVuZChEYXRlRmllbGQucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQgPSB0aGlzLiR0cGwuZmluZCgnaW5wdXQnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3MoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cigncGxhY2Vob2xkZXInKTtcbiAgICBcbiAgICAgICAgICAgIC8vYm9vdHN0cmFwLWRhdGVwaWNrZXIgaXMgc2V0IGBiZGF0ZWlja2VyYCB0byBleGNsdWRlIGNvbmZsaWN0IHdpdGggalF1ZXJ5IFVJIG9uZS4gKGluIGRhdGUuanMpICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuJHRwbC5iZGF0ZXBpY2tlcih0aGlzLm9wdGlvbnMuZGF0ZXBpY2tlcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vbmVlZCB0byBkaXNhYmxlIG9yaWdpbmFsIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5vZmYoJ2ZvY3VzIGtleWRvd24nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy91cGRhdGUgdmFsdWUgb2YgZGF0ZXBpY2tlclxuICAgICAgICAgICAgdGhpcy4kaW5wdXQua2V5dXAoJC5wcm94eShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgdGhpcy4kdHBsLnJlbW92ZURhdGEoJ2RhdGUnKTtcbiAgICAgICAgICAgICAgIHRoaXMuJHRwbC5iZGF0ZXBpY2tlcigndXBkYXRlJyk7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgfSwgICBcbiAgICAgICAgXG4gICAgICAgdmFsdWUyaW5wdXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgIHRoaXMuJGlucHV0LnZhbCh2YWx1ZSA/IHRoaXMuZHBnLmZvcm1hdERhdGUodmFsdWUsIHRoaXMucGFyc2VkVmlld0Zvcm1hdCwgdGhpcy5vcHRpb25zLmRhdGVwaWNrZXIubGFuZ3VhZ2UpIDogJycpO1xuICAgICAgICAgICB0aGlzLiR0cGwuYmRhdGVwaWNrZXIoJ3VwZGF0ZScpO1xuICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgIGlucHV0MnZhbHVlOiBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgIHJldHVybiB0aGlzLmh0bWwydmFsdWUodGhpcy4kaW5wdXQudmFsKCkpO1xuICAgICAgIH0sICAgICAgICAgICAgICBcbiAgICAgICAgXG4gICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAkLmZuLmVkaXRhYmxldHlwZXMudGV4dC5wcm90b3R5cGUuYWN0aXZhdGUuY2FsbCh0aGlzKTtcbiAgICAgICB9LFxuICAgICAgIFxuICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgLy9yZXNldCBhdXRvc3VibWl0IHRvIGVtcHR5ICBcbiAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgRGF0ZUZpZWxkLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5kYXRlLmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsIFxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgdHBsOic8ZGl2IGNsYXNzPVwiaW5wdXQtYXBwZW5kIGRhdGVcIj48aW5wdXQgdHlwZT1cInRleHRcIi8+PHNwYW4gY2xhc3M9XCJhZGQtb25cIj48aSBjbGFzcz1cImljb24tdGhcIj48L2k+PC9zcGFuPjwvZGl2PicsXG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgaW5wdXRjbGFzcyBcbiAgICAgICAgQGRlZmF1bHQgJ2lucHV0LXNtYWxsJ1xuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgaW5wdXRjbGFzczogJ2lucHV0LXNtYWxsJyxcbiAgICAgICAgXG4gICAgICAgIC8qIGRhdGVwaWNrZXIgY29uZmlnICovXG4gICAgICAgIGRhdGVwaWNrZXI6IHtcbiAgICAgICAgICAgIHdlZWtTdGFydDogMCxcbiAgICAgICAgICAgIHN0YXJ0VmlldzogMCxcbiAgICAgICAgICAgIG1pblZpZXdNb2RlOiAwLFxuICAgICAgICAgICAgYXV0b2Nsb3NlOiB0cnVlXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICAkLmZuLmVkaXRhYmxldHlwZXMuZGF0ZWZpZWxkID0gRGF0ZUZpZWxkO1xuXG59KHdpbmRvdy5qUXVlcnkpKTtcbi8qKlxuQm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLiAgXG5CYXNlZCBvbiBbc21hbG90IGJvb3RzdHJhcC1kYXRldGltZXBpY2tlciBwbHVnaW5dKGh0dHBzOi8vZ2l0aHViLmNvbS9zbWFsb3QvYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyKS4gXG5CZWZvcmUgdXNhZ2UgeW91IHNob3VsZCBtYW51YWxseSBpbmNsdWRlIGRlcGVuZGVudCBqcyBhbmQgY3NzOlxuXG4gICAgPGxpbmsgaHJlZj1cImNzcy9kYXRldGltZXBpY2tlci5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCIgdHlwZT1cInRleHQvY3NzXCI+PC9saW5rPiBcbiAgICA8c2NyaXB0IHNyYz1cImpzL2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci5qc1wiPjwvc2NyaXB0PlxuXG5Gb3IgKippMThuKiogeW91IHNob3VsZCBpbmNsdWRlIGpzIGZpbGUgZnJvbSBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vc21hbG90L2Jvb3RzdHJhcC1kYXRldGltZXBpY2tlci90cmVlL21hc3Rlci9qcy9sb2NhbGVzXG5hbmQgc2V0IGBsYW5ndWFnZWAgb3B0aW9uLiAgXG5cbkBjbGFzcyBkYXRldGltZVxuQGV4dGVuZHMgYWJzdHJhY3RpbnB1dFxuQGZpbmFsXG5Ac2luY2UgMS40LjRcbkBleGFtcGxlXG48YSBocmVmPVwiI1wiIGlkPVwibGFzdF9zZWVuXCIgZGF0YS10eXBlPVwiZGF0ZXRpbWVcIiBkYXRhLXBrPVwiMVwiIGRhdGEtdXJsPVwiL3Bvc3RcIiB0aXRsZT1cIlNlbGVjdCBkYXRlICYgdGltZVwiPjE1LzAzLzIwMTMgMTI6NDU8L2E+XG48c2NyaXB0PlxuJChmdW5jdGlvbigpe1xuICAgICQoJyNsYXN0X3NlZW4nKS5lZGl0YWJsZSh7XG4gICAgICAgIGZvcm1hdDogJ3l5eXktbW0tZGQgaGg6aWknLCAgICBcbiAgICAgICAgdmlld2Zvcm1hdDogJ2RkL21tL3l5eXkgaGg6aWknLCAgICBcbiAgICAgICAgZGF0ZXRpbWVwaWNrZXI6IHtcbiAgICAgICAgICAgICAgICB3ZWVrU3RhcnQ6IDFcbiAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59KTtcbjwvc2NyaXB0PlxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICA7XG5cbiAgICB2YXIgRGF0ZVRpbWUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2RhdGV0aW1lJywgb3B0aW9ucywgRGF0ZVRpbWUuZGVmYXVsdHMpO1xuICAgICAgICB0aGlzLmluaXRQaWNrZXIob3B0aW9ucywgRGF0ZVRpbWUuZGVmYXVsdHMpO1xuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChEYXRlVGltZSwgJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQpO1xuXG4gICAgJC5leHRlbmQoRGF0ZVRpbWUucHJvdG90eXBlLCB7XG4gICAgICAgIGluaXRQaWNrZXI6IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICAvLydmb3JtYXQnIGlzIHNldCBkaXJlY3RseSBmcm9tIHNldHRpbmdzIG9yIGRhdGEtKiBhdHRyaWJ1dGVzXG5cbiAgICAgICAgICAgIC8vYnkgZGVmYXVsdCB2aWV3Zm9ybWF0IGVxdWFscyB0byBmb3JtYXRcbiAgICAgICAgICAgIGlmKCF0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy52aWV3Zm9ybWF0ID0gdGhpcy5vcHRpb25zLmZvcm1hdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy90cnkgcGFyc2UgZGF0ZXRpbWVwaWNrZXIgY29uZmlnIGRlZmluZWQgYXMganNvbiBzdHJpbmcgaW4gZGF0YS1kYXRldGltZXBpY2tlclxuICAgICAgICAgICAgb3B0aW9ucy5kYXRldGltZXBpY2tlciA9ICQuZm4uZWRpdGFibGV1dGlscy50cnlQYXJzZUpzb24ob3B0aW9ucy5kYXRldGltZXBpY2tlciwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIC8vb3ZlcnJpZGluZyBkYXRldGltZXBpY2tlciBjb25maWcgKGFzIGJ5IGRlZmF1bHQgalF1ZXJ5IGV4dGVuZCgpIGlzIG5vdCByZWN1cnNpdmUpXG4gICAgICAgICAgICAvL3NpbmNlIDEuNCBkYXRldGltZXBpY2tlciBpbnRlcm5hbGx5IHVzZXMgdmlld2Zvcm1hdCBpbnN0ZWFkIG9mIGZvcm1hdC4gRm9ybWF0IGlzIGZvciBzdWJtaXQgb25seVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRhdGV0aW1lcGlja2VyID0gJC5leHRlbmQoe30sIGRlZmF1bHRzLmRhdGV0aW1lcGlja2VyLCBvcHRpb25zLmRhdGV0aW1lcGlja2VyLCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiB0aGlzLm9wdGlvbnMudmlld2Zvcm1hdFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vbGFuZ3VhZ2VcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlci5sYW5ndWFnZSA9IHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlci5sYW5ndWFnZSB8fCAnZW4nOyBcblxuICAgICAgICAgICAgLy9zdG9yZSBEUGdsb2JhbFxuICAgICAgICAgICAgdGhpcy5kcGcgPSAkLmZuLmRhdGV0aW1lcGlja2VyLkRQR2xvYmFsOyBcblxuICAgICAgICAgICAgLy9zdG9yZSBwYXJzZWQgZm9ybWF0c1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRGb3JtYXQgPSB0aGlzLmRwZy5wYXJzZUZvcm1hdCh0aGlzLm9wdGlvbnMuZm9ybWF0LCB0aGlzLm9wdGlvbnMuZm9ybWF0VHlwZSk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlZFZpZXdGb3JtYXQgPSB0aGlzLmRwZy5wYXJzZUZvcm1hdCh0aGlzLm9wdGlvbnMudmlld2Zvcm1hdCwgdGhpcy5vcHRpb25zLmZvcm1hdFR5cGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQuZGF0ZXRpbWVwaWNrZXIodGhpcy5vcHRpb25zLmRhdGV0aW1lcGlja2VyKTtcblxuICAgICAgICAgICAgLy9hZGp1c3QgY29udGFpbmVyIHBvc2l0aW9uIHdoZW4gdmlld01vZGUgY2hhbmdlc1xuICAgICAgICAgICAgLy9zZWUgaHR0cHM6Ly9naXRodWIuY29tL3NtYWxvdC9ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvcHVsbC84MFxuICAgICAgICAgICAgdGhpcy4kaW5wdXQub24oJ2NoYW5nZU1vZGUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKS5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICAvL3RpbWVvdXQgaGVyZSwgb3RoZXJ3aXNlIGNvbnRhaW5lciBjaGFuZ2VzIHBvc2l0aW9uIGJlZm9yZSBmb3JtIGhhcyBuZXcgc2l6ZVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgZi50cmlnZ2VySGFuZGxlcigncmVzaXplJyk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy9cImNsZWFyXCIgbGlua1xuICAgICAgICAgICAgaWYodGhpcy5vcHRpb25zLmNsZWFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY2xlYXIgPSAkKCc8YSBocmVmPVwiI1wiPjwvYT4nKS5odG1sKHRoaXMub3B0aW9ucy5jbGVhcikuY2xpY2soJC5wcm94eShmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy4kdHBsLnBhcmVudCgpLmFwcGVuZCgkKCc8ZGl2IGNsYXNzPVwiZWRpdGFibGUtY2xlYXJcIj4nKS5hcHBlbmQodGhpcy4kY2xlYXIpKTsgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHZhbHVlMmh0bWw6IGZ1bmN0aW9uKHZhbHVlLCBlbGVtZW50KSB7XG4gICAgICAgICAgICAvL2Zvcm1hdERhdGUgd29ya3Mgd2l0aCBVVENEYXRlIVxuICAgICAgICAgICAgdmFyIHRleHQgPSB2YWx1ZSA/IHRoaXMuZHBnLmZvcm1hdERhdGUodGhpcy50b1VUQyh2YWx1ZSksIHRoaXMucGFyc2VkVmlld0Zvcm1hdCwgdGhpcy5vcHRpb25zLmRhdGV0aW1lcGlja2VyLmxhbmd1YWdlLCB0aGlzLm9wdGlvbnMuZm9ybWF0VHlwZSkgOiAnJztcbiAgICAgICAgICAgIGlmKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBEYXRlVGltZS5zdXBlcmNsYXNzLnZhbHVlMmh0bWwuY2FsbCh0aGlzLCB0ZXh0LCBlbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24oaHRtbCkge1xuICAgICAgICAgICAgLy9wYXJzZURhdGUgcmV0dXJuIHV0YyBkYXRlIVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZURhdGUoaHRtbCwgdGhpcy5wYXJzZWRWaWV3Rm9ybWF0KTsgXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPyB0aGlzLmZyb21VVEModmFsdWUpIDogbnVsbDtcbiAgICAgICAgfSxcblxuICAgICAgICB2YWx1ZTJzdHI6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAvL2Zvcm1hdERhdGUgd29ya3Mgd2l0aCBVVENEYXRlIVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlID8gdGhpcy5kcGcuZm9ybWF0RGF0ZSh0aGlzLnRvVVRDKHZhbHVlKSwgdGhpcy5wYXJzZWRGb3JtYXQsIHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlci5sYW5ndWFnZSwgdGhpcy5vcHRpb25zLmZvcm1hdFR5cGUpIDogJyc7XG4gICAgICAgfSxcblxuICAgICAgIHN0cjJ2YWx1ZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgICAgIC8vcGFyc2VEYXRlIHJldHVybiB1dGMgZGF0ZSFcbiAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5wYXJzZURhdGUoc3RyLCB0aGlzLnBhcnNlZEZvcm1hdCk7XG4gICAgICAgICAgIHJldHVybiB2YWx1ZSA/IHRoaXMuZnJvbVVUQyh2YWx1ZSkgOiBudWxsO1xuICAgICAgIH0sXG5cbiAgICAgICB2YWx1ZTJzdWJtaXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlMnN0cih2YWx1ZSk7XG4gICAgICAgfSxcblxuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICBpZih2YWx1ZSkge1xuICAgICAgICAgICAgIHRoaXMuJGlucHV0LmRhdGEoJ2RhdGV0aW1lcGlja2VyJykuc2V0RGF0ZSh2YWx1ZSk7XG4gICAgICAgICAgIH1cbiAgICAgICB9LFxuXG4gICAgICAgaW5wdXQydmFsdWU6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgLy9kYXRlIG1heSBiZSBjbGVhcmVkLCBpbiB0aGF0IGNhc2UgZ2V0RGF0ZSgpIHRyaWdnZXJzIGVycm9yXG4gICAgICAgICAgIHZhciBkdCA9IHRoaXMuJGlucHV0LmRhdGEoJ2RhdGV0aW1lcGlja2VyJyk7XG4gICAgICAgICAgIHJldHVybiBkdC5kYXRlID8gZHQuZ2V0RGF0ZSgpIDogbnVsbDtcbiAgICAgICB9LFxuXG4gICAgICAgYWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgIH0sXG5cbiAgICAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy4kaW5wdXQuZGF0YSgnZGF0ZXRpbWVwaWNrZXInKS5kYXRlID0gbnVsbDtcbiAgICAgICAgICB0aGlzLiRpbnB1dC5maW5kKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuICAgICAgICAgIGlmKCF0aGlzLm9wdGlvbnMuc2hvd2J1dHRvbnMpIHtcbiAgICAgICAgICAgICB0aGlzLiRpbnB1dC5jbG9zZXN0KCdmb3JtJykuc3VibWl0KCk7IFxuICAgICAgICAgIH0gICAgICAgICAgXG4gICAgICAgfSxcblxuICAgICAgIGF1dG9zdWJtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC5vbignbW91c2V1cCcsICcubWludXRlJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICB2YXIgJGZvcm0gPSAkKHRoaXMpLmNsb3Nlc3QoJ2Zvcm0nKTtcbiAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgJGZvcm0uc3VibWl0KCk7XG4gICAgICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICAgICB9KTtcbiAgICAgICB9LFxuXG4gICAgICAgLy9jb252ZXJ0IGRhdGUgZnJvbSBsb2NhbCB0byB1dGNcbiAgICAgICB0b1VUQzogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgIHJldHVybiB2YWx1ZSA/IG5ldyBEYXRlKHZhbHVlLnZhbHVlT2YoKSAtIHZhbHVlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMCkgOiB2YWx1ZTsgIFxuICAgICAgIH0sXG5cbiAgICAgICAvL2NvbnZlcnQgZGF0ZSBmcm9tIHV0YyB0byBsb2NhbFxuICAgICAgIGZyb21VVEM6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICByZXR1cm4gdmFsdWUgPyBuZXcgRGF0ZSh2YWx1ZS52YWx1ZU9mKCkgKyB2YWx1ZS5nZXRUaW1lem9uZU9mZnNldCgpICogNjAwMDApIDogdmFsdWU7ICBcbiAgICAgICB9LFxuXG4gICAgICAgLypcbiAgICAgICAgRm9yIGluY29ycmVjdCBkYXRlIGJvb3RzdHJhcC1kYXRldGltZXBpY2tlciByZXR1cm5zIGN1cnJlbnQgZGF0ZSB0aGF0IGlzIG5vdCBzdWl0YWJsZVxuICAgICAgICBmb3IgZGF0ZXRpbWVmaWVsZC5cbiAgICAgICAgVGhpcyBmdW5jdGlvbiByZXR1cm5zIG51bGwgZm9yIGluY29ycmVjdCBkYXRlLiAgXG4gICAgICAgKi9cbiAgICAgICBwYXJzZURhdGU6IGZ1bmN0aW9uKHN0ciwgZm9ybWF0KSB7XG4gICAgICAgICAgIHZhciBkYXRlID0gbnVsbCwgZm9ybWF0dGVkQmFjaztcbiAgICAgICAgICAgaWYoc3RyKSB7XG4gICAgICAgICAgICAgICBkYXRlID0gdGhpcy5kcGcucGFyc2VEYXRlKHN0ciwgZm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXRpbWVwaWNrZXIubGFuZ3VhZ2UsIHRoaXMub3B0aW9ucy5mb3JtYXRUeXBlKTtcbiAgICAgICAgICAgICAgIGlmKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgZm9ybWF0dGVkQmFjayA9IHRoaXMuZHBnLmZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0LCB0aGlzLm9wdGlvbnMuZGF0ZXRpbWVwaWNrZXIubGFuZ3VhZ2UsIHRoaXMub3B0aW9ucy5mb3JtYXRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICBpZihzdHIgIT09IGZvcm1hdHRlZEJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgfVxuICAgICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIERhdGVUaW1lLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5hYnN0cmFjdGlucHV0LmRlZmF1bHRzLCB7XG4gICAgICAgIC8qKlxuICAgICAgICBAcHJvcGVydHkgdHBsIFxuICAgICAgICBAZGVmYXVsdCA8ZGl2PjwvZGl2PlxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgdHBsOic8ZGl2IGNsYXNzPVwiZWRpdGFibGUtZGF0ZSB3ZWxsXCI+PC9kaXY+JyxcbiAgICAgICAgLyoqXG4gICAgICAgIEBwcm9wZXJ0eSBpbnB1dGNsYXNzIFxuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICBpbnB1dGNsYXNzOiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgRm9ybWF0IHVzZWQgZm9yIHNlbmRpbmcgdmFsdWUgdG8gc2VydmVyLiBBbHNvIGFwcGxpZWQgd2hlbiBjb252ZXJ0aW5nIGRhdGUgZnJvbSA8Y29kZT5kYXRhLXZhbHVlPC9jb2RlPiBhdHRyaWJ1dGUuPGJyPlxuICAgICAgICBQb3NzaWJsZSB0b2tlbnMgYXJlOiA8Y29kZT5kLCBkZCwgbSwgbW0sIHl5LCB5eXl5LCBoLCBpPC9jb2RlPiAgXG4gICAgICAgIFxuICAgICAgICBAcHJvcGVydHkgZm9ybWF0IFxuICAgICAgICBAdHlwZSBzdHJpbmdcbiAgICAgICAgQGRlZmF1bHQgeXl5eS1tbS1kZCBoaDppaVxuICAgICAgICAqKi8gICAgICAgICBcbiAgICAgICAgZm9ybWF0Oid5eXl5LW1tLWRkIGhoOmlpJyxcbiAgICAgICAgZm9ybWF0VHlwZTonc3RhbmRhcmQnLFxuICAgICAgICAvKipcbiAgICAgICAgRm9ybWF0IHVzZWQgZm9yIGRpc3BsYXlpbmcgZGF0ZS4gQWxzbyBhcHBsaWVkIHdoZW4gY29udmVydGluZyBkYXRlIGZyb20gZWxlbWVudCdzIHRleHQgb24gaW5pdC4gICBcbiAgICAgICAgSWYgbm90IHNwZWNpZmllZCBlcXVhbHMgdG8gPGNvZGU+Zm9ybWF0PC9jb2RlPlxuICAgICAgICBcbiAgICAgICAgQHByb3BlcnR5IHZpZXdmb3JtYXQgXG4gICAgICAgIEB0eXBlIHN0cmluZ1xuICAgICAgICBAZGVmYXVsdCBudWxsXG4gICAgICAgICoqL1xuICAgICAgICB2aWV3Zm9ybWF0OiBudWxsLFxuICAgICAgICAvKipcbiAgICAgICAgQ29uZmlndXJhdGlvbiBvZiBkYXRldGltZXBpY2tlci5cbiAgICAgICAgRnVsbCBsaXN0IG9mIG9wdGlvbnM6IGh0dHBzOi8vZ2l0aHViLmNvbS9zbWFsb3QvYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyXG5cbiAgICAgICAgQHByb3BlcnR5IGRhdGV0aW1lcGlja2VyIFxuICAgICAgICBAdHlwZSBvYmplY3RcbiAgICAgICAgQGRlZmF1bHQgeyB9XG4gICAgICAgICoqL1xuICAgICAgICBkYXRldGltZXBpY2tlcjp7XG4gICAgICAgICAgICB0b2RheUhpZ2hsaWdodDogZmFsc2UsXG4gICAgICAgICAgICBhdXRvY2xvc2U6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICBUZXh0IHNob3duIGFzIGNsZWFyIGRhdGUgYnV0dG9uLiBcbiAgICAgICAgSWYgPGNvZGU+ZmFsc2U8L2NvZGU+IGNsZWFyIGJ1dHRvbiB3aWxsIG5vdCBiZSByZW5kZXJlZC5cblxuICAgICAgICBAcHJvcGVydHkgY2xlYXIgXG4gICAgICAgIEB0eXBlIGJvb2xlYW58c3RyaW5nXG4gICAgICAgIEBkZWZhdWx0ICd4IGNsZWFyJ1xuICAgICAgICAqKi9cbiAgICAgICAgY2xlYXI6ICcmdGltZXM7IGNsZWFyJ1xuICAgIH0pO1xuXG4gICAgJC5mbi5lZGl0YWJsZXR5cGVzLmRhdGV0aW1lID0gRGF0ZVRpbWU7XG5cbn0od2luZG93LmpRdWVyeSkpO1xuLyoqXG5Cb290c3RyYXAgZGF0ZXRpbWVmaWVsZCBpbnB1dCAtIGRhdGV0aW1lIGlucHV0IGZvciBpbmxpbmUgbW9kZS5cblNob3dzIG5vcm1hbCA8aW5wdXQgdHlwZT1cInRleHRcIj4gYW5kIGJpbmRzIHBvcHVwIGRhdGV0aW1lcGlja2VyLiAgXG5BdXRvbWF0aWNhbGx5IHNob3duIGluIGlubGluZSBtb2RlLlxuXG5AY2xhc3MgZGF0ZXRpbWVmaWVsZFxuQGV4dGVuZHMgZGF0ZXRpbWVcblxuKiovXG4oZnVuY3Rpb24gKCQpIHtcbiAgICA7XG4gICAgXG4gICAgdmFyIERhdGVUaW1lRmllbGQgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXQoJ2RhdGV0aW1lZmllbGQnLCBvcHRpb25zLCBEYXRlVGltZUZpZWxkLmRlZmF1bHRzKTtcbiAgICAgICAgdGhpcy5pbml0UGlja2VyKG9wdGlvbnMsIERhdGVUaW1lRmllbGQuZGVmYXVsdHMpO1xuICAgIH07XG5cbiAgICAkLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChEYXRlVGltZUZpZWxkLCAkLmZuLmVkaXRhYmxldHlwZXMuZGF0ZXRpbWUpO1xuICAgIFxuICAgICQuZXh0ZW5kKERhdGVUaW1lRmllbGQucHJvdG90eXBlLCB7XG4gICAgICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy4kaW5wdXQgPSB0aGlzLiR0cGwuZmluZCgnaW5wdXQnKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q2xhc3MoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cigncGxhY2Vob2xkZXInKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy4kdHBsLmRhdGV0aW1lcGlja2VyKHRoaXMub3B0aW9ucy5kYXRldGltZXBpY2tlcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vbmVlZCB0byBkaXNhYmxlIG9yaWdpbmFsIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgICAgICB0aGlzLiRpbnB1dC5vZmYoJ2ZvY3VzIGtleWRvd24nKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy91cGRhdGUgdmFsdWUgb2YgZGF0ZXBpY2tlclxuICAgICAgICAgICAgdGhpcy4kaW5wdXQua2V5dXAoJC5wcm94eShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgdGhpcy4kdHBsLnJlbW92ZURhdGEoJ2RhdGUnKTtcbiAgICAgICAgICAgICAgIHRoaXMuJHRwbC5kYXRldGltZXBpY2tlcigndXBkYXRlJyk7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgfSwgICBcbiAgICAgIFxuICAgICAgIHZhbHVlMmlucHV0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICB0aGlzLiRpbnB1dC52YWwodGhpcy52YWx1ZTJodG1sKHZhbHVlKSk7XG4gICAgICAgICAgIHRoaXMuJHRwbC5kYXRldGltZXBpY2tlcigndXBkYXRlJyk7XG4gICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgaW5wdXQydmFsdWU6IGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgcmV0dXJuIHRoaXMuaHRtbDJ2YWx1ZSh0aGlzLiRpbnB1dC52YWwoKSk7XG4gICAgICAgfSwgICAgICAgICAgICAgIFxuICAgICAgICBcbiAgICAgICBhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICQuZm4uZWRpdGFibGV0eXBlcy50ZXh0LnByb3RvdHlwZS5hY3RpdmF0ZS5jYWxsKHRoaXMpO1xuICAgICAgIH0sXG4gICAgICAgXG4gICAgICAgYXV0b3N1Ym1pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAvL3Jlc2V0IGF1dG9zdWJtaXQgdG8gZW1wdHkgIFxuICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBEYXRlVGltZUZpZWxkLmRlZmF1bHRzID0gJC5leHRlbmQoe30sICQuZm4uZWRpdGFibGV0eXBlcy5kYXRldGltZS5kZWZhdWx0cywge1xuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IHRwbCBcbiAgICAgICAgKiovICAgICAgICAgXG4gICAgICAgIHRwbDonPGRpdiBjbGFzcz1cImlucHV0LWFwcGVuZCBkYXRlXCI+PGlucHV0IHR5cGU9XCJ0ZXh0XCIvPjxzcGFuIGNsYXNzPVwiYWRkLW9uXCI+PGkgY2xhc3M9XCJpY29uLXRoXCI+PC9pPjwvc3Bhbj48L2Rpdj4nLFxuICAgICAgICAvKipcbiAgICAgICAgQHByb3BlcnR5IGlucHV0Y2xhc3MgXG4gICAgICAgIEBkZWZhdWx0ICdpbnB1dC1tZWRpdW0nXG4gICAgICAgICoqLyAgICAgICAgIFxuICAgICAgICBpbnB1dGNsYXNzOiAnaW5wdXQtbWVkaXVtJyxcbiAgICAgICAgXG4gICAgICAgIC8qIGRhdGV0aW1lcGlja2VyIGNvbmZpZyAqL1xuICAgICAgICBkYXRldGltZXBpY2tlcjp7XG4gICAgICAgICAgICB0b2RheUhpZ2hsaWdodDogZmFsc2UsXG4gICAgICAgICAgICBhdXRvY2xvc2U6IHRydWVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgICQuZm4uZWRpdGFibGV0eXBlcy5kYXRldGltZWZpZWxkID0gRGF0ZVRpbWVGaWVsZDtcblxufSh3aW5kb3cualF1ZXJ5KSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VkaXRhYmxlL2pzL2Jvb3RzdHJhcC1lZGl0YWJsZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n");

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Editable_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Editable_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__Editable_vue__);\n\n\nVue.component('editable', __WEBPACK_IMPORTED_MODULE_0__Editable_vue___default.a);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5qcz8zNDc5Il0sIm5hbWVzIjpbIlZ1ZSIsImNvbXBvbmVudCJdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7O0FBRUFBLElBQUlDLFNBQUosQ0FBYyxVQUFkLEVBQTBCLHFEQUExQiIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IEVkaXRhYmxlIGZyb20gJy4vRWRpdGFibGUudnVlJ1xuXG5WdWUuY29tcG9uZW50KCdlZGl0YWJsZScsIEVkaXRhYmxlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9tYWluLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3\n");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(5)(undefined);\n// imports\n\n\n// module\nexports.push([module.i, \"/*! X-editable - v1.5.1 \\n* In-place editing with Twitter Bootstrap, jQuery UI or pure jQuery\\n* http://github.com/vitalets/x-editable\\n* Copyright (c) 2013 Vitaliy Potapov; Licensed MIT */\\n.editableform {\\n    margin-bottom: 0; /* overwrites bootstrap margin */\\n}\\n\\n.editableform .control-group {\\n    margin-bottom: 0; /* overwrites bootstrap margin */\\n    white-space: nowrap; /* prevent wrapping buttons on new line */\\n    line-height: 20px; /* overwriting bootstrap line-height. See #133 */\\n}\\n\\n/* \\n  BS3 width:1005 for inputs breaks editable form in popup \\n  See: https://github.com/vitalets/x-editable/issues/393\\n*/\\n.editableform .form-control {\\n    width: auto;\\n}\\n\\n.editable-buttons {\\n   display: inline-block; /* should be inline to take effect of parent's white-space: nowrap */\\n   vertical-align: top;\\n   margin-left: 7px;\\n   /* inline-block emulation for IE7*/\\n   zoom: 1; \\n   *display: inline;\\n}\\n\\n.editable-buttons.editable-buttons-bottom {\\n   display: block; \\n   margin-top: 7px;\\n   margin-left: 0;\\n}\\n\\n.editable-input {\\n    vertical-align: top; \\n    display: inline-block; /* should be inline to take effect of parent's white-space: nowrap */\\n    width: auto; /* bootstrap-responsive has width: 100% that breakes layout */\\n    white-space: normal; /* reset white-space decalred in parent*/\\n   /* display-inline emulation for IE7*/\\n   zoom: 1; \\n   *display: inline;   \\n}\\n\\n.editable-buttons .editable-cancel {\\n   margin-left: 7px; \\n}\\n\\n/*for jquery-ui buttons need set height to look more pretty*/\\n.editable-buttons button.ui-button-icon-only {\\n   height: 24px; \\n   width: 30px;\\n}\\n\\n.editableform-loading {\\n    background: url(\" + __webpack_require__(7) + \") center center no-repeat;  \\n    height: 25px;\\n    width: auto; \\n    min-width: 25px; \\n}\\n\\n.editable-inline .editableform-loading {\\n    background-position: left 5px;      \\n}\\n\\n .editable-error-block {\\n    max-width: 300px;\\n    margin: 5px 0 0 0;\\n    width: auto;\\n    white-space: normal;\\n}\\n\\n/*add padding for jquery ui*/\\n.editable-error-block.ui-state-error {\\n    padding: 3px;  \\n}  \\n\\n.editable-error {\\n   color: red;  \\n}\\n\\n/* ---- For specific types ---- */\\n\\n.editableform .editable-date {\\n    padding: 0; \\n    margin: 0;\\n    float: left;\\n}\\n\\n/* move datepicker icon to center of add-on button. See https://github.com/vitalets/x-editable/issues/183 */\\n.editable-inline .add-on .icon-th {\\n   margin-top: 3px;\\n   margin-left: 1px; \\n}\\n\\n\\n/* checklist vertical alignment */\\n.editable-checklist label input[type=\\\"checkbox\\\"], \\n.editable-checklist label span {\\n    vertical-align: middle;\\n    margin: 0;\\n}\\n\\n.editable-checklist label {\\n    white-space: nowrap; \\n}\\n\\n/* set exact width of textarea to fit buttons toolbar */\\n.editable-wysihtml5 {\\n    width: 566px; \\n    height: 250px; \\n}\\n\\n/* clear button shown as link in date inputs */\\n.editable-clear {\\n   clear: both;\\n   font-size: 0.9em;\\n   text-decoration: none;\\n   text-align: right;\\n}\\n\\n/* IOS-style clear button for text inputs */\\n.editable-clear-x {\\n   background: url(\" + __webpack_require__(6) + \") center center no-repeat;\\n   display: block;\\n   width: 13px;    \\n   height: 13px;\\n   position: absolute;\\n   opacity: 0.6;\\n   z-index: 100;\\n   \\n   top: 50%;\\n   right: 6px;\\n   margin-top: -6px;\\n   \\n}\\n\\n.editable-clear-x:hover {\\n   opacity: 1;\\n}\\n\\n.editable-pre-wrapped {\\n   white-space: pre-wrap;\\n}\\n.editable-container.editable-popup {\\n    max-width: none !important; /* without this rule poshytip/tooltip does not stretch */\\n}  \\n\\n.editable-container.popover {\\n    width: auto; /* without this rule popover does not stretch */\\n}\\n\\n.editable-container.editable-inline {\\n    display: inline-block; \\n    vertical-align: middle;\\n    width: auto;\\n    /* inline-block emulation for IE7*/\\n    zoom: 1; \\n    *display: inline;    \\n}\\n\\n.editable-container.ui-widget {\\n   font-size: inherit;  /* jqueryui widget font 1.1em too big, overwrite it */\\n   z-index: 9990; /* should be less than select2 dropdown z-index to close dropdown first when click */\\n}\\n.editable-click, \\na.editable-click, \\na.editable-click:hover {\\n    text-decoration: none;\\n    border-bottom: dashed 1px #0088cc;\\n}\\n\\n.editable-click.editable-disabled, \\na.editable-click.editable-disabled, \\na.editable-click.editable-disabled:hover {\\n   color: #585858;  \\n   cursor: default;\\n   border-bottom: none;\\n}\\n\\n.editable-empty, .editable-empty:hover, .editable-empty:focus{\\n  font-style: italic; \\n  color: #DD1144;  \\n  /* border-bottom: none; */\\n  text-decoration: none;\\n}\\n\\n.editable-unsaved {\\n  font-weight: bold; \\n}\\n\\n.editable-unsaved:after {\\n/*    content: '*'*/\\n}\\n\\n.editable-bg-transition {\\n  -webkit-transition: background-color 1400ms ease-out;\\n  -moz-transition: background-color 1400ms ease-out;\\n  -o-transition: background-color 1400ms ease-out;\\n  -ms-transition: background-color 1400ms ease-out;\\n  transition: background-color 1400ms ease-out;  \\n}\\n\\n/*see https://github.com/vitalets/x-editable/issues/139 */\\n.form-horizontal .editable\\n{ \\n    padding-top: 5px;\\n    display:inline-block;\\n}\\n\\n\\n/*!\\n * Datepicker for Bootstrap\\n *\\n * Copyright 2012 Stefan Petre\\n * Improvements by Andrew Rowls\\n * Licensed under the Apache License v2.0\\n * http://www.apache.org/licenses/LICENSE-2.0\\n *\\n */\\n.datepicker {\\n  padding: 4px;\\n  -webkit-border-radius: 4px;\\n  -moz-border-radius: 4px;\\n  border-radius: 4px;\\n  direction: ltr;\\n  /*.dow {\\n\\t\\tborder-top: 1px solid #ddd !important;\\n\\t}*/\\n\\n}\\n.datepicker-inline {\\n  width: 220px;\\n}\\n.datepicker.datepicker-rtl {\\n  direction: rtl;\\n}\\n.datepicker.datepicker-rtl table tr td span {\\n  float: right;\\n}\\n.datepicker-dropdown {\\n  top: 0;\\n  left: 0;\\n}\\n.datepicker-dropdown:before {\\n  content: '';\\n  display: inline-block;\\n  border-left: 7px solid transparent;\\n  border-right: 7px solid transparent;\\n  border-bottom: 7px solid #ccc;\\n  border-bottom-color: rgba(0, 0, 0, 0.2);\\n  position: absolute;\\n  top: -7px;\\n  left: 6px;\\n}\\n.datepicker-dropdown:after {\\n  content: '';\\n  display: inline-block;\\n  border-left: 6px solid transparent;\\n  border-right: 6px solid transparent;\\n  border-bottom: 6px solid #ffffff;\\n  position: absolute;\\n  top: -6px;\\n  left: 7px;\\n}\\n.datepicker > div {\\n  display: none;\\n}\\n.datepicker.days div.datepicker-days {\\n  display: block;\\n}\\n.datepicker.months div.datepicker-months {\\n  display: block;\\n}\\n.datepicker.years div.datepicker-years {\\n  display: block;\\n}\\n.datepicker table {\\n  margin: 0;\\n}\\n.datepicker td,\\n.datepicker th {\\n  text-align: center;\\n  width: 20px;\\n  height: 20px;\\n  -webkit-border-radius: 4px;\\n  -moz-border-radius: 4px;\\n  border-radius: 4px;\\n  border: none;\\n}\\n.table-striped .datepicker table tr td,\\n.table-striped .datepicker table tr th {\\n  background-color: transparent;\\n}\\n.datepicker table tr td.day:hover {\\n  background: #eeeeee;\\n  cursor: pointer;\\n}\\n.datepicker table tr td.old,\\n.datepicker table tr td.new {\\n  color: #999999;\\n}\\n.datepicker table tr td.disabled,\\n.datepicker table tr td.disabled:hover {\\n  background: none;\\n  color: #999999;\\n  cursor: default;\\n}\\n.datepicker table tr td.today,\\n.datepicker table tr td.today:hover,\\n.datepicker table tr td.today.disabled,\\n.datepicker table tr td.today.disabled:hover {\\n  background-color: #fde19a;\\n  background-image: -moz-linear-gradient(top, #fdd49a, #fdf59a);\\n  background-image: -ms-linear-gradient(top, #fdd49a, #fdf59a);\\n  background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#fdd49a), to(#fdf59a));\\n  background-image: -webkit-linear-gradient(top, #fdd49a, #fdf59a);\\n  background-image: -o-linear-gradient(top, #fdd49a, #fdf59a);\\n  background-image: linear-gradient(top, #fdd49a, #fdf59a);\\n  background-repeat: repeat-x;\\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#fdd49a', endColorstr='#fdf59a', GradientType=0);\\n  border-color: #fdf59a #fdf59a #fbed50;\\n  border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);\\n  filter: progid:DXImageTransform.Microsoft.gradient(enabled=false);\\n  color: #000;\\n}\\n.datepicker table tr td.today:hover,\\n.datepicker table tr td.today:hover:hover,\\n.datepicker table tr td.today.disabled:hover,\\n.datepicker table tr td.today.disabled:hover:hover,\\n.datepicker table tr td.today:active,\\n.datepicker table tr td.today:hover:active,\\n.datepicker table tr td.today.disabled:active,\\n.datepicker table tr td.today.disabled:hover:active,\\n.datepicker table tr td.today.active,\\n.datepicker table tr td.today:hover.active,\\n.datepicker table tr td.today.disabled.active,\\n.datepicker table tr td.today.disabled:hover.active,\\n.datepicker table tr td.today.disabled,\\n.datepicker table tr td.today:hover.disabled,\\n.datepicker table tr td.today.disabled.disabled,\\n.datepicker table tr td.today.disabled:hover.disabled,\\n.datepicker table tr td.today[disabled],\\n.datepicker table tr td.today:hover[disabled],\\n.datepicker table tr td.today.disabled[disabled],\\n.datepicker table tr td.today.disabled:hover[disabled] {\\n  background-color: #fdf59a;\\n}\\n.datepicker table tr td.today:active,\\n.datepicker table tr td.today:hover:active,\\n.datepicker table tr td.today.disabled:active,\\n.datepicker table tr td.today.disabled:hover:active,\\n.datepicker table tr td.today.active,\\n.datepicker table tr td.today:hover.active,\\n.datepicker table tr td.today.disabled.active,\\n.datepicker table tr td.today.disabled:hover.active {\\n  background-color: #fbf069 \\\\9;\\n}\\n.datepicker table tr td.today:hover:hover {\\n  color: #000;\\n}\\n.datepicker table tr td.today.active:hover {\\n  color: #fff;\\n}\\n.datepicker table tr td.range,\\n.datepicker table tr td.range:hover,\\n.datepicker table tr td.range.disabled,\\n.datepicker table tr td.range.disabled:hover {\\n  background: #eeeeee;\\n  -webkit-border-radius: 0;\\n  -moz-border-radius: 0;\\n  border-radius: 0;\\n}\\n.datepicker table tr td.range.today,\\n.datepicker table tr td.range.today:hover,\\n.datepicker table tr td.range.today.disabled,\\n.datepicker table tr td.range.today.disabled:hover {\\n  background-color: #f3d17a;\\n  background-image: -moz-linear-gradient(top, #f3c17a, #f3e97a);\\n  background-image: -ms-linear-gradient(top, #f3c17a, #f3e97a);\\n  background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#f3c17a), to(#f3e97a));\\n  background-image: -webkit-linear-gradient(top, #f3c17a, #f3e97a);\\n  background-image: -o-linear-gradient(top, #f3c17a, #f3e97a);\\n  background-image: linear-gradient(top, #f3c17a, #f3e97a);\\n  background-repeat: repeat-x;\\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#f3c17a', endColorstr='#f3e97a', GradientType=0);\\n  border-color: #f3e97a #f3e97a #edde34;\\n  border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);\\n  filter: progid:DXImageTransform.Microsoft.gradient(enabled=false);\\n  -webkit-border-radius: 0;\\n  -moz-border-radius: 0;\\n  border-radius: 0;\\n}\\n.datepicker table tr td.range.today:hover,\\n.datepicker table tr td.range.today:hover:hover,\\n.datepicker table tr td.range.today.disabled:hover,\\n.datepicker table tr td.range.today.disabled:hover:hover,\\n.datepicker table tr td.range.today:active,\\n.datepicker table tr td.range.today:hover:active,\\n.datepicker table tr td.range.today.disabled:active,\\n.datepicker table tr td.range.today.disabled:hover:active,\\n.datepicker table tr td.range.today.active,\\n.datepicker table tr td.range.today:hover.active,\\n.datepicker table tr td.range.today.disabled.active,\\n.datepicker table tr td.range.today.disabled:hover.active,\\n.datepicker table tr td.range.today.disabled,\\n.datepicker table tr td.range.today:hover.disabled,\\n.datepicker table tr td.range.today.disabled.disabled,\\n.datepicker table tr td.range.today.disabled:hover.disabled,\\n.datepicker table tr td.range.today[disabled],\\n.datepicker table tr td.range.today:hover[disabled],\\n.datepicker table tr td.range.today.disabled[disabled],\\n.datepicker table tr td.range.today.disabled:hover[disabled] {\\n  background-color: #f3e97a;\\n}\\n.datepicker table tr td.range.today:active,\\n.datepicker table tr td.range.today:hover:active,\\n.datepicker table tr td.range.today.disabled:active,\\n.datepicker table tr td.range.today.disabled:hover:active,\\n.datepicker table tr td.range.today.active,\\n.datepicker table tr td.range.today:hover.active,\\n.datepicker table tr td.range.today.disabled.active,\\n.datepicker table tr td.range.today.disabled:hover.active {\\n  background-color: #efe24b \\\\9;\\n}\\n.datepicker table tr td.selected,\\n.datepicker table tr td.selected:hover,\\n.datepicker table tr td.selected.disabled,\\n.datepicker table tr td.selected.disabled:hover {\\n  background-color: #9e9e9e;\\n  background-image: -moz-linear-gradient(top, #b3b3b3, #808080);\\n  background-image: -ms-linear-gradient(top, #b3b3b3, #808080);\\n  background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#b3b3b3), to(#808080));\\n  background-image: -webkit-linear-gradient(top, #b3b3b3, #808080);\\n  background-image: -o-linear-gradient(top, #b3b3b3, #808080);\\n  background-image: linear-gradient(top, #b3b3b3, #808080);\\n  background-repeat: repeat-x;\\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#b3b3b3', endColorstr='#808080', GradientType=0);\\n  border-color: #808080 #808080 #595959;\\n  border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);\\n  filter: progid:DXImageTransform.Microsoft.gradient(enabled=false);\\n  color: #fff;\\n  text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);\\n}\\n.datepicker table tr td.selected:hover,\\n.datepicker table tr td.selected:hover:hover,\\n.datepicker table tr td.selected.disabled:hover,\\n.datepicker table tr td.selected.disabled:hover:hover,\\n.datepicker table tr td.selected:active,\\n.datepicker table tr td.selected:hover:active,\\n.datepicker table tr td.selected.disabled:active,\\n.datepicker table tr td.selected.disabled:hover:active,\\n.datepicker table tr td.selected.active,\\n.datepicker table tr td.selected:hover.active,\\n.datepicker table tr td.selected.disabled.active,\\n.datepicker table tr td.selected.disabled:hover.active,\\n.datepicker table tr td.selected.disabled,\\n.datepicker table tr td.selected:hover.disabled,\\n.datepicker table tr td.selected.disabled.disabled,\\n.datepicker table tr td.selected.disabled:hover.disabled,\\n.datepicker table tr td.selected[disabled],\\n.datepicker table tr td.selected:hover[disabled],\\n.datepicker table tr td.selected.disabled[disabled],\\n.datepicker table tr td.selected.disabled:hover[disabled] {\\n  background-color: #808080;\\n}\\n.datepicker table tr td.selected:active,\\n.datepicker table tr td.selected:hover:active,\\n.datepicker table tr td.selected.disabled:active,\\n.datepicker table tr td.selected.disabled:hover:active,\\n.datepicker table tr td.selected.active,\\n.datepicker table tr td.selected:hover.active,\\n.datepicker table tr td.selected.disabled.active,\\n.datepicker table tr td.selected.disabled:hover.active {\\n  background-color: #666666 \\\\9;\\n}\\n.datepicker table tr td.active,\\n.datepicker table tr td.active:hover,\\n.datepicker table tr td.active.disabled,\\n.datepicker table tr td.active.disabled:hover {\\n  background-color: #006dcc;\\n  background-image: -moz-linear-gradient(top, #0088cc, #0044cc);\\n  background-image: -ms-linear-gradient(top, #0088cc, #0044cc);\\n  background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#0088cc), to(#0044cc));\\n  background-image: -webkit-linear-gradient(top, #0088cc, #0044cc);\\n  background-image: -o-linear-gradient(top, #0088cc, #0044cc);\\n  background-image: linear-gradient(top, #0088cc, #0044cc);\\n  background-repeat: repeat-x;\\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#0088cc', endColorstr='#0044cc', GradientType=0);\\n  border-color: #0044cc #0044cc #002a80;\\n  border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);\\n  filter: progid:DXImageTransform.Microsoft.gradient(enabled=false);\\n  color: #fff;\\n  text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);\\n}\\n.datepicker table tr td.active:hover,\\n.datepicker table tr td.active:hover:hover,\\n.datepicker table tr td.active.disabled:hover,\\n.datepicker table tr td.active.disabled:hover:hover,\\n.datepicker table tr td.active:active,\\n.datepicker table tr td.active:hover:active,\\n.datepicker table tr td.active.disabled:active,\\n.datepicker table tr td.active.disabled:hover:active,\\n.datepicker table tr td.active.active,\\n.datepicker table tr td.active:hover.active,\\n.datepicker table tr td.active.disabled.active,\\n.datepicker table tr td.active.disabled:hover.active,\\n.datepicker table tr td.active.disabled,\\n.datepicker table tr td.active:hover.disabled,\\n.datepicker table tr td.active.disabled.disabled,\\n.datepicker table tr td.active.disabled:hover.disabled,\\n.datepicker table tr td.active[disabled],\\n.datepicker table tr td.active:hover[disabled],\\n.datepicker table tr td.active.disabled[disabled],\\n.datepicker table tr td.active.disabled:hover[disabled] {\\n  background-color: #0044cc;\\n}\\n.datepicker table tr td.active:active,\\n.datepicker table tr td.active:hover:active,\\n.datepicker table tr td.active.disabled:active,\\n.datepicker table tr td.active.disabled:hover:active,\\n.datepicker table tr td.active.active,\\n.datepicker table tr td.active:hover.active,\\n.datepicker table tr td.active.disabled.active,\\n.datepicker table tr td.active.disabled:hover.active {\\n  background-color: #003399 \\\\9;\\n}\\n.datepicker table tr td span {\\n  display: block;\\n  width: 23%;\\n  height: 54px;\\n  line-height: 54px;\\n  float: left;\\n  margin: 1%;\\n  cursor: pointer;\\n  -webkit-border-radius: 4px;\\n  -moz-border-radius: 4px;\\n  border-radius: 4px;\\n}\\n.datepicker table tr td span:hover {\\n  background: #eeeeee;\\n}\\n.datepicker table tr td span.disabled,\\n.datepicker table tr td span.disabled:hover {\\n  background: none;\\n  color: #999999;\\n  cursor: default;\\n}\\n.datepicker table tr td span.active,\\n.datepicker table tr td span.active:hover,\\n.datepicker table tr td span.active.disabled,\\n.datepicker table tr td span.active.disabled:hover {\\n  background-color: #006dcc;\\n  background-image: -moz-linear-gradient(top, #0088cc, #0044cc);\\n  background-image: -ms-linear-gradient(top, #0088cc, #0044cc);\\n  background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#0088cc), to(#0044cc));\\n  background-image: -webkit-linear-gradient(top, #0088cc, #0044cc);\\n  background-image: -o-linear-gradient(top, #0088cc, #0044cc);\\n  background-image: linear-gradient(top, #0088cc, #0044cc);\\n  background-repeat: repeat-x;\\n  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr='#0088cc', endColorstr='#0044cc', GradientType=0);\\n  border-color: #0044cc #0044cc #002a80;\\n  border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);\\n  filter: progid:DXImageTransform.Microsoft.gradient(enabled=false);\\n  color: #fff;\\n  text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);\\n}\\n.datepicker table tr td span.active:hover,\\n.datepicker table tr td span.active:hover:hover,\\n.datepicker table tr td span.active.disabled:hover,\\n.datepicker table tr td span.active.disabled:hover:hover,\\n.datepicker table tr td span.active:active,\\n.datepicker table tr td span.active:hover:active,\\n.datepicker table tr td span.active.disabled:active,\\n.datepicker table tr td span.active.disabled:hover:active,\\n.datepicker table tr td span.active.active,\\n.datepicker table tr td span.active:hover.active,\\n.datepicker table tr td span.active.disabled.active,\\n.datepicker table tr td span.active.disabled:hover.active,\\n.datepicker table tr td span.active.disabled,\\n.datepicker table tr td span.active:hover.disabled,\\n.datepicker table tr td span.active.disabled.disabled,\\n.datepicker table tr td span.active.disabled:hover.disabled,\\n.datepicker table tr td span.active[disabled],\\n.datepicker table tr td span.active:hover[disabled],\\n.datepicker table tr td span.active.disabled[disabled],\\n.datepicker table tr td span.active.disabled:hover[disabled] {\\n  background-color: #0044cc;\\n}\\n.datepicker table tr td span.active:active,\\n.datepicker table tr td span.active:hover:active,\\n.datepicker table tr td span.active.disabled:active,\\n.datepicker table tr td span.active.disabled:hover:active,\\n.datepicker table tr td span.active.active,\\n.datepicker table tr td span.active:hover.active,\\n.datepicker table tr td span.active.disabled.active,\\n.datepicker table tr td span.active.disabled:hover.active {\\n  background-color: #003399 \\\\9;\\n}\\n.datepicker table tr td span.old,\\n.datepicker table tr td span.new {\\n  color: #999999;\\n}\\n.datepicker th.datepicker-switch {\\n  width: 145px;\\n}\\n.datepicker thead tr:first-child th,\\n.datepicker tfoot tr th {\\n  cursor: pointer;\\n}\\n.datepicker thead tr:first-child th:hover,\\n.datepicker tfoot tr th:hover {\\n  background: #eeeeee;\\n}\\n.datepicker .cw {\\n  font-size: 10px;\\n  width: 12px;\\n  padding: 0 2px 0 5px;\\n  vertical-align: middle;\\n}\\n.datepicker thead tr:first-child th.cw {\\n  cursor: default;\\n  background-color: transparent;\\n}\\n.input-append.date .add-on i,\\n.input-prepend.date .add-on i {\\n  display: block;\\n  cursor: pointer;\\n  width: 16px;\\n  height: 16px;\\n}\\n.input-daterange input {\\n  text-align: center;\\n}\\n.input-daterange input:first-child {\\n  -webkit-border-radius: 3px 0 0 3px;\\n  -moz-border-radius: 3px 0 0 3px;\\n  border-radius: 3px 0 0 3px;\\n}\\n.input-daterange input:last-child {\\n  -webkit-border-radius: 0 3px 3px 0;\\n  -moz-border-radius: 0 3px 3px 0;\\n  border-radius: 0 3px 3px 0;\\n}\\n.input-daterange .add-on {\\n  display: inline-block;\\n  width: auto;\\n  min-width: 16px;\\n  height: 18px;\\n  padding: 4px 5px;\\n  font-weight: normal;\\n  line-height: 18px;\\n  text-align: center;\\n  text-shadow: 0 1px 0 #ffffff;\\n  vertical-align: middle;\\n  background-color: #eeeeee;\\n  border: 1px solid #ccc;\\n  margin-left: -5px;\\n  margin-right: -5px;\\n}\\n\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC1lZGl0YWJsZS5jc3M/YmMwMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7QUFHQTtBQUNBLHNNQUF1TSxpQ0FBaUMsdUJBQXVCLHFDQUFxQyxrQ0FBa0MsdUJBQXVCLDREQUE0RCxtRUFBbUUscURBQXFELGdLQUFnSyxrQkFBa0IsR0FBRyx1QkFBdUIsMkJBQTJCLCtGQUErRixzQkFBc0IscURBQXFELHVCQUF1QixHQUFHLCtDQUErQyxvQkFBb0Isc0JBQXNCLG9CQUFvQixHQUFHLHFCQUFxQiwwQkFBMEIsNkJBQTZCLHdGQUF3Rix5RkFBeUYsaUdBQWlHLHVCQUF1QixNQUFNLHdDQUF3QyxzQkFBc0IsSUFBSSxpSEFBaUgsa0JBQWtCLGtCQUFrQixHQUFHLDJCQUEyQiw4RUFBcUYscUJBQXFCLGtCQUFrQix1QkFBdUIsSUFBSSw0Q0FBNEMsb0NBQW9DLFNBQVMsNEJBQTRCLHVCQUF1Qix3QkFBd0Isa0JBQWtCLDBCQUEwQixHQUFHLHlFQUF5RSxtQkFBbUIsS0FBSyx1QkFBdUIsZ0JBQWdCLEtBQUssd0VBQXdFLGlCQUFpQixpQkFBaUIsa0JBQWtCLEdBQUcscUpBQXFKLHFCQUFxQixzQkFBc0IsSUFBSSxnSUFBZ0ksNkJBQTZCLGdCQUFnQixHQUFHLCtCQUErQiwwQkFBMEIsSUFBSSxtRkFBbUYsbUJBQW1CLHFCQUFxQixJQUFJLHNFQUFzRSxpQkFBaUIsc0JBQXNCLDJCQUEyQix1QkFBdUIsR0FBRyxxRUFBcUUsNkVBQWtGLG9CQUFvQixpQkFBaUIsc0JBQXNCLHdCQUF3QixrQkFBa0Isa0JBQWtCLG1CQUFtQixnQkFBZ0Isc0JBQXNCLFFBQVEsNkJBQTZCLGdCQUFnQixHQUFHLDJCQUEyQiwyQkFBMkIsR0FBRyxzQ0FBc0MsaUNBQWlDLDZEQUE2RCxtQ0FBbUMsa0JBQWtCLG9EQUFvRCx5Q0FBeUMsNEJBQTRCLDhCQUE4QixrQkFBa0IsdURBQXVELHdCQUF3QixPQUFPLG1DQUFtQyx3QkFBd0IsMkVBQTJFLHlGQUF5RixpRUFBaUUsNEJBQTRCLHdDQUF3QyxHQUFHLHlIQUF5SCxvQkFBb0IsdUJBQXVCLHlCQUF5QixHQUFHLGtFQUFrRSx1QkFBdUIsb0JBQW9CLDZCQUE2Qiw2QkFBNkIsR0FBRyx1QkFBdUIsc0JBQXNCLElBQUksNkJBQTZCLHlCQUF5Qiw2QkFBNkIseURBQXlELHNEQUFzRCxvREFBb0QscURBQXFELGlEQUFpRCxLQUFLLDZGQUE2Rix3QkFBd0IsMkJBQTJCLEdBQUcsNk5BQTZOLGlCQUFpQiwrQkFBK0IsNEJBQTRCLHVCQUF1QixtQkFBbUIsWUFBWSw0Q0FBNEMsS0FBSyxPQUFPLHNCQUFzQixpQkFBaUIsR0FBRyw4QkFBOEIsbUJBQW1CLEdBQUcsK0NBQStDLGlCQUFpQixHQUFHLHdCQUF3QixXQUFXLFlBQVksR0FBRywrQkFBK0IsZ0JBQWdCLDBCQUEwQix1Q0FBdUMsd0NBQXdDLGtDQUFrQyw0Q0FBNEMsdUJBQXVCLGNBQWMsY0FBYyxHQUFHLDhCQUE4QixnQkFBZ0IsMEJBQTBCLHVDQUF1Qyx3Q0FBd0MscUNBQXFDLHVCQUF1QixjQUFjLGNBQWMsR0FBRyxxQkFBcUIsa0JBQWtCLEdBQUcsd0NBQXdDLG1CQUFtQixHQUFHLDRDQUE0QyxtQkFBbUIsR0FBRywwQ0FBMEMsbUJBQW1CLEdBQUcscUJBQXFCLGNBQWMsR0FBRyxtQ0FBbUMsdUJBQXVCLGdCQUFnQixpQkFBaUIsK0JBQStCLDRCQUE0Qix1QkFBdUIsaUJBQWlCLEdBQUcsbUZBQW1GLGtDQUFrQyxHQUFHLHFDQUFxQyx3QkFBd0Isb0JBQW9CLEdBQUcsNkRBQTZELG1CQUFtQixHQUFHLDZFQUE2RSxxQkFBcUIsbUJBQW1CLG9CQUFvQixHQUFHLCtKQUErSiw4QkFBOEIsa0VBQWtFLGlFQUFpRSx3RkFBd0YscUVBQXFFLGdFQUFnRSw2REFBNkQsZ0NBQWdDLHVIQUF1SCwwQ0FBMEMsNEVBQTRFLHNFQUFzRSxnQkFBZ0IsR0FBRyxtN0JBQW03Qiw4QkFBOEIsR0FBRyxxWEFBcVgsa0NBQWtDLEdBQUcsNkNBQTZDLGdCQUFnQixHQUFHLDhDQUE4QyxnQkFBZ0IsR0FBRywrSkFBK0osd0JBQXdCLDZCQUE2QiwwQkFBMEIscUJBQXFCLEdBQUcsdUxBQXVMLDhCQUE4QixrRUFBa0UsaUVBQWlFLHdGQUF3RixxRUFBcUUsZ0VBQWdFLDZEQUE2RCxnQ0FBZ0MsdUhBQXVILDBDQUEwQyw0RUFBNEUsc0VBQXNFLDZCQUE2QiwwQkFBMEIscUJBQXFCLEdBQUcsMmlDQUEyaUMsOEJBQThCLEdBQUcscWFBQXFhLGtDQUFrQyxHQUFHLDJLQUEySyw4QkFBOEIsa0VBQWtFLGlFQUFpRSx3RkFBd0YscUVBQXFFLGdFQUFnRSw2REFBNkQsZ0NBQWdDLHVIQUF1SCwwQ0FBMEMsNEVBQTRFLHNFQUFzRSxnQkFBZ0IsOENBQThDLEdBQUcsKytCQUErK0IsOEJBQThCLEdBQUcsNllBQTZZLGtDQUFrQyxHQUFHLG1LQUFtSyw4QkFBOEIsa0VBQWtFLGlFQUFpRSx3RkFBd0YscUVBQXFFLGdFQUFnRSw2REFBNkQsZ0NBQWdDLHVIQUF1SCwwQ0FBMEMsNEVBQTRFLHNFQUFzRSxnQkFBZ0IsOENBQThDLEdBQUcsdThCQUF1OEIsOEJBQThCLEdBQUcsNlhBQTZYLGtDQUFrQyxHQUFHLGdDQUFnQyxtQkFBbUIsZUFBZSxpQkFBaUIsc0JBQXNCLGdCQUFnQixlQUFlLG9CQUFvQiwrQkFBK0IsNEJBQTRCLHVCQUF1QixHQUFHLHNDQUFzQyx3QkFBd0IsR0FBRyx1RkFBdUYscUJBQXFCLG1CQUFtQixvQkFBb0IsR0FBRyx1TEFBdUwsOEJBQThCLGtFQUFrRSxpRUFBaUUsd0ZBQXdGLHFFQUFxRSxnRUFBZ0UsNkRBQTZELGdDQUFnQyx1SEFBdUgsMENBQTBDLDRFQUE0RSxzRUFBc0UsZ0JBQWdCLDhDQUE4QyxHQUFHLDJpQ0FBMmlDLDhCQUE4QixHQUFHLHFhQUFxYSxrQ0FBa0MsR0FBRyx1RUFBdUUsbUJBQW1CLEdBQUcsb0NBQW9DLGlCQUFpQixHQUFHLGlFQUFpRSxvQkFBb0IsR0FBRyw2RUFBNkUsd0JBQXdCLEdBQUcsbUJBQW1CLG9CQUFvQixnQkFBZ0IseUJBQXlCLDJCQUEyQixHQUFHLDBDQUEwQyxvQkFBb0Isa0NBQWtDLEdBQUcsZ0VBQWdFLG1CQUFtQixvQkFBb0IsZ0JBQWdCLGlCQUFpQixHQUFHLDBCQUEwQix1QkFBdUIsR0FBRyxzQ0FBc0MsdUNBQXVDLG9DQUFvQywrQkFBK0IsR0FBRyxxQ0FBcUMsdUNBQXVDLG9DQUFvQywrQkFBK0IsR0FBRyw0QkFBNEIsMEJBQTBCLGdCQUFnQixvQkFBb0IsaUJBQWlCLHFCQUFxQix3QkFBd0Isc0JBQXNCLHVCQUF1QixpQ0FBaUMsMkJBQTJCLDhCQUE4QiwyQkFBMkIsc0JBQXNCLHVCQUF1QixHQUFHOztBQUU3NnFCIiwiZmlsZSI6IjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIvKiEgWC1lZGl0YWJsZSAtIHYxLjUuMSBcXG4qIEluLXBsYWNlIGVkaXRpbmcgd2l0aCBUd2l0dGVyIEJvb3RzdHJhcCwgalF1ZXJ5IFVJIG9yIHB1cmUgalF1ZXJ5XFxuKiBodHRwOi8vZ2l0aHViLmNvbS92aXRhbGV0cy94LWVkaXRhYmxlXFxuKiBDb3B5cmlnaHQgKGMpIDIwMTMgVml0YWxpeSBQb3RhcG92OyBMaWNlbnNlZCBNSVQgKi9cXG4uZWRpdGFibGVmb3JtIHtcXG4gICAgbWFyZ2luLWJvdHRvbTogMDsgLyogb3ZlcndyaXRlcyBib290c3RyYXAgbWFyZ2luICovXFxufVxcblxcbi5lZGl0YWJsZWZvcm0gLmNvbnRyb2wtZ3JvdXAge1xcbiAgICBtYXJnaW4tYm90dG9tOiAwOyAvKiBvdmVyd3JpdGVzIGJvb3RzdHJhcCBtYXJnaW4gKi9cXG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDsgLyogcHJldmVudCB3cmFwcGluZyBidXR0b25zIG9uIG5ldyBsaW5lICovXFxuICAgIGxpbmUtaGVpZ2h0OiAyMHB4OyAvKiBvdmVyd3JpdGluZyBib290c3RyYXAgbGluZS1oZWlnaHQuIFNlZSAjMTMzICovXFxufVxcblxcbi8qIFxcbiAgQlMzIHdpZHRoOjEwMDUgZm9yIGlucHV0cyBicmVha3MgZWRpdGFibGUgZm9ybSBpbiBwb3B1cCBcXG4gIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL3ZpdGFsZXRzL3gtZWRpdGFibGUvaXNzdWVzLzM5M1xcbiovXFxuLmVkaXRhYmxlZm9ybSAuZm9ybS1jb250cm9sIHtcXG4gICAgd2lkdGg6IGF1dG87XFxufVxcblxcbi5lZGl0YWJsZS1idXR0b25zIHtcXG4gICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IC8qIHNob3VsZCBiZSBpbmxpbmUgdG8gdGFrZSBlZmZlY3Qgb2YgcGFyZW50J3Mgd2hpdGUtc3BhY2U6IG5vd3JhcCAqL1xcbiAgIHZlcnRpY2FsLWFsaWduOiB0b3A7XFxuICAgbWFyZ2luLWxlZnQ6IDdweDtcXG4gICAvKiBpbmxpbmUtYmxvY2sgZW11bGF0aW9uIGZvciBJRTcqL1xcbiAgIHpvb206IDE7IFxcbiAgICpkaXNwbGF5OiBpbmxpbmU7XFxufVxcblxcbi5lZGl0YWJsZS1idXR0b25zLmVkaXRhYmxlLWJ1dHRvbnMtYm90dG9tIHtcXG4gICBkaXNwbGF5OiBibG9jazsgXFxuICAgbWFyZ2luLXRvcDogN3B4O1xcbiAgIG1hcmdpbi1sZWZ0OiAwO1xcbn1cXG5cXG4uZWRpdGFibGUtaW5wdXQge1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogdG9wOyBcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrOyAvKiBzaG91bGQgYmUgaW5saW5lIHRvIHRha2UgZWZmZWN0IG9mIHBhcmVudCdzIHdoaXRlLXNwYWNlOiBub3dyYXAgKi9cXG4gICAgd2lkdGg6IGF1dG87IC8qIGJvb3RzdHJhcC1yZXNwb25zaXZlIGhhcyB3aWR0aDogMTAwJSB0aGF0IGJyZWFrZXMgbGF5b3V0ICovXFxuICAgIHdoaXRlLXNwYWNlOiBub3JtYWw7IC8qIHJlc2V0IHdoaXRlLXNwYWNlIGRlY2FscmVkIGluIHBhcmVudCovXFxuICAgLyogZGlzcGxheS1pbmxpbmUgZW11bGF0aW9uIGZvciBJRTcqL1xcbiAgIHpvb206IDE7IFxcbiAgICpkaXNwbGF5OiBpbmxpbmU7ICAgXFxufVxcblxcbi5lZGl0YWJsZS1idXR0b25zIC5lZGl0YWJsZS1jYW5jZWwge1xcbiAgIG1hcmdpbi1sZWZ0OiA3cHg7IFxcbn1cXG5cXG4vKmZvciBqcXVlcnktdWkgYnV0dG9ucyBuZWVkIHNldCBoZWlnaHQgdG8gbG9vayBtb3JlIHByZXR0eSovXFxuLmVkaXRhYmxlLWJ1dHRvbnMgYnV0dG9uLnVpLWJ1dHRvbi1pY29uLW9ubHkge1xcbiAgIGhlaWdodDogMjRweDsgXFxuICAgd2lkdGg6IDMwcHg7XFxufVxcblxcbi5lZGl0YWJsZWZvcm0tbG9hZGluZyB7XFxuICAgIGJhY2tncm91bmQ6IHVybChcIiArIHJlcXVpcmUoXCIuLi9pbWcvbG9hZGluZy5naWZcIikgKyBcIikgY2VudGVyIGNlbnRlciBuby1yZXBlYXQ7ICBcXG4gICAgaGVpZ2h0OiAyNXB4O1xcbiAgICB3aWR0aDogYXV0bzsgXFxuICAgIG1pbi13aWR0aDogMjVweDsgXFxufVxcblxcbi5lZGl0YWJsZS1pbmxpbmUgLmVkaXRhYmxlZm9ybS1sb2FkaW5nIHtcXG4gICAgYmFja2dyb3VuZC1wb3NpdGlvbjogbGVmdCA1cHg7ICAgICAgXFxufVxcblxcbiAuZWRpdGFibGUtZXJyb3ItYmxvY2sge1xcbiAgICBtYXgtd2lkdGg6IDMwMHB4O1xcbiAgICBtYXJnaW46IDVweCAwIDAgMDtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIHdoaXRlLXNwYWNlOiBub3JtYWw7XFxufVxcblxcbi8qYWRkIHBhZGRpbmcgZm9yIGpxdWVyeSB1aSovXFxuLmVkaXRhYmxlLWVycm9yLWJsb2NrLnVpLXN0YXRlLWVycm9yIHtcXG4gICAgcGFkZGluZzogM3B4OyAgXFxufSAgXFxuXFxuLmVkaXRhYmxlLWVycm9yIHtcXG4gICBjb2xvcjogcmVkOyAgXFxufVxcblxcbi8qIC0tLS0gRm9yIHNwZWNpZmljIHR5cGVzIC0tLS0gKi9cXG5cXG4uZWRpdGFibGVmb3JtIC5lZGl0YWJsZS1kYXRlIHtcXG4gICAgcGFkZGluZzogMDsgXFxuICAgIG1hcmdpbjogMDtcXG4gICAgZmxvYXQ6IGxlZnQ7XFxufVxcblxcbi8qIG1vdmUgZGF0ZXBpY2tlciBpY29uIHRvIGNlbnRlciBvZiBhZGQtb24gYnV0dG9uLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGFsZXRzL3gtZWRpdGFibGUvaXNzdWVzLzE4MyAqL1xcbi5lZGl0YWJsZS1pbmxpbmUgLmFkZC1vbiAuaWNvbi10aCB7XFxuICAgbWFyZ2luLXRvcDogM3B4O1xcbiAgIG1hcmdpbi1sZWZ0OiAxcHg7IFxcbn1cXG5cXG5cXG4vKiBjaGVja2xpc3QgdmVydGljYWwgYWxpZ25tZW50ICovXFxuLmVkaXRhYmxlLWNoZWNrbGlzdCBsYWJlbCBpbnB1dFt0eXBlPVxcXCJjaGVja2JveFxcXCJdLCBcXG4uZWRpdGFibGUtY2hlY2tsaXN0IGxhYmVsIHNwYW4ge1xcbiAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgICBtYXJnaW46IDA7XFxufVxcblxcbi5lZGl0YWJsZS1jaGVja2xpc3QgbGFiZWwge1xcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwOyBcXG59XFxuXFxuLyogc2V0IGV4YWN0IHdpZHRoIG9mIHRleHRhcmVhIHRvIGZpdCBidXR0b25zIHRvb2xiYXIgKi9cXG4uZWRpdGFibGUtd3lzaWh0bWw1IHtcXG4gICAgd2lkdGg6IDU2NnB4OyBcXG4gICAgaGVpZ2h0OiAyNTBweDsgXFxufVxcblxcbi8qIGNsZWFyIGJ1dHRvbiBzaG93biBhcyBsaW5rIGluIGRhdGUgaW5wdXRzICovXFxuLmVkaXRhYmxlLWNsZWFyIHtcXG4gICBjbGVhcjogYm90aDtcXG4gICBmb250LXNpemU6IDAuOWVtO1xcbiAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICB0ZXh0LWFsaWduOiByaWdodDtcXG59XFxuXFxuLyogSU9TLXN0eWxlIGNsZWFyIGJ1dHRvbiBmb3IgdGV4dCBpbnB1dHMgKi9cXG4uZWRpdGFibGUtY2xlYXIteCB7XFxuICAgYmFja2dyb3VuZDogdXJsKFwiICsgcmVxdWlyZShcIi4uL2ltZy9jbGVhci5wbmdcIikgKyBcIikgY2VudGVyIGNlbnRlciBuby1yZXBlYXQ7XFxuICAgZGlzcGxheTogYmxvY2s7XFxuICAgd2lkdGg6IDEzcHg7ICAgIFxcbiAgIGhlaWdodDogMTNweDtcXG4gICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgb3BhY2l0eTogMC42O1xcbiAgIHotaW5kZXg6IDEwMDtcXG4gICBcXG4gICB0b3A6IDUwJTtcXG4gICByaWdodDogNnB4O1xcbiAgIG1hcmdpbi10b3A6IC02cHg7XFxuICAgXFxufVxcblxcbi5lZGl0YWJsZS1jbGVhci14OmhvdmVyIHtcXG4gICBvcGFjaXR5OiAxO1xcbn1cXG5cXG4uZWRpdGFibGUtcHJlLXdyYXBwZWQge1xcbiAgIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcXG59XFxuLmVkaXRhYmxlLWNvbnRhaW5lci5lZGl0YWJsZS1wb3B1cCB7XFxuICAgIG1heC13aWR0aDogbm9uZSAhaW1wb3J0YW50OyAvKiB3aXRob3V0IHRoaXMgcnVsZSBwb3NoeXRpcC90b29sdGlwIGRvZXMgbm90IHN0cmV0Y2ggKi9cXG59ICBcXG5cXG4uZWRpdGFibGUtY29udGFpbmVyLnBvcG92ZXIge1xcbiAgICB3aWR0aDogYXV0bzsgLyogd2l0aG91dCB0aGlzIHJ1bGUgcG9wb3ZlciBkb2VzIG5vdCBzdHJldGNoICovXFxufVxcblxcbi5lZGl0YWJsZS1jb250YWluZXIuZWRpdGFibGUtaW5saW5lIHtcXG4gICAgZGlzcGxheTogaW5saW5lLWJsb2NrOyBcXG4gICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcXG4gICAgd2lkdGg6IGF1dG87XFxuICAgIC8qIGlubGluZS1ibG9jayBlbXVsYXRpb24gZm9yIElFNyovXFxuICAgIHpvb206IDE7IFxcbiAgICAqZGlzcGxheTogaW5saW5lOyAgICBcXG59XFxuXFxuLmVkaXRhYmxlLWNvbnRhaW5lci51aS13aWRnZXQge1xcbiAgIGZvbnQtc2l6ZTogaW5oZXJpdDsgIC8qIGpxdWVyeXVpIHdpZGdldCBmb250IDEuMWVtIHRvbyBiaWcsIG92ZXJ3cml0ZSBpdCAqL1xcbiAgIHotaW5kZXg6IDk5OTA7IC8qIHNob3VsZCBiZSBsZXNzIHRoYW4gc2VsZWN0MiBkcm9wZG93biB6LWluZGV4IHRvIGNsb3NlIGRyb3Bkb3duIGZpcnN0IHdoZW4gY2xpY2sgKi9cXG59XFxuLmVkaXRhYmxlLWNsaWNrLCBcXG5hLmVkaXRhYmxlLWNsaWNrLCBcXG5hLmVkaXRhYmxlLWNsaWNrOmhvdmVyIHtcXG4gICAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcbiAgICBib3JkZXItYm90dG9tOiBkYXNoZWQgMXB4ICMwMDg4Y2M7XFxufVxcblxcbi5lZGl0YWJsZS1jbGljay5lZGl0YWJsZS1kaXNhYmxlZCwgXFxuYS5lZGl0YWJsZS1jbGljay5lZGl0YWJsZS1kaXNhYmxlZCwgXFxuYS5lZGl0YWJsZS1jbGljay5lZGl0YWJsZS1kaXNhYmxlZDpob3ZlciB7XFxuICAgY29sb3I6ICM1ODU4NTg7ICBcXG4gICBjdXJzb3I6IGRlZmF1bHQ7XFxuICAgYm9yZGVyLWJvdHRvbTogbm9uZTtcXG59XFxuXFxuLmVkaXRhYmxlLWVtcHR5LCAuZWRpdGFibGUtZW1wdHk6aG92ZXIsIC5lZGl0YWJsZS1lbXB0eTpmb2N1c3tcXG4gIGZvbnQtc3R5bGU6IGl0YWxpYzsgXFxuICBjb2xvcjogI0REMTE0NDsgIFxcbiAgLyogYm9yZGVyLWJvdHRvbTogbm9uZTsgKi9cXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG59XFxuXFxuLmVkaXRhYmxlLXVuc2F2ZWQge1xcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7IFxcbn1cXG5cXG4uZWRpdGFibGUtdW5zYXZlZDphZnRlciB7XFxuLyogICAgY29udGVudDogJyonKi9cXG59XFxuXFxuLmVkaXRhYmxlLWJnLXRyYW5zaXRpb24ge1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDE0MDBtcyBlYXNlLW91dDtcXG4gIC1tb3otdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAxNDAwbXMgZWFzZS1vdXQ7XFxuICAtby10cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDE0MDBtcyBlYXNlLW91dDtcXG4gIC1tcy10cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDE0MDBtcyBlYXNlLW91dDtcXG4gIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMTQwMG1zIGVhc2Utb3V0OyAgXFxufVxcblxcbi8qc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92aXRhbGV0cy94LWVkaXRhYmxlL2lzc3Vlcy8xMzkgKi9cXG4uZm9ybS1ob3Jpem9udGFsIC5lZGl0YWJsZVxcbnsgXFxuICAgIHBhZGRpbmctdG9wOiA1cHg7XFxuICAgIGRpc3BsYXk6aW5saW5lLWJsb2NrO1xcbn1cXG5cXG5cXG4vKiFcXG4gKiBEYXRlcGlja2VyIGZvciBCb290c3RyYXBcXG4gKlxcbiAqIENvcHlyaWdodCAyMDEyIFN0ZWZhbiBQZXRyZVxcbiAqIEltcHJvdmVtZW50cyBieSBBbmRyZXcgUm93bHNcXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UgdjIuMFxcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxcbiAqXFxuICovXFxuLmRhdGVwaWNrZXIge1xcbiAgcGFkZGluZzogNHB4O1xcbiAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiA0cHg7XFxuICAtbW96LWJvcmRlci1yYWRpdXM6IDRweDtcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gIGRpcmVjdGlvbjogbHRyO1xcbiAgLyouZG93IHtcXG5cXHRcXHRib3JkZXItdG9wOiAxcHggc29saWQgI2RkZCAhaW1wb3J0YW50O1xcblxcdH0qL1xcblxcbn1cXG4uZGF0ZXBpY2tlci1pbmxpbmUge1xcbiAgd2lkdGg6IDIyMHB4O1xcbn1cXG4uZGF0ZXBpY2tlci5kYXRlcGlja2VyLXJ0bCB7XFxuICBkaXJlY3Rpb246IHJ0bDtcXG59XFxuLmRhdGVwaWNrZXIuZGF0ZXBpY2tlci1ydGwgdGFibGUgdHIgdGQgc3BhbiB7XFxuICBmbG9hdDogcmlnaHQ7XFxufVxcbi5kYXRlcGlja2VyLWRyb3Bkb3duIHtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxufVxcbi5kYXRlcGlja2VyLWRyb3Bkb3duOmJlZm9yZSB7XFxuICBjb250ZW50OiAnJztcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJvcmRlci1sZWZ0OiA3cHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItcmlnaHQ6IDdweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci1ib3R0b206IDdweCBzb2xpZCAjY2NjO1xcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjIpO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAtN3B4O1xcbiAgbGVmdDogNnB4O1xcbn1cXG4uZGF0ZXBpY2tlci1kcm9wZG93bjphZnRlciB7XFxuICBjb250ZW50OiAnJztcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJvcmRlci1sZWZ0OiA2cHggc29saWQgdHJhbnNwYXJlbnQ7XFxuICBib3JkZXItcmlnaHQ6IDZweCBzb2xpZCB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci1ib3R0b206IDZweCBzb2xpZCAjZmZmZmZmO1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAtNnB4O1xcbiAgbGVmdDogN3B4O1xcbn1cXG4uZGF0ZXBpY2tlciA+IGRpdiB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4uZGF0ZXBpY2tlci5kYXlzIGRpdi5kYXRlcGlja2VyLWRheXMge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcbi5kYXRlcGlja2VyLm1vbnRocyBkaXYuZGF0ZXBpY2tlci1tb250aHMge1xcbiAgZGlzcGxheTogYmxvY2s7XFxufVxcbi5kYXRlcGlja2VyLnllYXJzIGRpdi5kYXRlcGlja2VyLXllYXJzIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4uZGF0ZXBpY2tlciB0YWJsZSB7XFxuICBtYXJnaW46IDA7XFxufVxcbi5kYXRlcGlja2VyIHRkLFxcbi5kYXRlcGlja2VyIHRoIHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHdpZHRoOiAyMHB4O1xcbiAgaGVpZ2h0OiAyMHB4O1xcbiAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiA0cHg7XFxuICAtbW96LWJvcmRlci1yYWRpdXM6IDRweDtcXG4gIGJvcmRlci1yYWRpdXM6IDRweDtcXG4gIGJvcmRlcjogbm9uZTtcXG59XFxuLnRhYmxlLXN0cmlwZWQgLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQsXFxuLnRhYmxlLXN0cmlwZWQgLmRhdGVwaWNrZXIgdGFibGUgdHIgdGgge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxufVxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmRheTpob3ZlciB7XFxuICBiYWNrZ3JvdW5kOiAjZWVlZWVlO1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5vbGQsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQubmV3IHtcXG4gIGNvbG9yOiAjOTk5OTk5O1xcbn1cXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5kaXNhYmxlZCxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5kaXNhYmxlZDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kOiBub25lO1xcbiAgY29sb3I6ICM5OTk5OTk7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxufVxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5OmhvdmVyLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZGUxOWE7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICNmZGQ0OWEsICNmZGY1OWEpO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogLW1zLWxpbmVhci1ncmFkaWVudCh0b3AsICNmZGQ0OWEsICNmZGY1OWEpO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogLXdlYmtpdC1ncmFkaWVudChsaW5lYXIsIDAgMCwgMCAxMDAlLCBmcm9tKCNmZGQ0OWEpLCB0bygjZmRmNTlhKSk7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsICNmZGQ0OWEsICNmZGY1OWEpO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogLW8tbGluZWFyLWdyYWRpZW50KHRvcCwgI2ZkZDQ5YSwgI2ZkZjU5YSk7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiBsaW5lYXItZ3JhZGllbnQodG9wLCAjZmRkNDlhLCAjZmRmNTlhKTtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQteDtcXG4gIGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9JyNmZGQ0OWEnLCBlbmRDb2xvcnN0cj0nI2ZkZjU5YScsIEdyYWRpZW50VHlwZT0wKTtcXG4gIGJvcmRlci1jb2xvcjogI2ZkZjU5YSAjZmRmNTlhICNmYmVkNTA7XFxuICBib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4xKSByZ2JhKDAsIDAsIDAsIDAuMSkgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gIGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KGVuYWJsZWQ9ZmFsc2UpO1xcbiAgY29sb3I6ICMwMDA7XFxufVxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5OmhvdmVyLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5OmhvdmVyOmhvdmVyLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkOmhvdmVyLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkOmhvdmVyOmhvdmVyLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5OmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheTpob3ZlcjphY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuZGlzYWJsZWQ6YWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkOmhvdmVyOmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheS5hY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXk6aG92ZXIuYWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkLmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheS5kaXNhYmxlZDpob3Zlci5hY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuZGlzYWJsZWQsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXk6aG92ZXIuZGlzYWJsZWQsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuZGlzYWJsZWQuZGlzYWJsZWQsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuZGlzYWJsZWQ6aG92ZXIuZGlzYWJsZWQsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXlbZGlzYWJsZWRdLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5OmhvdmVyW2Rpc2FibGVkXSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheS5kaXNhYmxlZFtkaXNhYmxlZF0sXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuZGlzYWJsZWQ6aG92ZXJbZGlzYWJsZWRdIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmZGY1OWE7XFxufVxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5OmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheTpob3ZlcjphY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXkuZGlzYWJsZWQ6YWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkOmhvdmVyOmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheS5hY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXk6aG92ZXIuYWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmRpc2FibGVkLmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC50b2RheS5kaXNhYmxlZDpob3Zlci5hY3RpdmUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZiZjA2OSBcXFxcOTtcXG59XFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQudG9kYXk6aG92ZXI6aG92ZXIge1xcbiAgY29sb3I6ICMwMDA7XFxufVxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnRvZGF5LmFjdGl2ZTpob3ZlciB7XFxuICBjb2xvcjogI2ZmZjtcXG59XFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2U6aG92ZXIsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UuZGlzYWJsZWQsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UuZGlzYWJsZWQ6aG92ZXIge1xcbiAgYmFja2dyb3VuZDogI2VlZWVlZTtcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogMDtcXG4gIC1tb3otYm9yZGVyLXJhZGl1czogMDtcXG4gIGJvcmRlci1yYWRpdXM6IDA7XFxufVxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5LFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5OmhvdmVyLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5LmRpc2FibGVkLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5LmRpc2FibGVkOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmM2QxN2E7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICNmM2MxN2EsICNmM2U5N2EpO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogLW1zLWxpbmVhci1ncmFkaWVudCh0b3AsICNmM2MxN2EsICNmM2U5N2EpO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogLXdlYmtpdC1ncmFkaWVudChsaW5lYXIsIDAgMCwgMCAxMDAlLCBmcm9tKCNmM2MxN2EpLCB0bygjZjNlOTdhKSk7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsICNmM2MxN2EsICNmM2U5N2EpO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogLW8tbGluZWFyLWdyYWRpZW50KHRvcCwgI2YzYzE3YSwgI2YzZTk3YSk7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiBsaW5lYXItZ3JhZGllbnQodG9wLCAjZjNjMTdhLCAjZjNlOTdhKTtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQteDtcXG4gIGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9JyNmM2MxN2EnLCBlbmRDb2xvcnN0cj0nI2YzZTk3YScsIEdyYWRpZW50VHlwZT0wKTtcXG4gIGJvcmRlci1jb2xvcjogI2YzZTk3YSAjZjNlOTdhICNlZGRlMzQ7XFxuICBib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4xKSByZ2JhKDAsIDAsIDAsIDAuMSkgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gIGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KGVuYWJsZWQ9ZmFsc2UpO1xcbiAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAwO1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAwO1xcbiAgYm9yZGVyLXJhZGl1czogMDtcXG59XFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXk6aG92ZXIsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXk6aG92ZXI6aG92ZXIsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXkuZGlzYWJsZWQ6aG92ZXIsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXkuZGlzYWJsZWQ6aG92ZXI6aG92ZXIsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXk6YWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5OmhvdmVyOmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZDphY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXkuZGlzYWJsZWQ6aG92ZXI6YWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5LmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheTpob3Zlci5hY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXkuZGlzYWJsZWQuYWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5LmRpc2FibGVkOmhvdmVyLmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZCxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheTpob3Zlci5kaXNhYmxlZCxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZC5kaXNhYmxlZCxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZDpob3Zlci5kaXNhYmxlZCxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheVtkaXNhYmxlZF0sXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXk6aG92ZXJbZGlzYWJsZWRdLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5LmRpc2FibGVkW2Rpc2FibGVkXSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZDpob3ZlcltkaXNhYmxlZF0ge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2YzZTk3YTtcXG59XFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXk6YWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5OmhvdmVyOmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheS5kaXNhYmxlZDphY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXkuZGlzYWJsZWQ6aG92ZXI6YWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5LmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5yYW5nZS50b2RheTpob3Zlci5hY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQucmFuZ2UudG9kYXkuZGlzYWJsZWQuYWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnJhbmdlLnRvZGF5LmRpc2FibGVkOmhvdmVyLmFjdGl2ZSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWZlMjRiIFxcXFw5O1xcbn1cXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZCxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZDpob3ZlcixcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZC5kaXNhYmxlZCxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZC5kaXNhYmxlZDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjOWU5ZTllO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogLW1vei1saW5lYXItZ3JhZGllbnQodG9wLCAjYjNiM2IzLCAjODA4MDgwKTtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IC1tcy1saW5lYXItZ3JhZGllbnQodG9wLCAjYjNiM2IzLCAjODA4MDgwKTtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IC13ZWJraXQtZ3JhZGllbnQobGluZWFyLCAwIDAsIDAgMTAwJSwgZnJvbSgjYjNiM2IzKSwgdG8oIzgwODA4MCkpO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQodG9wLCAjYjNiM2IzLCAjODA4MDgwKTtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IC1vLWxpbmVhci1ncmFkaWVudCh0b3AsICNiM2IzYjMsICM4MDgwODApO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KHRvcCwgI2IzYjNiMywgIzgwODA4MCk7XFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogcmVwZWF0LXg7XFxuICBmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChzdGFydENvbG9yc3RyPScjYjNiM2IzJywgZW5kQ29sb3JzdHI9JyM4MDgwODAnLCBHcmFkaWVudFR5cGU9MCk7XFxuICBib3JkZXItY29sb3I6ICM4MDgwODAgIzgwODA4MCAjNTk1OTU5O1xcbiAgYm9yZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMSkgcmdiYSgwLCAwLCAwLCAwLjEpIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxuICBmaWx0ZXI6IHByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChlbmFibGVkPWZhbHNlKTtcXG4gIGNvbG9yOiAjZmZmO1xcbiAgdGV4dC1zaGFkb3c6IDAgLTFweCAwIHJnYmEoMCwgMCwgMCwgMC4yNSk7XFxufVxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkOmhvdmVyLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkOmhvdmVyOmhvdmVyLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkOmhvdmVyLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkOmhvdmVyOmhvdmVyLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkOmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZDpob3ZlcjphY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQuZGlzYWJsZWQ6YWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkOmhvdmVyOmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZC5hY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQ6aG92ZXIuYWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkLmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZC5kaXNhYmxlZDpob3Zlci5hY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQuZGlzYWJsZWQsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQ6aG92ZXIuZGlzYWJsZWQsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQuZGlzYWJsZWQuZGlzYWJsZWQsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQuZGlzYWJsZWQ6aG92ZXIuZGlzYWJsZWQsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWRbZGlzYWJsZWRdLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkOmhvdmVyW2Rpc2FibGVkXSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZC5kaXNhYmxlZFtkaXNhYmxlZF0sXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQuZGlzYWJsZWQ6aG92ZXJbZGlzYWJsZWRdIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICM4MDgwODA7XFxufVxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkOmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZDpob3ZlcjphY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQuZGlzYWJsZWQ6YWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkOmhvdmVyOmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZC5hY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuc2VsZWN0ZWQ6aG92ZXIuYWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLnNlbGVjdGVkLmRpc2FibGVkLmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5zZWxlY3RlZC5kaXNhYmxlZDpob3Zlci5hY3RpdmUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzY2NjY2NiBcXFxcOTtcXG59XFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZTpob3ZlcixcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmUuZGlzYWJsZWQsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwMDZkY2M7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiAtbW96LWxpbmVhci1ncmFkaWVudCh0b3AsICMwMDg4Y2MsICMwMDQ0Y2MpO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogLW1zLWxpbmVhci1ncmFkaWVudCh0b3AsICMwMDg4Y2MsICMwMDQ0Y2MpO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogLXdlYmtpdC1ncmFkaWVudChsaW5lYXIsIDAgMCwgMCAxMDAlLCBmcm9tKCMwMDg4Y2MpLCB0bygjMDA0NGNjKSk7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudCh0b3AsICMwMDg4Y2MsICMwMDQ0Y2MpO1xcbiAgYmFja2dyb3VuZC1pbWFnZTogLW8tbGluZWFyLWdyYWRpZW50KHRvcCwgIzAwODhjYywgIzAwNDRjYyk7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiBsaW5lYXItZ3JhZGllbnQodG9wLCAjMDA4OGNjLCAjMDA0NGNjKTtcXG4gIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQteDtcXG4gIGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KHN0YXJ0Q29sb3JzdHI9JyMwMDg4Y2MnLCBlbmRDb2xvcnN0cj0nIzAwNDRjYycsIEdyYWRpZW50VHlwZT0wKTtcXG4gIGJvcmRlci1jb2xvcjogIzAwNDRjYyAjMDA0NGNjICMwMDJhODA7XFxuICBib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4xKSByZ2JhKDAsIDAsIDAsIDAuMSkgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG4gIGZpbHRlcjogcHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LmdyYWRpZW50KGVuYWJsZWQ9ZmFsc2UpO1xcbiAgY29sb3I6ICNmZmY7XFxuICB0ZXh0LXNoYWRvdzogMCAtMXB4IDAgcmdiYSgwLCAwLCAwLCAwLjI1KTtcXG59XFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlOmhvdmVyLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZTpob3Zlcjpob3ZlcixcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmUuZGlzYWJsZWQ6aG92ZXIsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkOmhvdmVyOmhvdmVyLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZTphY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlOmhvdmVyOmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmUuZGlzYWJsZWQ6YWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZDpob3ZlcjphY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmU6aG92ZXIuYWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZC5hY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkOmhvdmVyLmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmUuZGlzYWJsZWQsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlOmhvdmVyLmRpc2FibGVkLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZC5kaXNhYmxlZCxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmUuZGlzYWJsZWQ6aG92ZXIuZGlzYWJsZWQsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlW2Rpc2FibGVkXSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmU6aG92ZXJbZGlzYWJsZWRdLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZFtkaXNhYmxlZF0sXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkOmhvdmVyW2Rpc2FibGVkXSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDA0NGNjO1xcbn1cXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmU6YWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZTpob3ZlcjphY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlLmRpc2FibGVkOmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmUuZGlzYWJsZWQ6aG92ZXI6YWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5hY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQuYWN0aXZlOmhvdmVyLmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZC5hY3RpdmUuZGlzYWJsZWQuYWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkLmFjdGl2ZS5kaXNhYmxlZDpob3Zlci5hY3RpdmUge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzAwMzM5OSBcXFxcOTtcXG59XFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3BhbiB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiAyMyU7XFxuICBoZWlnaHQ6IDU0cHg7XFxuICBsaW5lLWhlaWdodDogNTRweDtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgbWFyZ2luOiAxJTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiA0cHg7XFxuICBib3JkZXItcmFkaXVzOiA0cHg7XFxufVxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW46aG92ZXIge1xcbiAgYmFja2dyb3VuZDogI2VlZWVlZTtcXG59XFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5kaXNhYmxlZCxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmRpc2FibGVkOmhvdmVyIHtcXG4gIGJhY2tncm91bmQ6IG5vbmU7XFxuICBjb2xvcjogIzk5OTk5OTtcXG4gIGN1cnNvcjogZGVmYXVsdDtcXG59XFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmU6aG92ZXIsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmUuZGlzYWJsZWQsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmUuZGlzYWJsZWQ6aG92ZXIge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzAwNmRjYztcXG4gIGJhY2tncm91bmQtaW1hZ2U6IC1tb3otbGluZWFyLWdyYWRpZW50KHRvcCwgIzAwODhjYywgIzAwNDRjYyk7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiAtbXMtbGluZWFyLWdyYWRpZW50KHRvcCwgIzAwODhjYywgIzAwNDRjYyk7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiAtd2Via2l0LWdyYWRpZW50KGxpbmVhciwgMCAwLCAwIDEwMCUsIGZyb20oIzAwODhjYyksIHRvKCMwMDQ0Y2MpKTtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KHRvcCwgIzAwODhjYywgIzAwNDRjYyk7XFxuICBiYWNrZ3JvdW5kLWltYWdlOiAtby1saW5lYXItZ3JhZGllbnQodG9wLCAjMDA4OGNjLCAjMDA0NGNjKTtcXG4gIGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudCh0b3AsICMwMDg4Y2MsICMwMDQ0Y2MpO1xcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IHJlcGVhdC14O1xcbiAgZmlsdGVyOiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoc3RhcnRDb2xvcnN0cj0nIzAwODhjYycsIGVuZENvbG9yc3RyPScjMDA0NGNjJywgR3JhZGllbnRUeXBlPTApO1xcbiAgYm9yZGVyLWNvbG9yOiAjMDA0NGNjICMwMDQ0Y2MgIzAwMmE4MDtcXG4gIGJvcmRlci1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjEpIHJnYmEoMCwgMCwgMCwgMC4xKSByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbiAgZmlsdGVyOiBwcm9naWQ6RFhJbWFnZVRyYW5zZm9ybS5NaWNyb3NvZnQuZ3JhZGllbnQoZW5hYmxlZD1mYWxzZSk7XFxuICBjb2xvcjogI2ZmZjtcXG4gIHRleHQtc2hhZG93OiAwIC0xcHggMCByZ2JhKDAsIDAsIDAsIDAuMjUpO1xcbn1cXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZTpob3ZlcixcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZTpob3Zlcjpob3ZlcixcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZDpob3ZlcixcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZDpob3Zlcjpob3ZlcixcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZTphY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmU6aG92ZXI6YWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlLmRpc2FibGVkOmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZDpob3ZlcjphY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmUuYWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlOmhvdmVyLmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZC5hY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmUuZGlzYWJsZWQ6aG92ZXIuYWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlLmRpc2FibGVkLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlOmhvdmVyLmRpc2FibGVkLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlLmRpc2FibGVkLmRpc2FibGVkLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlLmRpc2FibGVkOmhvdmVyLmRpc2FibGVkLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlW2Rpc2FibGVkXSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZTpob3ZlcltkaXNhYmxlZF0sXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmUuZGlzYWJsZWRbZGlzYWJsZWRdLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlLmRpc2FibGVkOmhvdmVyW2Rpc2FibGVkXSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDA0NGNjO1xcbn1cXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZTphY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmU6aG92ZXI6YWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlLmRpc2FibGVkOmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZDpob3ZlcjphY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmUuYWN0aXZlLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4uYWN0aXZlOmhvdmVyLmFjdGl2ZSxcXG4uZGF0ZXBpY2tlciB0YWJsZSB0ciB0ZCBzcGFuLmFjdGl2ZS5kaXNhYmxlZC5hY3RpdmUsXFxuLmRhdGVwaWNrZXIgdGFibGUgdHIgdGQgc3Bhbi5hY3RpdmUuZGlzYWJsZWQ6aG92ZXIuYWN0aXZlIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMwMDMzOTkgXFxcXDk7XFxufVxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4ub2xkLFxcbi5kYXRlcGlja2VyIHRhYmxlIHRyIHRkIHNwYW4ubmV3IHtcXG4gIGNvbG9yOiAjOTk5OTk5O1xcbn1cXG4uZGF0ZXBpY2tlciB0aC5kYXRlcGlja2VyLXN3aXRjaCB7XFxuICB3aWR0aDogMTQ1cHg7XFxufVxcbi5kYXRlcGlja2VyIHRoZWFkIHRyOmZpcnN0LWNoaWxkIHRoLFxcbi5kYXRlcGlja2VyIHRmb290IHRyIHRoIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLmRhdGVwaWNrZXIgdGhlYWQgdHI6Zmlyc3QtY2hpbGQgdGg6aG92ZXIsXFxuLmRhdGVwaWNrZXIgdGZvb3QgdHIgdGg6aG92ZXIge1xcbiAgYmFja2dyb3VuZDogI2VlZWVlZTtcXG59XFxuLmRhdGVwaWNrZXIgLmN3IHtcXG4gIGZvbnQtc2l6ZTogMTBweDtcXG4gIHdpZHRoOiAxMnB4O1xcbiAgcGFkZGluZzogMCAycHggMCA1cHg7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbn1cXG4uZGF0ZXBpY2tlciB0aGVhZCB0cjpmaXJzdC1jaGlsZCB0aC5jdyB7XFxuICBjdXJzb3I6IGRlZmF1bHQ7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG59XFxuLmlucHV0LWFwcGVuZC5kYXRlIC5hZGQtb24gaSxcXG4uaW5wdXQtcHJlcGVuZC5kYXRlIC5hZGQtb24gaSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIHdpZHRoOiAxNnB4O1xcbiAgaGVpZ2h0OiAxNnB4O1xcbn1cXG4uaW5wdXQtZGF0ZXJhbmdlIGlucHV0IHtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG59XFxuLmlucHV0LWRhdGVyYW5nZSBpbnB1dDpmaXJzdC1jaGlsZCB7XFxuICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDNweCAwIDAgM3B4O1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAzcHggMCAwIDNweDtcXG4gIGJvcmRlci1yYWRpdXM6IDNweCAwIDAgM3B4O1xcbn1cXG4uaW5wdXQtZGF0ZXJhbmdlIGlucHV0Omxhc3QtY2hpbGQge1xcbiAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAwIDNweCAzcHggMDtcXG4gIC1tb3otYm9yZGVyLXJhZGl1czogMCAzcHggM3B4IDA7XFxuICBib3JkZXItcmFkaXVzOiAwIDNweCAzcHggMDtcXG59XFxuLmlucHV0LWRhdGVyYW5nZSAuYWRkLW9uIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHdpZHRoOiBhdXRvO1xcbiAgbWluLXdpZHRoOiAxNnB4O1xcbiAgaGVpZ2h0OiAxOHB4O1xcbiAgcGFkZGluZzogNHB4IDVweDtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBsaW5lLWhlaWdodDogMThweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIHRleHQtc2hhZG93OiAwIDFweCAwICNmZmZmZmY7XFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZWVlZTtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNjY2M7XFxuICBtYXJnaW4tbGVmdDogLTVweDtcXG4gIG1hcmdpbi1yaWdodDogLTVweDtcXG59XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC1lZGl0YWJsZS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzP2RhMDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnQkFBZ0I7QUFDbkQsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsY0FBYzs7QUFFbEU7QUFDQSIsImZpbGUiOiI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgbGlzdCA9IFtdO1xuXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcblx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuXHRcdFx0dmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG5cdFx0XHRpZihpdGVtWzJdKSB7XG5cdFx0XHRcdHJldHVybiBcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGNvbnRlbnQgKyBcIn1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBjb250ZW50O1xuXHRcdFx0fVxuXHRcdH0pLmpvaW4oXCJcIik7XG5cdH07XG5cblx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3Rcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxuXHRcdFx0bW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgXCJcIl1dO1xuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpZCA9IHRoaXNbaV1bMF07XG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcblx0XHR9XG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xuXHRcdFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXG5cdFx0XHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBtZWRpYVF1ZXJ5O1xuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRyZXR1cm4gbGlzdDtcbn07XG5cbmZ1bmN0aW9uIGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKSB7XG5cdHZhciBjb250ZW50ID0gaXRlbVsxXSB8fCAnJztcblx0dmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXHRpZiAoIWNzc01hcHBpbmcpIHtcblx0XHRyZXR1cm4gY29udGVudDtcblx0fVxuXG5cdGlmICh1c2VTb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgc291cmNlTWFwcGluZyA9IHRvQ29tbWVudChjc3NNYXBwaW5nKTtcblx0XHR2YXIgc291cmNlVVJMcyA9IGNzc01hcHBpbmcuc291cmNlcy5tYXAoZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0cmV0dXJuICcvKiMgc291cmNlVVJMPScgKyBjc3NNYXBwaW5nLnNvdXJjZVJvb3QgKyBzb3VyY2UgKyAnICovJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbignXFxuJyk7XG5cdH1cblxuXHRyZXR1cm4gW2NvbnRlbnRdLmpvaW4oJ1xcbicpO1xufVxuXG4vLyBBZGFwdGVkIGZyb20gY29udmVydC1zb3VyY2UtbWFwIChNSVQpXG5mdW5jdGlvbiB0b0NvbW1lbnQoc291cmNlTWFwKSB7XG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuXHR2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcblx0dmFyIGRhdGEgPSAnc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsJyArIGJhc2U2NDtcblxuXHRyZXR1cm4gJy8qIyAnICsgZGF0YSArICcgKi8nO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"clear.png?f470863024f982806a178d720710f024\";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvaW1nL2NsZWFyLnBuZz80ODNlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJjbGVhci5wbmc/ZjQ3MDg2MzAyNGY5ODI4MDZhMTc4ZDcyMDcxMGYwMjRcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9lZGl0YWJsZS9pbWcvY2xlYXIucG5nXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6\n");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"loading.gif?7b9776076d5fceef4993b55c9383dedd\";\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvaW1nL2xvYWRpbmcuZ2lmPzdiODgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImxvYWRpbmcuZ2lmPzdiOTc3NjA3NmQ1ZmNlZWY0OTkzYjU1YzkzODNkZWRkXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZWRpdGFibGUvaW1nL2xvYWRpbmcuZ2lmXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(4);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(9)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!./bootstrap-editable.css\", function() {\n\t\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!./bootstrap-editable.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC1lZGl0YWJsZS5jc3M/ZTIzZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSxFQUFFO0FBQzVDIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9ib290c3RyYXAtZWRpdGFibGUuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC1lZGl0YWJsZS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vYm9vdHN0cmFwLWVkaXRhYmxlLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC1lZGl0YWJsZS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(selector) {\n\t\tif (typeof memo[selector] === \"undefined\") {\n\t\t\tmemo[selector] = fn.call(this, selector);\n\t\t}\n\n\t\treturn memo[selector]\n\t};\n})(function (target) {\n\treturn document.querySelector(target)\n});\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(10);\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton) options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n\tif (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\toptions.attrs.type = \"text/css\";\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\toptions.attrs.type = \"text/css\";\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzP2I3ODEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDOztBQUVBO0FBQ0EsbUJBQW1CLDJCQUEyQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTs7QUFFQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBLDZCQUE2QixtQkFBbUI7O0FBRWhEOztBQUVBOztBQUVBO0FBQ0EiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5cbnZhciBzdHlsZXNJbkRvbSA9IHt9O1xuXG52YXJcdG1lbW9pemUgPSBmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW87XG5cblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBtZW1vO1xuXHR9O1xufTtcblxudmFyIGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0Ly8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3Ncblx0Ly8gQHNlZSBodHRwOi8vYnJvd3NlcmhhY2tzLmNvbS8jaGFjay1lNzFkODY5MmY2NTMzNDE3M2ZlZTcxNWMyMjJjYjgwNVxuXHQvLyBUZXN0cyBmb3IgZXhpc3RlbmNlIG9mIHN0YW5kYXJkIGdsb2JhbHMgaXMgdG8gYWxsb3cgc3R5bGUtbG9hZGVyXG5cdC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuXHQvLyBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyL2lzc3Vlcy8xNzdcblx0cmV0dXJuIHdpbmRvdyAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5hbGwgJiYgIXdpbmRvdy5hdG9iO1xufSk7XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbihzZWxlY3Rvcikge1xuXHRcdGlmICh0eXBlb2YgbWVtb1tzZWxlY3Rvcl0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdG1lbW9bc2VsZWN0b3JdID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdH07XG59KShmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldClcbn0pO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgPGhlYWQ+IGVsZW1lbnRcblx0aWYgKCFvcHRpb25zLmluc2VydEludG8pIG9wdGlvbnMuaW5zZXJ0SW50byA9IFwiaGVhZFwiO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiB0aGUgdGFyZ2V0XG5cdGlmICghb3B0aW9ucy5pbnNlcnRBdCkgb3B0aW9ucy5pbnNlcnRBdCA9IFwiYm90dG9tXCI7XG5cblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0LCBvcHRpb25zKTtcblxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcblx0XHR2YXIgbWF5UmVtb3ZlID0gW107XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdFx0ZG9tU3R5bGUucmVmcy0tO1xuXHRcdFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xuXHRcdH1cblxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCwgb3B0aW9ucyk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cblx0XHRcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykgZG9tU3R5bGUucGFydHNbal0oKTtcblxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn07XG5cbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tIChzdHlsZXMsIG9wdGlvbnMpIHtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblxuXHRcdGlmKGRvbVN0eWxlKSB7XG5cdFx0XHRkb21TdHlsZS5yZWZzKys7XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyAobGlzdCwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGVzID0gW107XG5cdHZhciBuZXdTdHlsZXMgPSB7fTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IGxpc3RbaV07XG5cdFx0dmFyIGlkID0gb3B0aW9ucy5iYXNlID8gaXRlbVswXSArIG9wdGlvbnMuYmFzZSA6IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cblx0XHRpZighbmV3U3R5bGVzW2lkXSkgc3R5bGVzLnB1c2gobmV3U3R5bGVzW2lkXSA9IHtpZDogaWQsIHBhcnRzOiBbcGFydF19KTtcblx0XHRlbHNlIG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudCAob3B0aW9ucywgc3R5bGUpIHtcblx0dmFyIHRhcmdldCA9IGdldEVsZW1lbnQob3B0aW9ucy5pbnNlcnRJbnRvKVxuXG5cdGlmICghdGFyZ2V0KSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnRJbnRvJyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG5cdH1cblxuXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZXNJbnNlcnRlZEF0VG9wW3N0eWxlc0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcblx0XHRpZiAoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0YXJnZXQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmIChsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHRcdH1cblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGUpO1xuXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwiYm90dG9tXCIpIHtcblx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuXHR9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n");

/***/ }),
/* 10 */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9saWIvdXJscy5qcz85YzMxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVyxFQUFFO0FBQ3JELHdDQUF3QyxXQUFXLEVBQUU7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esc0NBQXNDO0FBQ3RDLEdBQUc7QUFDSDtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIvbGliL3VybHMuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n");

/***/ }),
/* 11 */
/***/ (function(module, exports) {

eval("/* globals __VUE_SSR_CONTEXT__ */\n\n// this module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyLmpzP2Q0ZjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gdGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgcmF3U2NyaXB0RXhwb3J0cyxcbiAgY29tcGlsZWRUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyIC8qIHNlcnZlciBvbmx5ICovXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICB2YXIgZnVuY3Rpb25hbCA9IG9wdGlvbnMuZnVuY3Rpb25hbFxuICAgIHZhciBleGlzdGluZyA9IGZ1bmN0aW9uYWxcbiAgICAgID8gb3B0aW9ucy5yZW5kZXJcbiAgICAgIDogb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICBpZiAoIWZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nXG4gICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKVxuICAgICAgICA6IFtob29rXVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb2FsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBleGlzdGluZyhoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('a', {\n    attrs: {\n      \"href\": \"javascript:;\",\n      \"data-type\": _vm.type,\n      \"disabled\": _vm.disabled,\n      \"emptytext\": _vm.emptytext\n    }\n  }, [_vm._v(_vm._s(_vm.value))])\n},staticRenderFns: []}\nmodule.exports.render._withStripped = true\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-hot-reload-api\").rerender(\"data-v-409b4816\", module.exports)\n  }\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvRWRpdGFibGUudnVlP2ZiNzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFtQixhQUFhLDBCQUEwQjtBQUMxRTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7XG4gIHJldHVybiBfYygnYScsIHtcbiAgICBhdHRyczoge1xuICAgICAgXCJocmVmXCI6IFwiamF2YXNjcmlwdDo7XCIsXG4gICAgICBcImRhdGEtdHlwZVwiOiBfdm0udHlwZSxcbiAgICAgIFwiZGlzYWJsZWRcIjogX3ZtLmRpc2FibGVkLFxuICAgICAgXCJlbXB0eXRleHRcIjogX3ZtLmVtcHR5dGV4dFxuICAgIH1cbiAgfSwgW192bS5fdihfdm0uX3MoX3ZtLnZhbHVlKSldKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtdfVxubW9kdWxlLmV4cG9ydHMucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi00MDliNDgxNlwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTQwOWI0ODE2XCIsXCJoYXNTY29wZWRcIjpmYWxzZX0hLi9+L3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCEuL3NyYy9FZGl0YWJsZS52dWVcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n");

/***/ }),
/* 13 */
/***/ (function(module, exports) {

eval("var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n * Bootstrap v3.3.5 (http://getbootstrap.com)\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under the MIT license\n */\nif (\"undefined\" == typeof jQuery) throw new Error(\"Bootstrap's JavaScript requires jQuery\");+function (a) {\n  \"use strict\";\n  var b = a.fn.jquery.split(\" \")[0].split(\".\");if (b[0] < 2 && b[1] < 9 || 1 == b[0] && 9 == b[1] && b[2] < 1) throw new Error(\"Bootstrap's JavaScript requires jQuery version 1.9.1 or higher\");\n}(jQuery), +function (a) {\n  \"use strict\";\n  function b() {\n    var a = document.createElement(\"bootstrap\"),\n        b = { WebkitTransition: \"webkitTransitionEnd\", MozTransition: \"transitionend\", OTransition: \"oTransitionEnd otransitionend\", transition: \"transitionend\" };for (var c in b) {\n      if (void 0 !== a.style[c]) return { end: b[c] };\n    }return !1;\n  }a.fn.emulateTransitionEnd = function (b) {\n    var c = !1,\n        d = this;a(this).one(\"bsTransitionEnd\", function () {\n      c = !0;\n    });var e = function e() {\n      c || a(d).trigger(a.support.transition.end);\n    };return setTimeout(e, b), this;\n  }, a(function () {\n    a.support.transition = b(), a.support.transition && (a.event.special.bsTransitionEnd = { bindType: a.support.transition.end, delegateType: a.support.transition.end, handle: function handle(b) {\n        return a(b.target).is(this) ? b.handleObj.handler.apply(this, arguments) : void 0;\n      } });\n  });\n}(jQuery), +function (a) {\n  \"use strict\";\n  function b(b) {\n    return this.each(function () {\n      var c = a(this),\n          e = c.data(\"bs.alert\");e || c.data(\"bs.alert\", e = new d(this)), \"string\" == typeof b && e[b].call(c);\n    });\n  }var c = '[data-dismiss=\"alert\"]',\n      d = function d(b) {\n    a(b).on(\"click\", c, this.close);\n  };d.VERSION = \"3.3.5\", d.TRANSITION_DURATION = 150, d.prototype.close = function (b) {\n    function c() {\n      g.detach().trigger(\"closed.bs.alert\").remove();\n    }var e = a(this),\n        f = e.attr(\"data-target\");f || (f = e.attr(\"href\"), f = f && f.replace(/.*(?=#[^\\s]*$)/, \"\"));var g = a(f);b && b.preventDefault(), g.length || (g = e.closest(\".alert\")), g.trigger(b = a.Event(\"close.bs.alert\")), b.isDefaultPrevented() || (g.removeClass(\"in\"), a.support.transition && g.hasClass(\"fade\") ? g.one(\"bsTransitionEnd\", c).emulateTransitionEnd(d.TRANSITION_DURATION) : c());\n  };var e = a.fn.alert;a.fn.alert = b, a.fn.alert.Constructor = d, a.fn.alert.noConflict = function () {\n    return a.fn.alert = e, this;\n  }, a(document).on(\"click.bs.alert.data-api\", c, d.prototype.close);\n}(jQuery), +function (a) {\n  \"use strict\";\n  function b(b) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data(\"bs.button\"),\n          f = \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && b;e || d.data(\"bs.button\", e = new c(this, f)), \"toggle\" == b ? e.toggle() : b && e.setState(b);\n    });\n  }var c = function c(b, d) {\n    this.$element = a(b), this.options = a.extend({}, c.DEFAULTS, d), this.isLoading = !1;\n  };c.VERSION = \"3.3.5\", c.DEFAULTS = { loadingText: \"loading...\" }, c.prototype.setState = function (b) {\n    var c = \"disabled\",\n        d = this.$element,\n        e = d.is(\"input\") ? \"val\" : \"html\",\n        f = d.data();b += \"Text\", null == f.resetText && d.data(\"resetText\", d[e]()), setTimeout(a.proxy(function () {\n      d[e](null == f[b] ? this.options[b] : f[b]), \"loadingText\" == b ? (this.isLoading = !0, d.addClass(c).attr(c, c)) : this.isLoading && (this.isLoading = !1, d.removeClass(c).removeAttr(c));\n    }, this), 0);\n  }, c.prototype.toggle = function () {\n    var a = !0,\n        b = this.$element.closest('[data-toggle=\"buttons\"]');if (b.length) {\n      var c = this.$element.find(\"input\");\"radio\" == c.prop(\"type\") ? (c.prop(\"checked\") && (a = !1), b.find(\".active\").removeClass(\"active\"), this.$element.addClass(\"active\")) : \"checkbox\" == c.prop(\"type\") && (c.prop(\"checked\") !== this.$element.hasClass(\"active\") && (a = !1), this.$element.toggleClass(\"active\")), c.prop(\"checked\", this.$element.hasClass(\"active\")), a && c.trigger(\"change\");\n    } else this.$element.attr(\"aria-pressed\", !this.$element.hasClass(\"active\")), this.$element.toggleClass(\"active\");\n  };var d = a.fn.button;a.fn.button = b, a.fn.button.Constructor = c, a.fn.button.noConflict = function () {\n    return a.fn.button = d, this;\n  }, a(document).on(\"click.bs.button.data-api\", '[data-toggle^=\"button\"]', function (c) {\n    var d = a(c.target);d.hasClass(\"btn\") || (d = d.closest(\".btn\")), b.call(d, \"toggle\"), a(c.target).is('input[type=\"radio\"]') || a(c.target).is('input[type=\"checkbox\"]') || c.preventDefault();\n  }).on(\"focus.bs.button.data-api blur.bs.button.data-api\", '[data-toggle^=\"button\"]', function (b) {\n    a(b.target).closest(\".btn\").toggleClass(\"focus\", /^focus(in)?$/.test(b.type));\n  });\n}(jQuery), +function (a) {\n  \"use strict\";\n  function b(b) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data(\"bs.carousel\"),\n          f = a.extend({}, c.DEFAULTS, d.data(), \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && b),\n          g = \"string\" == typeof b ? b : f.slide;e || d.data(\"bs.carousel\", e = new c(this, f)), \"number\" == typeof b ? e.to(b) : g ? e[g]() : f.interval && e.pause().cycle();\n    });\n  }var c = function c(b, _c) {\n    this.$element = a(b), this.$indicators = this.$element.find(\".carousel-indicators\"), this.options = _c, this.paused = null, this.sliding = null, this.interval = null, this.$active = null, this.$items = null, this.options.keyboard && this.$element.on(\"keydown.bs.carousel\", a.proxy(this.keydown, this)), \"hover\" == this.options.pause && !(\"ontouchstart\" in document.documentElement) && this.$element.on(\"mouseenter.bs.carousel\", a.proxy(this.pause, this)).on(\"mouseleave.bs.carousel\", a.proxy(this.cycle, this));\n  };c.VERSION = \"3.3.5\", c.TRANSITION_DURATION = 600, c.DEFAULTS = { interval: 5e3, pause: \"hover\", wrap: !0, keyboard: !0 }, c.prototype.keydown = function (a) {\n    if (!/input|textarea/i.test(a.target.tagName)) {\n      switch (a.which) {case 37:\n          this.prev();break;case 39:\n          this.next();break;default:\n          return;}a.preventDefault();\n    }\n  }, c.prototype.cycle = function (b) {\n    return b || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval(a.proxy(this.next, this), this.options.interval)), this;\n  }, c.prototype.getItemIndex = function (a) {\n    return this.$items = a.parent().children(\".item\"), this.$items.index(a || this.$active);\n  }, c.prototype.getItemForDirection = function (a, b) {\n    var c = this.getItemIndex(b),\n        d = \"prev\" == a && 0 === c || \"next\" == a && c == this.$items.length - 1;if (d && !this.options.wrap) return b;var e = \"prev\" == a ? -1 : 1,\n        f = (c + e) % this.$items.length;return this.$items.eq(f);\n  }, c.prototype.to = function (a) {\n    var b = this,\n        c = this.getItemIndex(this.$active = this.$element.find(\".item.active\"));return a > this.$items.length - 1 || 0 > a ? void 0 : this.sliding ? this.$element.one(\"slid.bs.carousel\", function () {\n      b.to(a);\n    }) : c == a ? this.pause().cycle() : this.slide(a > c ? \"next\" : \"prev\", this.$items.eq(a));\n  }, c.prototype.pause = function (b) {\n    return b || (this.paused = !0), this.$element.find(\".next, .prev\").length && a.support.transition && (this.$element.trigger(a.support.transition.end), this.cycle(!0)), this.interval = clearInterval(this.interval), this;\n  }, c.prototype.next = function () {\n    return this.sliding ? void 0 : this.slide(\"next\");\n  }, c.prototype.prev = function () {\n    return this.sliding ? void 0 : this.slide(\"prev\");\n  }, c.prototype.slide = function (b, d) {\n    var e = this.$element.find(\".item.active\"),\n        f = d || this.getItemForDirection(b, e),\n        g = this.interval,\n        h = \"next\" == b ? \"left\" : \"right\",\n        i = this;if (f.hasClass(\"active\")) return this.sliding = !1;var j = f[0],\n        k = a.Event(\"slide.bs.carousel\", { relatedTarget: j, direction: h });if (this.$element.trigger(k), !k.isDefaultPrevented()) {\n      if (this.sliding = !0, g && this.pause(), this.$indicators.length) {\n        this.$indicators.find(\".active\").removeClass(\"active\");var l = a(this.$indicators.children()[this.getItemIndex(f)]);l && l.addClass(\"active\");\n      }var m = a.Event(\"slid.bs.carousel\", { relatedTarget: j, direction: h });return a.support.transition && this.$element.hasClass(\"slide\") ? (f.addClass(b), f[0].offsetWidth, e.addClass(h), f.addClass(h), e.one(\"bsTransitionEnd\", function () {\n        f.removeClass([b, h].join(\" \")).addClass(\"active\"), e.removeClass([\"active\", h].join(\" \")), i.sliding = !1, setTimeout(function () {\n          i.$element.trigger(m);\n        }, 0);\n      }).emulateTransitionEnd(c.TRANSITION_DURATION)) : (e.removeClass(\"active\"), f.addClass(\"active\"), this.sliding = !1, this.$element.trigger(m)), g && this.cycle(), this;\n    }\n  };var d = a.fn.carousel;a.fn.carousel = b, a.fn.carousel.Constructor = c, a.fn.carousel.noConflict = function () {\n    return a.fn.carousel = d, this;\n  };var e = function e(c) {\n    var d,\n        e = a(this),\n        f = a(e.attr(\"data-target\") || (d = e.attr(\"href\")) && d.replace(/.*(?=#[^\\s]+$)/, \"\"));if (f.hasClass(\"carousel\")) {\n      var g = a.extend({}, f.data(), e.data()),\n          h = e.attr(\"data-slide-to\");h && (g.interval = !1), b.call(f, g), h && f.data(\"bs.carousel\").to(h), c.preventDefault();\n    }\n  };a(document).on(\"click.bs.carousel.data-api\", \"[data-slide]\", e).on(\"click.bs.carousel.data-api\", \"[data-slide-to]\", e), a(window).on(\"load\", function () {\n    a('[data-ride=\"carousel\"]').each(function () {\n      var c = a(this);b.call(c, c.data());\n    });\n  });\n}(jQuery), +function (a) {\n  \"use strict\";\n  function b(b) {\n    var c,\n        d = b.attr(\"data-target\") || (c = b.attr(\"href\")) && c.replace(/.*(?=#[^\\s]+$)/, \"\");return a(d);\n  }function c(b) {\n    return this.each(function () {\n      var c = a(this),\n          e = c.data(\"bs.collapse\"),\n          f = a.extend({}, d.DEFAULTS, c.data(), \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && b);!e && f.toggle && /show|hide/.test(b) && (f.toggle = !1), e || c.data(\"bs.collapse\", e = new d(this, f)), \"string\" == typeof b && e[b]();\n    });\n  }var d = function d(b, c) {\n    this.$element = a(b), this.options = a.extend({}, d.DEFAULTS, c), this.$trigger = a('[data-toggle=\"collapse\"][href=\"#' + b.id + '\"],[data-toggle=\"collapse\"][data-target=\"#' + b.id + '\"]'), this.transitioning = null, this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), this.options.toggle && this.toggle();\n  };d.VERSION = \"3.3.5\", d.TRANSITION_DURATION = 350, d.DEFAULTS = { toggle: !0 }, d.prototype.dimension = function () {\n    var a = this.$element.hasClass(\"width\");return a ? \"width\" : \"height\";\n  }, d.prototype.show = function () {\n    if (!this.transitioning && !this.$element.hasClass(\"in\")) {\n      var b,\n          e = this.$parent && this.$parent.children(\".panel\").children(\".in, .collapsing\");if (!(e && e.length && (b = e.data(\"bs.collapse\"), b && b.transitioning))) {\n        var f = a.Event(\"show.bs.collapse\");if (this.$element.trigger(f), !f.isDefaultPrevented()) {\n          e && e.length && (c.call(e, \"hide\"), b || e.data(\"bs.collapse\", null));var g = this.dimension();this.$element.removeClass(\"collapse\").addClass(\"collapsing\")[g](0).attr(\"aria-expanded\", !0), this.$trigger.removeClass(\"collapsed\").attr(\"aria-expanded\", !0), this.transitioning = 1;var h = function h() {\n            this.$element.removeClass(\"collapsing\").addClass(\"collapse in\")[g](\"\"), this.transitioning = 0, this.$element.trigger(\"shown.bs.collapse\");\n          };if (!a.support.transition) return h.call(this);var i = a.camelCase([\"scroll\", g].join(\"-\"));this.$element.one(\"bsTransitionEnd\", a.proxy(h, this)).emulateTransitionEnd(d.TRANSITION_DURATION)[g](this.$element[0][i]);\n        }\n      }\n    }\n  }, d.prototype.hide = function () {\n    if (!this.transitioning && this.$element.hasClass(\"in\")) {\n      var b = a.Event(\"hide.bs.collapse\");if (this.$element.trigger(b), !b.isDefaultPrevented()) {\n        var c = this.dimension();this.$element[c](this.$element[c]())[0].offsetHeight, this.$element.addClass(\"collapsing\").removeClass(\"collapse in\").attr(\"aria-expanded\", !1), this.$trigger.addClass(\"collapsed\").attr(\"aria-expanded\", !1), this.transitioning = 1;var e = function e() {\n          this.transitioning = 0, this.$element.removeClass(\"collapsing\").addClass(\"collapse\").trigger(\"hidden.bs.collapse\");\n        };return a.support.transition ? void this.$element[c](0).one(\"bsTransitionEnd\", a.proxy(e, this)).emulateTransitionEnd(d.TRANSITION_DURATION) : e.call(this);\n      }\n    }\n  }, d.prototype.toggle = function () {\n    this[this.$element.hasClass(\"in\") ? \"hide\" : \"show\"]();\n  }, d.prototype.getParent = function () {\n    return a(this.options.parent).find('[data-toggle=\"collapse\"][data-parent=\"' + this.options.parent + '\"]').each(a.proxy(function (c, d) {\n      var e = a(d);this.addAriaAndCollapsedClass(b(e), e);\n    }, this)).end();\n  }, d.prototype.addAriaAndCollapsedClass = function (a, b) {\n    var c = a.hasClass(\"in\");a.attr(\"aria-expanded\", c), b.toggleClass(\"collapsed\", !c).attr(\"aria-expanded\", c);\n  };var e = a.fn.collapse;a.fn.collapse = c, a.fn.collapse.Constructor = d, a.fn.collapse.noConflict = function () {\n    return a.fn.collapse = e, this;\n  }, a(document).on(\"click.bs.collapse.data-api\", '[data-toggle=\"collapse\"]', function (d) {\n    var e = a(this);e.attr(\"data-target\") || d.preventDefault();var f = b(e),\n        g = f.data(\"bs.collapse\"),\n        h = g ? \"toggle\" : e.data();c.call(f, h);\n  });\n}(jQuery), +function (a) {\n  \"use strict\";\n  function b(b) {\n    var c = b.attr(\"data-target\");c || (c = b.attr(\"href\"), c = c && /#[A-Za-z]/.test(c) && c.replace(/.*(?=#[^\\s]*$)/, \"\"));var d = c && a(c);return d && d.length ? d : b.parent();\n  }function c(c) {\n    c && 3 === c.which || (a(e).remove(), a(f).each(function () {\n      var d = a(this),\n          e = b(d),\n          f = { relatedTarget: this };e.hasClass(\"open\") && (c && \"click\" == c.type && /input|textarea/i.test(c.target.tagName) && a.contains(e[0], c.target) || (e.trigger(c = a.Event(\"hide.bs.dropdown\", f)), c.isDefaultPrevented() || (d.attr(\"aria-expanded\", \"false\"), e.removeClass(\"open\").trigger(\"hidden.bs.dropdown\", f))));\n    }));\n  }function d(b) {\n    return this.each(function () {\n      var c = a(this),\n          d = c.data(\"bs.dropdown\");d || c.data(\"bs.dropdown\", d = new g(this)), \"string\" == typeof b && d[b].call(c);\n    });\n  }var e = \".dropdown-backdrop\",\n      f = '[data-toggle=\"dropdown\"]',\n      g = function g(b) {\n    a(b).on(\"click.bs.dropdown\", this.toggle);\n  };g.VERSION = \"3.3.5\", g.prototype.toggle = function (d) {\n    var e = a(this);if (!e.is(\".disabled, :disabled\")) {\n      var f = b(e),\n          g = f.hasClass(\"open\");if (c(), !g) {\n        \"ontouchstart\" in document.documentElement && !f.closest(\".navbar-nav\").length && a(document.createElement(\"div\")).addClass(\"dropdown-backdrop\").insertAfter(a(this)).on(\"click\", c);var h = { relatedTarget: this };if (f.trigger(d = a.Event(\"show.bs.dropdown\", h)), d.isDefaultPrevented()) return;e.trigger(\"focus\").attr(\"aria-expanded\", \"true\"), f.toggleClass(\"open\").trigger(\"shown.bs.dropdown\", h);\n      }return !1;\n    }\n  }, g.prototype.keydown = function (c) {\n    if (/(38|40|27|32)/.test(c.which) && !/input|textarea/i.test(c.target.tagName)) {\n      var d = a(this);if (c.preventDefault(), c.stopPropagation(), !d.is(\".disabled, :disabled\")) {\n        var e = b(d),\n            g = e.hasClass(\"open\");if (!g && 27 != c.which || g && 27 == c.which) return 27 == c.which && e.find(f).trigger(\"focus\"), d.trigger(\"click\");var h = \" li:not(.disabled):visible a\",\n            i = e.find(\".dropdown-menu\" + h);if (i.length) {\n          var j = i.index(c.target);38 == c.which && j > 0 && j--, 40 == c.which && j < i.length - 1 && j++, ~j || (j = 0), i.eq(j).trigger(\"focus\");\n        }\n      }\n    }\n  };var h = a.fn.dropdown;a.fn.dropdown = d, a.fn.dropdown.Constructor = g, a.fn.dropdown.noConflict = function () {\n    return a.fn.dropdown = h, this;\n  }, a(document).on(\"click.bs.dropdown.data-api\", c).on(\"click.bs.dropdown.data-api\", \".dropdown form\", function (a) {\n    a.stopPropagation();\n  }).on(\"click.bs.dropdown.data-api\", f, g.prototype.toggle).on(\"keydown.bs.dropdown.data-api\", f, g.prototype.keydown).on(\"keydown.bs.dropdown.data-api\", \".dropdown-menu\", g.prototype.keydown);\n}(jQuery), +function (a) {\n  \"use strict\";\n  function b(b, d) {\n    return this.each(function () {\n      var e = a(this),\n          f = e.data(\"bs.modal\"),\n          g = a.extend({}, c.DEFAULTS, e.data(), \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && b);f || e.data(\"bs.modal\", f = new c(this, g)), \"string\" == typeof b ? f[b](d) : g.show && f.show(d);\n    });\n  }var c = function c(b, _c2) {\n    this.options = _c2, this.$body = a(document.body), this.$element = a(b), this.$dialog = this.$element.find(\".modal-dialog\"), this.$backdrop = null, this.isShown = null, this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, this.options.remote && this.$element.find(\".modal-content\").load(this.options.remote, a.proxy(function () {\n      this.$element.trigger(\"loaded.bs.modal\");\n    }, this));\n  };c.VERSION = \"3.3.5\", c.TRANSITION_DURATION = 300, c.BACKDROP_TRANSITION_DURATION = 150, c.DEFAULTS = { backdrop: !0, keyboard: !0, show: !0 }, c.prototype.toggle = function (a) {\n    return this.isShown ? this.hide() : this.show(a);\n  }, c.prototype.show = function (b) {\n    var d = this,\n        e = a.Event(\"show.bs.modal\", { relatedTarget: b });this.$element.trigger(e), this.isShown || e.isDefaultPrevented() || (this.isShown = !0, this.checkScrollbar(), this.setScrollbar(), this.$body.addClass(\"modal-open\"), this.escape(), this.resize(), this.$element.on(\"click.dismiss.bs.modal\", '[data-dismiss=\"modal\"]', a.proxy(this.hide, this)), this.$dialog.on(\"mousedown.dismiss.bs.modal\", function () {\n      d.$element.one(\"mouseup.dismiss.bs.modal\", function (b) {\n        a(b.target).is(d.$element) && (d.ignoreBackdropClick = !0);\n      });\n    }), this.backdrop(function () {\n      var e = a.support.transition && d.$element.hasClass(\"fade\");d.$element.parent().length || d.$element.appendTo(d.$body), d.$element.show().scrollTop(0), d.adjustDialog(), e && d.$element[0].offsetWidth, d.$element.addClass(\"in\"), d.enforceFocus();var f = a.Event(\"shown.bs.modal\", { relatedTarget: b });e ? d.$dialog.one(\"bsTransitionEnd\", function () {\n        d.$element.trigger(\"focus\").trigger(f);\n      }).emulateTransitionEnd(c.TRANSITION_DURATION) : d.$element.trigger(\"focus\").trigger(f);\n    }));\n  }, c.prototype.hide = function (b) {\n    b && b.preventDefault(), b = a.Event(\"hide.bs.modal\"), this.$element.trigger(b), this.isShown && !b.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), a(document).off(\"focusin.bs.modal\"), this.$element.removeClass(\"in\").off(\"click.dismiss.bs.modal\").off(\"mouseup.dismiss.bs.modal\"), this.$dialog.off(\"mousedown.dismiss.bs.modal\"), a.support.transition && this.$element.hasClass(\"fade\") ? this.$element.one(\"bsTransitionEnd\", a.proxy(this.hideModal, this)).emulateTransitionEnd(c.TRANSITION_DURATION) : this.hideModal());\n  }, c.prototype.enforceFocus = function () {\n    a(document).off(\"focusin.bs.modal\").on(\"focusin.bs.modal\", a.proxy(function (a) {\n      this.$element[0] === a.target || this.$element.has(a.target).length || this.$element.trigger(\"focus\");\n    }, this));\n  }, c.prototype.escape = function () {\n    this.isShown && this.options.keyboard ? this.$element.on(\"keydown.dismiss.bs.modal\", a.proxy(function (a) {\n      27 == a.which && this.hide();\n    }, this)) : this.isShown || this.$element.off(\"keydown.dismiss.bs.modal\");\n  }, c.prototype.resize = function () {\n    this.isShown ? a(window).on(\"resize.bs.modal\", a.proxy(this.handleUpdate, this)) : a(window).off(\"resize.bs.modal\");\n  }, c.prototype.hideModal = function () {\n    var a = this;this.$element.hide(), this.backdrop(function () {\n      a.$body.removeClass(\"modal-open\"), a.resetAdjustments(), a.resetScrollbar(), a.$element.trigger(\"hidden.bs.modal\");\n    });\n  }, c.prototype.removeBackdrop = function () {\n    this.$backdrop && this.$backdrop.remove(), this.$backdrop = null;\n  }, c.prototype.backdrop = function (b) {\n    var d = this,\n        e = this.$element.hasClass(\"fade\") ? \"fade\" : \"\";if (this.isShown && this.options.backdrop) {\n      var f = a.support.transition && e;if (this.$backdrop = a(document.createElement(\"div\")).addClass(\"modal-backdrop \" + e).appendTo(this.$body), this.$element.on(\"click.dismiss.bs.modal\", a.proxy(function (a) {\n        return this.ignoreBackdropClick ? void (this.ignoreBackdropClick = !1) : void (a.target === a.currentTarget && (\"static\" == this.options.backdrop ? this.$element[0].focus() : this.hide()));\n      }, this)), f && this.$backdrop[0].offsetWidth, this.$backdrop.addClass(\"in\"), !b) return;f ? this.$backdrop.one(\"bsTransitionEnd\", b).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : b();\n    } else if (!this.isShown && this.$backdrop) {\n      this.$backdrop.removeClass(\"in\");var g = function g() {\n        d.removeBackdrop(), b && b();\n      };a.support.transition && this.$element.hasClass(\"fade\") ? this.$backdrop.one(\"bsTransitionEnd\", g).emulateTransitionEnd(c.BACKDROP_TRANSITION_DURATION) : g();\n    } else b && b();\n  }, c.prototype.handleUpdate = function () {\n    this.adjustDialog();\n  }, c.prototype.adjustDialog = function () {\n    var a = this.$element[0].scrollHeight > document.documentElement.clientHeight;this.$element.css({ paddingLeft: !this.bodyIsOverflowing && a ? this.scrollbarWidth : \"\", paddingRight: this.bodyIsOverflowing && !a ? this.scrollbarWidth : \"\" });\n  }, c.prototype.resetAdjustments = function () {\n    this.$element.css({ paddingLeft: \"\", paddingRight: \"\" });\n  }, c.prototype.checkScrollbar = function () {\n    var a = window.innerWidth;if (!a) {\n      var b = document.documentElement.getBoundingClientRect();a = b.right - Math.abs(b.left);\n    }this.bodyIsOverflowing = document.body.clientWidth < a, this.scrollbarWidth = this.measureScrollbar();\n  }, c.prototype.setScrollbar = function () {\n    var a = parseInt(this.$body.css(\"padding-right\") || 0, 10);this.originalBodyPad = document.body.style.paddingRight || \"\", this.bodyIsOverflowing && this.$body.css(\"padding-right\", a + this.scrollbarWidth);\n  }, c.prototype.resetScrollbar = function () {\n    this.$body.css(\"padding-right\", this.originalBodyPad);\n  }, c.prototype.measureScrollbar = function () {\n    var a = document.createElement(\"div\");a.className = \"modal-scrollbar-measure\", this.$body.append(a);var b = a.offsetWidth - a.clientWidth;return this.$body[0].removeChild(a), b;\n  };var d = a.fn.modal;a.fn.modal = b, a.fn.modal.Constructor = c, a.fn.modal.noConflict = function () {\n    return a.fn.modal = d, this;\n  }, a(document).on(\"click.bs.modal.data-api\", '[data-toggle=\"modal\"]', function (c) {\n    var d = a(this),\n        e = d.attr(\"href\"),\n        f = a(d.attr(\"data-target\") || e && e.replace(/.*(?=#[^\\s]+$)/, \"\")),\n        g = f.data(\"bs.modal\") ? \"toggle\" : a.extend({ remote: !/#/.test(e) && e }, f.data(), d.data());d.is(\"a\") && c.preventDefault(), f.one(\"show.bs.modal\", function (a) {\n      a.isDefaultPrevented() || f.one(\"hidden.bs.modal\", function () {\n        d.is(\":visible\") && d.trigger(\"focus\");\n      });\n    }), b.call(f, g, this);\n  });\n}(jQuery), +function (a) {\n  \"use strict\";\n  function b(b) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data(\"bs.tooltip\"),\n          f = \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && b;(e || !/destroy|hide/.test(b)) && (e || d.data(\"bs.tooltip\", e = new c(this, f)), \"string\" == typeof b && e[b]());\n    });\n  }var c = function c(a, b) {\n    this.type = null, this.options = null, this.enabled = null, this.timeout = null, this.hoverState = null, this.$element = null, this.inState = null, this.init(\"tooltip\", a, b);\n  };c.VERSION = \"3.3.5\", c.TRANSITION_DURATION = 150, c.DEFAULTS = { animation: !0, placement: \"top\", selector: !1, template: '<div class=\"tooltip\" role=\"tooltip\"><div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div></div>', trigger: \"hover focus\", title: \"\", delay: 0, html: !1, container: !1, viewport: { selector: \"body\", padding: 0 } }, c.prototype.init = function (b, c, d) {\n    if (this.enabled = !0, this.type = b, this.$element = a(c), this.options = this.getOptions(d), this.$viewport = this.options.viewport && a(a.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport), this.inState = { click: !1, hover: !1, focus: !1 }, this.$element[0] instanceof document.constructor && !this.options.selector) throw new Error(\"`selector` option must be specified when initializing \" + this.type + \" on the window.document object!\");for (var e = this.options.trigger.split(\" \"), f = e.length; f--;) {\n      var g = e[f];if (\"click\" == g) this.$element.on(\"click.\" + this.type, this.options.selector, a.proxy(this.toggle, this));else if (\"manual\" != g) {\n        var h = \"hover\" == g ? \"mouseenter\" : \"focusin\",\n            i = \"hover\" == g ? \"mouseleave\" : \"focusout\";this.$element.on(h + \".\" + this.type, this.options.selector, a.proxy(this.enter, this)), this.$element.on(i + \".\" + this.type, this.options.selector, a.proxy(this.leave, this));\n      }\n    }this.options.selector ? this._options = a.extend({}, this.options, { trigger: \"manual\", selector: \"\" }) : this.fixTitle();\n  }, c.prototype.getDefaults = function () {\n    return c.DEFAULTS;\n  }, c.prototype.getOptions = function (b) {\n    return b = a.extend({}, this.getDefaults(), this.$element.data(), b), b.delay && \"number\" == typeof b.delay && (b.delay = { show: b.delay, hide: b.delay }), b;\n  }, c.prototype.getDelegateOptions = function () {\n    var b = {},\n        c = this.getDefaults();return this._options && a.each(this._options, function (a, d) {\n      c[a] != d && (b[a] = d);\n    }), b;\n  }, c.prototype.enter = function (b) {\n    var c = b instanceof this.constructor ? b : a(b.currentTarget).data(\"bs.\" + this.type);return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data(\"bs.\" + this.type, c)), b instanceof a.Event && (c.inState[\"focusin\" == b.type ? \"focus\" : \"hover\"] = !0), c.tip().hasClass(\"in\") || \"in\" == c.hoverState ? void (c.hoverState = \"in\") : (clearTimeout(c.timeout), c.hoverState = \"in\", c.options.delay && c.options.delay.show ? void (c.timeout = setTimeout(function () {\n      \"in\" == c.hoverState && c.show();\n    }, c.options.delay.show)) : c.show());\n  }, c.prototype.isInStateTrue = function () {\n    for (var a in this.inState) {\n      if (this.inState[a]) return !0;\n    }return !1;\n  }, c.prototype.leave = function (b) {\n    var c = b instanceof this.constructor ? b : a(b.currentTarget).data(\"bs.\" + this.type);return c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data(\"bs.\" + this.type, c)), b instanceof a.Event && (c.inState[\"focusout\" == b.type ? \"focus\" : \"hover\"] = !1), c.isInStateTrue() ? void 0 : (clearTimeout(c.timeout), c.hoverState = \"out\", c.options.delay && c.options.delay.hide ? void (c.timeout = setTimeout(function () {\n      \"out\" == c.hoverState && c.hide();\n    }, c.options.delay.hide)) : c.hide());\n  }, c.prototype.show = function () {\n    var b = a.Event(\"show.bs.\" + this.type);if (this.hasContent() && this.enabled) {\n      this.$element.trigger(b);var d = a.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);if (b.isDefaultPrevented() || !d) return;var e = this,\n          f = this.tip(),\n          g = this.getUID(this.type);this.setContent(), f.attr(\"id\", g), this.$element.attr(\"aria-describedby\", g), this.options.animation && f.addClass(\"fade\");var h = \"function\" == typeof this.options.placement ? this.options.placement.call(this, f[0], this.$element[0]) : this.options.placement,\n          i = /\\s?auto?\\s?/i,\n          j = i.test(h);j && (h = h.replace(i, \"\") || \"top\"), f.detach().css({ top: 0, left: 0, display: \"block\" }).addClass(h).data(\"bs.\" + this.type, this), this.options.container ? f.appendTo(this.options.container) : f.insertAfter(this.$element), this.$element.trigger(\"inserted.bs.\" + this.type);var k = this.getPosition(),\n          l = f[0].offsetWidth,\n          m = f[0].offsetHeight;if (j) {\n        var n = h,\n            o = this.getPosition(this.$viewport);h = \"bottom\" == h && k.bottom + m > o.bottom ? \"top\" : \"top\" == h && k.top - m < o.top ? \"bottom\" : \"right\" == h && k.right + l > o.width ? \"left\" : \"left\" == h && k.left - l < o.left ? \"right\" : h, f.removeClass(n).addClass(h);\n      }var p = this.getCalculatedOffset(h, k, l, m);this.applyPlacement(p, h);var q = function q() {\n        var a = e.hoverState;e.$element.trigger(\"shown.bs.\" + e.type), e.hoverState = null, \"out\" == a && e.leave(e);\n      };a.support.transition && this.$tip.hasClass(\"fade\") ? f.one(\"bsTransitionEnd\", q).emulateTransitionEnd(c.TRANSITION_DURATION) : q();\n    }\n  }, c.prototype.applyPlacement = function (b, c) {\n    var d = this.tip(),\n        e = d[0].offsetWidth,\n        f = d[0].offsetHeight,\n        g = parseInt(d.css(\"margin-top\"), 10),\n        h = parseInt(d.css(\"margin-left\"), 10);isNaN(g) && (g = 0), isNaN(h) && (h = 0), b.top += g, b.left += h, a.offset.setOffset(d[0], a.extend({ using: function using(a) {\n        d.css({ top: Math.round(a.top), left: Math.round(a.left) });\n      } }, b), 0), d.addClass(\"in\");var i = d[0].offsetWidth,\n        j = d[0].offsetHeight;\"top\" == c && j != f && (b.top = b.top + f - j);var k = this.getViewportAdjustedDelta(c, b, i, j);k.left ? b.left += k.left : b.top += k.top;var l = /top|bottom/.test(c),\n        m = l ? 2 * k.left - e + i : 2 * k.top - f + j,\n        n = l ? \"offsetWidth\" : \"offsetHeight\";d.offset(b), this.replaceArrow(m, d[0][n], l);\n  }, c.prototype.replaceArrow = function (a, b, c) {\n    this.arrow().css(c ? \"left\" : \"top\", 50 * (1 - a / b) + \"%\").css(c ? \"top\" : \"left\", \"\");\n  }, c.prototype.setContent = function () {\n    var a = this.tip(),\n        b = this.getTitle();a.find(\".tooltip-inner\")[this.options.html ? \"html\" : \"text\"](b), a.removeClass(\"fade in top bottom left right\");\n  }, c.prototype.hide = function (b) {\n    function d() {\n      \"in\" != e.hoverState && f.detach(), e.$element.removeAttr(\"aria-describedby\").trigger(\"hidden.bs.\" + e.type), b && b();\n    }var e = this,\n        f = a(this.$tip),\n        g = a.Event(\"hide.bs.\" + this.type);return this.$element.trigger(g), g.isDefaultPrevented() ? void 0 : (f.removeClass(\"in\"), a.support.transition && f.hasClass(\"fade\") ? f.one(\"bsTransitionEnd\", d).emulateTransitionEnd(c.TRANSITION_DURATION) : d(), this.hoverState = null, this);\n  }, c.prototype.fixTitle = function () {\n    var a = this.$element;(a.attr(\"title\") || \"string\" != typeof a.attr(\"data-original-title\")) && a.attr(\"data-original-title\", a.attr(\"title\") || \"\").attr(\"title\", \"\");\n  }, c.prototype.hasContent = function () {\n    return this.getTitle();\n  }, c.prototype.getPosition = function (b) {\n    b = b || this.$element;var c = b[0],\n        d = \"BODY\" == c.tagName,\n        e = c.getBoundingClientRect();null == e.width && (e = a.extend({}, e, { width: e.right - e.left, height: e.bottom - e.top }));var f = d ? { top: 0, left: 0 } : b.offset(),\n        g = { scroll: d ? document.documentElement.scrollTop || document.body.scrollTop : b.scrollTop() },\n        h = d ? { width: a(window).width(), height: a(window).height() } : null;return a.extend({}, e, g, h, f);\n  }, c.prototype.getCalculatedOffset = function (a, b, c, d) {\n    return \"bottom\" == a ? { top: b.top + b.height, left: b.left + b.width / 2 - c / 2 } : \"top\" == a ? { top: b.top - d, left: b.left + b.width / 2 - c / 2 } : \"left\" == a ? { top: b.top + b.height / 2 - d / 2, left: b.left - c } : { top: b.top + b.height / 2 - d / 2, left: b.left + b.width };\n  }, c.prototype.getViewportAdjustedDelta = function (a, b, c, d) {\n    var e = { top: 0, left: 0 };if (!this.$viewport) return e;var f = this.options.viewport && this.options.viewport.padding || 0,\n        g = this.getPosition(this.$viewport);if (/right|left/.test(a)) {\n      var h = b.top - f - g.scroll,\n          i = b.top + f - g.scroll + d;h < g.top ? e.top = g.top - h : i > g.top + g.height && (e.top = g.top + g.height - i);\n    } else {\n      var j = b.left - f,\n          k = b.left + f + c;j < g.left ? e.left = g.left - j : k > g.right && (e.left = g.left + g.width - k);\n    }return e;\n  }, c.prototype.getTitle = function () {\n    var a,\n        b = this.$element,\n        c = this.options;return a = b.attr(\"data-original-title\") || (\"function\" == typeof c.title ? c.title.call(b[0]) : c.title);\n  }, c.prototype.getUID = function (a) {\n    do {\n      a += ~~(1e6 * Math.random());\n    } while (document.getElementById(a));return a;\n  }, c.prototype.tip = function () {\n    if (!this.$tip && (this.$tip = a(this.options.template), 1 != this.$tip.length)) throw new Error(this.type + \" `template` option must consist of exactly 1 top-level element!\");return this.$tip;\n  }, c.prototype.arrow = function () {\n    return this.$arrow = this.$arrow || this.tip().find(\".tooltip-arrow\");\n  }, c.prototype.enable = function () {\n    this.enabled = !0;\n  }, c.prototype.disable = function () {\n    this.enabled = !1;\n  }, c.prototype.toggleEnabled = function () {\n    this.enabled = !this.enabled;\n  }, c.prototype.toggle = function (b) {\n    var c = this;b && (c = a(b.currentTarget).data(\"bs.\" + this.type), c || (c = new this.constructor(b.currentTarget, this.getDelegateOptions()), a(b.currentTarget).data(\"bs.\" + this.type, c))), b ? (c.inState.click = !c.inState.click, c.isInStateTrue() ? c.enter(c) : c.leave(c)) : c.tip().hasClass(\"in\") ? c.leave(c) : c.enter(c);\n  }, c.prototype.destroy = function () {\n    var a = this;clearTimeout(this.timeout), this.hide(function () {\n      a.$element.off(\".\" + a.type).removeData(\"bs.\" + a.type), a.$tip && a.$tip.detach(), a.$tip = null, a.$arrow = null, a.$viewport = null;\n    });\n  };var d = a.fn.tooltip;a.fn.tooltip = b, a.fn.tooltip.Constructor = c, a.fn.tooltip.noConflict = function () {\n    return a.fn.tooltip = d, this;\n  };\n}(jQuery), +function (a) {\n  \"use strict\";\n  function b(b) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data(\"bs.popover\"),\n          f = \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && b;(e || !/destroy|hide/.test(b)) && (e || d.data(\"bs.popover\", e = new c(this, f)), \"string\" == typeof b && e[b]());\n    });\n  }var c = function c(a, b) {\n    this.init(\"popover\", a, b);\n  };if (!a.fn.tooltip) throw new Error(\"Popover requires tooltip.js\");c.VERSION = \"3.3.5\", c.DEFAULTS = a.extend({}, a.fn.tooltip.Constructor.DEFAULTS, { placement: \"right\", trigger: \"click\", content: \"\", template: '<div class=\"popover\" role=\"tooltip\"><div class=\"arrow\"></div><h3 class=\"popover-title\"></h3><div class=\"popover-content\"></div></div>' }), c.prototype = a.extend({}, a.fn.tooltip.Constructor.prototype), c.prototype.constructor = c, c.prototype.getDefaults = function () {\n    return c.DEFAULTS;\n  }, c.prototype.setContent = function () {\n    var a = this.tip(),\n        b = this.getTitle(),\n        c = this.getContent();a.find(\".popover-title\")[this.options.html ? \"html\" : \"text\"](b), a.find(\".popover-content\").children().detach().end()[this.options.html ? \"string\" == typeof c ? \"html\" : \"append\" : \"text\"](c), a.removeClass(\"fade top bottom left right in\"), a.find(\".popover-title\").html() || a.find(\".popover-title\").hide();\n  }, c.prototype.hasContent = function () {\n    return this.getTitle() || this.getContent();\n  }, c.prototype.getContent = function () {\n    var a = this.$element,\n        b = this.options;return a.attr(\"data-content\") || (\"function\" == typeof b.content ? b.content.call(a[0]) : b.content);\n  }, c.prototype.arrow = function () {\n    return this.$arrow = this.$arrow || this.tip().find(\".arrow\");\n  };var d = a.fn.popover;a.fn.popover = b, a.fn.popover.Constructor = c, a.fn.popover.noConflict = function () {\n    return a.fn.popover = d, this;\n  };\n}(jQuery), +function (a) {\n  \"use strict\";\n  function b(c, d) {\n    this.$body = a(document.body), this.$scrollElement = a(a(c).is(document.body) ? window : c), this.options = a.extend({}, b.DEFAULTS, d), this.selector = (this.options.target || \"\") + \" .nav li > a\", this.offsets = [], this.targets = [], this.activeTarget = null, this.scrollHeight = 0, this.$scrollElement.on(\"scroll.bs.scrollspy\", a.proxy(this.process, this)), this.refresh(), this.process();\n  }function c(c) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data(\"bs.scrollspy\"),\n          f = \"object\" == (typeof c === \"undefined\" ? \"undefined\" : _typeof(c)) && c;e || d.data(\"bs.scrollspy\", e = new b(this, f)), \"string\" == typeof c && e[c]();\n    });\n  }b.VERSION = \"3.3.5\", b.DEFAULTS = { offset: 10 }, b.prototype.getScrollHeight = function () {\n    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);\n  }, b.prototype.refresh = function () {\n    var b = this,\n        c = \"offset\",\n        d = 0;this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(), a.isWindow(this.$scrollElement[0]) || (c = \"position\", d = this.$scrollElement.scrollTop()), this.$body.find(this.selector).map(function () {\n      var b = a(this),\n          e = b.data(\"target\") || b.attr(\"href\"),\n          f = /^#./.test(e) && a(e);return f && f.length && f.is(\":visible\") && [[f[c]().top + d, e]] || null;\n    }).sort(function (a, b) {\n      return a[0] - b[0];\n    }).each(function () {\n      b.offsets.push(this[0]), b.targets.push(this[1]);\n    });\n  }, b.prototype.process = function () {\n    var a,\n        b = this.$scrollElement.scrollTop() + this.options.offset,\n        c = this.getScrollHeight(),\n        d = this.options.offset + c - this.$scrollElement.height(),\n        e = this.offsets,\n        f = this.targets,\n        g = this.activeTarget;if (this.scrollHeight != c && this.refresh(), b >= d) return g != (a = f[f.length - 1]) && this.activate(a);if (g && b < e[0]) return this.activeTarget = null, this.clear();for (a = e.length; a--;) {\n      g != f[a] && b >= e[a] && (void 0 === e[a + 1] || b < e[a + 1]) && this.activate(f[a]);\n    }\n  }, b.prototype.activate = function (b) {\n    this.activeTarget = b, this.clear();var c = this.selector + '[data-target=\"' + b + '\"],' + this.selector + '[href=\"' + b + '\"]',\n        d = a(c).parents(\"li\").addClass(\"active\");d.parent(\".dropdown-menu\").length && (d = d.closest(\"li.dropdown\").addClass(\"active\")), d.trigger(\"activate.bs.scrollspy\");\n  }, b.prototype.clear = function () {\n    a(this.selector).parentsUntil(this.options.target, \".active\").removeClass(\"active\");\n  };var d = a.fn.scrollspy;a.fn.scrollspy = c, a.fn.scrollspy.Constructor = b, a.fn.scrollspy.noConflict = function () {\n    return a.fn.scrollspy = d, this;\n  }, a(window).on(\"load.bs.scrollspy.data-api\", function () {\n    a('[data-spy=\"scroll\"]').each(function () {\n      var b = a(this);c.call(b, b.data());\n    });\n  });\n}(jQuery), +function (a) {\n  \"use strict\";\n  function b(b) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data(\"bs.tab\");e || d.data(\"bs.tab\", e = new c(this)), \"string\" == typeof b && e[b]();\n    });\n  }var c = function c(b) {\n    this.element = a(b);\n  };c.VERSION = \"3.3.5\", c.TRANSITION_DURATION = 150, c.prototype.show = function () {\n    var b = this.element,\n        c = b.closest(\"ul:not(.dropdown-menu)\"),\n        d = b.data(\"target\");if (d || (d = b.attr(\"href\"), d = d && d.replace(/.*(?=#[^\\s]*$)/, \"\")), !b.parent(\"li\").hasClass(\"active\")) {\n      var e = c.find(\".active:last a\"),\n          f = a.Event(\"hide.bs.tab\", { relatedTarget: b[0] }),\n          g = a.Event(\"show.bs.tab\", { relatedTarget: e[0] });if (e.trigger(f), b.trigger(g), !g.isDefaultPrevented() && !f.isDefaultPrevented()) {\n        var h = a(d);this.activate(b.closest(\"li\"), c), this.activate(h, h.parent(), function () {\n          e.trigger({ type: \"hidden.bs.tab\", relatedTarget: b[0] }), b.trigger({ type: \"shown.bs.tab\", relatedTarget: e[0] });\n        });\n      }\n    }\n  }, c.prototype.activate = function (b, d, e) {\n    function f() {\n      g.removeClass(\"active\").find(\"> .dropdown-menu > .active\").removeClass(\"active\").end().find('[data-toggle=\"tab\"]').attr(\"aria-expanded\", !1), b.addClass(\"active\").find('[data-toggle=\"tab\"]').attr(\"aria-expanded\", !0), h ? (b[0].offsetWidth, b.addClass(\"in\")) : b.removeClass(\"fade\"), b.parent(\".dropdown-menu\").length && b.closest(\"li.dropdown\").addClass(\"active\").end().find('[data-toggle=\"tab\"]').attr(\"aria-expanded\", !0), e && e();\n    }var g = d.find(\"> .active\"),\n        h = e && a.support.transition && (g.length && g.hasClass(\"fade\") || !!d.find(\"> .fade\").length);g.length && h ? g.one(\"bsTransitionEnd\", f).emulateTransitionEnd(c.TRANSITION_DURATION) : f(), g.removeClass(\"in\");\n  };var d = a.fn.tab;a.fn.tab = b, a.fn.tab.Constructor = c, a.fn.tab.noConflict = function () {\n    return a.fn.tab = d, this;\n  };var e = function e(c) {\n    c.preventDefault(), b.call(a(this), \"show\");\n  };a(document).on(\"click.bs.tab.data-api\", '[data-toggle=\"tab\"]', e).on(\"click.bs.tab.data-api\", '[data-toggle=\"pill\"]', e);\n}(jQuery), +function (a) {\n  \"use strict\";\n  function b(b) {\n    return this.each(function () {\n      var d = a(this),\n          e = d.data(\"bs.affix\"),\n          f = \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && b;e || d.data(\"bs.affix\", e = new c(this, f)), \"string\" == typeof b && e[b]();\n    });\n  }var c = function c(b, d) {\n    this.options = a.extend({}, c.DEFAULTS, d), this.$target = a(this.options.target).on(\"scroll.bs.affix.data-api\", a.proxy(this.checkPosition, this)).on(\"click.bs.affix.data-api\", a.proxy(this.checkPositionWithEventLoop, this)), this.$element = a(b), this.affixed = null, this.unpin = null, this.pinnedOffset = null, this.checkPosition();\n  };c.VERSION = \"3.3.5\", c.RESET = \"affix affix-top affix-bottom\", c.DEFAULTS = { offset: 0, target: window }, c.prototype.getState = function (a, b, c, d) {\n    var e = this.$target.scrollTop(),\n        f = this.$element.offset(),\n        g = this.$target.height();if (null != c && \"top\" == this.affixed) return c > e ? \"top\" : !1;if (\"bottom\" == this.affixed) return null != c ? e + this.unpin <= f.top ? !1 : \"bottom\" : a - d >= e + g ? !1 : \"bottom\";var h = null == this.affixed,\n        i = h ? e : f.top,\n        j = h ? g : b;return null != c && c >= e ? \"top\" : null != d && i + j >= a - d ? \"bottom\" : !1;\n  }, c.prototype.getPinnedOffset = function () {\n    if (this.pinnedOffset) return this.pinnedOffset;this.$element.removeClass(c.RESET).addClass(\"affix\");var a = this.$target.scrollTop(),\n        b = this.$element.offset();return this.pinnedOffset = b.top - a;\n  }, c.prototype.checkPositionWithEventLoop = function () {\n    setTimeout(a.proxy(this.checkPosition, this), 1);\n  }, c.prototype.checkPosition = function () {\n    if (this.$element.is(\":visible\")) {\n      var b = this.$element.height(),\n          d = this.options.offset,\n          e = d.top,\n          f = d.bottom,\n          g = Math.max(a(document).height(), a(document.body).height());\"object\" != (typeof d === \"undefined\" ? \"undefined\" : _typeof(d)) && (f = e = d), \"function\" == typeof e && (e = d.top(this.$element)), \"function\" == typeof f && (f = d.bottom(this.$element));var h = this.getState(g, b, e, f);if (this.affixed != h) {\n        null != this.unpin && this.$element.css(\"top\", \"\");var i = \"affix\" + (h ? \"-\" + h : \"\"),\n            j = a.Event(i + \".bs.affix\");if (this.$element.trigger(j), j.isDefaultPrevented()) return;this.affixed = h, this.unpin = \"bottom\" == h ? this.getPinnedOffset() : null, this.$element.removeClass(c.RESET).addClass(i).trigger(i.replace(\"affix\", \"affixed\") + \".bs.affix\");\n      }\"bottom\" == h && this.$element.offset({ top: g - b - f });\n    }\n  };var d = a.fn.affix;a.fn.affix = b, a.fn.affix.Constructor = c, a.fn.affix.noConflict = function () {\n    return a.fn.affix = d, this;\n  }, a(window).on(\"load\", function () {\n    a('[data-spy=\"affix\"]').each(function () {\n      var c = a(this),\n          d = c.data();d.offset = d.offset || {}, null != d.offsetBottom && (d.offset.bottom = d.offsetBottom), null != d.offsetTop && (d.offset.top = d.offsetTop), b.call(c, d);\n    });\n  });\n}(jQuery);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvanMvYm9vdHN0cmFwLm1pbi5qcz9iYzA2Il0sIm5hbWVzIjpbImpRdWVyeSIsIkVycm9yIiwiYSIsImIiLCJmbiIsImpxdWVyeSIsInNwbGl0IiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiV2Via2l0VHJhbnNpdGlvbiIsIk1velRyYW5zaXRpb24iLCJPVHJhbnNpdGlvbiIsInRyYW5zaXRpb24iLCJjIiwic3R5bGUiLCJlbmQiLCJlbXVsYXRlVHJhbnNpdGlvbkVuZCIsImQiLCJvbmUiLCJlIiwidHJpZ2dlciIsInN1cHBvcnQiLCJzZXRUaW1lb3V0IiwiZXZlbnQiLCJzcGVjaWFsIiwiYnNUcmFuc2l0aW9uRW5kIiwiYmluZFR5cGUiLCJkZWxlZ2F0ZVR5cGUiLCJoYW5kbGUiLCJ0YXJnZXQiLCJpcyIsImhhbmRsZU9iaiIsImhhbmRsZXIiLCJhcHBseSIsImFyZ3VtZW50cyIsImVhY2giLCJkYXRhIiwiY2FsbCIsIm9uIiwiY2xvc2UiLCJWRVJTSU9OIiwiVFJBTlNJVElPTl9EVVJBVElPTiIsInByb3RvdHlwZSIsImciLCJkZXRhY2giLCJyZW1vdmUiLCJmIiwiYXR0ciIsInJlcGxhY2UiLCJwcmV2ZW50RGVmYXVsdCIsImxlbmd0aCIsImNsb3Nlc3QiLCJFdmVudCIsImlzRGVmYXVsdFByZXZlbnRlZCIsInJlbW92ZUNsYXNzIiwiaGFzQ2xhc3MiLCJhbGVydCIsIkNvbnN0cnVjdG9yIiwibm9Db25mbGljdCIsInRvZ2dsZSIsInNldFN0YXRlIiwiJGVsZW1lbnQiLCJvcHRpb25zIiwiZXh0ZW5kIiwiREVGQVVMVFMiLCJpc0xvYWRpbmciLCJsb2FkaW5nVGV4dCIsInJlc2V0VGV4dCIsInByb3h5IiwiYWRkQ2xhc3MiLCJyZW1vdmVBdHRyIiwiZmluZCIsInByb3AiLCJ0b2dnbGVDbGFzcyIsImJ1dHRvbiIsInRlc3QiLCJ0eXBlIiwic2xpZGUiLCJ0byIsImludGVydmFsIiwicGF1c2UiLCJjeWNsZSIsIiRpbmRpY2F0b3JzIiwicGF1c2VkIiwic2xpZGluZyIsIiRhY3RpdmUiLCIkaXRlbXMiLCJrZXlib2FyZCIsImtleWRvd24iLCJkb2N1bWVudEVsZW1lbnQiLCJ3cmFwIiwidGFnTmFtZSIsIndoaWNoIiwicHJldiIsIm5leHQiLCJjbGVhckludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJnZXRJdGVtSW5kZXgiLCJwYXJlbnQiLCJjaGlsZHJlbiIsImluZGV4IiwiZ2V0SXRlbUZvckRpcmVjdGlvbiIsImVxIiwiaCIsImkiLCJqIiwiayIsInJlbGF0ZWRUYXJnZXQiLCJkaXJlY3Rpb24iLCJsIiwibSIsIm9mZnNldFdpZHRoIiwiam9pbiIsImNhcm91c2VsIiwid2luZG93IiwiJHRyaWdnZXIiLCJpZCIsInRyYW5zaXRpb25pbmciLCIkcGFyZW50IiwiZ2V0UGFyZW50IiwiYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzIiwiZGltZW5zaW9uIiwic2hvdyIsImNhbWVsQ2FzZSIsImhpZGUiLCJvZmZzZXRIZWlnaHQiLCJjb2xsYXBzZSIsImNvbnRhaW5zIiwiaW5zZXJ0QWZ0ZXIiLCJzdG9wUHJvcGFnYXRpb24iLCJkcm9wZG93biIsIiRib2R5IiwiYm9keSIsIiRkaWFsb2ciLCIkYmFja2Ryb3AiLCJpc1Nob3duIiwib3JpZ2luYWxCb2R5UGFkIiwic2Nyb2xsYmFyV2lkdGgiLCJpZ25vcmVCYWNrZHJvcENsaWNrIiwicmVtb3RlIiwibG9hZCIsIkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04iLCJiYWNrZHJvcCIsImNoZWNrU2Nyb2xsYmFyIiwic2V0U2Nyb2xsYmFyIiwiZXNjYXBlIiwicmVzaXplIiwiYXBwZW5kVG8iLCJzY3JvbGxUb3AiLCJhZGp1c3REaWFsb2ciLCJlbmZvcmNlRm9jdXMiLCJvZmYiLCJoaWRlTW9kYWwiLCJoYXMiLCJoYW5kbGVVcGRhdGUiLCJyZXNldEFkanVzdG1lbnRzIiwicmVzZXRTY3JvbGxiYXIiLCJyZW1vdmVCYWNrZHJvcCIsImN1cnJlbnRUYXJnZXQiLCJmb2N1cyIsInNjcm9sbEhlaWdodCIsImNsaWVudEhlaWdodCIsImNzcyIsInBhZGRpbmdMZWZ0IiwiYm9keUlzT3ZlcmZsb3dpbmciLCJwYWRkaW5nUmlnaHQiLCJpbm5lcldpZHRoIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicmlnaHQiLCJNYXRoIiwiYWJzIiwibGVmdCIsImNsaWVudFdpZHRoIiwibWVhc3VyZVNjcm9sbGJhciIsInBhcnNlSW50IiwiY2xhc3NOYW1lIiwiYXBwZW5kIiwicmVtb3ZlQ2hpbGQiLCJtb2RhbCIsImVuYWJsZWQiLCJ0aW1lb3V0IiwiaG92ZXJTdGF0ZSIsImluU3RhdGUiLCJpbml0IiwiYW5pbWF0aW9uIiwicGxhY2VtZW50Iiwic2VsZWN0b3IiLCJ0ZW1wbGF0ZSIsInRpdGxlIiwiZGVsYXkiLCJodG1sIiwiY29udGFpbmVyIiwidmlld3BvcnQiLCJwYWRkaW5nIiwiZ2V0T3B0aW9ucyIsIiR2aWV3cG9ydCIsImlzRnVuY3Rpb24iLCJjbGljayIsImhvdmVyIiwiY29uc3RydWN0b3IiLCJlbnRlciIsImxlYXZlIiwiX29wdGlvbnMiLCJmaXhUaXRsZSIsImdldERlZmF1bHRzIiwiZ2V0RGVsZWdhdGVPcHRpb25zIiwidGlwIiwiY2xlYXJUaW1lb3V0IiwiaXNJblN0YXRlVHJ1ZSIsImhhc0NvbnRlbnQiLCJvd25lckRvY3VtZW50IiwiZ2V0VUlEIiwic2V0Q29udGVudCIsInRvcCIsImRpc3BsYXkiLCJnZXRQb3NpdGlvbiIsIm4iLCJvIiwiYm90dG9tIiwid2lkdGgiLCJwIiwiZ2V0Q2FsY3VsYXRlZE9mZnNldCIsImFwcGx5UGxhY2VtZW50IiwicSIsIiR0aXAiLCJpc05hTiIsIm9mZnNldCIsInNldE9mZnNldCIsInVzaW5nIiwicm91bmQiLCJnZXRWaWV3cG9ydEFkanVzdGVkRGVsdGEiLCJyZXBsYWNlQXJyb3ciLCJhcnJvdyIsImdldFRpdGxlIiwiaGVpZ2h0Iiwic2Nyb2xsIiwicmFuZG9tIiwiZ2V0RWxlbWVudEJ5SWQiLCIkYXJyb3ciLCJlbmFibGUiLCJkaXNhYmxlIiwidG9nZ2xlRW5hYmxlZCIsImRlc3Ryb3kiLCJyZW1vdmVEYXRhIiwidG9vbHRpcCIsImNvbnRlbnQiLCJnZXRDb250ZW50IiwicG9wb3ZlciIsIiRzY3JvbGxFbGVtZW50Iiwib2Zmc2V0cyIsInRhcmdldHMiLCJhY3RpdmVUYXJnZXQiLCJwcm9jZXNzIiwicmVmcmVzaCIsImdldFNjcm9sbEhlaWdodCIsIm1heCIsImlzV2luZG93IiwibWFwIiwic29ydCIsInB1c2giLCJhY3RpdmF0ZSIsImNsZWFyIiwicGFyZW50cyIsInBhcmVudHNVbnRpbCIsInNjcm9sbHNweSIsImVsZW1lbnQiLCJ0YWIiLCIkdGFyZ2V0IiwiY2hlY2tQb3NpdGlvbiIsImNoZWNrUG9zaXRpb25XaXRoRXZlbnRMb29wIiwiYWZmaXhlZCIsInVucGluIiwicGlubmVkT2Zmc2V0IiwiUkVTRVQiLCJnZXRTdGF0ZSIsImdldFBpbm5lZE9mZnNldCIsImFmZml4Iiwib2Zmc2V0Qm90dG9tIiwib2Zmc2V0VG9wIl0sIm1hcHBpbmdzIjoiOztBQUFBOzs7OztBQUtBLElBQUcsZUFBYSxPQUFPQSxNQUF2QixFQUE4QixNQUFNLElBQUlDLEtBQUosQ0FBVSx3Q0FBVixDQUFOLENBQTBELENBQUMsVUFBU0MsQ0FBVCxFQUFXO0FBQUM7QUFBYSxNQUFJQyxJQUFFRCxFQUFFRSxFQUFGLENBQUtDLE1BQUwsQ0FBWUMsS0FBWixDQUFrQixHQUFsQixFQUF1QixDQUF2QixFQUEwQkEsS0FBMUIsQ0FBZ0MsR0FBaEMsQ0FBTixDQUEyQyxJQUFHSCxFQUFFLENBQUYsSUFBSyxDQUFMLElBQVFBLEVBQUUsQ0FBRixJQUFLLENBQWIsSUFBZ0IsS0FBR0EsRUFBRSxDQUFGLENBQUgsSUFBUyxLQUFHQSxFQUFFLENBQUYsQ0FBWixJQUFrQkEsRUFBRSxDQUFGLElBQUssQ0FBMUMsRUFBNEMsTUFBTSxJQUFJRixLQUFKLENBQVUsZ0VBQVYsQ0FBTjtBQUFrRixDQUFsTSxDQUFtTUQsTUFBbk0sQ0FBRCxFQUE0TSxDQUFDLFVB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LENBQXBDLEVBQXNDWCxFQUFFRSxFQUFGLENBQUtnUixLQUFMLENBQVcxTixVQUFYLEdBQXNCLFlBQVU7QUFBQyxXQUFPeEQsRUFBRUUsRUFBRixDQUFLZ1IsS0FBTCxHQUFXblEsQ0FBWCxFQUFhLElBQXBCO0FBQXlCLEdBQWhHLEVBQWlHZixFQUFFZ0gsTUFBRixFQUFVNUUsRUFBVixDQUFhLE1BQWIsRUFBb0IsWUFBVTtBQUFDcEMsTUFBRSxvQkFBRixFQUF3QmlDLElBQXhCLENBQTZCLFlBQVU7QUFBQyxVQUFJdEIsSUFBRVgsRUFBRSxJQUFGLENBQU47QUFBQSxVQUFjZSxJQUFFSixFQUFFdUIsSUFBRixFQUFoQixDQUF5Qm5CLEVBQUVpTixNQUFGLEdBQVNqTixFQUFFaU4sTUFBRixJQUFVLEVBQW5CLEVBQXNCLFFBQU1qTixFQUFFb1EsWUFBUixLQUF1QnBRLEVBQUVpTixNQUFGLENBQVNSLE1BQVQsR0FBZ0J6TSxFQUFFb1EsWUFBekMsQ0FBdEIsRUFBNkUsUUFBTXBRLEVBQUVxUSxTQUFSLEtBQW9CclEsRUFBRWlOLE1BQUYsQ0FBU2IsR0FBVCxHQUFhcE0sRUFBRXFRLFNBQW5DLENBQTdFLEVBQTJIblIsRUFBRWtDLElBQUYsQ0FBT3hCLENBQVAsRUFBU0ksQ0FBVCxDQUEzSDtBQUF1SSxLQUF4TTtBQUEwTSxHQUF6TyxDQUFqRztBQUE0VSxDQUFuMkUsQ0FBbzJFakIsTUFBcDJFLENBRGhuRSIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQm9vdHN0cmFwIHYzLjMuNSAoaHR0cDovL2dldGJvb3RzdHJhcC5jb20pXG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICovXG5pZihcInVuZGVmaW5lZFwiPT10eXBlb2YgalF1ZXJ5KXRocm93IG5ldyBFcnJvcihcIkJvb3RzdHJhcCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgalF1ZXJ5XCIpOytmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjt2YXIgYj1hLmZuLmpxdWVyeS5zcGxpdChcIiBcIilbMF0uc3BsaXQoXCIuXCIpO2lmKGJbMF08MiYmYlsxXTw5fHwxPT1iWzBdJiY5PT1iWzFdJiZiWzJdPDEpdGhyb3cgbmV3IEVycm9yKFwiQm9vdHN0cmFwJ3MgSmF2YVNjcmlwdCByZXF1aXJlcyBqUXVlcnkgdmVyc2lvbiAxLjkuMSBvciBoaWdoZXJcIil9KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYm9vdHN0cmFwXCIpLGI9e1dlYmtpdFRyYW5zaXRpb246XCJ3ZWJraXRUcmFuc2l0aW9uRW5kXCIsTW96VHJhbnNpdGlvbjpcInRyYW5zaXRpb25lbmRcIixPVHJhbnNpdGlvbjpcIm9UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kXCIsdHJhbnNpdGlvbjpcInRyYW5zaXRpb25lbmRcIn07Zm9yKHZhciBjIGluIGIpaWYodm9pZCAwIT09YS5zdHlsZVtjXSlyZXR1cm57ZW5kOmJbY119O3JldHVybiExfWEuZm4uZW11bGF0ZVRyYW5zaXRpb25FbmQ9ZnVuY3Rpb24oYil7dmFyIGM9ITEsZD10aGlzO2EodGhpcykub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsZnVuY3Rpb24oKXtjPSEwfSk7dmFyIGU9ZnVuY3Rpb24oKXtjfHxhKGQpLnRyaWdnZXIoYS5zdXBwb3J0LnRyYW5zaXRpb24uZW5kKX07cmV0dXJuIHNldFRpbWVvdXQoZSxiKSx0aGlzfSxhKGZ1bmN0aW9uKCl7YS5zdXBwb3J0LnRyYW5zaXRpb249YigpLGEuc3VwcG9ydC50cmFuc2l0aW9uJiYoYS5ldmVudC5zcGVjaWFsLmJzVHJhbnNpdGlvbkVuZD17YmluZFR5cGU6YS5zdXBwb3J0LnRyYW5zaXRpb24uZW5kLGRlbGVnYXRlVHlwZTphLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQsaGFuZGxlOmZ1bmN0aW9uKGIpe3JldHVybiBhKGIudGFyZ2V0KS5pcyh0aGlzKT9iLmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTp2b2lkIDB9fSl9KX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGM9YSh0aGlzKSxlPWMuZGF0YShcImJzLmFsZXJ0XCIpO2V8fGMuZGF0YShcImJzLmFsZXJ0XCIsZT1uZXcgZCh0aGlzKSksXCJzdHJpbmdcIj09dHlwZW9mIGImJmVbYl0uY2FsbChjKX0pfXZhciBjPSdbZGF0YS1kaXNtaXNzPVwiYWxlcnRcIl0nLGQ9ZnVuY3Rpb24oYil7YShiKS5vbihcImNsaWNrXCIsYyx0aGlzLmNsb3NlKX07ZC5WRVJTSU9OPVwiMy4zLjVcIixkLlRSQU5TSVRJT05fRFVSQVRJT049MTUwLGQucHJvdG90eXBlLmNsb3NlPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGMoKXtnLmRldGFjaCgpLnRyaWdnZXIoXCJjbG9zZWQuYnMuYWxlcnRcIikucmVtb3ZlKCl9dmFyIGU9YSh0aGlzKSxmPWUuYXR0cihcImRhdGEtdGFyZ2V0XCIpO2Z8fChmPWUuYXR0cihcImhyZWZcIiksZj1mJiZmLnJlcGxhY2UoLy4qKD89I1teXFxzXSokKS8sXCJcIikpO3ZhciBnPWEoZik7YiYmYi5wcmV2ZW50RGVmYXVsdCgpLGcubGVuZ3RofHwoZz1lLmNsb3Nlc3QoXCIuYWxlcnRcIikpLGcudHJpZ2dlcihiPWEuRXZlbnQoXCJjbG9zZS5icy5hbGVydFwiKSksYi5pc0RlZmF1bHRQcmV2ZW50ZWQoKXx8KGcucmVtb3ZlQ2xhc3MoXCJpblwiKSxhLnN1cHBvcnQudHJhbnNpdGlvbiYmZy5oYXNDbGFzcyhcImZhZGVcIik/Zy5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixjKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChkLlRSQU5TSVRJT05fRFVSQVRJT04pOmMoKSl9O3ZhciBlPWEuZm4uYWxlcnQ7YS5mbi5hbGVydD1iLGEuZm4uYWxlcnQuQ29uc3RydWN0b3I9ZCxhLmZuLmFsZXJ0Lm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5hbGVydD1lLHRoaXN9LGEoZG9jdW1lbnQpLm9uKFwiY2xpY2suYnMuYWxlcnQuZGF0YS1hcGlcIixjLGQucHJvdG90eXBlLmNsb3NlKX0oalF1ZXJ5KSwrZnVuY3Rpb24oYSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gYihiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxlPWQuZGF0YShcImJzLmJ1dHRvblwiKSxmPVwib2JqZWN0XCI9PXR5cGVvZiBiJiZiO2V8fGQuZGF0YShcImJzLmJ1dHRvblwiLGU9bmV3IGModGhpcyxmKSksXCJ0b2dnbGVcIj09Yj9lLnRvZ2dsZSgpOmImJmUuc2V0U3RhdGUoYil9KX12YXIgYz1mdW5jdGlvbihiLGQpe3RoaXMuJGVsZW1lbnQ9YShiKSx0aGlzLm9wdGlvbnM9YS5leHRlbmQoe30sYy5ERUZBVUxUUyxkKSx0aGlzLmlzTG9hZGluZz0hMX07Yy5WRVJTSU9OPVwiMy4zLjVcIixjLkRFRkFVTFRTPXtsb2FkaW5nVGV4dDpcImxvYWRpbmcuLi5cIn0sYy5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24oYil7dmFyIGM9XCJkaXNhYmxlZFwiLGQ9dGhpcy4kZWxlbWVudCxlPWQuaXMoXCJpbnB1dFwiKT9cInZhbFwiOlwiaHRtbFwiLGY9ZC5kYXRhKCk7Yis9XCJUZXh0XCIsbnVsbD09Zi5yZXNldFRleHQmJmQuZGF0YShcInJlc2V0VGV4dFwiLGRbZV0oKSksc2V0VGltZW91dChhLnByb3h5KGZ1bmN0aW9uKCl7ZFtlXShudWxsPT1mW2JdP3RoaXMub3B0aW9uc1tiXTpmW2JdKSxcImxvYWRpbmdUZXh0XCI9PWI/KHRoaXMuaXNMb2FkaW5nPSEwLGQuYWRkQ2xhc3MoYykuYXR0cihjLGMpKTp0aGlzLmlzTG9hZGluZyYmKHRoaXMuaXNMb2FkaW5nPSExLGQucmVtb3ZlQ2xhc3MoYykucmVtb3ZlQXR0cihjKSl9LHRoaXMpLDApfSxjLnByb3RvdHlwZS50b2dnbGU9ZnVuY3Rpb24oKXt2YXIgYT0hMCxiPXRoaXMuJGVsZW1lbnQuY2xvc2VzdCgnW2RhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiXScpO2lmKGIubGVuZ3RoKXt2YXIgYz10aGlzLiRlbGVtZW50LmZpbmQoXCJpbnB1dFwiKTtcInJhZGlvXCI9PWMucHJvcChcInR5cGVcIik/KGMucHJvcChcImNoZWNrZWRcIikmJihhPSExKSxiLmZpbmQoXCIuYWN0aXZlXCIpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpLHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoXCJhY3RpdmVcIikpOlwiY2hlY2tib3hcIj09Yy5wcm9wKFwidHlwZVwiKSYmKGMucHJvcChcImNoZWNrZWRcIikhPT10aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwiYWN0aXZlXCIpJiYoYT0hMSksdGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyhcImFjdGl2ZVwiKSksYy5wcm9wKFwiY2hlY2tlZFwiLHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJhY3RpdmVcIikpLGEmJmMudHJpZ2dlcihcImNoYW5nZVwiKX1lbHNlIHRoaXMuJGVsZW1lbnQuYXR0cihcImFyaWEtcHJlc3NlZFwiLCF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwiYWN0aXZlXCIpKSx0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKFwiYWN0aXZlXCIpfTt2YXIgZD1hLmZuLmJ1dHRvbjthLmZuLmJ1dHRvbj1iLGEuZm4uYnV0dG9uLkNvbnN0cnVjdG9yPWMsYS5mbi5idXR0b24ubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLmJ1dHRvbj1kLHRoaXN9LGEoZG9jdW1lbnQpLm9uKFwiY2xpY2suYnMuYnV0dG9uLmRhdGEtYXBpXCIsJ1tkYXRhLXRvZ2dsZV49XCJidXR0b25cIl0nLGZ1bmN0aW9uKGMpe3ZhciBkPWEoYy50YXJnZXQpO2QuaGFzQ2xhc3MoXCJidG5cIil8fChkPWQuY2xvc2VzdChcIi5idG5cIikpLGIuY2FsbChkLFwidG9nZ2xlXCIpLGEoYy50YXJnZXQpLmlzKCdpbnB1dFt0eXBlPVwicmFkaW9cIl0nKXx8YShjLnRhcmdldCkuaXMoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXScpfHxjLnByZXZlbnREZWZhdWx0KCl9KS5vbihcImZvY3VzLmJzLmJ1dHRvbi5kYXRhLWFwaSBibHVyLmJzLmJ1dHRvbi5kYXRhLWFwaVwiLCdbZGF0YS10b2dnbGVePVwiYnV0dG9uXCJdJyxmdW5jdGlvbihiKXthKGIudGFyZ2V0KS5jbG9zZXN0KFwiLmJ0blwiKS50b2dnbGVDbGFzcyhcImZvY3VzXCIsL15mb2N1cyhpbik/JC8udGVzdChiLnR5cGUpKX0pfShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGIpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZD1hKHRoaXMpLGU9ZC5kYXRhKFwiYnMuY2Fyb3VzZWxcIiksZj1hLmV4dGVuZCh7fSxjLkRFRkFVTFRTLGQuZGF0YSgpLFwib2JqZWN0XCI9PXR5cGVvZiBiJiZiKSxnPVwic3RyaW5nXCI9PXR5cGVvZiBiP2I6Zi5zbGlkZTtlfHxkLmRhdGEoXCJicy5jYXJvdXNlbFwiLGU9bmV3IGModGhpcyxmKSksXCJudW1iZXJcIj09dHlwZW9mIGI/ZS50byhiKTpnP2VbZ10oKTpmLmludGVydmFsJiZlLnBhdXNlKCkuY3ljbGUoKX0pfXZhciBjPWZ1bmN0aW9uKGIsYyl7dGhpcy4kZWxlbWVudD1hKGIpLHRoaXMuJGluZGljYXRvcnM9dGhpcy4kZWxlbWVudC5maW5kKFwiLmNhcm91c2VsLWluZGljYXRvcnNcIiksdGhpcy5vcHRpb25zPWMsdGhpcy5wYXVzZWQ9bnVsbCx0aGlzLnNsaWRpbmc9bnVsbCx0aGlzLmludGVydmFsPW51bGwsdGhpcy4kYWN0aXZlPW51bGwsdGhpcy4kaXRlbXM9bnVsbCx0aGlzLm9wdGlvbnMua2V5Ym9hcmQmJnRoaXMuJGVsZW1lbnQub24oXCJrZXlkb3duLmJzLmNhcm91c2VsXCIsYS5wcm94eSh0aGlzLmtleWRvd24sdGhpcykpLFwiaG92ZXJcIj09dGhpcy5vcHRpb25zLnBhdXNlJiYhKFwib250b3VjaHN0YXJ0XCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpJiZ0aGlzLiRlbGVtZW50Lm9uKFwibW91c2VlbnRlci5icy5jYXJvdXNlbFwiLGEucHJveHkodGhpcy5wYXVzZSx0aGlzKSkub24oXCJtb3VzZWxlYXZlLmJzLmNhcm91c2VsXCIsYS5wcm94eSh0aGlzLmN5Y2xlLHRoaXMpKX07Yy5WRVJTSU9OPVwiMy4zLjVcIixjLlRSQU5TSVRJT05fRFVSQVRJT049NjAwLGMuREVGQVVMVFM9e2ludGVydmFsOjVlMyxwYXVzZTpcImhvdmVyXCIsd3JhcDohMCxrZXlib2FyZDohMH0sYy5wcm90b3R5cGUua2V5ZG93bj1mdW5jdGlvbihhKXtpZighL2lucHV0fHRleHRhcmVhL2kudGVzdChhLnRhcmdldC50YWdOYW1lKSl7c3dpdGNoKGEud2hpY2gpe2Nhc2UgMzc6dGhpcy5wcmV2KCk7YnJlYWs7Y2FzZSAzOTp0aGlzLm5leHQoKTticmVhaztkZWZhdWx0OnJldHVybn1hLnByZXZlbnREZWZhdWx0KCl9fSxjLnByb3RvdHlwZS5jeWNsZT1mdW5jdGlvbihiKXtyZXR1cm4gYnx8KHRoaXMucGF1c2VkPSExKSx0aGlzLmludGVydmFsJiZjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpLHRoaXMub3B0aW9ucy5pbnRlcnZhbCYmIXRoaXMucGF1c2VkJiYodGhpcy5pbnRlcnZhbD1zZXRJbnRlcnZhbChhLnByb3h5KHRoaXMubmV4dCx0aGlzKSx0aGlzLm9wdGlvbnMuaW50ZXJ2YWwpKSx0aGlzfSxjLnByb3RvdHlwZS5nZXRJdGVtSW5kZXg9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuJGl0ZW1zPWEucGFyZW50KCkuY2hpbGRyZW4oXCIuaXRlbVwiKSx0aGlzLiRpdGVtcy5pbmRleChhfHx0aGlzLiRhY3RpdmUpfSxjLnByb3RvdHlwZS5nZXRJdGVtRm9yRGlyZWN0aW9uPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5nZXRJdGVtSW5kZXgoYiksZD1cInByZXZcIj09YSYmMD09PWN8fFwibmV4dFwiPT1hJiZjPT10aGlzLiRpdGVtcy5sZW5ndGgtMTtpZihkJiYhdGhpcy5vcHRpb25zLndyYXApcmV0dXJuIGI7dmFyIGU9XCJwcmV2XCI9PWE/LTE6MSxmPShjK2UpJXRoaXMuJGl0ZW1zLmxlbmd0aDtyZXR1cm4gdGhpcy4kaXRlbXMuZXEoZil9LGMucHJvdG90eXBlLnRvPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz10aGlzLmdldEl0ZW1JbmRleCh0aGlzLiRhY3RpdmU9dGhpcy4kZWxlbWVudC5maW5kKFwiLml0ZW0uYWN0aXZlXCIpKTtyZXR1cm4gYT50aGlzLiRpdGVtcy5sZW5ndGgtMXx8MD5hP3ZvaWQgMDp0aGlzLnNsaWRpbmc/dGhpcy4kZWxlbWVudC5vbmUoXCJzbGlkLmJzLmNhcm91c2VsXCIsZnVuY3Rpb24oKXtiLnRvKGEpfSk6Yz09YT90aGlzLnBhdXNlKCkuY3ljbGUoKTp0aGlzLnNsaWRlKGE+Yz9cIm5leHRcIjpcInByZXZcIix0aGlzLiRpdGVtcy5lcShhKSl9LGMucHJvdG90eXBlLnBhdXNlPWZ1bmN0aW9uKGIpe3JldHVybiBifHwodGhpcy5wYXVzZWQ9ITApLHRoaXMuJGVsZW1lbnQuZmluZChcIi5uZXh0LCAucHJldlwiKS5sZW5ndGgmJmEuc3VwcG9ydC50cmFuc2l0aW9uJiYodGhpcy4kZWxlbWVudC50cmlnZ2VyKGEuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCksdGhpcy5jeWNsZSghMCkpLHRoaXMuaW50ZXJ2YWw9Y2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsKSx0aGlzfSxjLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2xpZGluZz92b2lkIDA6dGhpcy5zbGlkZShcIm5leHRcIil9LGMucHJvdG90eXBlLnByZXY9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zbGlkaW5nP3ZvaWQgMDp0aGlzLnNsaWRlKFwicHJldlwiKX0sYy5wcm90b3R5cGUuc2xpZGU9ZnVuY3Rpb24oYixkKXt2YXIgZT10aGlzLiRlbGVtZW50LmZpbmQoXCIuaXRlbS5hY3RpdmVcIiksZj1kfHx0aGlzLmdldEl0ZW1Gb3JEaXJlY3Rpb24oYixlKSxnPXRoaXMuaW50ZXJ2YWwsaD1cIm5leHRcIj09Yj9cImxlZnRcIjpcInJpZ2h0XCIsaT10aGlzO2lmKGYuaGFzQ2xhc3MoXCJhY3RpdmVcIikpcmV0dXJuIHRoaXMuc2xpZGluZz0hMTt2YXIgaj1mWzBdLGs9YS5FdmVudChcInNsaWRlLmJzLmNhcm91c2VsXCIse3JlbGF0ZWRUYXJnZXQ6aixkaXJlY3Rpb246aH0pO2lmKHRoaXMuJGVsZW1lbnQudHJpZ2dlcihrKSwhay5pc0RlZmF1bHRQcmV2ZW50ZWQoKSl7aWYodGhpcy5zbGlkaW5nPSEwLGcmJnRoaXMucGF1c2UoKSx0aGlzLiRpbmRpY2F0b3JzLmxlbmd0aCl7dGhpcy4kaW5kaWNhdG9ycy5maW5kKFwiLmFjdGl2ZVwiKS5yZW1vdmVDbGFzcyhcImFjdGl2ZVwiKTt2YXIgbD1hKHRoaXMuJGluZGljYXRvcnMuY2hpbGRyZW4oKVt0aGlzLmdldEl0ZW1JbmRleChmKV0pO2wmJmwuYWRkQ2xhc3MoXCJhY3RpdmVcIil9dmFyIG09YS5FdmVudChcInNsaWQuYnMuY2Fyb3VzZWxcIix7cmVsYXRlZFRhcmdldDpqLGRpcmVjdGlvbjpofSk7cmV0dXJuIGEuc3VwcG9ydC50cmFuc2l0aW9uJiZ0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwic2xpZGVcIik/KGYuYWRkQ2xhc3MoYiksZlswXS5vZmZzZXRXaWR0aCxlLmFkZENsYXNzKGgpLGYuYWRkQ2xhc3MoaCksZS5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixmdW5jdGlvbigpe2YucmVtb3ZlQ2xhc3MoW2IsaF0uam9pbihcIiBcIikpLmFkZENsYXNzKFwiYWN0aXZlXCIpLGUucmVtb3ZlQ2xhc3MoW1wiYWN0aXZlXCIsaF0uam9pbihcIiBcIikpLGkuc2xpZGluZz0hMSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aS4kZWxlbWVudC50cmlnZ2VyKG0pfSwwKX0pLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGMuVFJBTlNJVElPTl9EVVJBVElPTikpOihlLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpLGYuYWRkQ2xhc3MoXCJhY3RpdmVcIiksdGhpcy5zbGlkaW5nPSExLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihtKSksZyYmdGhpcy5jeWNsZSgpLHRoaXN9fTt2YXIgZD1hLmZuLmNhcm91c2VsO2EuZm4uY2Fyb3VzZWw9YixhLmZuLmNhcm91c2VsLkNvbnN0cnVjdG9yPWMsYS5mbi5jYXJvdXNlbC5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4uY2Fyb3VzZWw9ZCx0aGlzfTt2YXIgZT1mdW5jdGlvbihjKXt2YXIgZCxlPWEodGhpcyksZj1hKGUuYXR0cihcImRhdGEtdGFyZ2V0XCIpfHwoZD1lLmF0dHIoXCJocmVmXCIpKSYmZC5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLFwiXCIpKTtpZihmLmhhc0NsYXNzKFwiY2Fyb3VzZWxcIikpe3ZhciBnPWEuZXh0ZW5kKHt9LGYuZGF0YSgpLGUuZGF0YSgpKSxoPWUuYXR0cihcImRhdGEtc2xpZGUtdG9cIik7aCYmKGcuaW50ZXJ2YWw9ITEpLGIuY2FsbChmLGcpLGgmJmYuZGF0YShcImJzLmNhcm91c2VsXCIpLnRvKGgpLGMucHJldmVudERlZmF1bHQoKX19O2EoZG9jdW1lbnQpLm9uKFwiY2xpY2suYnMuY2Fyb3VzZWwuZGF0YS1hcGlcIixcIltkYXRhLXNsaWRlXVwiLGUpLm9uKFwiY2xpY2suYnMuY2Fyb3VzZWwuZGF0YS1hcGlcIixcIltkYXRhLXNsaWRlLXRvXVwiLGUpLGEod2luZG93KS5vbihcImxvYWRcIixmdW5jdGlvbigpe2EoJ1tkYXRhLXJpZGU9XCJjYXJvdXNlbFwiXScpLmVhY2goZnVuY3Rpb24oKXt2YXIgYz1hKHRoaXMpO2IuY2FsbChjLGMuZGF0YSgpKX0pfSl9KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7dmFyIGMsZD1iLmF0dHIoXCJkYXRhLXRhcmdldFwiKXx8KGM9Yi5hdHRyKFwiaHJlZlwiKSkmJmMucmVwbGFjZSgvLiooPz0jW15cXHNdKyQpLyxcIlwiKTtyZXR1cm4gYShkKX1mdW5jdGlvbiBjKGIpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgYz1hKHRoaXMpLGU9Yy5kYXRhKFwiYnMuY29sbGFwc2VcIiksZj1hLmV4dGVuZCh7fSxkLkRFRkFVTFRTLGMuZGF0YSgpLFwib2JqZWN0XCI9PXR5cGVvZiBiJiZiKTshZSYmZi50b2dnbGUmJi9zaG93fGhpZGUvLnRlc3QoYikmJihmLnRvZ2dsZT0hMSksZXx8Yy5kYXRhKFwiYnMuY29sbGFwc2VcIixlPW5ldyBkKHRoaXMsZikpLFwic3RyaW5nXCI9PXR5cGVvZiBiJiZlW2JdKCl9KX12YXIgZD1mdW5jdGlvbihiLGMpe3RoaXMuJGVsZW1lbnQ9YShiKSx0aGlzLm9wdGlvbnM9YS5leHRlbmQoe30sZC5ERUZBVUxUUyxjKSx0aGlzLiR0cmlnZ2VyPWEoJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2hyZWY9XCIjJytiLmlkKydcIl0sW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl1bZGF0YS10YXJnZXQ9XCIjJytiLmlkKydcIl0nKSx0aGlzLnRyYW5zaXRpb25pbmc9bnVsbCx0aGlzLm9wdGlvbnMucGFyZW50P3RoaXMuJHBhcmVudD10aGlzLmdldFBhcmVudCgpOnRoaXMuYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuJGVsZW1lbnQsdGhpcy4kdHJpZ2dlciksdGhpcy5vcHRpb25zLnRvZ2dsZSYmdGhpcy50b2dnbGUoKX07ZC5WRVJTSU9OPVwiMy4zLjVcIixkLlRSQU5TSVRJT05fRFVSQVRJT049MzUwLGQuREVGQVVMVFM9e3RvZ2dsZTohMH0sZC5wcm90b3R5cGUuZGltZW5zaW9uPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcIndpZHRoXCIpO3JldHVybiBhP1wid2lkdGhcIjpcImhlaWdodFwifSxkLnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKCl7aWYoIXRoaXMudHJhbnNpdGlvbmluZyYmIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJpblwiKSl7dmFyIGIsZT10aGlzLiRwYXJlbnQmJnRoaXMuJHBhcmVudC5jaGlsZHJlbihcIi5wYW5lbFwiKS5jaGlsZHJlbihcIi5pbiwgLmNvbGxhcHNpbmdcIik7aWYoIShlJiZlLmxlbmd0aCYmKGI9ZS5kYXRhKFwiYnMuY29sbGFwc2VcIiksYiYmYi50cmFuc2l0aW9uaW5nKSkpe3ZhciBmPWEuRXZlbnQoXCJzaG93LmJzLmNvbGxhcHNlXCIpO2lmKHRoaXMuJGVsZW1lbnQudHJpZ2dlcihmKSwhZi5pc0RlZmF1bHRQcmV2ZW50ZWQoKSl7ZSYmZS5sZW5ndGgmJihjLmNhbGwoZSxcImhpZGVcIiksYnx8ZS5kYXRhKFwiYnMuY29sbGFwc2VcIixudWxsKSk7dmFyIGc9dGhpcy5kaW1lbnNpb24oKTt0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFwiY29sbGFwc2VcIikuYWRkQ2xhc3MoXCJjb2xsYXBzaW5nXCIpW2ddKDApLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITApLHRoaXMuJHRyaWdnZXIucmVtb3ZlQ2xhc3MoXCJjb2xsYXBzZWRcIikuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwhMCksdGhpcy50cmFuc2l0aW9uaW5nPTE7dmFyIGg9ZnVuY3Rpb24oKXt0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFwiY29sbGFwc2luZ1wiKS5hZGRDbGFzcyhcImNvbGxhcHNlIGluXCIpW2ddKFwiXCIpLHRoaXMudHJhbnNpdGlvbmluZz0wLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcInNob3duLmJzLmNvbGxhcHNlXCIpfTtpZighYS5zdXBwb3J0LnRyYW5zaXRpb24pcmV0dXJuIGguY2FsbCh0aGlzKTt2YXIgaT1hLmNhbWVsQ2FzZShbXCJzY3JvbGxcIixnXS5qb2luKFwiLVwiKSk7dGhpcy4kZWxlbWVudC5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixhLnByb3h5KGgsdGhpcykpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGQuVFJBTlNJVElPTl9EVVJBVElPTilbZ10odGhpcy4kZWxlbWVudFswXVtpXSl9fX19LGQucHJvdG90eXBlLmhpZGU9ZnVuY3Rpb24oKXtpZighdGhpcy50cmFuc2l0aW9uaW5nJiZ0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwiaW5cIikpe3ZhciBiPWEuRXZlbnQoXCJoaWRlLmJzLmNvbGxhcHNlXCIpO2lmKHRoaXMuJGVsZW1lbnQudHJpZ2dlcihiKSwhYi5pc0RlZmF1bHRQcmV2ZW50ZWQoKSl7dmFyIGM9dGhpcy5kaW1lbnNpb24oKTt0aGlzLiRlbGVtZW50W2NdKHRoaXMuJGVsZW1lbnRbY10oKSlbMF0ub2Zmc2V0SGVpZ2h0LHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoXCJjb2xsYXBzaW5nXCIpLnJlbW92ZUNsYXNzKFwiY29sbGFwc2UgaW5cIikuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwhMSksdGhpcy4kdHJpZ2dlci5hZGRDbGFzcyhcImNvbGxhcHNlZFwiKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCExKSx0aGlzLnRyYW5zaXRpb25pbmc9MTt2YXIgZT1mdW5jdGlvbigpe3RoaXMudHJhbnNpdGlvbmluZz0wLHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJjb2xsYXBzaW5nXCIpLmFkZENsYXNzKFwiY29sbGFwc2VcIikudHJpZ2dlcihcImhpZGRlbi5icy5jb2xsYXBzZVwiKX07cmV0dXJuIGEuc3VwcG9ydC50cmFuc2l0aW9uP3ZvaWQgdGhpcy4kZWxlbWVudFtjXSgwKS5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixhLnByb3h5KGUsdGhpcykpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGQuVFJBTlNJVElPTl9EVVJBVElPTik6ZS5jYWxsKHRoaXMpfX19LGQucHJvdG90eXBlLnRvZ2dsZT1mdW5jdGlvbigpe3RoaXNbdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhcImluXCIpP1wiaGlkZVwiOlwic2hvd1wiXSgpfSxkLnByb3RvdHlwZS5nZXRQYXJlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gYSh0aGlzLm9wdGlvbnMucGFyZW50KS5maW5kKCdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXBhcmVudD1cIicrdGhpcy5vcHRpb25zLnBhcmVudCsnXCJdJykuZWFjaChhLnByb3h5KGZ1bmN0aW9uKGMsZCl7dmFyIGU9YShkKTt0aGlzLmFkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhiKGUpLGUpfSx0aGlzKSkuZW5kKCl9LGQucHJvdG90eXBlLmFkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcz1mdW5jdGlvbihhLGIpe3ZhciBjPWEuaGFzQ2xhc3MoXCJpblwiKTthLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsYyksYi50b2dnbGVDbGFzcyhcImNvbGxhcHNlZFwiLCFjKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLGMpfTt2YXIgZT1hLmZuLmNvbGxhcHNlO2EuZm4uY29sbGFwc2U9YyxhLmZuLmNvbGxhcHNlLkNvbnN0cnVjdG9yPWQsYS5mbi5jb2xsYXBzZS5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4uY29sbGFwc2U9ZSx0aGlzfSxhKGRvY3VtZW50KS5vbihcImNsaWNrLmJzLmNvbGxhcHNlLmRhdGEtYXBpXCIsJ1tkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdJyxmdW5jdGlvbihkKXt2YXIgZT1hKHRoaXMpO2UuYXR0cihcImRhdGEtdGFyZ2V0XCIpfHxkLnByZXZlbnREZWZhdWx0KCk7dmFyIGY9YihlKSxnPWYuZGF0YShcImJzLmNvbGxhcHNlXCIpLGg9Zz9cInRvZ2dsZVwiOmUuZGF0YSgpO2MuY2FsbChmLGgpfSl9KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7dmFyIGM9Yi5hdHRyKFwiZGF0YS10YXJnZXRcIik7Y3x8KGM9Yi5hdHRyKFwiaHJlZlwiKSxjPWMmJi8jW0EtWmEtel0vLnRlc3QoYykmJmMucmVwbGFjZSgvLiooPz0jW15cXHNdKiQpLyxcIlwiKSk7dmFyIGQ9YyYmYShjKTtyZXR1cm4gZCYmZC5sZW5ndGg/ZDpiLnBhcmVudCgpfWZ1bmN0aW9uIGMoYyl7YyYmMz09PWMud2hpY2h8fChhKGUpLnJlbW92ZSgpLGEoZikuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZT1iKGQpLGY9e3JlbGF0ZWRUYXJnZXQ6dGhpc307ZS5oYXNDbGFzcyhcIm9wZW5cIikmJihjJiZcImNsaWNrXCI9PWMudHlwZSYmL2lucHV0fHRleHRhcmVhL2kudGVzdChjLnRhcmdldC50YWdOYW1lKSYmYS5jb250YWlucyhlWzBdLGMudGFyZ2V0KXx8KGUudHJpZ2dlcihjPWEuRXZlbnQoXCJoaWRlLmJzLmRyb3Bkb3duXCIsZikpLGMuaXNEZWZhdWx0UHJldmVudGVkKCl8fChkLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsXCJmYWxzZVwiKSxlLnJlbW92ZUNsYXNzKFwib3BlblwiKS50cmlnZ2VyKFwiaGlkZGVuLmJzLmRyb3Bkb3duXCIsZikpKSl9KSl9ZnVuY3Rpb24gZChiKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGM9YSh0aGlzKSxkPWMuZGF0YShcImJzLmRyb3Bkb3duXCIpO2R8fGMuZGF0YShcImJzLmRyb3Bkb3duXCIsZD1uZXcgZyh0aGlzKSksXCJzdHJpbmdcIj09dHlwZW9mIGImJmRbYl0uY2FsbChjKX0pfXZhciBlPVwiLmRyb3Bkb3duLWJhY2tkcm9wXCIsZj0nW2RhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIl0nLGc9ZnVuY3Rpb24oYil7YShiKS5vbihcImNsaWNrLmJzLmRyb3Bkb3duXCIsdGhpcy50b2dnbGUpfTtnLlZFUlNJT049XCIzLjMuNVwiLGcucHJvdG90eXBlLnRvZ2dsZT1mdW5jdGlvbihkKXt2YXIgZT1hKHRoaXMpO2lmKCFlLmlzKFwiLmRpc2FibGVkLCA6ZGlzYWJsZWRcIikpe3ZhciBmPWIoZSksZz1mLmhhc0NsYXNzKFwib3BlblwiKTtpZihjKCksIWcpe1wib250b3VjaHN0YXJ0XCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQmJiFmLmNsb3Nlc3QoXCIubmF2YmFyLW5hdlwiKS5sZW5ndGgmJmEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkuYWRkQ2xhc3MoXCJkcm9wZG93bi1iYWNrZHJvcFwiKS5pbnNlcnRBZnRlcihhKHRoaXMpKS5vbihcImNsaWNrXCIsYyk7dmFyIGg9e3JlbGF0ZWRUYXJnZXQ6dGhpc307aWYoZi50cmlnZ2VyKGQ9YS5FdmVudChcInNob3cuYnMuZHJvcGRvd25cIixoKSksZC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSlyZXR1cm47ZS50cmlnZ2VyKFwiZm9jdXNcIikuYXR0cihcImFyaWEtZXhwYW5kZWRcIixcInRydWVcIiksZi50b2dnbGVDbGFzcyhcIm9wZW5cIikudHJpZ2dlcihcInNob3duLmJzLmRyb3Bkb3duXCIsaCl9cmV0dXJuITF9fSxnLnByb3RvdHlwZS5rZXlkb3duPWZ1bmN0aW9uKGMpe2lmKC8oMzh8NDB8Mjd8MzIpLy50ZXN0KGMud2hpY2gpJiYhL2lucHV0fHRleHRhcmVhL2kudGVzdChjLnRhcmdldC50YWdOYW1lKSl7dmFyIGQ9YSh0aGlzKTtpZihjLnByZXZlbnREZWZhdWx0KCksYy5zdG9wUHJvcGFnYXRpb24oKSwhZC5pcyhcIi5kaXNhYmxlZCwgOmRpc2FibGVkXCIpKXt2YXIgZT1iKGQpLGc9ZS5oYXNDbGFzcyhcIm9wZW5cIik7aWYoIWcmJjI3IT1jLndoaWNofHxnJiYyNz09Yy53aGljaClyZXR1cm4gMjc9PWMud2hpY2gmJmUuZmluZChmKS50cmlnZ2VyKFwiZm9jdXNcIiksZC50cmlnZ2VyKFwiY2xpY2tcIik7dmFyIGg9XCIgbGk6bm90KC5kaXNhYmxlZCk6dmlzaWJsZSBhXCIsaT1lLmZpbmQoXCIuZHJvcGRvd24tbWVudVwiK2gpO2lmKGkubGVuZ3RoKXt2YXIgaj1pLmluZGV4KGMudGFyZ2V0KTszOD09Yy53aGljaCYmaj4wJiZqLS0sNDA9PWMud2hpY2gmJmo8aS5sZW5ndGgtMSYmaisrLH5qfHwoaj0wKSxpLmVxKGopLnRyaWdnZXIoXCJmb2N1c1wiKX19fX07dmFyIGg9YS5mbi5kcm9wZG93bjthLmZuLmRyb3Bkb3duPWQsYS5mbi5kcm9wZG93bi5Db25zdHJ1Y3Rvcj1nLGEuZm4uZHJvcGRvd24ubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLmRyb3Bkb3duPWgsdGhpc30sYShkb2N1bWVudCkub24oXCJjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaVwiLGMpLm9uKFwiY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGlcIixcIi5kcm9wZG93biBmb3JtXCIsZnVuY3Rpb24oYSl7YS5zdG9wUHJvcGFnYXRpb24oKX0pLm9uKFwiY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGlcIixmLGcucHJvdG90eXBlLnRvZ2dsZSkub24oXCJrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpXCIsZixnLnByb3RvdHlwZS5rZXlkb3duKS5vbihcImtleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGlcIixcIi5kcm9wZG93bi1tZW51XCIsZy5wcm90b3R5cGUua2V5ZG93bil9KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYixkKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGU9YSh0aGlzKSxmPWUuZGF0YShcImJzLm1vZGFsXCIpLGc9YS5leHRlbmQoe30sYy5ERUZBVUxUUyxlLmRhdGEoKSxcIm9iamVjdFwiPT10eXBlb2YgYiYmYik7Znx8ZS5kYXRhKFwiYnMubW9kYWxcIixmPW5ldyBjKHRoaXMsZykpLFwic3RyaW5nXCI9PXR5cGVvZiBiP2ZbYl0oZCk6Zy5zaG93JiZmLnNob3coZCl9KX12YXIgYz1mdW5jdGlvbihiLGMpe3RoaXMub3B0aW9ucz1jLHRoaXMuJGJvZHk9YShkb2N1bWVudC5ib2R5KSx0aGlzLiRlbGVtZW50PWEoYiksdGhpcy4kZGlhbG9nPXRoaXMuJGVsZW1lbnQuZmluZChcIi5tb2RhbC1kaWFsb2dcIiksdGhpcy4kYmFja2Ryb3A9bnVsbCx0aGlzLmlzU2hvd249bnVsbCx0aGlzLm9yaWdpbmFsQm9keVBhZD1udWxsLHRoaXMuc2Nyb2xsYmFyV2lkdGg9MCx0aGlzLmlnbm9yZUJhY2tkcm9wQ2xpY2s9ITEsdGhpcy5vcHRpb25zLnJlbW90ZSYmdGhpcy4kZWxlbWVudC5maW5kKFwiLm1vZGFsLWNvbnRlbnRcIikubG9hZCh0aGlzLm9wdGlvbnMucmVtb3RlLGEucHJveHkoZnVuY3Rpb24oKXt0aGlzLiRlbGVtZW50LnRyaWdnZXIoXCJsb2FkZWQuYnMubW9kYWxcIil9LHRoaXMpKX07Yy5WRVJTSU9OPVwiMy4zLjVcIixjLlRSQU5TSVRJT05fRFVSQVRJT049MzAwLGMuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTj0xNTAsYy5ERUZBVUxUUz17YmFja2Ryb3A6ITAsa2V5Ym9hcmQ6ITAsc2hvdzohMH0sYy5wcm90b3R5cGUudG9nZ2xlPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmlzU2hvd24/dGhpcy5oaWRlKCk6dGhpcy5zaG93KGEpfSxjLnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKGIpe3ZhciBkPXRoaXMsZT1hLkV2ZW50KFwic2hvdy5icy5tb2RhbFwiLHtyZWxhdGVkVGFyZ2V0OmJ9KTt0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSksdGhpcy5pc1Nob3dufHxlLmlzRGVmYXVsdFByZXZlbnRlZCgpfHwodGhpcy5pc1Nob3duPSEwLHRoaXMuY2hlY2tTY3JvbGxiYXIoKSx0aGlzLnNldFNjcm9sbGJhcigpLHRoaXMuJGJvZHkuYWRkQ2xhc3MoXCJtb2RhbC1vcGVuXCIpLHRoaXMuZXNjYXBlKCksdGhpcy5yZXNpemUoKSx0aGlzLiRlbGVtZW50Lm9uKFwiY2xpY2suZGlzbWlzcy5icy5tb2RhbFwiLCdbZGF0YS1kaXNtaXNzPVwibW9kYWxcIl0nLGEucHJveHkodGhpcy5oaWRlLHRoaXMpKSx0aGlzLiRkaWFsb2cub24oXCJtb3VzZWRvd24uZGlzbWlzcy5icy5tb2RhbFwiLGZ1bmN0aW9uKCl7ZC4kZWxlbWVudC5vbmUoXCJtb3VzZXVwLmRpc21pc3MuYnMubW9kYWxcIixmdW5jdGlvbihiKXthKGIudGFyZ2V0KS5pcyhkLiRlbGVtZW50KSYmKGQuaWdub3JlQmFja2Ryb3BDbGljaz0hMCl9KX0pLHRoaXMuYmFja2Ryb3AoZnVuY3Rpb24oKXt2YXIgZT1hLnN1cHBvcnQudHJhbnNpdGlvbiYmZC4kZWxlbWVudC5oYXNDbGFzcyhcImZhZGVcIik7ZC4kZWxlbWVudC5wYXJlbnQoKS5sZW5ndGh8fGQuJGVsZW1lbnQuYXBwZW5kVG8oZC4kYm9keSksZC4kZWxlbWVudC5zaG93KCkuc2Nyb2xsVG9wKDApLGQuYWRqdXN0RGlhbG9nKCksZSYmZC4kZWxlbWVudFswXS5vZmZzZXRXaWR0aCxkLiRlbGVtZW50LmFkZENsYXNzKFwiaW5cIiksZC5lbmZvcmNlRm9jdXMoKTt2YXIgZj1hLkV2ZW50KFwic2hvd24uYnMubW9kYWxcIix7cmVsYXRlZFRhcmdldDpifSk7ZT9kLiRkaWFsb2cub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsZnVuY3Rpb24oKXtkLiRlbGVtZW50LnRyaWdnZXIoXCJmb2N1c1wiKS50cmlnZ2VyKGYpfSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoYy5UUkFOU0lUSU9OX0RVUkFUSU9OKTpkLiRlbGVtZW50LnRyaWdnZXIoXCJmb2N1c1wiKS50cmlnZ2VyKGYpfSkpfSxjLnByb3RvdHlwZS5oaWRlPWZ1bmN0aW9uKGIpe2ImJmIucHJldmVudERlZmF1bHQoKSxiPWEuRXZlbnQoXCJoaWRlLmJzLm1vZGFsXCIpLHRoaXMuJGVsZW1lbnQudHJpZ2dlcihiKSx0aGlzLmlzU2hvd24mJiFiLmlzRGVmYXVsdFByZXZlbnRlZCgpJiYodGhpcy5pc1Nob3duPSExLHRoaXMuZXNjYXBlKCksdGhpcy5yZXNpemUoKSxhKGRvY3VtZW50KS5vZmYoXCJmb2N1c2luLmJzLm1vZGFsXCIpLHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoXCJpblwiKS5vZmYoXCJjbGljay5kaXNtaXNzLmJzLm1vZGFsXCIpLm9mZihcIm1vdXNldXAuZGlzbWlzcy5icy5tb2RhbFwiKSx0aGlzLiRkaWFsb2cub2ZmKFwibW91c2Vkb3duLmRpc21pc3MuYnMubW9kYWxcIiksYS5zdXBwb3J0LnRyYW5zaXRpb24mJnRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJmYWRlXCIpP3RoaXMuJGVsZW1lbnQub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsYS5wcm94eSh0aGlzLmhpZGVNb2RhbCx0aGlzKSkuZW11bGF0ZVRyYW5zaXRpb25FbmQoYy5UUkFOU0lUSU9OX0RVUkFUSU9OKTp0aGlzLmhpZGVNb2RhbCgpKX0sYy5wcm90b3R5cGUuZW5mb3JjZUZvY3VzPWZ1bmN0aW9uKCl7YShkb2N1bWVudCkub2ZmKFwiZm9jdXNpbi5icy5tb2RhbFwiKS5vbihcImZvY3VzaW4uYnMubW9kYWxcIixhLnByb3h5KGZ1bmN0aW9uKGEpe3RoaXMuJGVsZW1lbnRbMF09PT1hLnRhcmdldHx8dGhpcy4kZWxlbWVudC5oYXMoYS50YXJnZXQpLmxlbmd0aHx8dGhpcy4kZWxlbWVudC50cmlnZ2VyKFwiZm9jdXNcIil9LHRoaXMpKX0sYy5wcm90b3R5cGUuZXNjYXBlPWZ1bmN0aW9uKCl7dGhpcy5pc1Nob3duJiZ0aGlzLm9wdGlvbnMua2V5Ym9hcmQ/dGhpcy4kZWxlbWVudC5vbihcImtleWRvd24uZGlzbWlzcy5icy5tb2RhbFwiLGEucHJveHkoZnVuY3Rpb24oYSl7Mjc9PWEud2hpY2gmJnRoaXMuaGlkZSgpfSx0aGlzKSk6dGhpcy5pc1Nob3dufHx0aGlzLiRlbGVtZW50Lm9mZihcImtleWRvd24uZGlzbWlzcy5icy5tb2RhbFwiKX0sYy5wcm90b3R5cGUucmVzaXplPWZ1bmN0aW9uKCl7dGhpcy5pc1Nob3duP2Eod2luZG93KS5vbihcInJlc2l6ZS5icy5tb2RhbFwiLGEucHJveHkodGhpcy5oYW5kbGVVcGRhdGUsdGhpcykpOmEod2luZG93KS5vZmYoXCJyZXNpemUuYnMubW9kYWxcIil9LGMucHJvdG90eXBlLmhpZGVNb2RhbD1mdW5jdGlvbigpe3ZhciBhPXRoaXM7dGhpcy4kZWxlbWVudC5oaWRlKCksdGhpcy5iYWNrZHJvcChmdW5jdGlvbigpe2EuJGJvZHkucmVtb3ZlQ2xhc3MoXCJtb2RhbC1vcGVuXCIpLGEucmVzZXRBZGp1c3RtZW50cygpLGEucmVzZXRTY3JvbGxiYXIoKSxhLiRlbGVtZW50LnRyaWdnZXIoXCJoaWRkZW4uYnMubW9kYWxcIil9KX0sYy5wcm90b3R5cGUucmVtb3ZlQmFja2Ryb3A9ZnVuY3Rpb24oKXt0aGlzLiRiYWNrZHJvcCYmdGhpcy4kYmFja2Ryb3AucmVtb3ZlKCksdGhpcy4kYmFja2Ryb3A9bnVsbH0sYy5wcm90b3R5cGUuYmFja2Ryb3A9ZnVuY3Rpb24oYil7dmFyIGQ9dGhpcyxlPXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXCJmYWRlXCIpP1wiZmFkZVwiOlwiXCI7aWYodGhpcy5pc1Nob3duJiZ0aGlzLm9wdGlvbnMuYmFja2Ryb3Ape3ZhciBmPWEuc3VwcG9ydC50cmFuc2l0aW9uJiZlO2lmKHRoaXMuJGJhY2tkcm9wPWEoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSkuYWRkQ2xhc3MoXCJtb2RhbC1iYWNrZHJvcCBcIitlKS5hcHBlbmRUbyh0aGlzLiRib2R5KSx0aGlzLiRlbGVtZW50Lm9uKFwiY2xpY2suZGlzbWlzcy5icy5tb2RhbFwiLGEucHJveHkoZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuaWdub3JlQmFja2Ryb3BDbGljaz92b2lkKHRoaXMuaWdub3JlQmFja2Ryb3BDbGljaz0hMSk6dm9pZChhLnRhcmdldD09PWEuY3VycmVudFRhcmdldCYmKFwic3RhdGljXCI9PXRoaXMub3B0aW9ucy5iYWNrZHJvcD90aGlzLiRlbGVtZW50WzBdLmZvY3VzKCk6dGhpcy5oaWRlKCkpKX0sdGhpcykpLGYmJnRoaXMuJGJhY2tkcm9wWzBdLm9mZnNldFdpZHRoLHRoaXMuJGJhY2tkcm9wLmFkZENsYXNzKFwiaW5cIiksIWIpcmV0dXJuO2Y/dGhpcy4kYmFja2Ryb3Aub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsYikuZW11bGF0ZVRyYW5zaXRpb25FbmQoYy5CQUNLRFJPUF9UUkFOU0lUSU9OX0RVUkFUSU9OKTpiKCl9ZWxzZSBpZighdGhpcy5pc1Nob3duJiZ0aGlzLiRiYWNrZHJvcCl7dGhpcy4kYmFja2Ryb3AucmVtb3ZlQ2xhc3MoXCJpblwiKTt2YXIgZz1mdW5jdGlvbigpe2QucmVtb3ZlQmFja2Ryb3AoKSxiJiZiKCl9O2Euc3VwcG9ydC50cmFuc2l0aW9uJiZ0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFwiZmFkZVwiKT90aGlzLiRiYWNrZHJvcC5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixnKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChjLkJBQ0tEUk9QX1RSQU5TSVRJT05fRFVSQVRJT04pOmcoKX1lbHNlIGImJmIoKX0sYy5wcm90b3R5cGUuaGFuZGxlVXBkYXRlPWZ1bmN0aW9uKCl7dGhpcy5hZGp1c3REaWFsb2coKX0sYy5wcm90b3R5cGUuYWRqdXN0RGlhbG9nPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy4kZWxlbWVudFswXS5zY3JvbGxIZWlnaHQ+ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDt0aGlzLiRlbGVtZW50LmNzcyh7cGFkZGluZ0xlZnQ6IXRoaXMuYm9keUlzT3ZlcmZsb3dpbmcmJmE/dGhpcy5zY3JvbGxiYXJXaWR0aDpcIlwiLHBhZGRpbmdSaWdodDp0aGlzLmJvZHlJc092ZXJmbG93aW5nJiYhYT90aGlzLnNjcm9sbGJhcldpZHRoOlwiXCJ9KX0sYy5wcm90b3R5cGUucmVzZXRBZGp1c3RtZW50cz1mdW5jdGlvbigpe3RoaXMuJGVsZW1lbnQuY3NzKHtwYWRkaW5nTGVmdDpcIlwiLHBhZGRpbmdSaWdodDpcIlwifSl9LGMucHJvdG90eXBlLmNoZWNrU2Nyb2xsYmFyPWZ1bmN0aW9uKCl7dmFyIGE9d2luZG93LmlubmVyV2lkdGg7aWYoIWEpe3ZhciBiPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTthPWIucmlnaHQtTWF0aC5hYnMoYi5sZWZ0KX10aGlzLmJvZHlJc092ZXJmbG93aW5nPWRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGg8YSx0aGlzLnNjcm9sbGJhcldpZHRoPXRoaXMubWVhc3VyZVNjcm9sbGJhcigpfSxjLnByb3RvdHlwZS5zZXRTY3JvbGxiYXI9ZnVuY3Rpb24oKXt2YXIgYT1wYXJzZUludCh0aGlzLiRib2R5LmNzcyhcInBhZGRpbmctcmlnaHRcIil8fDAsMTApO3RoaXMub3JpZ2luYWxCb2R5UGFkPWRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0fHxcIlwiLHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcmJnRoaXMuJGJvZHkuY3NzKFwicGFkZGluZy1yaWdodFwiLGErdGhpcy5zY3JvbGxiYXJXaWR0aCl9LGMucHJvdG90eXBlLnJlc2V0U2Nyb2xsYmFyPWZ1bmN0aW9uKCl7dGhpcy4kYm9keS5jc3MoXCJwYWRkaW5nLXJpZ2h0XCIsdGhpcy5vcmlnaW5hbEJvZHlQYWQpfSxjLnByb3RvdHlwZS5tZWFzdXJlU2Nyb2xsYmFyPWZ1bmN0aW9uKCl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTthLmNsYXNzTmFtZT1cIm1vZGFsLXNjcm9sbGJhci1tZWFzdXJlXCIsdGhpcy4kYm9keS5hcHBlbmQoYSk7dmFyIGI9YS5vZmZzZXRXaWR0aC1hLmNsaWVudFdpZHRoO3JldHVybiB0aGlzLiRib2R5WzBdLnJlbW92ZUNoaWxkKGEpLGJ9O3ZhciBkPWEuZm4ubW9kYWw7YS5mbi5tb2RhbD1iLGEuZm4ubW9kYWwuQ29uc3RydWN0b3I9YyxhLmZuLm1vZGFsLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5tb2RhbD1kLHRoaXN9LGEoZG9jdW1lbnQpLm9uKFwiY2xpY2suYnMubW9kYWwuZGF0YS1hcGlcIiwnW2RhdGEtdG9nZ2xlPVwibW9kYWxcIl0nLGZ1bmN0aW9uKGMpe3ZhciBkPWEodGhpcyksZT1kLmF0dHIoXCJocmVmXCIpLGY9YShkLmF0dHIoXCJkYXRhLXRhcmdldFwiKXx8ZSYmZS5yZXBsYWNlKC8uKig/PSNbXlxcc10rJCkvLFwiXCIpKSxnPWYuZGF0YShcImJzLm1vZGFsXCIpP1widG9nZ2xlXCI6YS5leHRlbmQoe3JlbW90ZTohLyMvLnRlc3QoZSkmJmV9LGYuZGF0YSgpLGQuZGF0YSgpKTtkLmlzKFwiYVwiKSYmYy5wcmV2ZW50RGVmYXVsdCgpLGYub25lKFwic2hvdy5icy5tb2RhbFwiLGZ1bmN0aW9uKGEpe2EuaXNEZWZhdWx0UHJldmVudGVkKCl8fGYub25lKFwiaGlkZGVuLmJzLm1vZGFsXCIsZnVuY3Rpb24oKXtkLmlzKFwiOnZpc2libGVcIikmJmQudHJpZ2dlcihcImZvY3VzXCIpfSl9KSxiLmNhbGwoZixnLHRoaXMpfSl9KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZT1kLmRhdGEoXCJicy50b29sdGlwXCIpLGY9XCJvYmplY3RcIj09dHlwZW9mIGImJmI7KGV8fCEvZGVzdHJveXxoaWRlLy50ZXN0KGIpKSYmKGV8fGQuZGF0YShcImJzLnRvb2x0aXBcIixlPW5ldyBjKHRoaXMsZikpLFwic3RyaW5nXCI9PXR5cGVvZiBiJiZlW2JdKCkpfSl9dmFyIGM9ZnVuY3Rpb24oYSxiKXt0aGlzLnR5cGU9bnVsbCx0aGlzLm9wdGlvbnM9bnVsbCx0aGlzLmVuYWJsZWQ9bnVsbCx0aGlzLnRpbWVvdXQ9bnVsbCx0aGlzLmhvdmVyU3RhdGU9bnVsbCx0aGlzLiRlbGVtZW50PW51bGwsdGhpcy5pblN0YXRlPW51bGwsdGhpcy5pbml0KFwidG9vbHRpcFwiLGEsYil9O2MuVkVSU0lPTj1cIjMuMy41XCIsYy5UUkFOU0lUSU9OX0RVUkFUSU9OPTE1MCxjLkRFRkFVTFRTPXthbmltYXRpb246ITAscGxhY2VtZW50OlwidG9wXCIsc2VsZWN0b3I6ITEsdGVtcGxhdGU6JzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj48ZGl2IGNsYXNzPVwidG9vbHRpcC1hcnJvd1wiPjwvZGl2PjxkaXYgY2xhc3M9XCJ0b29sdGlwLWlubmVyXCI+PC9kaXY+PC9kaXY+Jyx0cmlnZ2VyOlwiaG92ZXIgZm9jdXNcIix0aXRsZTpcIlwiLGRlbGF5OjAsaHRtbDohMSxjb250YWluZXI6ITEsdmlld3BvcnQ6e3NlbGVjdG9yOlwiYm9keVwiLHBhZGRpbmc6MH19LGMucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oYixjLGQpe2lmKHRoaXMuZW5hYmxlZD0hMCx0aGlzLnR5cGU9Yix0aGlzLiRlbGVtZW50PWEoYyksdGhpcy5vcHRpb25zPXRoaXMuZ2V0T3B0aW9ucyhkKSx0aGlzLiR2aWV3cG9ydD10aGlzLm9wdGlvbnMudmlld3BvcnQmJmEoYS5pc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy52aWV3cG9ydCk/dGhpcy5vcHRpb25zLnZpZXdwb3J0LmNhbGwodGhpcyx0aGlzLiRlbGVtZW50KTp0aGlzLm9wdGlvbnMudmlld3BvcnQuc2VsZWN0b3J8fHRoaXMub3B0aW9ucy52aWV3cG9ydCksdGhpcy5pblN0YXRlPXtjbGljazohMSxob3ZlcjohMSxmb2N1czohMX0sdGhpcy4kZWxlbWVudFswXWluc3RhbmNlb2YgZG9jdW1lbnQuY29uc3RydWN0b3ImJiF0aGlzLm9wdGlvbnMuc2VsZWN0b3IpdGhyb3cgbmV3IEVycm9yKFwiYHNlbGVjdG9yYCBvcHRpb24gbXVzdCBiZSBzcGVjaWZpZWQgd2hlbiBpbml0aWFsaXppbmcgXCIrdGhpcy50eXBlK1wiIG9uIHRoZSB3aW5kb3cuZG9jdW1lbnQgb2JqZWN0IVwiKTtmb3IodmFyIGU9dGhpcy5vcHRpb25zLnRyaWdnZXIuc3BsaXQoXCIgXCIpLGY9ZS5sZW5ndGg7Zi0tOyl7dmFyIGc9ZVtmXTtpZihcImNsaWNrXCI9PWcpdGhpcy4kZWxlbWVudC5vbihcImNsaWNrLlwiK3RoaXMudHlwZSx0aGlzLm9wdGlvbnMuc2VsZWN0b3IsYS5wcm94eSh0aGlzLnRvZ2dsZSx0aGlzKSk7ZWxzZSBpZihcIm1hbnVhbFwiIT1nKXt2YXIgaD1cImhvdmVyXCI9PWc/XCJtb3VzZWVudGVyXCI6XCJmb2N1c2luXCIsaT1cImhvdmVyXCI9PWc/XCJtb3VzZWxlYXZlXCI6XCJmb2N1c291dFwiO3RoaXMuJGVsZW1lbnQub24oaCtcIi5cIit0aGlzLnR5cGUsdGhpcy5vcHRpb25zLnNlbGVjdG9yLGEucHJveHkodGhpcy5lbnRlcix0aGlzKSksdGhpcy4kZWxlbWVudC5vbihpK1wiLlwiK3RoaXMudHlwZSx0aGlzLm9wdGlvbnMuc2VsZWN0b3IsYS5wcm94eSh0aGlzLmxlYXZlLHRoaXMpKX19dGhpcy5vcHRpb25zLnNlbGVjdG9yP3RoaXMuX29wdGlvbnM9YS5leHRlbmQoe30sdGhpcy5vcHRpb25zLHt0cmlnZ2VyOlwibWFudWFsXCIsc2VsZWN0b3I6XCJcIn0pOnRoaXMuZml4VGl0bGUoKX0sYy5wcm90b3R5cGUuZ2V0RGVmYXVsdHM9ZnVuY3Rpb24oKXtyZXR1cm4gYy5ERUZBVUxUU30sYy5wcm90b3R5cGUuZ2V0T3B0aW9ucz1mdW5jdGlvbihiKXtyZXR1cm4gYj1hLmV4dGVuZCh7fSx0aGlzLmdldERlZmF1bHRzKCksdGhpcy4kZWxlbWVudC5kYXRhKCksYiksYi5kZWxheSYmXCJudW1iZXJcIj09dHlwZW9mIGIuZGVsYXkmJihiLmRlbGF5PXtzaG93OmIuZGVsYXksaGlkZTpiLmRlbGF5fSksYn0sYy5wcm90b3R5cGUuZ2V0RGVsZWdhdGVPcHRpb25zPWZ1bmN0aW9uKCl7dmFyIGI9e30sYz10aGlzLmdldERlZmF1bHRzKCk7cmV0dXJuIHRoaXMuX29wdGlvbnMmJmEuZWFjaCh0aGlzLl9vcHRpb25zLGZ1bmN0aW9uKGEsZCl7Y1thXSE9ZCYmKGJbYV09ZCl9KSxifSxjLnByb3RvdHlwZS5lbnRlcj1mdW5jdGlvbihiKXt2YXIgYz1iIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcj9iOmEoYi5jdXJyZW50VGFyZ2V0KS5kYXRhKFwiYnMuXCIrdGhpcy50eXBlKTtyZXR1cm4gY3x8KGM9bmV3IHRoaXMuY29uc3RydWN0b3IoYi5jdXJyZW50VGFyZ2V0LHRoaXMuZ2V0RGVsZWdhdGVPcHRpb25zKCkpLGEoYi5jdXJyZW50VGFyZ2V0KS5kYXRhKFwiYnMuXCIrdGhpcy50eXBlLGMpKSxiIGluc3RhbmNlb2YgYS5FdmVudCYmKGMuaW5TdGF0ZVtcImZvY3VzaW5cIj09Yi50eXBlP1wiZm9jdXNcIjpcImhvdmVyXCJdPSEwKSxjLnRpcCgpLmhhc0NsYXNzKFwiaW5cIil8fFwiaW5cIj09Yy5ob3ZlclN0YXRlP3ZvaWQoYy5ob3ZlclN0YXRlPVwiaW5cIik6KGNsZWFyVGltZW91dChjLnRpbWVvdXQpLGMuaG92ZXJTdGF0ZT1cImluXCIsYy5vcHRpb25zLmRlbGF5JiZjLm9wdGlvbnMuZGVsYXkuc2hvdz92b2lkKGMudGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XCJpblwiPT1jLmhvdmVyU3RhdGUmJmMuc2hvdygpfSxjLm9wdGlvbnMuZGVsYXkuc2hvdykpOmMuc2hvdygpKX0sYy5wcm90b3R5cGUuaXNJblN0YXRlVHJ1ZT1mdW5jdGlvbigpe2Zvcih2YXIgYSBpbiB0aGlzLmluU3RhdGUpaWYodGhpcy5pblN0YXRlW2FdKXJldHVybiEwO3JldHVybiExfSxjLnByb3RvdHlwZS5sZWF2ZT1mdW5jdGlvbihiKXt2YXIgYz1iIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3Rvcj9iOmEoYi5jdXJyZW50VGFyZ2V0KS5kYXRhKFwiYnMuXCIrdGhpcy50eXBlKTtyZXR1cm4gY3x8KGM9bmV3IHRoaXMuY29uc3RydWN0b3IoYi5jdXJyZW50VGFyZ2V0LHRoaXMuZ2V0RGVsZWdhdGVPcHRpb25zKCkpLGEoYi5jdXJyZW50VGFyZ2V0KS5kYXRhKFwiYnMuXCIrdGhpcy50eXBlLGMpKSxiIGluc3RhbmNlb2YgYS5FdmVudCYmKGMuaW5TdGF0ZVtcImZvY3Vzb3V0XCI9PWIudHlwZT9cImZvY3VzXCI6XCJob3ZlclwiXT0hMSksYy5pc0luU3RhdGVUcnVlKCk/dm9pZCAwOihjbGVhclRpbWVvdXQoYy50aW1lb3V0KSxjLmhvdmVyU3RhdGU9XCJvdXRcIixjLm9wdGlvbnMuZGVsYXkmJmMub3B0aW9ucy5kZWxheS5oaWRlP3ZvaWQoYy50aW1lb3V0PXNldFRpbWVvdXQoZnVuY3Rpb24oKXtcIm91dFwiPT1jLmhvdmVyU3RhdGUmJmMuaGlkZSgpfSxjLm9wdGlvbnMuZGVsYXkuaGlkZSkpOmMuaGlkZSgpKX0sYy5wcm90b3R5cGUuc2hvdz1mdW5jdGlvbigpe3ZhciBiPWEuRXZlbnQoXCJzaG93LmJzLlwiK3RoaXMudHlwZSk7aWYodGhpcy5oYXNDb250ZW50KCkmJnRoaXMuZW5hYmxlZCl7dGhpcy4kZWxlbWVudC50cmlnZ2VyKGIpO3ZhciBkPWEuY29udGFpbnModGhpcy4kZWxlbWVudFswXS5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCx0aGlzLiRlbGVtZW50WzBdKTtpZihiLmlzRGVmYXVsdFByZXZlbnRlZCgpfHwhZClyZXR1cm47dmFyIGU9dGhpcyxmPXRoaXMudGlwKCksZz10aGlzLmdldFVJRCh0aGlzLnR5cGUpO3RoaXMuc2V0Q29udGVudCgpLGYuYXR0cihcImlkXCIsZyksdGhpcy4kZWxlbWVudC5hdHRyKFwiYXJpYS1kZXNjcmliZWRieVwiLGcpLHRoaXMub3B0aW9ucy5hbmltYXRpb24mJmYuYWRkQ2xhc3MoXCJmYWRlXCIpO3ZhciBoPVwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMub3B0aW9ucy5wbGFjZW1lbnQ/dGhpcy5vcHRpb25zLnBsYWNlbWVudC5jYWxsKHRoaXMsZlswXSx0aGlzLiRlbGVtZW50WzBdKTp0aGlzLm9wdGlvbnMucGxhY2VtZW50LGk9L1xccz9hdXRvP1xccz8vaSxqPWkudGVzdChoKTtqJiYoaD1oLnJlcGxhY2UoaSxcIlwiKXx8XCJ0b3BcIiksZi5kZXRhY2goKS5jc3Moe3RvcDowLGxlZnQ6MCxkaXNwbGF5OlwiYmxvY2tcIn0pLmFkZENsYXNzKGgpLmRhdGEoXCJicy5cIit0aGlzLnR5cGUsdGhpcyksdGhpcy5vcHRpb25zLmNvbnRhaW5lcj9mLmFwcGVuZFRvKHRoaXMub3B0aW9ucy5jb250YWluZXIpOmYuaW5zZXJ0QWZ0ZXIodGhpcy4kZWxlbWVudCksdGhpcy4kZWxlbWVudC50cmlnZ2VyKFwiaW5zZXJ0ZWQuYnMuXCIrdGhpcy50eXBlKTt2YXIgaz10aGlzLmdldFBvc2l0aW9uKCksbD1mWzBdLm9mZnNldFdpZHRoLG09ZlswXS5vZmZzZXRIZWlnaHQ7aWYoail7dmFyIG49aCxvPXRoaXMuZ2V0UG9zaXRpb24odGhpcy4kdmlld3BvcnQpO2g9XCJib3R0b21cIj09aCYmay5ib3R0b20rbT5vLmJvdHRvbT9cInRvcFwiOlwidG9wXCI9PWgmJmsudG9wLW08by50b3A/XCJib3R0b21cIjpcInJpZ2h0XCI9PWgmJmsucmlnaHQrbD5vLndpZHRoP1wibGVmdFwiOlwibGVmdFwiPT1oJiZrLmxlZnQtbDxvLmxlZnQ/XCJyaWdodFwiOmgsZi5yZW1vdmVDbGFzcyhuKS5hZGRDbGFzcyhoKX12YXIgcD10aGlzLmdldENhbGN1bGF0ZWRPZmZzZXQoaCxrLGwsbSk7dGhpcy5hcHBseVBsYWNlbWVudChwLGgpO3ZhciBxPWZ1bmN0aW9uKCl7dmFyIGE9ZS5ob3ZlclN0YXRlO2UuJGVsZW1lbnQudHJpZ2dlcihcInNob3duLmJzLlwiK2UudHlwZSksZS5ob3ZlclN0YXRlPW51bGwsXCJvdXRcIj09YSYmZS5sZWF2ZShlKX07YS5zdXBwb3J0LnRyYW5zaXRpb24mJnRoaXMuJHRpcC5oYXNDbGFzcyhcImZhZGVcIik/Zi5vbmUoXCJic1RyYW5zaXRpb25FbmRcIixxKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChjLlRSQU5TSVRJT05fRFVSQVRJT04pOnEoKX19LGMucHJvdG90eXBlLmFwcGx5UGxhY2VtZW50PWZ1bmN0aW9uKGIsYyl7dmFyIGQ9dGhpcy50aXAoKSxlPWRbMF0ub2Zmc2V0V2lkdGgsZj1kWzBdLm9mZnNldEhlaWdodCxnPXBhcnNlSW50KGQuY3NzKFwibWFyZ2luLXRvcFwiKSwxMCksaD1wYXJzZUludChkLmNzcyhcIm1hcmdpbi1sZWZ0XCIpLDEwKTtpc05hTihnKSYmKGc9MCksaXNOYU4oaCkmJihoPTApLGIudG9wKz1nLGIubGVmdCs9aCxhLm9mZnNldC5zZXRPZmZzZXQoZFswXSxhLmV4dGVuZCh7dXNpbmc6ZnVuY3Rpb24oYSl7ZC5jc3Moe3RvcDpNYXRoLnJvdW5kKGEudG9wKSxsZWZ0Ok1hdGgucm91bmQoYS5sZWZ0KX0pfX0sYiksMCksZC5hZGRDbGFzcyhcImluXCIpO3ZhciBpPWRbMF0ub2Zmc2V0V2lkdGgsaj1kWzBdLm9mZnNldEhlaWdodDtcInRvcFwiPT1jJiZqIT1mJiYoYi50b3A9Yi50b3ArZi1qKTt2YXIgaz10aGlzLmdldFZpZXdwb3J0QWRqdXN0ZWREZWx0YShjLGIsaSxqKTtrLmxlZnQ/Yi5sZWZ0Kz1rLmxlZnQ6Yi50b3ArPWsudG9wO3ZhciBsPS90b3B8Ym90dG9tLy50ZXN0KGMpLG09bD8yKmsubGVmdC1lK2k6MiprLnRvcC1mK2osbj1sP1wib2Zmc2V0V2lkdGhcIjpcIm9mZnNldEhlaWdodFwiO2Qub2Zmc2V0KGIpLHRoaXMucmVwbGFjZUFycm93KG0sZFswXVtuXSxsKX0sYy5wcm90b3R5cGUucmVwbGFjZUFycm93PWZ1bmN0aW9uKGEsYixjKXt0aGlzLmFycm93KCkuY3NzKGM/XCJsZWZ0XCI6XCJ0b3BcIiw1MCooMS1hL2IpK1wiJVwiKS5jc3MoYz9cInRvcFwiOlwibGVmdFwiLFwiXCIpfSxjLnByb3RvdHlwZS5zZXRDb250ZW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy50aXAoKSxiPXRoaXMuZ2V0VGl0bGUoKTthLmZpbmQoXCIudG9vbHRpcC1pbm5lclwiKVt0aGlzLm9wdGlvbnMuaHRtbD9cImh0bWxcIjpcInRleHRcIl0oYiksYS5yZW1vdmVDbGFzcyhcImZhZGUgaW4gdG9wIGJvdHRvbSBsZWZ0IHJpZ2h0XCIpfSxjLnByb3RvdHlwZS5oaWRlPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGQoKXtcImluXCIhPWUuaG92ZXJTdGF0ZSYmZi5kZXRhY2goKSxlLiRlbGVtZW50LnJlbW92ZUF0dHIoXCJhcmlhLWRlc2NyaWJlZGJ5XCIpLnRyaWdnZXIoXCJoaWRkZW4uYnMuXCIrZS50eXBlKSxiJiZiKCl9dmFyIGU9dGhpcyxmPWEodGhpcy4kdGlwKSxnPWEuRXZlbnQoXCJoaWRlLmJzLlwiK3RoaXMudHlwZSk7cmV0dXJuIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihnKSxnLmlzRGVmYXVsdFByZXZlbnRlZCgpP3ZvaWQgMDooZi5yZW1vdmVDbGFzcyhcImluXCIpLGEuc3VwcG9ydC50cmFuc2l0aW9uJiZmLmhhc0NsYXNzKFwiZmFkZVwiKT9mLm9uZShcImJzVHJhbnNpdGlvbkVuZFwiLGQpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGMuVFJBTlNJVElPTl9EVVJBVElPTik6ZCgpLHRoaXMuaG92ZXJTdGF0ZT1udWxsLHRoaXMpfSxjLnByb3RvdHlwZS5maXhUaXRsZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuJGVsZW1lbnQ7KGEuYXR0cihcInRpdGxlXCIpfHxcInN0cmluZ1wiIT10eXBlb2YgYS5hdHRyKFwiZGF0YS1vcmlnaW5hbC10aXRsZVwiKSkmJmEuYXR0cihcImRhdGEtb3JpZ2luYWwtdGl0bGVcIixhLmF0dHIoXCJ0aXRsZVwiKXx8XCJcIikuYXR0cihcInRpdGxlXCIsXCJcIil9LGMucHJvdG90eXBlLmhhc0NvbnRlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRUaXRsZSgpfSxjLnByb3RvdHlwZS5nZXRQb3NpdGlvbj1mdW5jdGlvbihiKXtiPWJ8fHRoaXMuJGVsZW1lbnQ7dmFyIGM9YlswXSxkPVwiQk9EWVwiPT1jLnRhZ05hbWUsZT1jLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO251bGw9PWUud2lkdGgmJihlPWEuZXh0ZW5kKHt9LGUse3dpZHRoOmUucmlnaHQtZS5sZWZ0LGhlaWdodDplLmJvdHRvbS1lLnRvcH0pKTt2YXIgZj1kP3t0b3A6MCxsZWZ0OjB9OmIub2Zmc2V0KCksZz17c2Nyb2xsOmQ/ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcHx8ZG9jdW1lbnQuYm9keS5zY3JvbGxUb3A6Yi5zY3JvbGxUb3AoKX0saD1kP3t3aWR0aDphKHdpbmRvdykud2lkdGgoKSxoZWlnaHQ6YSh3aW5kb3cpLmhlaWdodCgpfTpudWxsO3JldHVybiBhLmV4dGVuZCh7fSxlLGcsaCxmKX0sYy5wcm90b3R5cGUuZ2V0Q2FsY3VsYXRlZE9mZnNldD1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm5cImJvdHRvbVwiPT1hP3t0b3A6Yi50b3ArYi5oZWlnaHQsbGVmdDpiLmxlZnQrYi53aWR0aC8yLWMvMn06XCJ0b3BcIj09YT97dG9wOmIudG9wLWQsbGVmdDpiLmxlZnQrYi53aWR0aC8yLWMvMn06XCJsZWZ0XCI9PWE/e3RvcDpiLnRvcCtiLmhlaWdodC8yLWQvMixsZWZ0OmIubGVmdC1jfTp7dG9wOmIudG9wK2IuaGVpZ2h0LzItZC8yLGxlZnQ6Yi5sZWZ0K2Iud2lkdGh9fSxjLnByb3RvdHlwZS5nZXRWaWV3cG9ydEFkanVzdGVkRGVsdGE9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9e3RvcDowLGxlZnQ6MH07aWYoIXRoaXMuJHZpZXdwb3J0KXJldHVybiBlO3ZhciBmPXRoaXMub3B0aW9ucy52aWV3cG9ydCYmdGhpcy5vcHRpb25zLnZpZXdwb3J0LnBhZGRpbmd8fDAsZz10aGlzLmdldFBvc2l0aW9uKHRoaXMuJHZpZXdwb3J0KTtpZigvcmlnaHR8bGVmdC8udGVzdChhKSl7dmFyIGg9Yi50b3AtZi1nLnNjcm9sbCxpPWIudG9wK2YtZy5zY3JvbGwrZDtoPGcudG9wP2UudG9wPWcudG9wLWg6aT5nLnRvcCtnLmhlaWdodCYmKGUudG9wPWcudG9wK2cuaGVpZ2h0LWkpfWVsc2V7dmFyIGo9Yi5sZWZ0LWYsaz1iLmxlZnQrZitjO2o8Zy5sZWZ0P2UubGVmdD1nLmxlZnQtajprPmcucmlnaHQmJihlLmxlZnQ9Zy5sZWZ0K2cud2lkdGgtayl9cmV0dXJuIGV9LGMucHJvdG90eXBlLmdldFRpdGxlPWZ1bmN0aW9uKCl7dmFyIGEsYj10aGlzLiRlbGVtZW50LGM9dGhpcy5vcHRpb25zO3JldHVybiBhPWIuYXR0cihcImRhdGEtb3JpZ2luYWwtdGl0bGVcIil8fChcImZ1bmN0aW9uXCI9PXR5cGVvZiBjLnRpdGxlP2MudGl0bGUuY2FsbChiWzBdKTpjLnRpdGxlKX0sYy5wcm90b3R5cGUuZ2V0VUlEPWZ1bmN0aW9uKGEpe2RvIGErPX5+KDFlNipNYXRoLnJhbmRvbSgpKTt3aGlsZShkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKSk7cmV0dXJuIGF9LGMucHJvdG90eXBlLnRpcD1mdW5jdGlvbigpe2lmKCF0aGlzLiR0aXAmJih0aGlzLiR0aXA9YSh0aGlzLm9wdGlvbnMudGVtcGxhdGUpLDEhPXRoaXMuJHRpcC5sZW5ndGgpKXRocm93IG5ldyBFcnJvcih0aGlzLnR5cGUrXCIgYHRlbXBsYXRlYCBvcHRpb24gbXVzdCBjb25zaXN0IG9mIGV4YWN0bHkgMSB0b3AtbGV2ZWwgZWxlbWVudCFcIik7cmV0dXJuIHRoaXMuJHRpcH0sYy5wcm90b3R5cGUuYXJyb3c9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kYXJyb3c9dGhpcy4kYXJyb3d8fHRoaXMudGlwKCkuZmluZChcIi50b29sdGlwLWFycm93XCIpfSxjLnByb3RvdHlwZS5lbmFibGU9ZnVuY3Rpb24oKXt0aGlzLmVuYWJsZWQ9ITB9LGMucHJvdG90eXBlLmRpc2FibGU9ZnVuY3Rpb24oKXt0aGlzLmVuYWJsZWQ9ITF9LGMucHJvdG90eXBlLnRvZ2dsZUVuYWJsZWQ9ZnVuY3Rpb24oKXt0aGlzLmVuYWJsZWQ9IXRoaXMuZW5hYmxlZH0sYy5wcm90b3R5cGUudG9nZ2xlPWZ1bmN0aW9uKGIpe3ZhciBjPXRoaXM7YiYmKGM9YShiLmN1cnJlbnRUYXJnZXQpLmRhdGEoXCJicy5cIit0aGlzLnR5cGUpLGN8fChjPW5ldyB0aGlzLmNvbnN0cnVjdG9yKGIuY3VycmVudFRhcmdldCx0aGlzLmdldERlbGVnYXRlT3B0aW9ucygpKSxhKGIuY3VycmVudFRhcmdldCkuZGF0YShcImJzLlwiK3RoaXMudHlwZSxjKSkpLGI/KGMuaW5TdGF0ZS5jbGljaz0hYy5pblN0YXRlLmNsaWNrLGMuaXNJblN0YXRlVHJ1ZSgpP2MuZW50ZXIoYyk6Yy5sZWF2ZShjKSk6Yy50aXAoKS5oYXNDbGFzcyhcImluXCIpP2MubGVhdmUoYyk6Yy5lbnRlcihjKX0sYy5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7Y2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCksdGhpcy5oaWRlKGZ1bmN0aW9uKCl7YS4kZWxlbWVudC5vZmYoXCIuXCIrYS50eXBlKS5yZW1vdmVEYXRhKFwiYnMuXCIrYS50eXBlKSxhLiR0aXAmJmEuJHRpcC5kZXRhY2goKSxhLiR0aXA9bnVsbCxhLiRhcnJvdz1udWxsLGEuJHZpZXdwb3J0PW51bGx9KX07dmFyIGQ9YS5mbi50b29sdGlwO2EuZm4udG9vbHRpcD1iLGEuZm4udG9vbHRpcC5Db25zdHJ1Y3Rvcj1jLGEuZm4udG9vbHRpcC5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4udG9vbHRpcD1kLHRoaXN9fShqUXVlcnkpLCtmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBiKGIpe3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXt2YXIgZD1hKHRoaXMpLGU9ZC5kYXRhKFwiYnMucG9wb3ZlclwiKSxmPVwib2JqZWN0XCI9PXR5cGVvZiBiJiZiOyhlfHwhL2Rlc3Ryb3l8aGlkZS8udGVzdChiKSkmJihlfHxkLmRhdGEoXCJicy5wb3BvdmVyXCIsZT1uZXcgYyh0aGlzLGYpKSxcInN0cmluZ1wiPT10eXBlb2YgYiYmZVtiXSgpKX0pfXZhciBjPWZ1bmN0aW9uKGEsYil7dGhpcy5pbml0KFwicG9wb3ZlclwiLGEsYil9O2lmKCFhLmZuLnRvb2x0aXApdGhyb3cgbmV3IEVycm9yKFwiUG9wb3ZlciByZXF1aXJlcyB0b29sdGlwLmpzXCIpO2MuVkVSU0lPTj1cIjMuMy41XCIsYy5ERUZBVUxUUz1hLmV4dGVuZCh7fSxhLmZuLnRvb2x0aXAuQ29uc3RydWN0b3IuREVGQVVMVFMse3BsYWNlbWVudDpcInJpZ2h0XCIsdHJpZ2dlcjpcImNsaWNrXCIsY29udGVudDpcIlwiLHRlbXBsYXRlOic8ZGl2IGNsYXNzPVwicG9wb3ZlclwiIHJvbGU9XCJ0b29sdGlwXCI+PGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+PGgzIGNsYXNzPVwicG9wb3Zlci10aXRsZVwiPjwvaDM+PGRpdiBjbGFzcz1cInBvcG92ZXItY29udGVudFwiPjwvZGl2PjwvZGl2Pid9KSxjLnByb3RvdHlwZT1hLmV4dGVuZCh7fSxhLmZuLnRvb2x0aXAuQ29uc3RydWN0b3IucHJvdG90eXBlKSxjLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1jLGMucHJvdG90eXBlLmdldERlZmF1bHRzPWZ1bmN0aW9uKCl7cmV0dXJuIGMuREVGQVVMVFN9LGMucHJvdG90eXBlLnNldENvbnRlbnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnRpcCgpLGI9dGhpcy5nZXRUaXRsZSgpLGM9dGhpcy5nZXRDb250ZW50KCk7YS5maW5kKFwiLnBvcG92ZXItdGl0bGVcIilbdGhpcy5vcHRpb25zLmh0bWw/XCJodG1sXCI6XCJ0ZXh0XCJdKGIpLGEuZmluZChcIi5wb3BvdmVyLWNvbnRlbnRcIikuY2hpbGRyZW4oKS5kZXRhY2goKS5lbmQoKVt0aGlzLm9wdGlvbnMuaHRtbD9cInN0cmluZ1wiPT10eXBlb2YgYz9cImh0bWxcIjpcImFwcGVuZFwiOlwidGV4dFwiXShjKSxhLnJlbW92ZUNsYXNzKFwiZmFkZSB0b3AgYm90dG9tIGxlZnQgcmlnaHQgaW5cIiksYS5maW5kKFwiLnBvcG92ZXItdGl0bGVcIikuaHRtbCgpfHxhLmZpbmQoXCIucG9wb3Zlci10aXRsZVwiKS5oaWRlKCl9LGMucHJvdG90eXBlLmhhc0NvbnRlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRUaXRsZSgpfHx0aGlzLmdldENvbnRlbnQoKX0sYy5wcm90b3R5cGUuZ2V0Q29udGVudD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuJGVsZW1lbnQsYj10aGlzLm9wdGlvbnM7cmV0dXJuIGEuYXR0cihcImRhdGEtY29udGVudFwiKXx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIGIuY29udGVudD9iLmNvbnRlbnQuY2FsbChhWzBdKTpiLmNvbnRlbnQpfSxjLnByb3RvdHlwZS5hcnJvdz1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRhcnJvdz10aGlzLiRhcnJvd3x8dGhpcy50aXAoKS5maW5kKFwiLmFycm93XCIpfTt2YXIgZD1hLmZuLnBvcG92ZXI7YS5mbi5wb3BvdmVyPWIsYS5mbi5wb3BvdmVyLkNvbnN0cnVjdG9yPWMsYS5mbi5wb3BvdmVyLm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5wb3BvdmVyPWQsdGhpc319KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYyxkKXt0aGlzLiRib2R5PWEoZG9jdW1lbnQuYm9keSksdGhpcy4kc2Nyb2xsRWxlbWVudD1hKGEoYykuaXMoZG9jdW1lbnQuYm9keSk/d2luZG93OmMpLHRoaXMub3B0aW9ucz1hLmV4dGVuZCh7fSxiLkRFRkFVTFRTLGQpLHRoaXMuc2VsZWN0b3I9KHRoaXMub3B0aW9ucy50YXJnZXR8fFwiXCIpK1wiIC5uYXYgbGkgPiBhXCIsdGhpcy5vZmZzZXRzPVtdLHRoaXMudGFyZ2V0cz1bXSx0aGlzLmFjdGl2ZVRhcmdldD1udWxsLHRoaXMuc2Nyb2xsSGVpZ2h0PTAsdGhpcy4kc2Nyb2xsRWxlbWVudC5vbihcInNjcm9sbC5icy5zY3JvbGxzcHlcIixhLnByb3h5KHRoaXMucHJvY2Vzcyx0aGlzKSksdGhpcy5yZWZyZXNoKCksdGhpcy5wcm9jZXNzKCl9ZnVuY3Rpb24gYyhjKXtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7dmFyIGQ9YSh0aGlzKSxlPWQuZGF0YShcImJzLnNjcm9sbHNweVwiKSxmPVwib2JqZWN0XCI9PXR5cGVvZiBjJiZjO2V8fGQuZGF0YShcImJzLnNjcm9sbHNweVwiLGU9bmV3IGIodGhpcyxmKSksXCJzdHJpbmdcIj09dHlwZW9mIGMmJmVbY10oKX0pfWIuVkVSU0lPTj1cIjMuMy41XCIsYi5ERUZBVUxUUz17b2Zmc2V0OjEwfSxiLnByb3RvdHlwZS5nZXRTY3JvbGxIZWlnaHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kc2Nyb2xsRWxlbWVudFswXS5zY3JvbGxIZWlnaHR8fE1hdGgubWF4KHRoaXMuJGJvZHlbMF0uc2Nyb2xsSGVpZ2h0LGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQpfSxiLnByb3RvdHlwZS5yZWZyZXNoPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcyxjPVwib2Zmc2V0XCIsZD0wO3RoaXMub2Zmc2V0cz1bXSx0aGlzLnRhcmdldHM9W10sdGhpcy5zY3JvbGxIZWlnaHQ9dGhpcy5nZXRTY3JvbGxIZWlnaHQoKSxhLmlzV2luZG93KHRoaXMuJHNjcm9sbEVsZW1lbnRbMF0pfHwoYz1cInBvc2l0aW9uXCIsZD10aGlzLiRzY3JvbGxFbGVtZW50LnNjcm9sbFRvcCgpKSx0aGlzLiRib2R5LmZpbmQodGhpcy5zZWxlY3RvcikubWFwKGZ1bmN0aW9uKCl7dmFyIGI9YSh0aGlzKSxlPWIuZGF0YShcInRhcmdldFwiKXx8Yi5hdHRyKFwiaHJlZlwiKSxmPS9eIy4vLnRlc3QoZSkmJmEoZSk7cmV0dXJuIGYmJmYubGVuZ3RoJiZmLmlzKFwiOnZpc2libGVcIikmJltbZltjXSgpLnRvcCtkLGVdXXx8bnVsbH0pLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYVswXS1iWzBdfSkuZWFjaChmdW5jdGlvbigpe2Iub2Zmc2V0cy5wdXNoKHRoaXNbMF0pLGIudGFyZ2V0cy5wdXNoKHRoaXNbMV0pfSl9LGIucHJvdG90eXBlLnByb2Nlc3M9ZnVuY3Rpb24oKXt2YXIgYSxiPXRoaXMuJHNjcm9sbEVsZW1lbnQuc2Nyb2xsVG9wKCkrdGhpcy5vcHRpb25zLm9mZnNldCxjPXRoaXMuZ2V0U2Nyb2xsSGVpZ2h0KCksZD10aGlzLm9wdGlvbnMub2Zmc2V0K2MtdGhpcy4kc2Nyb2xsRWxlbWVudC5oZWlnaHQoKSxlPXRoaXMub2Zmc2V0cyxmPXRoaXMudGFyZ2V0cyxnPXRoaXMuYWN0aXZlVGFyZ2V0O2lmKHRoaXMuc2Nyb2xsSGVpZ2h0IT1jJiZ0aGlzLnJlZnJlc2goKSxiPj1kKXJldHVybiBnIT0oYT1mW2YubGVuZ3RoLTFdKSYmdGhpcy5hY3RpdmF0ZShhKTtpZihnJiZiPGVbMF0pcmV0dXJuIHRoaXMuYWN0aXZlVGFyZ2V0PW51bGwsdGhpcy5jbGVhcigpO2ZvcihhPWUubGVuZ3RoO2EtLTspZyE9ZlthXSYmYj49ZVthXSYmKHZvaWQgMD09PWVbYSsxXXx8YjxlW2ErMV0pJiZ0aGlzLmFjdGl2YXRlKGZbYV0pfSxiLnByb3RvdHlwZS5hY3RpdmF0ZT1mdW5jdGlvbihiKXt0aGlzLmFjdGl2ZVRhcmdldD1iLHRoaXMuY2xlYXIoKTt2YXIgYz10aGlzLnNlbGVjdG9yKydbZGF0YS10YXJnZXQ9XCInK2IrJ1wiXSwnK3RoaXMuc2VsZWN0b3IrJ1tocmVmPVwiJytiKydcIl0nLGQ9YShjKS5wYXJlbnRzKFwibGlcIikuYWRkQ2xhc3MoXCJhY3RpdmVcIik7ZC5wYXJlbnQoXCIuZHJvcGRvd24tbWVudVwiKS5sZW5ndGgmJihkPWQuY2xvc2VzdChcImxpLmRyb3Bkb3duXCIpLmFkZENsYXNzKFwiYWN0aXZlXCIpKSxcbiAgICBkLnRyaWdnZXIoXCJhY3RpdmF0ZS5icy5zY3JvbGxzcHlcIil9LGIucHJvdG90eXBlLmNsZWFyPWZ1bmN0aW9uKCl7YSh0aGlzLnNlbGVjdG9yKS5wYXJlbnRzVW50aWwodGhpcy5vcHRpb25zLnRhcmdldCxcIi5hY3RpdmVcIikucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIil9O3ZhciBkPWEuZm4uc2Nyb2xsc3B5O2EuZm4uc2Nyb2xsc3B5PWMsYS5mbi5zY3JvbGxzcHkuQ29uc3RydWN0b3I9YixhLmZuLnNjcm9sbHNweS5ub0NvbmZsaWN0PWZ1bmN0aW9uKCl7cmV0dXJuIGEuZm4uc2Nyb2xsc3B5PWQsdGhpc30sYSh3aW5kb3cpLm9uKFwibG9hZC5icy5zY3JvbGxzcHkuZGF0YS1hcGlcIixmdW5jdGlvbigpe2EoJ1tkYXRhLXNweT1cInNjcm9sbFwiXScpLmVhY2goZnVuY3Rpb24oKXt2YXIgYj1hKHRoaXMpO2MuY2FsbChiLGIuZGF0YSgpKX0pfSl9KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZT1kLmRhdGEoXCJicy50YWJcIik7ZXx8ZC5kYXRhKFwiYnMudGFiXCIsZT1uZXcgYyh0aGlzKSksXCJzdHJpbmdcIj09dHlwZW9mIGImJmVbYl0oKX0pfXZhciBjPWZ1bmN0aW9uKGIpe3RoaXMuZWxlbWVudD1hKGIpfTtjLlZFUlNJT049XCIzLjMuNVwiLGMuVFJBTlNJVElPTl9EVVJBVElPTj0xNTAsYy5wcm90b3R5cGUuc2hvdz1mdW5jdGlvbigpe3ZhciBiPXRoaXMuZWxlbWVudCxjPWIuY2xvc2VzdChcInVsOm5vdCguZHJvcGRvd24tbWVudSlcIiksZD1iLmRhdGEoXCJ0YXJnZXRcIik7aWYoZHx8KGQ9Yi5hdHRyKFwiaHJlZlwiKSxkPWQmJmQucmVwbGFjZSgvLiooPz0jW15cXHNdKiQpLyxcIlwiKSksIWIucGFyZW50KFwibGlcIikuaGFzQ2xhc3MoXCJhY3RpdmVcIikpe3ZhciBlPWMuZmluZChcIi5hY3RpdmU6bGFzdCBhXCIpLGY9YS5FdmVudChcImhpZGUuYnMudGFiXCIse3JlbGF0ZWRUYXJnZXQ6YlswXX0pLGc9YS5FdmVudChcInNob3cuYnMudGFiXCIse3JlbGF0ZWRUYXJnZXQ6ZVswXX0pO2lmKGUudHJpZ2dlcihmKSxiLnRyaWdnZXIoZyksIWcuaXNEZWZhdWx0UHJldmVudGVkKCkmJiFmLmlzRGVmYXVsdFByZXZlbnRlZCgpKXt2YXIgaD1hKGQpO3RoaXMuYWN0aXZhdGUoYi5jbG9zZXN0KFwibGlcIiksYyksdGhpcy5hY3RpdmF0ZShoLGgucGFyZW50KCksZnVuY3Rpb24oKXtlLnRyaWdnZXIoe3R5cGU6XCJoaWRkZW4uYnMudGFiXCIscmVsYXRlZFRhcmdldDpiWzBdfSksYi50cmlnZ2VyKHt0eXBlOlwic2hvd24uYnMudGFiXCIscmVsYXRlZFRhcmdldDplWzBdfSl9KX19fSxjLnByb3RvdHlwZS5hY3RpdmF0ZT1mdW5jdGlvbihiLGQsZSl7ZnVuY3Rpb24gZigpe2cucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIikuZmluZChcIj4gLmRyb3Bkb3duLW1lbnUgPiAuYWN0aXZlXCIpLnJlbW92ZUNsYXNzKFwiYWN0aXZlXCIpLmVuZCgpLmZpbmQoJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScpLmF0dHIoXCJhcmlhLWV4cGFuZGVkXCIsITEpLGIuYWRkQ2xhc3MoXCJhY3RpdmVcIikuZmluZCgnW2RhdGEtdG9nZ2xlPVwidGFiXCJdJykuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwhMCksaD8oYlswXS5vZmZzZXRXaWR0aCxiLmFkZENsYXNzKFwiaW5cIikpOmIucmVtb3ZlQ2xhc3MoXCJmYWRlXCIpLGIucGFyZW50KFwiLmRyb3Bkb3duLW1lbnVcIikubGVuZ3RoJiZiLmNsb3Nlc3QoXCJsaS5kcm9wZG93blwiKS5hZGRDbGFzcyhcImFjdGl2ZVwiKS5lbmQoKS5maW5kKCdbZGF0YS10b2dnbGU9XCJ0YWJcIl0nKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCEwKSxlJiZlKCl9dmFyIGc9ZC5maW5kKFwiPiAuYWN0aXZlXCIpLGg9ZSYmYS5zdXBwb3J0LnRyYW5zaXRpb24mJihnLmxlbmd0aCYmZy5oYXNDbGFzcyhcImZhZGVcIil8fCEhZC5maW5kKFwiPiAuZmFkZVwiKS5sZW5ndGgpO2cubGVuZ3RoJiZoP2cub25lKFwiYnNUcmFuc2l0aW9uRW5kXCIsZikuZW11bGF0ZVRyYW5zaXRpb25FbmQoYy5UUkFOU0lUSU9OX0RVUkFUSU9OKTpmKCksZy5yZW1vdmVDbGFzcyhcImluXCIpfTt2YXIgZD1hLmZuLnRhYjthLmZuLnRhYj1iLGEuZm4udGFiLkNvbnN0cnVjdG9yPWMsYS5mbi50YWIubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiBhLmZuLnRhYj1kLHRoaXN9O3ZhciBlPWZ1bmN0aW9uKGMpe2MucHJldmVudERlZmF1bHQoKSxiLmNhbGwoYSh0aGlzKSxcInNob3dcIil9O2EoZG9jdW1lbnQpLm9uKFwiY2xpY2suYnMudGFiLmRhdGEtYXBpXCIsJ1tkYXRhLXRvZ2dsZT1cInRhYlwiXScsZSkub24oXCJjbGljay5icy50YWIuZGF0YS1hcGlcIiwnW2RhdGEtdG9nZ2xlPVwicGlsbFwiXScsZSl9KGpRdWVyeSksK2Z1bmN0aW9uKGEpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIGIoYil7cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe3ZhciBkPWEodGhpcyksZT1kLmRhdGEoXCJicy5hZmZpeFwiKSxmPVwib2JqZWN0XCI9PXR5cGVvZiBiJiZiO2V8fGQuZGF0YShcImJzLmFmZml4XCIsZT1uZXcgYyh0aGlzLGYpKSxcInN0cmluZ1wiPT10eXBlb2YgYiYmZVtiXSgpfSl9dmFyIGM9ZnVuY3Rpb24oYixkKXt0aGlzLm9wdGlvbnM9YS5leHRlbmQoe30sYy5ERUZBVUxUUyxkKSx0aGlzLiR0YXJnZXQ9YSh0aGlzLm9wdGlvbnMudGFyZ2V0KS5vbihcInNjcm9sbC5icy5hZmZpeC5kYXRhLWFwaVwiLGEucHJveHkodGhpcy5jaGVja1Bvc2l0aW9uLHRoaXMpKS5vbihcImNsaWNrLmJzLmFmZml4LmRhdGEtYXBpXCIsYS5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb25XaXRoRXZlbnRMb29wLHRoaXMpKSx0aGlzLiRlbGVtZW50PWEoYiksdGhpcy5hZmZpeGVkPW51bGwsdGhpcy51bnBpbj1udWxsLHRoaXMucGlubmVkT2Zmc2V0PW51bGwsdGhpcy5jaGVja1Bvc2l0aW9uKCl9O2MuVkVSU0lPTj1cIjMuMy41XCIsYy5SRVNFVD1cImFmZml4IGFmZml4LXRvcCBhZmZpeC1ib3R0b21cIixjLkRFRkFVTFRTPXtvZmZzZXQ6MCx0YXJnZXQ6d2luZG93fSxjLnByb3RvdHlwZS5nZXRTdGF0ZT1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLiR0YXJnZXQuc2Nyb2xsVG9wKCksZj10aGlzLiRlbGVtZW50Lm9mZnNldCgpLGc9dGhpcy4kdGFyZ2V0LmhlaWdodCgpO2lmKG51bGwhPWMmJlwidG9wXCI9PXRoaXMuYWZmaXhlZClyZXR1cm4gYz5lP1widG9wXCI6ITE7aWYoXCJib3R0b21cIj09dGhpcy5hZmZpeGVkKXJldHVybiBudWxsIT1jP2UrdGhpcy51bnBpbjw9Zi50b3A/ITE6XCJib3R0b21cIjphLWQ+PWUrZz8hMTpcImJvdHRvbVwiO3ZhciBoPW51bGw9PXRoaXMuYWZmaXhlZCxpPWg/ZTpmLnRvcCxqPWg/ZzpiO3JldHVybiBudWxsIT1jJiZjPj1lP1widG9wXCI6bnVsbCE9ZCYmaStqPj1hLWQ/XCJib3R0b21cIjohMX0sYy5wcm90b3R5cGUuZ2V0UGlubmVkT2Zmc2V0PWZ1bmN0aW9uKCl7aWYodGhpcy5waW5uZWRPZmZzZXQpcmV0dXJuIHRoaXMucGlubmVkT2Zmc2V0O3RoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoYy5SRVNFVCkuYWRkQ2xhc3MoXCJhZmZpeFwiKTt2YXIgYT10aGlzLiR0YXJnZXQuc2Nyb2xsVG9wKCksYj10aGlzLiRlbGVtZW50Lm9mZnNldCgpO3JldHVybiB0aGlzLnBpbm5lZE9mZnNldD1iLnRvcC1hfSxjLnByb3RvdHlwZS5jaGVja1Bvc2l0aW9uV2l0aEV2ZW50TG9vcD1mdW5jdGlvbigpe3NldFRpbWVvdXQoYS5wcm94eSh0aGlzLmNoZWNrUG9zaXRpb24sdGhpcyksMSl9LGMucHJvdG90eXBlLmNoZWNrUG9zaXRpb249ZnVuY3Rpb24oKXtpZih0aGlzLiRlbGVtZW50LmlzKFwiOnZpc2libGVcIikpe3ZhciBiPXRoaXMuJGVsZW1lbnQuaGVpZ2h0KCksZD10aGlzLm9wdGlvbnMub2Zmc2V0LGU9ZC50b3AsZj1kLmJvdHRvbSxnPU1hdGgubWF4KGEoZG9jdW1lbnQpLmhlaWdodCgpLGEoZG9jdW1lbnQuYm9keSkuaGVpZ2h0KCkpO1wib2JqZWN0XCIhPXR5cGVvZiBkJiYoZj1lPWQpLFwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJihlPWQudG9wKHRoaXMuJGVsZW1lbnQpKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBmJiYoZj1kLmJvdHRvbSh0aGlzLiRlbGVtZW50KSk7dmFyIGg9dGhpcy5nZXRTdGF0ZShnLGIsZSxmKTtpZih0aGlzLmFmZml4ZWQhPWgpe251bGwhPXRoaXMudW5waW4mJnRoaXMuJGVsZW1lbnQuY3NzKFwidG9wXCIsXCJcIik7dmFyIGk9XCJhZmZpeFwiKyhoP1wiLVwiK2g6XCJcIiksaj1hLkV2ZW50KGkrXCIuYnMuYWZmaXhcIik7aWYodGhpcy4kZWxlbWVudC50cmlnZ2VyKGopLGouaXNEZWZhdWx0UHJldmVudGVkKCkpcmV0dXJuO3RoaXMuYWZmaXhlZD1oLHRoaXMudW5waW49XCJib3R0b21cIj09aD90aGlzLmdldFBpbm5lZE9mZnNldCgpOm51bGwsdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhjLlJFU0VUKS5hZGRDbGFzcyhpKS50cmlnZ2VyKGkucmVwbGFjZShcImFmZml4XCIsXCJhZmZpeGVkXCIpK1wiLmJzLmFmZml4XCIpfVwiYm90dG9tXCI9PWgmJnRoaXMuJGVsZW1lbnQub2Zmc2V0KHt0b3A6Zy1iLWZ9KX19O3ZhciBkPWEuZm4uYWZmaXg7YS5mbi5hZmZpeD1iLGEuZm4uYWZmaXguQ29uc3RydWN0b3I9YyxhLmZuLmFmZml4Lm5vQ29uZmxpY3Q9ZnVuY3Rpb24oKXtyZXR1cm4gYS5mbi5hZmZpeD1kLHRoaXN9LGEod2luZG93KS5vbihcImxvYWRcIixmdW5jdGlvbigpe2EoJ1tkYXRhLXNweT1cImFmZml4XCJdJykuZWFjaChmdW5jdGlvbigpe3ZhciBjPWEodGhpcyksZD1jLmRhdGEoKTtkLm9mZnNldD1kLm9mZnNldHx8e30sbnVsbCE9ZC5vZmZzZXRCb3R0b20mJihkLm9mZnNldC5ib3R0b209ZC5vZmZzZXRCb3R0b20pLG51bGwhPWQub2Zmc2V0VG9wJiYoZC5vZmZzZXQudG9wPWQub2Zmc2V0VG9wKSxiLmNhbGwoYyxkKX0pfSl9KGpRdWVyeSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vc3JjL2VkaXRhYmxlL2pzL2Jvb3RzdHJhcC5taW4uanMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n");

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(5)(undefined);\n// imports\n\n\n// module\nexports.push([module.i, \"/*!\\n * Bootstrap v3.3.7 (http://getbootstrap.com)\\n * Copyright 2011-2017 Twitter, Inc.\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n */\\n\\n/*!\\n * Generated using the Bootstrap Customizer (https://getbootstrap.com/docs/3.3/customize/?id=6729ca5bfebd0b65e0f15f121902b07d)\\n * Config saved to config.json and https://gist.github.com/6729ca5bfebd0b65e0f15f121902b07d\\n *//*!\\n * Bootstrap v3.3.7 (http://getbootstrap.com)\\n * Copyright 2011-2016 Twitter, Inc.\\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\\n *//*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}h1{font-size:2em;margin:0.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace, monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=\\\"button\\\"],input[type=\\\"reset\\\"],input[type=\\\"submit\\\"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=\\\"checkbox\\\"],input[type=\\\"radio\\\"]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:0}input[type=\\\"number\\\"]::-webkit-inner-spin-button,input[type=\\\"number\\\"]::-webkit-outer-spin-button{height:auto}input[type=\\\"search\\\"]{-webkit-appearance:textfield;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box}input[type=\\\"search\\\"]::-webkit-search-cancel-button,input[type=\\\"search\\\"]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid #c0c0c0;margin:0 2px;padding:0.35em 0.625em 0.75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:bold}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}*:before,*:after{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html{font-size:10px;-webkit-tap-highlight-color:rgba(0,0,0,0)}body{font-family:\\\"Helvetica Neue\\\",Helvetica,Arial,sans-serif;font-size:14px;line-height:1.42857143;color:#333;background-color:#fff}input,button,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit}a{color:#337ab7;text-decoration:none}a:hover,a:focus{color:#23527c;text-decoration:underline}a:focus{outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}figure{margin:0}img{vertical-align:middle}.img-responsive{display:block;max-width:100%;height:auto}.img-rounded{border-radius:6px}.img-thumbnail{padding:4px;line-height:1.42857143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out;display:inline-block;max-width:100%;height:auto}.img-circle{border-radius:50%}hr{margin-top:20px;margin-bottom:20px;border:0;border-top:1px solid #eee}.sr-only{position:absolute;width:1px;height:1px;margin:-1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}[role=\\\"button\\\"]{cursor:pointer}.btn{display:inline-block;margin-bottom:0;font-weight:normal;text-align:center;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;cursor:pointer;background-image:none;border:1px solid transparent;white-space:nowrap;padding:6px 12px;font-size:14px;line-height:1.42857143;border-radius:4px;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.btn:focus,.btn:active:focus,.btn.active:focus,.btn.focus,.btn:active.focus,.btn.active.focus{outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn:hover,.btn:focus,.btn.focus{color:#333;text-decoration:none}.btn:active,.btn.active{outline:0;background-image:none;-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,0.125);box-shadow:inset 0 3px 5px rgba(0,0,0,0.125)}.btn.disabled,.btn[disabled],fieldset[disabled] .btn{cursor:not-allowed;opacity:.65;filter:alpha(opacity=65);-webkit-box-shadow:none;box-shadow:none}a.btn.disabled,fieldset[disabled] a.btn{pointer-events:none}.btn-default{color:#333;background-color:#fff;border-color:#ccc}.btn-default:focus,.btn-default.focus{color:#333;background-color:#e6e6e6;border-color:#8c8c8c}.btn-default:hover{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default:active,.btn-default.active,.open>.dropdown-toggle.btn-default{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default:active:hover,.btn-default.active:hover,.open>.dropdown-toggle.btn-default:hover,.btn-default:active:focus,.btn-default.active:focus,.open>.dropdown-toggle.btn-default:focus,.btn-default:active.focus,.btn-default.active.focus,.open>.dropdown-toggle.btn-default.focus{color:#333;background-color:#d4d4d4;border-color:#8c8c8c}.btn-default:active,.btn-default.active,.open>.dropdown-toggle.btn-default{background-image:none}.btn-default.disabled:hover,.btn-default[disabled]:hover,fieldset[disabled] .btn-default:hover,.btn-default.disabled:focus,.btn-default[disabled]:focus,fieldset[disabled] .btn-default:focus,.btn-default.disabled.focus,.btn-default[disabled].focus,fieldset[disabled] .btn-default.focus{background-color:#fff;border-color:#ccc}.btn-default .badge{color:#fff;background-color:#333}.btn-primary{color:#fff;background-color:#337ab7;border-color:#2e6da4}.btn-primary:focus,.btn-primary.focus{color:#fff;background-color:#286090;border-color:#122b40}.btn-primary:hover{color:#fff;background-color:#286090;border-color:#204d74}.btn-primary:active,.btn-primary.active,.open>.dropdown-toggle.btn-primary{color:#fff;background-color:#286090;border-color:#204d74}.btn-primary:active:hover,.btn-primary.active:hover,.open>.dropdown-toggle.btn-primary:hover,.btn-primary:active:focus,.btn-primary.active:focus,.open>.dropdown-toggle.btn-primary:focus,.btn-primary:active.focus,.btn-primary.active.focus,.open>.dropdown-toggle.btn-primary.focus{color:#fff;background-color:#204d74;border-color:#122b40}.btn-primary:active,.btn-primary.active,.open>.dropdown-toggle.btn-primary{background-image:none}.btn-primary.disabled:hover,.btn-primary[disabled]:hover,fieldset[disabled] .btn-primary:hover,.btn-primary.disabled:focus,.btn-primary[disabled]:focus,fieldset[disabled] .btn-primary:focus,.btn-primary.disabled.focus,.btn-primary[disabled].focus,fieldset[disabled] .btn-primary.focus{background-color:#337ab7;border-color:#2e6da4}.btn-primary .badge{color:#337ab7;background-color:#fff}.btn-success{color:#fff;background-color:#5cb85c;border-color:#4cae4c}.btn-success:focus,.btn-success.focus{color:#fff;background-color:#449d44;border-color:#255625}.btn-success:hover{color:#fff;background-color:#449d44;border-color:#398439}.btn-success:active,.btn-success.active,.open>.dropdown-toggle.btn-success{color:#fff;background-color:#449d44;border-color:#398439}.btn-success:active:hover,.btn-success.active:hover,.open>.dropdown-toggle.btn-success:hover,.btn-success:active:focus,.btn-success.active:focus,.open>.dropdown-toggle.btn-success:focus,.btn-success:active.focus,.btn-success.active.focus,.open>.dropdown-toggle.btn-success.focus{color:#fff;background-color:#398439;border-color:#255625}.btn-success:active,.btn-success.active,.open>.dropdown-toggle.btn-success{background-image:none}.btn-success.disabled:hover,.btn-success[disabled]:hover,fieldset[disabled] .btn-success:hover,.btn-success.disabled:focus,.btn-success[disabled]:focus,fieldset[disabled] .btn-success:focus,.btn-success.disabled.focus,.btn-success[disabled].focus,fieldset[disabled] .btn-success.focus{background-color:#5cb85c;border-color:#4cae4c}.btn-success .badge{color:#5cb85c;background-color:#fff}.btn-info{color:#fff;background-color:#5bc0de;border-color:#46b8da}.btn-info:focus,.btn-info.focus{color:#fff;background-color:#31b0d5;border-color:#1b6d85}.btn-info:hover{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info:active,.btn-info.active,.open>.dropdown-toggle.btn-info{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info:active:hover,.btn-info.active:hover,.open>.dropdown-toggle.btn-info:hover,.btn-info:active:focus,.btn-info.active:focus,.open>.dropdown-toggle.btn-info:focus,.btn-info:active.focus,.btn-info.active.focus,.open>.dropdown-toggle.btn-info.focus{color:#fff;background-color:#269abc;border-color:#1b6d85}.btn-info:active,.btn-info.active,.open>.dropdown-toggle.btn-info{background-image:none}.btn-info.disabled:hover,.btn-info[disabled]:hover,fieldset[disabled] .btn-info:hover,.btn-info.disabled:focus,.btn-info[disabled]:focus,fieldset[disabled] .btn-info:focus,.btn-info.disabled.focus,.btn-info[disabled].focus,fieldset[disabled] .btn-info.focus{background-color:#5bc0de;border-color:#46b8da}.btn-info .badge{color:#5bc0de;background-color:#fff}.btn-warning{color:#fff;background-color:#f0ad4e;border-color:#eea236}.btn-warning:focus,.btn-warning.focus{color:#fff;background-color:#ec971f;border-color:#985f0d}.btn-warning:hover{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning:active,.btn-warning.active,.open>.dropdown-toggle.btn-warning{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning:active:hover,.btn-warning.active:hover,.open>.dropdown-toggle.btn-warning:hover,.btn-warning:active:focus,.btn-warning.active:focus,.open>.dropdown-toggle.btn-warning:focus,.btn-warning:active.focus,.btn-warning.active.focus,.open>.dropdown-toggle.btn-warning.focus{color:#fff;background-color:#d58512;border-color:#985f0d}.btn-warning:active,.btn-warning.active,.open>.dropdown-toggle.btn-warning{background-image:none}.btn-warning.disabled:hover,.btn-warning[disabled]:hover,fieldset[disabled] .btn-warning:hover,.btn-warning.disabled:focus,.btn-warning[disabled]:focus,fieldset[disabled] .btn-warning:focus,.btn-warning.disabled.focus,.btn-warning[disabled].focus,fieldset[disabled] .btn-warning.focus{background-color:#f0ad4e;border-color:#eea236}.btn-warning .badge{color:#f0ad4e;background-color:#fff}.btn-danger{color:#fff;background-color:#d9534f;border-color:#d43f3a}.btn-danger:focus,.btn-danger.focus{color:#fff;background-color:#c9302c;border-color:#761c19}.btn-danger:hover{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger:active,.btn-danger.active,.open>.dropdown-toggle.btn-danger{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger:active:hover,.btn-danger.active:hover,.open>.dropdown-toggle.btn-danger:hover,.btn-danger:active:focus,.btn-danger.active:focus,.open>.dropdown-toggle.btn-danger:focus,.btn-danger:active.focus,.btn-danger.active.focus,.open>.dropdown-toggle.btn-danger.focus{color:#fff;background-color:#ac2925;border-color:#761c19}.btn-danger:active,.btn-danger.active,.open>.dropdown-toggle.btn-danger{background-image:none}.btn-danger.disabled:hover,.btn-danger[disabled]:hover,fieldset[disabled] .btn-danger:hover,.btn-danger.disabled:focus,.btn-danger[disabled]:focus,fieldset[disabled] .btn-danger:focus,.btn-danger.disabled.focus,.btn-danger[disabled].focus,fieldset[disabled] .btn-danger.focus{background-color:#d9534f;border-color:#d43f3a}.btn-danger .badge{color:#d9534f;background-color:#fff}.btn-link{color:#337ab7;font-weight:normal;border-radius:0}.btn-link,.btn-link:active,.btn-link.active,.btn-link[disabled],fieldset[disabled] .btn-link{background-color:transparent;-webkit-box-shadow:none;box-shadow:none}.btn-link,.btn-link:hover,.btn-link:focus,.btn-link:active{border-color:transparent}.btn-link:hover,.btn-link:focus{color:#23527c;text-decoration:underline;background-color:transparent}.btn-link[disabled]:hover,fieldset[disabled] .btn-link:hover,.btn-link[disabled]:focus,fieldset[disabled] .btn-link:focus{color:#777;text-decoration:none}.btn-lg,.btn-group-lg>.btn{padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}.btn-sm,.btn-group-sm>.btn{padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.btn-xs,.btn-group-xs>.btn{padding:1px 5px;font-size:12px;line-height:1.5;border-radius:3px}.btn-block{display:block;width:100%}.btn-block+.btn-block{margin-top:5px}input[type=\\\"submit\\\"].btn-block,input[type=\\\"reset\\\"].btn-block,input[type=\\\"button\\\"].btn-block{width:100%}.caret{display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-top:4px dashed;border-top:4px solid \\\\9;border-right:4px solid transparent;border-left:4px solid transparent}.dropup,.dropdown{position:relative}.dropdown-toggle:focus{outline:0}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:160px;padding:5px 0;margin:2px 0 0;list-style:none;font-size:14px;text-align:left;background-color:#fff;border:1px solid #ccc;border:1px solid rgba(0,0,0,0.15);border-radius:4px;-webkit-box-shadow:0 6px 12px rgba(0,0,0,0.175);box-shadow:0 6px 12px rgba(0,0,0,0.175);-webkit-background-clip:padding-box;background-clip:padding-box}.dropdown-menu.pull-right{right:0;left:auto}.dropdown-menu .divider{height:1px;margin:9px 0;overflow:hidden;background-color:#e5e5e5}.dropdown-menu>li>a{display:block;padding:3px 20px;clear:both;font-weight:normal;line-height:1.42857143;color:#333;white-space:nowrap}.dropdown-menu>li>a:hover,.dropdown-menu>li>a:focus{text-decoration:none;color:#262626;background-color:#f5f5f5}.dropdown-menu>.active>a,.dropdown-menu>.active>a:hover,.dropdown-menu>.active>a:focus{color:#fff;text-decoration:none;outline:0;background-color:#337ab7}.dropdown-menu>.disabled>a,.dropdown-menu>.disabled>a:hover,.dropdown-menu>.disabled>a:focus{color:#777}.dropdown-menu>.disabled>a:hover,.dropdown-menu>.disabled>a:focus{text-decoration:none;background-color:transparent;background-image:none;filter:progid:DXImageTransform.Microsoft.gradient(enabled = false);cursor:not-allowed}.open>.dropdown-menu{display:block}.open>a{outline:0}.dropdown-menu-right{left:auto;right:0}.dropdown-menu-left{left:0;right:auto}.dropdown-header{display:block;padding:3px 20px;font-size:12px;line-height:1.42857143;color:#777;white-space:nowrap}.dropdown-backdrop{position:fixed;left:0;right:0;bottom:0;top:0;z-index:990}.pull-right>.dropdown-menu{right:0;left:auto}.dropup .caret,.navbar-fixed-bottom .dropdown .caret{border-top:0;border-bottom:4px dashed;border-bottom:4px solid \\\\9;content:\\\"\\\"}.dropup .dropdown-menu,.navbar-fixed-bottom .dropdown .dropdown-menu{top:auto;bottom:100%;margin-bottom:2px}@media (min-width:768px){.navbar-right .dropdown-menu{left:auto;right:0}.navbar-right .dropdown-menu-left{left:0;right:auto}}.btn-group,.btn-group-vertical{position:relative;display:inline-block;vertical-align:middle}.btn-group>.btn,.btn-group-vertical>.btn{position:relative;float:left}.btn-group>.btn:hover,.btn-group-vertical>.btn:hover,.btn-group>.btn:focus,.btn-group-vertical>.btn:focus,.btn-group>.btn:active,.btn-group-vertical>.btn:active,.btn-group>.btn.active,.btn-group-vertical>.btn.active{z-index:2}.btn-group .btn+.btn,.btn-group .btn+.btn-group,.btn-group .btn-group+.btn,.btn-group .btn-group+.btn-group{margin-left:-1px}.btn-toolbar{margin-left:-5px}.btn-toolbar .btn,.btn-toolbar .btn-group,.btn-toolbar .input-group{float:left}.btn-toolbar>.btn,.btn-toolbar>.btn-group,.btn-toolbar>.input-group{margin-left:5px}.btn-group>.btn:not(:first-child):not(:last-child):not(.dropdown-toggle){border-radius:0}.btn-group>.btn:first-child{margin-left:0}.btn-group>.btn:first-child:not(:last-child):not(.dropdown-toggle){border-bottom-right-radius:0;border-top-right-radius:0}.btn-group>.btn:last-child:not(:first-child),.btn-group>.dropdown-toggle:not(:first-child){border-bottom-left-radius:0;border-top-left-radius:0}.btn-group>.btn-group{float:left}.btn-group>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-bottom-right-radius:0;border-top-right-radius:0}.btn-group>.btn-group:last-child:not(:first-child)>.btn:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.btn-group .dropdown-toggle:active,.btn-group.open .dropdown-toggle{outline:0}.btn-group>.btn+.dropdown-toggle{padding-left:8px;padding-right:8px}.btn-group>.btn-lg+.dropdown-toggle{padding-left:12px;padding-right:12px}.btn-group.open .dropdown-toggle{-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,0.125);box-shadow:inset 0 3px 5px rgba(0,0,0,0.125)}.btn-group.open .dropdown-toggle.btn-link{-webkit-box-shadow:none;box-shadow:none}.btn .caret{margin-left:0}.btn-lg .caret{border-width:5px 5px 0;border-bottom-width:0}.dropup .btn-lg .caret{border-width:0 5px 5px}.btn-group-vertical>.btn,.btn-group-vertical>.btn-group,.btn-group-vertical>.btn-group>.btn{display:block;float:none;width:100%;max-width:100%}.btn-group-vertical>.btn-group>.btn{float:none}.btn-group-vertical>.btn+.btn,.btn-group-vertical>.btn+.btn-group,.btn-group-vertical>.btn-group+.btn,.btn-group-vertical>.btn-group+.btn-group{margin-top:-1px;margin-left:0}.btn-group-vertical>.btn:not(:first-child):not(:last-child){border-radius:0}.btn-group-vertical>.btn:first-child:not(:last-child){border-top-right-radius:4px;border-top-left-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn:last-child:not(:first-child){border-top-right-radius:0;border-top-left-radius:0;border-bottom-right-radius:4px;border-bottom-left-radius:4px}.btn-group-vertical>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group-vertical>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group-vertical>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn-group:last-child:not(:first-child)>.btn:first-child{border-top-right-radius:0;border-top-left-radius:0}.btn-group-justified{display:table;width:100%;table-layout:fixed;border-collapse:separate}.btn-group-justified>.btn,.btn-group-justified>.btn-group{float:none;display:table-cell;width:1%}.btn-group-justified>.btn-group .btn{width:100%}.btn-group-justified>.btn-group .dropdown-menu{left:auto}[data-toggle=\\\"buttons\\\"]>.btn input[type=\\\"radio\\\"],[data-toggle=\\\"buttons\\\"]>.btn-group>.btn input[type=\\\"radio\\\"],[data-toggle=\\\"buttons\\\"]>.btn input[type=\\\"checkbox\\\"],[data-toggle=\\\"buttons\\\"]>.btn-group>.btn input[type=\\\"checkbox\\\"]{position:absolute;clip:rect(0, 0, 0, 0);pointer-events:none}.tooltip{position:absolute;z-index:1070;display:block;font-family:\\\"Helvetica Neue\\\",Helvetica,Arial,sans-serif;font-style:normal;font-weight:normal;letter-spacing:normal;line-break:auto;line-height:1.42857143;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;white-space:normal;word-break:normal;word-spacing:normal;word-wrap:normal;font-size:12px;opacity:0;filter:alpha(opacity=0)}.tooltip.in{opacity:.9;filter:alpha(opacity=90)}.tooltip.top{margin-top:-3px;padding:5px 0}.tooltip.right{margin-left:3px;padding:0 5px}.tooltip.bottom{margin-top:3px;padding:5px 0}.tooltip.left{margin-left:-3px;padding:0 5px}.tooltip-inner{max-width:200px;padding:3px 8px;color:#fff;text-align:center;background-color:#000;border-radius:4px}.tooltip-arrow{position:absolute;width:0;height:0;border-color:transparent;border-style:solid}.tooltip.top .tooltip-arrow{bottom:0;left:50%;margin-left:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-left .tooltip-arrow{bottom:0;right:5px;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-right .tooltip-arrow{bottom:0;left:5px;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.right .tooltip-arrow{top:50%;left:0;margin-top:-5px;border-width:5px 5px 5px 0;border-right-color:#000}.tooltip.left .tooltip-arrow{top:50%;right:0;margin-top:-5px;border-width:5px 0 5px 5px;border-left-color:#000}.tooltip.bottom .tooltip-arrow{top:0;left:50%;margin-left:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-left .tooltip-arrow{top:0;right:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-right .tooltip-arrow{top:0;left:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.clearfix:before,.clearfix:after,.btn-toolbar:before,.btn-toolbar:after,.btn-group-vertical>.btn-group:before,.btn-group-vertical>.btn-group:after{content:\\\" \\\";display:table}.clearfix:after,.btn-toolbar:after,.btn-group-vertical>.btn-group:after{clear:both}.center-block{display:block;margin-left:auto;margin-right:auto}.pull-right{float:right !important}.pull-left{float:left !important}.hide{display:none !important}.show{display:block !important}.invisible{visibility:hidden}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.hidden{display:none !important}.affix{position:fixed}\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC5taW4uY3NzPzlhYWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSwycUJBQTRxQix1QkFBdUIsMEJBQTBCLDhCQUE4QixLQUFLLFNBQVMsMkZBQTJGLGNBQWMsNEJBQTRCLHFCQUFxQix3QkFBd0Isc0JBQXNCLGFBQWEsU0FBUyxrQkFBa0IsYUFBYSxFQUFFLDZCQUE2QixpQkFBaUIsVUFBVSxZQUFZLHlCQUF5QixTQUFTLGlCQUFpQixJQUFJLGtCQUFrQixHQUFHLGNBQWMsZ0JBQWdCLEtBQUssZ0JBQWdCLFdBQVcsTUFBTSxjQUFjLFFBQVEsY0FBYyxjQUFjLGtCQUFrQix3QkFBd0IsSUFBSSxXQUFXLElBQUksZUFBZSxJQUFJLFNBQVMsZUFBZSxnQkFBZ0IsT0FBTyxnQkFBZ0IsR0FBRywrQkFBK0IsNEJBQTRCLHVCQUF1QixTQUFTLElBQUksY0FBYyxrQkFBa0IsaUNBQWlDLGNBQWMsc0NBQXNDLGNBQWMsYUFBYSxTQUFTLE9BQU8saUJBQWlCLGNBQWMsb0JBQW9CLGdGQUFnRiwwQkFBMEIsZUFBZSxzQ0FBc0MsZUFBZSxpREFBaUQsU0FBUyxVQUFVLE1BQU0sbUJBQW1CLCtDQUErQyw4QkFBOEIsMkJBQTJCLHNCQUFzQixVQUFVLG9HQUFvRyxZQUFZLHVCQUF1Qiw2QkFBNkIsK0JBQStCLDRCQUE0Qix1QkFBdUIsdUdBQXVHLHdCQUF3QixTQUFTLHlCQUF5QixhQUFhLDhCQUE4QixPQUFPLFNBQVMsVUFBVSxTQUFTLGNBQWMsU0FBUyxpQkFBaUIsTUFBTSx5QkFBeUIsaUJBQWlCLE1BQU0sVUFBVSxFQUFFLDhCQUE4QiwyQkFBMkIsc0JBQXNCLGlCQUFpQiw4QkFBOEIsMkJBQTJCLHNCQUFzQixLQUFLLGVBQWUsMENBQTBDLEtBQUssMERBQTBELGVBQWUsdUJBQXVCLFdBQVcsc0JBQXNCLDZCQUE2QixvQkFBb0Isa0JBQWtCLG9CQUFvQixF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QkFBeUIsbUJBQW1CLDRCQUE0QixTQUFTLFNBQVMsaUJBQWlCLHVCQUF1QixzQkFBc0IsaUNBQWlDLFNBQVMsVUFBVSxtQkFBbUIsdUJBQXVCLHNCQUFzQixrQ0FBa0MsU0FBUyxTQUFTLG1CQUFtQix1QkFBdUIsc0JBQXNCLDhCQUE4QixRQUFRLE9BQU8sZ0JBQWdCLDJCQUEyQix3QkFBd0IsNkJBQTZCLFFBQVEsUUFBUSxnQkFBZ0IsMkJBQTJCLHVCQUF1QiwrQkFBK0IsTUFBTSxTQUFTLGlCQUFpQix1QkFBdUIseUJBQXlCLG9DQUFvQyxNQUFNLFVBQVUsZ0JBQWdCLHVCQUF1Qix5QkFBeUIscUNBQXFDLE1BQU0sU0FBUyxnQkFBZ0IsdUJBQXVCLHlCQUF5QixtSkFBbUosY0FBYyxjQUFjLHdFQUF3RSxXQUFXLGNBQWMsY0FBYyxpQkFBaUIsa0JBQWtCLFlBQVksdUJBQXVCLFdBQVcsc0JBQXNCLE1BQU0sd0JBQXdCLE1BQU0seUJBQXlCLFdBQVcsa0JBQWtCLFdBQVcsV0FBVyxrQkFBa0IsaUJBQWlCLDZCQUE2QixTQUFTLFFBQVEsd0JBQXdCLE9BQU8sZUFBZTs7QUFFbnVxQiIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi8qIVxcbiAqIEJvb3RzdHJhcCB2My4zLjcgKGh0dHA6Ly9nZXRib290c3RyYXAuY29tKVxcbiAqIENvcHlyaWdodCAyMDExLTIwMTcgVHdpdHRlciwgSW5jLlxcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXFxuICovXFxuXFxuLyohXFxuICogR2VuZXJhdGVkIHVzaW5nIHRoZSBCb290c3RyYXAgQ3VzdG9taXplciAoaHR0cHM6Ly9nZXRib290c3RyYXAuY29tL2RvY3MvMy4zL2N1c3RvbWl6ZS8/aWQ9NjcyOWNhNWJmZWJkMGI2NWUwZjE1ZjEyMTkwMmIwN2QpXFxuICogQ29uZmlnIHNhdmVkIHRvIGNvbmZpZy5qc29uIGFuZCBodHRwczovL2dpc3QuZ2l0aHViLmNvbS82NzI5Y2E1YmZlYmQwYjY1ZTBmMTVmMTIxOTAyYjA3ZFxcbiAqLy8qIVxcbiAqIEJvb3RzdHJhcCB2My4zLjcgKGh0dHA6Ly9nZXRib290c3RyYXAuY29tKVxcbiAqIENvcHlyaWdodCAyMDExLTIwMTYgVHdpdHRlciwgSW5jLlxcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXFxuICovLyohIG5vcm1hbGl6ZS5jc3MgdjMuMC4zIHwgTUlUIExpY2Vuc2UgfCBnaXRodWIuY29tL25lY29sYXMvbm9ybWFsaXplLmNzcyAqL2h0bWx7Zm9udC1mYW1pbHk6c2Fucy1zZXJpZjstbXMtdGV4dC1zaXplLWFkanVzdDoxMDAlOy13ZWJraXQtdGV4dC1zaXplLWFkanVzdDoxMDAlfWJvZHl7bWFyZ2luOjB9YXJ0aWNsZSxhc2lkZSxkZXRhaWxzLGZpZ2NhcHRpb24sZmlndXJlLGZvb3RlcixoZWFkZXIsaGdyb3VwLG1haW4sbWVudSxuYXYsc2VjdGlvbixzdW1tYXJ5e2Rpc3BsYXk6YmxvY2t9YXVkaW8sY2FudmFzLHByb2dyZXNzLHZpZGVve2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfWF1ZGlvOm5vdChbY29udHJvbHNdKXtkaXNwbGF5Om5vbmU7aGVpZ2h0OjB9W2hpZGRlbl0sdGVtcGxhdGV7ZGlzcGxheTpub25lfWF7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudH1hOmFjdGl2ZSxhOmhvdmVye291dGxpbmU6MH1hYmJyW3RpdGxlXXtib3JkZXItYm90dG9tOjFweCBkb3R0ZWR9YixzdHJvbmd7Zm9udC13ZWlnaHQ6Ym9sZH1kZm57Zm9udC1zdHlsZTppdGFsaWN9aDF7Zm9udC1zaXplOjJlbTttYXJnaW46MC42N2VtIDB9bWFya3tiYWNrZ3JvdW5kOiNmZjA7Y29sb3I6IzAwMH1zbWFsbHtmb250LXNpemU6ODAlfXN1YixzdXB7Zm9udC1zaXplOjc1JTtsaW5lLWhlaWdodDowO3Bvc2l0aW9uOnJlbGF0aXZlO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfXN1cHt0b3A6LTAuNWVtfXN1Yntib3R0b206LTAuMjVlbX1pbWd7Ym9yZGVyOjB9c3ZnOm5vdCg6cm9vdCl7b3ZlcmZsb3c6aGlkZGVufWZpZ3VyZXttYXJnaW46MWVtIDQwcHh9aHJ7LXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94Oy1tb3otYm94LXNpemluZzpjb250ZW50LWJveDtib3gtc2l6aW5nOmNvbnRlbnQtYm94O2hlaWdodDowfXByZXtvdmVyZmxvdzphdXRvfWNvZGUsa2JkLHByZSxzYW1we2ZvbnQtZmFtaWx5Om1vbm9zcGFjZSwgbW9ub3NwYWNlO2ZvbnQtc2l6ZToxZW19YnV0dG9uLGlucHV0LG9wdGdyb3VwLHNlbGVjdCx0ZXh0YXJlYXtjb2xvcjppbmhlcml0O2ZvbnQ6aW5oZXJpdDttYXJnaW46MH1idXR0b257b3ZlcmZsb3c6dmlzaWJsZX1idXR0b24sc2VsZWN0e3RleHQtdHJhbnNmb3JtOm5vbmV9YnV0dG9uLGh0bWwgaW5wdXRbdHlwZT1cXFwiYnV0dG9uXFxcIl0saW5wdXRbdHlwZT1cXFwicmVzZXRcXFwiXSxpbnB1dFt0eXBlPVxcXCJzdWJtaXRcXFwiXXstd2Via2l0LWFwcGVhcmFuY2U6YnV0dG9uO2N1cnNvcjpwb2ludGVyfWJ1dHRvbltkaXNhYmxlZF0saHRtbCBpbnB1dFtkaXNhYmxlZF17Y3Vyc29yOmRlZmF1bHR9YnV0dG9uOjotbW96LWZvY3VzLWlubmVyLGlucHV0OjotbW96LWZvY3VzLWlubmVye2JvcmRlcjowO3BhZGRpbmc6MH1pbnB1dHtsaW5lLWhlaWdodDpub3JtYWx9aW5wdXRbdHlwZT1cXFwiY2hlY2tib3hcXFwiXSxpbnB1dFt0eXBlPVxcXCJyYWRpb1xcXCJdey13ZWJraXQtYm94LXNpemluZzpib3JkZXItYm94Oy1tb3otYm94LXNpemluZzpib3JkZXItYm94O2JveC1zaXppbmc6Ym9yZGVyLWJveDtwYWRkaW5nOjB9aW5wdXRbdHlwZT1cXFwibnVtYmVyXFxcIl06Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24saW5wdXRbdHlwZT1cXFwibnVtYmVyXFxcIl06Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b257aGVpZ2h0OmF1dG99aW5wdXRbdHlwZT1cXFwic2VhcmNoXFxcIl17LXdlYmtpdC1hcHBlYXJhbmNlOnRleHRmaWVsZDstd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7LW1vei1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JveC1zaXppbmc6Y29udGVudC1ib3h9aW5wdXRbdHlwZT1cXFwic2VhcmNoXFxcIl06Oi13ZWJraXQtc2VhcmNoLWNhbmNlbC1idXR0b24saW5wdXRbdHlwZT1cXFwic2VhcmNoXFxcIl06Oi13ZWJraXQtc2VhcmNoLWRlY29yYXRpb257LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmV9ZmllbGRzZXR7Ym9yZGVyOjFweCBzb2xpZCAjYzBjMGMwO21hcmdpbjowIDJweDtwYWRkaW5nOjAuMzVlbSAwLjYyNWVtIDAuNzVlbX1sZWdlbmR7Ym9yZGVyOjA7cGFkZGluZzowfXRleHRhcmVhe292ZXJmbG93OmF1dG99b3B0Z3JvdXB7Zm9udC13ZWlnaHQ6Ym9sZH10YWJsZXtib3JkZXItY29sbGFwc2U6Y29sbGFwc2U7Ym9yZGVyLXNwYWNpbmc6MH10ZCx0aHtwYWRkaW5nOjB9Knstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3h9KjpiZWZvcmUsKjphZnRlcnstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3h9aHRtbHtmb250LXNpemU6MTBweDstd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6cmdiYSgwLDAsMCwwKX1ib2R5e2ZvbnQtZmFtaWx5OlxcXCJIZWx2ZXRpY2EgTmV1ZVxcXCIsSGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjE0cHg7bGluZS1oZWlnaHQ6MS40Mjg1NzE0Mztjb2xvcjojMzMzO2JhY2tncm91bmQtY29sb3I6I2ZmZn1pbnB1dCxidXR0b24sc2VsZWN0LHRleHRhcmVhe2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOmluaGVyaXQ7bGluZS1oZWlnaHQ6aW5oZXJpdH1he2NvbG9yOiMzMzdhYjc7dGV4dC1kZWNvcmF0aW9uOm5vbmV9YTpob3ZlcixhOmZvY3Vze2NvbG9yOiMyMzUyN2M7dGV4dC1kZWNvcmF0aW9uOnVuZGVybGluZX1hOmZvY3Vze291dGxpbmU6NXB4IGF1dG8gLXdlYmtpdC1mb2N1cy1yaW5nLWNvbG9yO291dGxpbmUtb2Zmc2V0Oi0ycHh9ZmlndXJle21hcmdpbjowfWltZ3t2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmltZy1yZXNwb25zaXZle2Rpc3BsYXk6YmxvY2s7bWF4LXdpZHRoOjEwMCU7aGVpZ2h0OmF1dG99LmltZy1yb3VuZGVke2JvcmRlci1yYWRpdXM6NnB4fS5pbWctdGh1bWJuYWlse3BhZGRpbmc6NHB4O2xpbmUtaGVpZ2h0OjEuNDI4NTcxNDM7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlcjoxcHggc29saWQgI2RkZDtib3JkZXItcmFkaXVzOjRweDstd2Via2l0LXRyYW5zaXRpb246YWxsIC4ycyBlYXNlLWluLW91dDstby10cmFuc2l0aW9uOmFsbCAuMnMgZWFzZS1pbi1vdXQ7dHJhbnNpdGlvbjphbGwgLjJzIGVhc2UtaW4tb3V0O2Rpc3BsYXk6aW5saW5lLWJsb2NrO21heC13aWR0aDoxMDAlO2hlaWdodDphdXRvfS5pbWctY2lyY2xle2JvcmRlci1yYWRpdXM6NTAlfWhye21hcmdpbi10b3A6MjBweDttYXJnaW4tYm90dG9tOjIwcHg7Ym9yZGVyOjA7Ym9yZGVyLXRvcDoxcHggc29saWQgI2VlZX0uc3Itb25seXtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDoxcHg7aGVpZ2h0OjFweDttYXJnaW46LTFweDtwYWRkaW5nOjA7b3ZlcmZsb3c6aGlkZGVuO2NsaXA6cmVjdCgwLCAwLCAwLCAwKTtib3JkZXI6MH0uc3Itb25seS1mb2N1c2FibGU6YWN0aXZlLC5zci1vbmx5LWZvY3VzYWJsZTpmb2N1c3twb3NpdGlvbjpzdGF0aWM7d2lkdGg6YXV0bztoZWlnaHQ6YXV0bzttYXJnaW46MDtvdmVyZmxvdzp2aXNpYmxlO2NsaXA6YXV0b31bcm9sZT1cXFwiYnV0dG9uXFxcIl17Y3Vyc29yOnBvaW50ZXJ9LmJ0bntkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tYm90dG9tOjA7Zm9udC13ZWlnaHQ6bm9ybWFsO3RleHQtYWxpZ246Y2VudGVyO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTstbXMtdG91Y2gtYWN0aW9uOm1hbmlwdWxhdGlvbjt0b3VjaC1hY3Rpb246bWFuaXB1bGF0aW9uO2N1cnNvcjpwb2ludGVyO2JhY2tncm91bmQtaW1hZ2U6bm9uZTtib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50O3doaXRlLXNwYWNlOm5vd3JhcDtwYWRkaW5nOjZweCAxMnB4O2ZvbnQtc2l6ZToxNHB4O2xpbmUtaGVpZ2h0OjEuNDI4NTcxNDM7Ym9yZGVyLXJhZGl1czo0cHg7LXdlYmtpdC11c2VyLXNlbGVjdDpub25lOy1tb3otdXNlci1zZWxlY3Q6bm9uZTstbXMtdXNlci1zZWxlY3Q6bm9uZTt1c2VyLXNlbGVjdDpub25lfS5idG46Zm9jdXMsLmJ0bjphY3RpdmU6Zm9jdXMsLmJ0bi5hY3RpdmU6Zm9jdXMsLmJ0bi5mb2N1cywuYnRuOmFjdGl2ZS5mb2N1cywuYnRuLmFjdGl2ZS5mb2N1c3tvdXRsaW5lOjVweCBhdXRvIC13ZWJraXQtZm9jdXMtcmluZy1jb2xvcjtvdXRsaW5lLW9mZnNldDotMnB4fS5idG46aG92ZXIsLmJ0bjpmb2N1cywuYnRuLmZvY3Vze2NvbG9yOiMzMzM7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmJ0bjphY3RpdmUsLmJ0bi5hY3RpdmV7b3V0bGluZTowO2JhY2tncm91bmQtaW1hZ2U6bm9uZTstd2Via2l0LWJveC1zaGFkb3c6aW5zZXQgMCAzcHggNXB4IHJnYmEoMCwwLDAsMC4xMjUpO2JveC1zaGFkb3c6aW5zZXQgMCAzcHggNXB4IHJnYmEoMCwwLDAsMC4xMjUpfS5idG4uZGlzYWJsZWQsLmJ0bltkaXNhYmxlZF0sZmllbGRzZXRbZGlzYWJsZWRdIC5idG57Y3Vyc29yOm5vdC1hbGxvd2VkO29wYWNpdHk6LjY1O2ZpbHRlcjphbHBoYShvcGFjaXR5PTY1KTstd2Via2l0LWJveC1zaGFkb3c6bm9uZTtib3gtc2hhZG93Om5vbmV9YS5idG4uZGlzYWJsZWQsZmllbGRzZXRbZGlzYWJsZWRdIGEuYnRue3BvaW50ZXItZXZlbnRzOm5vbmV9LmJ0bi1kZWZhdWx0e2NvbG9yOiMzMzM7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlci1jb2xvcjojY2NjfS5idG4tZGVmYXVsdDpmb2N1cywuYnRuLWRlZmF1bHQuZm9jdXN7Y29sb3I6IzMzMztiYWNrZ3JvdW5kLWNvbG9yOiNlNmU2ZTY7Ym9yZGVyLWNvbG9yOiM4YzhjOGN9LmJ0bi1kZWZhdWx0OmhvdmVye2NvbG9yOiMzMzM7YmFja2dyb3VuZC1jb2xvcjojZTZlNmU2O2JvcmRlci1jb2xvcjojYWRhZGFkfS5idG4tZGVmYXVsdDphY3RpdmUsLmJ0bi1kZWZhdWx0LmFjdGl2ZSwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1kZWZhdWx0e2NvbG9yOiMzMzM7YmFja2dyb3VuZC1jb2xvcjojZTZlNmU2O2JvcmRlci1jb2xvcjojYWRhZGFkfS5idG4tZGVmYXVsdDphY3RpdmU6aG92ZXIsLmJ0bi1kZWZhdWx0LmFjdGl2ZTpob3Zlciwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1kZWZhdWx0OmhvdmVyLC5idG4tZGVmYXVsdDphY3RpdmU6Zm9jdXMsLmJ0bi1kZWZhdWx0LmFjdGl2ZTpmb2N1cywub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1kZWZhdWx0OmZvY3VzLC5idG4tZGVmYXVsdDphY3RpdmUuZm9jdXMsLmJ0bi1kZWZhdWx0LmFjdGl2ZS5mb2N1cywub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1kZWZhdWx0LmZvY3Vze2NvbG9yOiMzMzM7YmFja2dyb3VuZC1jb2xvcjojZDRkNGQ0O2JvcmRlci1jb2xvcjojOGM4YzhjfS5idG4tZGVmYXVsdDphY3RpdmUsLmJ0bi1kZWZhdWx0LmFjdGl2ZSwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1kZWZhdWx0e2JhY2tncm91bmQtaW1hZ2U6bm9uZX0uYnRuLWRlZmF1bHQuZGlzYWJsZWQ6aG92ZXIsLmJ0bi1kZWZhdWx0W2Rpc2FibGVkXTpob3ZlcixmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi1kZWZhdWx0OmhvdmVyLC5idG4tZGVmYXVsdC5kaXNhYmxlZDpmb2N1cywuYnRuLWRlZmF1bHRbZGlzYWJsZWRdOmZvY3VzLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLWRlZmF1bHQ6Zm9jdXMsLmJ0bi1kZWZhdWx0LmRpc2FibGVkLmZvY3VzLC5idG4tZGVmYXVsdFtkaXNhYmxlZF0uZm9jdXMsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4tZGVmYXVsdC5mb2N1c3tiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Ym9yZGVyLWNvbG9yOiNjY2N9LmJ0bi1kZWZhdWx0IC5iYWRnZXtjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzMzM30uYnRuLXByaW1hcnl7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiMzMzdhYjc7Ym9yZGVyLWNvbG9yOiMyZTZkYTR9LmJ0bi1wcmltYXJ5OmZvY3VzLC5idG4tcHJpbWFyeS5mb2N1c3tjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzI4NjA5MDtib3JkZXItY29sb3I6IzEyMmI0MH0uYnRuLXByaW1hcnk6aG92ZXJ7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiMyODYwOTA7Ym9yZGVyLWNvbG9yOiMyMDRkNzR9LmJ0bi1wcmltYXJ5OmFjdGl2ZSwuYnRuLXByaW1hcnkuYWN0aXZlLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXByaW1hcnl7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiMyODYwOTA7Ym9yZGVyLWNvbG9yOiMyMDRkNzR9LmJ0bi1wcmltYXJ5OmFjdGl2ZTpob3ZlciwuYnRuLXByaW1hcnkuYWN0aXZlOmhvdmVyLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXByaW1hcnk6aG92ZXIsLmJ0bi1wcmltYXJ5OmFjdGl2ZTpmb2N1cywuYnRuLXByaW1hcnkuYWN0aXZlOmZvY3VzLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXByaW1hcnk6Zm9jdXMsLmJ0bi1wcmltYXJ5OmFjdGl2ZS5mb2N1cywuYnRuLXByaW1hcnkuYWN0aXZlLmZvY3VzLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXByaW1hcnkuZm9jdXN7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiMyMDRkNzQ7Ym9yZGVyLWNvbG9yOiMxMjJiNDB9LmJ0bi1wcmltYXJ5OmFjdGl2ZSwuYnRuLXByaW1hcnkuYWN0aXZlLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXByaW1hcnl7YmFja2dyb3VuZC1pbWFnZTpub25lfS5idG4tcHJpbWFyeS5kaXNhYmxlZDpob3ZlciwuYnRuLXByaW1hcnlbZGlzYWJsZWRdOmhvdmVyLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLXByaW1hcnk6aG92ZXIsLmJ0bi1wcmltYXJ5LmRpc2FibGVkOmZvY3VzLC5idG4tcHJpbWFyeVtkaXNhYmxlZF06Zm9jdXMsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4tcHJpbWFyeTpmb2N1cywuYnRuLXByaW1hcnkuZGlzYWJsZWQuZm9jdXMsLmJ0bi1wcmltYXJ5W2Rpc2FibGVkXS5mb2N1cyxmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi1wcmltYXJ5LmZvY3Vze2JhY2tncm91bmQtY29sb3I6IzMzN2FiNztib3JkZXItY29sb3I6IzJlNmRhNH0uYnRuLXByaW1hcnkgLmJhZGdle2NvbG9yOiMzMzdhYjc7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5idG4tc3VjY2Vzc3tjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzVjYjg1Yztib3JkZXItY29sb3I6IzRjYWU0Y30uYnRuLXN1Y2Nlc3M6Zm9jdXMsLmJ0bi1zdWNjZXNzLmZvY3Vze2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojNDQ5ZDQ0O2JvcmRlci1jb2xvcjojMjU1NjI1fS5idG4tc3VjY2Vzczpob3Zlcntjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzQ0OWQ0NDtib3JkZXItY29sb3I6IzM5ODQzOX0uYnRuLXN1Y2Nlc3M6YWN0aXZlLC5idG4tc3VjY2Vzcy5hY3RpdmUsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tc3VjY2Vzc3tjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzQ0OWQ0NDtib3JkZXItY29sb3I6IzM5ODQzOX0uYnRuLXN1Y2Nlc3M6YWN0aXZlOmhvdmVyLC5idG4tc3VjY2Vzcy5hY3RpdmU6aG92ZXIsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tc3VjY2Vzczpob3ZlciwuYnRuLXN1Y2Nlc3M6YWN0aXZlOmZvY3VzLC5idG4tc3VjY2Vzcy5hY3RpdmU6Zm9jdXMsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tc3VjY2Vzczpmb2N1cywuYnRuLXN1Y2Nlc3M6YWN0aXZlLmZvY3VzLC5idG4tc3VjY2Vzcy5hY3RpdmUuZm9jdXMsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tc3VjY2Vzcy5mb2N1c3tjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6IzM5ODQzOTtib3JkZXItY29sb3I6IzI1NTYyNX0uYnRuLXN1Y2Nlc3M6YWN0aXZlLC5idG4tc3VjY2Vzcy5hY3RpdmUsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tc3VjY2Vzc3tiYWNrZ3JvdW5kLWltYWdlOm5vbmV9LmJ0bi1zdWNjZXNzLmRpc2FibGVkOmhvdmVyLC5idG4tc3VjY2Vzc1tkaXNhYmxlZF06aG92ZXIsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4tc3VjY2Vzczpob3ZlciwuYnRuLXN1Y2Nlc3MuZGlzYWJsZWQ6Zm9jdXMsLmJ0bi1zdWNjZXNzW2Rpc2FibGVkXTpmb2N1cyxmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi1zdWNjZXNzOmZvY3VzLC5idG4tc3VjY2Vzcy5kaXNhYmxlZC5mb2N1cywuYnRuLXN1Y2Nlc3NbZGlzYWJsZWRdLmZvY3VzLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLXN1Y2Nlc3MuZm9jdXN7YmFja2dyb3VuZC1jb2xvcjojNWNiODVjO2JvcmRlci1jb2xvcjojNGNhZTRjfS5idG4tc3VjY2VzcyAuYmFkZ2V7Y29sb3I6IzVjYjg1YztiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9LmJ0bi1pbmZve2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojNWJjMGRlO2JvcmRlci1jb2xvcjojNDZiOGRhfS5idG4taW5mbzpmb2N1cywuYnRuLWluZm8uZm9jdXN7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiMzMWIwZDU7Ym9yZGVyLWNvbG9yOiMxYjZkODV9LmJ0bi1pbmZvOmhvdmVye2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojMzFiMGQ1O2JvcmRlci1jb2xvcjojMjY5YWJjfS5idG4taW5mbzphY3RpdmUsLmJ0bi1pbmZvLmFjdGl2ZSwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1pbmZve2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojMzFiMGQ1O2JvcmRlci1jb2xvcjojMjY5YWJjfS5idG4taW5mbzphY3RpdmU6aG92ZXIsLmJ0bi1pbmZvLmFjdGl2ZTpob3Zlciwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1pbmZvOmhvdmVyLC5idG4taW5mbzphY3RpdmU6Zm9jdXMsLmJ0bi1pbmZvLmFjdGl2ZTpmb2N1cywub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1pbmZvOmZvY3VzLC5idG4taW5mbzphY3RpdmUuZm9jdXMsLmJ0bi1pbmZvLmFjdGl2ZS5mb2N1cywub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1pbmZvLmZvY3Vze2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojMjY5YWJjO2JvcmRlci1jb2xvcjojMWI2ZDg1fS5idG4taW5mbzphY3RpdmUsLmJ0bi1pbmZvLmFjdGl2ZSwub3Blbj4uZHJvcGRvd24tdG9nZ2xlLmJ0bi1pbmZve2JhY2tncm91bmQtaW1hZ2U6bm9uZX0uYnRuLWluZm8uZGlzYWJsZWQ6aG92ZXIsLmJ0bi1pbmZvW2Rpc2FibGVkXTpob3ZlcixmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi1pbmZvOmhvdmVyLC5idG4taW5mby5kaXNhYmxlZDpmb2N1cywuYnRuLWluZm9bZGlzYWJsZWRdOmZvY3VzLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLWluZm86Zm9jdXMsLmJ0bi1pbmZvLmRpc2FibGVkLmZvY3VzLC5idG4taW5mb1tkaXNhYmxlZF0uZm9jdXMsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4taW5mby5mb2N1c3tiYWNrZ3JvdW5kLWNvbG9yOiM1YmMwZGU7Ym9yZGVyLWNvbG9yOiM0NmI4ZGF9LmJ0bi1pbmZvIC5iYWRnZXtjb2xvcjojNWJjMGRlO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uYnRuLXdhcm5pbmd7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiNmMGFkNGU7Ym9yZGVyLWNvbG9yOiNlZWEyMzZ9LmJ0bi13YXJuaW5nOmZvY3VzLC5idG4td2FybmluZy5mb2N1c3tjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6I2VjOTcxZjtib3JkZXItY29sb3I6Izk4NWYwZH0uYnRuLXdhcm5pbmc6aG92ZXJ7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiNlYzk3MWY7Ym9yZGVyLWNvbG9yOiNkNTg1MTJ9LmJ0bi13YXJuaW5nOmFjdGl2ZSwuYnRuLXdhcm5pbmcuYWN0aXZlLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXdhcm5pbmd7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiNlYzk3MWY7Ym9yZGVyLWNvbG9yOiNkNTg1MTJ9LmJ0bi13YXJuaW5nOmFjdGl2ZTpob3ZlciwuYnRuLXdhcm5pbmcuYWN0aXZlOmhvdmVyLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXdhcm5pbmc6aG92ZXIsLmJ0bi13YXJuaW5nOmFjdGl2ZTpmb2N1cywuYnRuLXdhcm5pbmcuYWN0aXZlOmZvY3VzLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXdhcm5pbmc6Zm9jdXMsLmJ0bi13YXJuaW5nOmFjdGl2ZS5mb2N1cywuYnRuLXdhcm5pbmcuYWN0aXZlLmZvY3VzLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXdhcm5pbmcuZm9jdXN7Y29sb3I6I2ZmZjtiYWNrZ3JvdW5kLWNvbG9yOiNkNTg1MTI7Ym9yZGVyLWNvbG9yOiM5ODVmMGR9LmJ0bi13YXJuaW5nOmFjdGl2ZSwuYnRuLXdhcm5pbmcuYWN0aXZlLC5vcGVuPi5kcm9wZG93bi10b2dnbGUuYnRuLXdhcm5pbmd7YmFja2dyb3VuZC1pbWFnZTpub25lfS5idG4td2FybmluZy5kaXNhYmxlZDpob3ZlciwuYnRuLXdhcm5pbmdbZGlzYWJsZWRdOmhvdmVyLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLXdhcm5pbmc6aG92ZXIsLmJ0bi13YXJuaW5nLmRpc2FibGVkOmZvY3VzLC5idG4td2FybmluZ1tkaXNhYmxlZF06Zm9jdXMsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4td2FybmluZzpmb2N1cywuYnRuLXdhcm5pbmcuZGlzYWJsZWQuZm9jdXMsLmJ0bi13YXJuaW5nW2Rpc2FibGVkXS5mb2N1cyxmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi13YXJuaW5nLmZvY3Vze2JhY2tncm91bmQtY29sb3I6I2YwYWQ0ZTtib3JkZXItY29sb3I6I2VlYTIzNn0uYnRuLXdhcm5pbmcgLmJhZGdle2NvbG9yOiNmMGFkNGU7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5idG4tZGFuZ2Vye2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojZDk1MzRmO2JvcmRlci1jb2xvcjojZDQzZjNhfS5idG4tZGFuZ2VyOmZvY3VzLC5idG4tZGFuZ2VyLmZvY3Vze2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojYzkzMDJjO2JvcmRlci1jb2xvcjojNzYxYzE5fS5idG4tZGFuZ2VyOmhvdmVye2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojYzkzMDJjO2JvcmRlci1jb2xvcjojYWMyOTI1fS5idG4tZGFuZ2VyOmFjdGl2ZSwuYnRuLWRhbmdlci5hY3RpdmUsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tZGFuZ2Vye2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojYzkzMDJjO2JvcmRlci1jb2xvcjojYWMyOTI1fS5idG4tZGFuZ2VyOmFjdGl2ZTpob3ZlciwuYnRuLWRhbmdlci5hY3RpdmU6aG92ZXIsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tZGFuZ2VyOmhvdmVyLC5idG4tZGFuZ2VyOmFjdGl2ZTpmb2N1cywuYnRuLWRhbmdlci5hY3RpdmU6Zm9jdXMsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tZGFuZ2VyOmZvY3VzLC5idG4tZGFuZ2VyOmFjdGl2ZS5mb2N1cywuYnRuLWRhbmdlci5hY3RpdmUuZm9jdXMsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tZGFuZ2VyLmZvY3Vze2NvbG9yOiNmZmY7YmFja2dyb3VuZC1jb2xvcjojYWMyOTI1O2JvcmRlci1jb2xvcjojNzYxYzE5fS5idG4tZGFuZ2VyOmFjdGl2ZSwuYnRuLWRhbmdlci5hY3RpdmUsLm9wZW4+LmRyb3Bkb3duLXRvZ2dsZS5idG4tZGFuZ2Vye2JhY2tncm91bmQtaW1hZ2U6bm9uZX0uYnRuLWRhbmdlci5kaXNhYmxlZDpob3ZlciwuYnRuLWRhbmdlcltkaXNhYmxlZF06aG92ZXIsZmllbGRzZXRbZGlzYWJsZWRdIC5idG4tZGFuZ2VyOmhvdmVyLC5idG4tZGFuZ2VyLmRpc2FibGVkOmZvY3VzLC5idG4tZGFuZ2VyW2Rpc2FibGVkXTpmb2N1cyxmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi1kYW5nZXI6Zm9jdXMsLmJ0bi1kYW5nZXIuZGlzYWJsZWQuZm9jdXMsLmJ0bi1kYW5nZXJbZGlzYWJsZWRdLmZvY3VzLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLWRhbmdlci5mb2N1c3tiYWNrZ3JvdW5kLWNvbG9yOiNkOTUzNGY7Ym9yZGVyLWNvbG9yOiNkNDNmM2F9LmJ0bi1kYW5nZXIgLmJhZGdle2NvbG9yOiNkOTUzNGY7YmFja2dyb3VuZC1jb2xvcjojZmZmfS5idG4tbGlua3tjb2xvcjojMzM3YWI3O2ZvbnQtd2VpZ2h0Om5vcm1hbDtib3JkZXItcmFkaXVzOjB9LmJ0bi1saW5rLC5idG4tbGluazphY3RpdmUsLmJ0bi1saW5rLmFjdGl2ZSwuYnRuLWxpbmtbZGlzYWJsZWRdLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLWxpbmt7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDstd2Via2l0LWJveC1zaGFkb3c6bm9uZTtib3gtc2hhZG93Om5vbmV9LmJ0bi1saW5rLC5idG4tbGluazpob3ZlciwuYnRuLWxpbms6Zm9jdXMsLmJ0bi1saW5rOmFjdGl2ZXtib3JkZXItY29sb3I6dHJhbnNwYXJlbnR9LmJ0bi1saW5rOmhvdmVyLC5idG4tbGluazpmb2N1c3tjb2xvcjojMjM1MjdjO3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmU7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudH0uYnRuLWxpbmtbZGlzYWJsZWRdOmhvdmVyLGZpZWxkc2V0W2Rpc2FibGVkXSAuYnRuLWxpbms6aG92ZXIsLmJ0bi1saW5rW2Rpc2FibGVkXTpmb2N1cyxmaWVsZHNldFtkaXNhYmxlZF0gLmJ0bi1saW5rOmZvY3Vze2NvbG9yOiM3Nzc7dGV4dC1kZWNvcmF0aW9uOm5vbmV9LmJ0bi1sZywuYnRuLWdyb3VwLWxnPi5idG57cGFkZGluZzoxMHB4IDE2cHg7Zm9udC1zaXplOjE4cHg7bGluZS1oZWlnaHQ6MS4zMzMzMzMzO2JvcmRlci1yYWRpdXM6NnB4fS5idG4tc20sLmJ0bi1ncm91cC1zbT4uYnRue3BhZGRpbmc6NXB4IDEwcHg7Zm9udC1zaXplOjEycHg7bGluZS1oZWlnaHQ6MS41O2JvcmRlci1yYWRpdXM6M3B4fS5idG4teHMsLmJ0bi1ncm91cC14cz4uYnRue3BhZGRpbmc6MXB4IDVweDtmb250LXNpemU6MTJweDtsaW5lLWhlaWdodDoxLjU7Ym9yZGVyLXJhZGl1czozcHh9LmJ0bi1ibG9ja3tkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCV9LmJ0bi1ibG9jaysuYnRuLWJsb2Nre21hcmdpbi10b3A6NXB4fWlucHV0W3R5cGU9XFxcInN1Ym1pdFxcXCJdLmJ0bi1ibG9jayxpbnB1dFt0eXBlPVxcXCJyZXNldFxcXCJdLmJ0bi1ibG9jayxpbnB1dFt0eXBlPVxcXCJidXR0b25cXFwiXS5idG4tYmxvY2t7d2lkdGg6MTAwJX0uY2FyZXR7ZGlzcGxheTppbmxpbmUtYmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDttYXJnaW4tbGVmdDoycHg7dmVydGljYWwtYWxpZ246bWlkZGxlO2JvcmRlci10b3A6NHB4IGRhc2hlZDtib3JkZXItdG9wOjRweCBzb2xpZCBcXFxcOTtib3JkZXItcmlnaHQ6NHB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1sZWZ0OjRweCBzb2xpZCB0cmFuc3BhcmVudH0uZHJvcHVwLC5kcm9wZG93bntwb3NpdGlvbjpyZWxhdGl2ZX0uZHJvcGRvd24tdG9nZ2xlOmZvY3Vze291dGxpbmU6MH0uZHJvcGRvd24tbWVudXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MTAwJTtsZWZ0OjA7ei1pbmRleDoxMDAwO2Rpc3BsYXk6bm9uZTtmbG9hdDpsZWZ0O21pbi13aWR0aDoxNjBweDtwYWRkaW5nOjVweCAwO21hcmdpbjoycHggMCAwO2xpc3Qtc3R5bGU6bm9uZTtmb250LXNpemU6MTRweDt0ZXh0LWFsaWduOmxlZnQ7YmFja2dyb3VuZC1jb2xvcjojZmZmO2JvcmRlcjoxcHggc29saWQgI2NjYztib3JkZXI6MXB4IHNvbGlkIHJnYmEoMCwwLDAsMC4xNSk7Ym9yZGVyLXJhZGl1czo0cHg7LXdlYmtpdC1ib3gtc2hhZG93OjAgNnB4IDEycHggcmdiYSgwLDAsMCwwLjE3NSk7Ym94LXNoYWRvdzowIDZweCAxMnB4IHJnYmEoMCwwLDAsMC4xNzUpOy13ZWJraXQtYmFja2dyb3VuZC1jbGlwOnBhZGRpbmctYm94O2JhY2tncm91bmQtY2xpcDpwYWRkaW5nLWJveH0uZHJvcGRvd24tbWVudS5wdWxsLXJpZ2h0e3JpZ2h0OjA7bGVmdDphdXRvfS5kcm9wZG93bi1tZW51IC5kaXZpZGVye2hlaWdodDoxcHg7bWFyZ2luOjlweCAwO292ZXJmbG93OmhpZGRlbjtiYWNrZ3JvdW5kLWNvbG9yOiNlNWU1ZTV9LmRyb3Bkb3duLW1lbnU+bGk+YXtkaXNwbGF5OmJsb2NrO3BhZGRpbmc6M3B4IDIwcHg7Y2xlYXI6Ym90aDtmb250LXdlaWdodDpub3JtYWw7bGluZS1oZWlnaHQ6MS40Mjg1NzE0Mztjb2xvcjojMzMzO3doaXRlLXNwYWNlOm5vd3JhcH0uZHJvcGRvd24tbWVudT5saT5hOmhvdmVyLC5kcm9wZG93bi1tZW51PmxpPmE6Zm9jdXN7dGV4dC1kZWNvcmF0aW9uOm5vbmU7Y29sb3I6IzI2MjYyNjtiYWNrZ3JvdW5kLWNvbG9yOiNmNWY1ZjV9LmRyb3Bkb3duLW1lbnU+LmFjdGl2ZT5hLC5kcm9wZG93bi1tZW51Pi5hY3RpdmU+YTpob3ZlciwuZHJvcGRvd24tbWVudT4uYWN0aXZlPmE6Zm9jdXN7Y29sb3I6I2ZmZjt0ZXh0LWRlY29yYXRpb246bm9uZTtvdXRsaW5lOjA7YmFja2dyb3VuZC1jb2xvcjojMzM3YWI3fS5kcm9wZG93bi1tZW51Pi5kaXNhYmxlZD5hLC5kcm9wZG93bi1tZW51Pi5kaXNhYmxlZD5hOmhvdmVyLC5kcm9wZG93bi1tZW51Pi5kaXNhYmxlZD5hOmZvY3Vze2NvbG9yOiM3Nzd9LmRyb3Bkb3duLW1lbnU+LmRpc2FibGVkPmE6aG92ZXIsLmRyb3Bkb3duLW1lbnU+LmRpc2FibGVkPmE6Zm9jdXN7dGV4dC1kZWNvcmF0aW9uOm5vbmU7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtiYWNrZ3JvdW5kLWltYWdlOm5vbmU7ZmlsdGVyOnByb2dpZDpEWEltYWdlVHJhbnNmb3JtLk1pY3Jvc29mdC5ncmFkaWVudChlbmFibGVkID0gZmFsc2UpO2N1cnNvcjpub3QtYWxsb3dlZH0ub3Blbj4uZHJvcGRvd24tbWVudXtkaXNwbGF5OmJsb2NrfS5vcGVuPmF7b3V0bGluZTowfS5kcm9wZG93bi1tZW51LXJpZ2h0e2xlZnQ6YXV0bztyaWdodDowfS5kcm9wZG93bi1tZW51LWxlZnR7bGVmdDowO3JpZ2h0OmF1dG99LmRyb3Bkb3duLWhlYWRlcntkaXNwbGF5OmJsb2NrO3BhZGRpbmc6M3B4IDIwcHg7Zm9udC1zaXplOjEycHg7bGluZS1oZWlnaHQ6MS40Mjg1NzE0Mztjb2xvcjojNzc3O3doaXRlLXNwYWNlOm5vd3JhcH0uZHJvcGRvd24tYmFja2Ryb3B7cG9zaXRpb246Zml4ZWQ7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjA7dG9wOjA7ei1pbmRleDo5OTB9LnB1bGwtcmlnaHQ+LmRyb3Bkb3duLW1lbnV7cmlnaHQ6MDtsZWZ0OmF1dG99LmRyb3B1cCAuY2FyZXQsLm5hdmJhci1maXhlZC1ib3R0b20gLmRyb3Bkb3duIC5jYXJldHtib3JkZXItdG9wOjA7Ym9yZGVyLWJvdHRvbTo0cHggZGFzaGVkO2JvcmRlci1ib3R0b206NHB4IHNvbGlkIFxcXFw5O2NvbnRlbnQ6XFxcIlxcXCJ9LmRyb3B1cCAuZHJvcGRvd24tbWVudSwubmF2YmFyLWZpeGVkLWJvdHRvbSAuZHJvcGRvd24gLmRyb3Bkb3duLW1lbnV7dG9wOmF1dG87Ym90dG9tOjEwMCU7bWFyZ2luLWJvdHRvbToycHh9QG1lZGlhIChtaW4td2lkdGg6NzY4cHgpey5uYXZiYXItcmlnaHQgLmRyb3Bkb3duLW1lbnV7bGVmdDphdXRvO3JpZ2h0OjB9Lm5hdmJhci1yaWdodCAuZHJvcGRvd24tbWVudS1sZWZ0e2xlZnQ6MDtyaWdodDphdXRvfX0uYnRuLWdyb3VwLC5idG4tZ3JvdXAtdmVydGljYWx7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246bWlkZGxlfS5idG4tZ3JvdXA+LmJ0biwuYnRuLWdyb3VwLXZlcnRpY2FsPi5idG57cG9zaXRpb246cmVsYXRpdmU7ZmxvYXQ6bGVmdH0uYnRuLWdyb3VwPi5idG46aG92ZXIsLmJ0bi1ncm91cC12ZXJ0aWNhbD4uYnRuOmhvdmVyLC5idG4tZ3JvdXA+LmJ0bjpmb2N1cywuYnRuLWdyb3VwLXZlcnRpY2FsPi5idG46Zm9jdXMsLmJ0bi1ncm91cD4uYnRuOmFjdGl2ZSwuYnRuLWdyb3VwLXZlcnRpY2FsPi5idG46YWN0aXZlLC5idG4tZ3JvdXA+LmJ0bi5hY3RpdmUsLmJ0bi1ncm91cC12ZXJ0aWNhbD4uYnRuLmFjdGl2ZXt6LWluZGV4OjJ9LmJ0bi1ncm91cCAuYnRuKy5idG4sLmJ0bi1ncm91cCAuYnRuKy5idG4tZ3JvdXAsLmJ0bi1ncm91cCAuYnRuLWdyb3VwKy5idG4sLmJ0bi1ncm91cCAuYnRuLWdyb3VwKy5idG4tZ3JvdXB7bWFyZ2luLWxlZnQ6LTFweH0uYnRuLXRvb2xiYXJ7bWFyZ2luLWxlZnQ6LTVweH0uYnRuLXRvb2xiYXIgLmJ0biwuYnRuLXRvb2xiYXIgLmJ0bi1ncm91cCwuYnRuLXRvb2xiYXIgLmlucHV0LWdyb3Vwe2Zsb2F0OmxlZnR9LmJ0bi10b29sYmFyPi5idG4sLmJ0bi10b29sYmFyPi5idG4tZ3JvdXAsLmJ0bi10b29sYmFyPi5pbnB1dC1ncm91cHttYXJnaW4tbGVmdDo1cHh9LmJ0bi1ncm91cD4uYnRuOm5vdCg6Zmlyc3QtY2hpbGQpOm5vdCg6bGFzdC1jaGlsZCk6bm90KC5kcm9wZG93bi10b2dnbGUpe2JvcmRlci1yYWRpdXM6MH0uYnRuLWdyb3VwPi5idG46Zmlyc3QtY2hpbGR7bWFyZ2luLWxlZnQ6MH0uYnRuLWdyb3VwPi5idG46Zmlyc3QtY2hpbGQ6bm90KDpsYXN0LWNoaWxkKTpub3QoLmRyb3Bkb3duLXRvZ2dsZSl7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czowfS5idG4tZ3JvdXA+LmJ0bjpsYXN0LWNoaWxkOm5vdCg6Zmlyc3QtY2hpbGQpLC5idG4tZ3JvdXA+LmRyb3Bkb3duLXRvZ2dsZTpub3QoOmZpcnN0LWNoaWxkKXtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czowfS5idG4tZ3JvdXA+LmJ0bi1ncm91cHtmbG9hdDpsZWZ0fS5idG4tZ3JvdXA+LmJ0bi1ncm91cDpub3QoOmZpcnN0LWNoaWxkKTpub3QoOmxhc3QtY2hpbGQpPi5idG57Ym9yZGVyLXJhZGl1czowfS5idG4tZ3JvdXA+LmJ0bi1ncm91cDpmaXJzdC1jaGlsZDpub3QoOmxhc3QtY2hpbGQpPi5idG46bGFzdC1jaGlsZCwuYnRuLWdyb3VwPi5idG4tZ3JvdXA6Zmlyc3QtY2hpbGQ6bm90KDpsYXN0LWNoaWxkKT4uZHJvcGRvd24tdG9nZ2xle2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6MH0uYnRuLWdyb3VwPi5idG4tZ3JvdXA6bGFzdC1jaGlsZDpub3QoOmZpcnN0LWNoaWxkKT4uYnRuOmZpcnN0LWNoaWxke2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MDtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjB9LmJ0bi1ncm91cCAuZHJvcGRvd24tdG9nZ2xlOmFjdGl2ZSwuYnRuLWdyb3VwLm9wZW4gLmRyb3Bkb3duLXRvZ2dsZXtvdXRsaW5lOjB9LmJ0bi1ncm91cD4uYnRuKy5kcm9wZG93bi10b2dnbGV7cGFkZGluZy1sZWZ0OjhweDtwYWRkaW5nLXJpZ2h0OjhweH0uYnRuLWdyb3VwPi5idG4tbGcrLmRyb3Bkb3duLXRvZ2dsZXtwYWRkaW5nLWxlZnQ6MTJweDtwYWRkaW5nLXJpZ2h0OjEycHh9LmJ0bi1ncm91cC5vcGVuIC5kcm9wZG93bi10b2dnbGV7LXdlYmtpdC1ib3gtc2hhZG93Omluc2V0IDAgM3B4IDVweCByZ2JhKDAsMCwwLDAuMTI1KTtib3gtc2hhZG93Omluc2V0IDAgM3B4IDVweCByZ2JhKDAsMCwwLDAuMTI1KX0uYnRuLWdyb3VwLm9wZW4gLmRyb3Bkb3duLXRvZ2dsZS5idG4tbGlua3std2Via2l0LWJveC1zaGFkb3c6bm9uZTtib3gtc2hhZG93Om5vbmV9LmJ0biAuY2FyZXR7bWFyZ2luLWxlZnQ6MH0uYnRuLWxnIC5jYXJldHtib3JkZXItd2lkdGg6NXB4IDVweCAwO2JvcmRlci1ib3R0b20td2lkdGg6MH0uZHJvcHVwIC5idG4tbGcgLmNhcmV0e2JvcmRlci13aWR0aDowIDVweCA1cHh9LmJ0bi1ncm91cC12ZXJ0aWNhbD4uYnRuLC5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cCwuYnRuLWdyb3VwLXZlcnRpY2FsPi5idG4tZ3JvdXA+LmJ0bntkaXNwbGF5OmJsb2NrO2Zsb2F0Om5vbmU7d2lkdGg6MTAwJTttYXgtd2lkdGg6MTAwJX0uYnRuLWdyb3VwLXZlcnRpY2FsPi5idG4tZ3JvdXA+LmJ0bntmbG9hdDpub25lfS5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bisuYnRuLC5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bisuYnRuLWdyb3VwLC5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cCsuYnRuLC5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cCsuYnRuLWdyb3Vwe21hcmdpbi10b3A6LTFweDttYXJnaW4tbGVmdDowfS5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bjpub3QoOmZpcnN0LWNoaWxkKTpub3QoOmxhc3QtY2hpbGQpe2JvcmRlci1yYWRpdXM6MH0uYnRuLWdyb3VwLXZlcnRpY2FsPi5idG46Zmlyc3QtY2hpbGQ6bm90KDpsYXN0LWNoaWxkKXtib3JkZXItdG9wLXJpZ2h0LXJhZGl1czo0cHg7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czo0cHg7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MDtib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOjB9LmJ0bi1ncm91cC12ZXJ0aWNhbD4uYnRuOmxhc3QtY2hpbGQ6bm90KDpmaXJzdC1jaGlsZCl7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6NHB4O2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6NHB4fS5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cDpub3QoOmZpcnN0LWNoaWxkKTpub3QoOmxhc3QtY2hpbGQpPi5idG57Ym9yZGVyLXJhZGl1czowfS5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cDpmaXJzdC1jaGlsZDpub3QoOmxhc3QtY2hpbGQpPi5idG46bGFzdC1jaGlsZCwuYnRuLWdyb3VwLXZlcnRpY2FsPi5idG4tZ3JvdXA6Zmlyc3QtY2hpbGQ6bm90KDpsYXN0LWNoaWxkKT4uZHJvcGRvd24tdG9nZ2xle2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjA7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czowfS5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cDpsYXN0LWNoaWxkOm5vdCg6Zmlyc3QtY2hpbGQpPi5idG46Zmlyc3QtY2hpbGR7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6MDtib3JkZXItdG9wLWxlZnQtcmFkaXVzOjB9LmJ0bi1ncm91cC1qdXN0aWZpZWR7ZGlzcGxheTp0YWJsZTt3aWR0aDoxMDAlO3RhYmxlLWxheW91dDpmaXhlZDtib3JkZXItY29sbGFwc2U6c2VwYXJhdGV9LmJ0bi1ncm91cC1qdXN0aWZpZWQ+LmJ0biwuYnRuLWdyb3VwLWp1c3RpZmllZD4uYnRuLWdyb3Vwe2Zsb2F0Om5vbmU7ZGlzcGxheTp0YWJsZS1jZWxsO3dpZHRoOjElfS5idG4tZ3JvdXAtanVzdGlmaWVkPi5idG4tZ3JvdXAgLmJ0bnt3aWR0aDoxMDAlfS5idG4tZ3JvdXAtanVzdGlmaWVkPi5idG4tZ3JvdXAgLmRyb3Bkb3duLW1lbnV7bGVmdDphdXRvfVtkYXRhLXRvZ2dsZT1cXFwiYnV0dG9uc1xcXCJdPi5idG4gaW5wdXRbdHlwZT1cXFwicmFkaW9cXFwiXSxbZGF0YS10b2dnbGU9XFxcImJ1dHRvbnNcXFwiXT4uYnRuLWdyb3VwPi5idG4gaW5wdXRbdHlwZT1cXFwicmFkaW9cXFwiXSxbZGF0YS10b2dnbGU9XFxcImJ1dHRvbnNcXFwiXT4uYnRuIGlucHV0W3R5cGU9XFxcImNoZWNrYm94XFxcIl0sW2RhdGEtdG9nZ2xlPVxcXCJidXR0b25zXFxcIl0+LmJ0bi1ncm91cD4uYnRuIGlucHV0W3R5cGU9XFxcImNoZWNrYm94XFxcIl17cG9zaXRpb246YWJzb2x1dGU7Y2xpcDpyZWN0KDAsIDAsIDAsIDApO3BvaW50ZXItZXZlbnRzOm5vbmV9LnRvb2x0aXB7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDoxMDcwO2Rpc3BsYXk6YmxvY2s7Zm9udC1mYW1pbHk6XFxcIkhlbHZldGljYSBOZXVlXFxcIixIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZjtmb250LXN0eWxlOm5vcm1hbDtmb250LXdlaWdodDpub3JtYWw7bGV0dGVyLXNwYWNpbmc6bm9ybWFsO2xpbmUtYnJlYWs6YXV0bztsaW5lLWhlaWdodDoxLjQyODU3MTQzO3RleHQtYWxpZ246bGVmdDt0ZXh0LWFsaWduOnN0YXJ0O3RleHQtZGVjb3JhdGlvbjpub25lO3RleHQtc2hhZG93Om5vbmU7dGV4dC10cmFuc2Zvcm06bm9uZTt3aGl0ZS1zcGFjZTpub3JtYWw7d29yZC1icmVhazpub3JtYWw7d29yZC1zcGFjaW5nOm5vcm1hbDt3b3JkLXdyYXA6bm9ybWFsO2ZvbnQtc2l6ZToxMnB4O29wYWNpdHk6MDtmaWx0ZXI6YWxwaGEob3BhY2l0eT0wKX0udG9vbHRpcC5pbntvcGFjaXR5Oi45O2ZpbHRlcjphbHBoYShvcGFjaXR5PTkwKX0udG9vbHRpcC50b3B7bWFyZ2luLXRvcDotM3B4O3BhZGRpbmc6NXB4IDB9LnRvb2x0aXAucmlnaHR7bWFyZ2luLWxlZnQ6M3B4O3BhZGRpbmc6MCA1cHh9LnRvb2x0aXAuYm90dG9te21hcmdpbi10b3A6M3B4O3BhZGRpbmc6NXB4IDB9LnRvb2x0aXAubGVmdHttYXJnaW4tbGVmdDotM3B4O3BhZGRpbmc6MCA1cHh9LnRvb2x0aXAtaW5uZXJ7bWF4LXdpZHRoOjIwMHB4O3BhZGRpbmc6M3B4IDhweDtjb2xvcjojZmZmO3RleHQtYWxpZ246Y2VudGVyO2JhY2tncm91bmQtY29sb3I6IzAwMDtib3JkZXItcmFkaXVzOjRweH0udG9vbHRpcC1hcnJvd3twb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDowO2hlaWdodDowO2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItc3R5bGU6c29saWR9LnRvb2x0aXAudG9wIC50b29sdGlwLWFycm93e2JvdHRvbTowO2xlZnQ6NTAlO21hcmdpbi1sZWZ0Oi01cHg7Ym9yZGVyLXdpZHRoOjVweCA1cHggMDtib3JkZXItdG9wLWNvbG9yOiMwMDB9LnRvb2x0aXAudG9wLWxlZnQgLnRvb2x0aXAtYXJyb3d7Ym90dG9tOjA7cmlnaHQ6NXB4O21hcmdpbi1ib3R0b206LTVweDtib3JkZXItd2lkdGg6NXB4IDVweCAwO2JvcmRlci10b3AtY29sb3I6IzAwMH0udG9vbHRpcC50b3AtcmlnaHQgLnRvb2x0aXAtYXJyb3d7Ym90dG9tOjA7bGVmdDo1cHg7bWFyZ2luLWJvdHRvbTotNXB4O2JvcmRlci13aWR0aDo1cHggNXB4IDA7Ym9yZGVyLXRvcC1jb2xvcjojMDAwfS50b29sdGlwLnJpZ2h0IC50b29sdGlwLWFycm93e3RvcDo1MCU7bGVmdDowO21hcmdpbi10b3A6LTVweDtib3JkZXItd2lkdGg6NXB4IDVweCA1cHggMDtib3JkZXItcmlnaHQtY29sb3I6IzAwMH0udG9vbHRpcC5sZWZ0IC50b29sdGlwLWFycm93e3RvcDo1MCU7cmlnaHQ6MDttYXJnaW4tdG9wOi01cHg7Ym9yZGVyLXdpZHRoOjVweCAwIDVweCA1cHg7Ym9yZGVyLWxlZnQtY29sb3I6IzAwMH0udG9vbHRpcC5ib3R0b20gLnRvb2x0aXAtYXJyb3d7dG9wOjA7bGVmdDo1MCU7bWFyZ2luLWxlZnQ6LTVweDtib3JkZXItd2lkdGg6MCA1cHggNXB4O2JvcmRlci1ib3R0b20tY29sb3I6IzAwMH0udG9vbHRpcC5ib3R0b20tbGVmdCAudG9vbHRpcC1hcnJvd3t0b3A6MDtyaWdodDo1cHg7bWFyZ2luLXRvcDotNXB4O2JvcmRlci13aWR0aDowIDVweCA1cHg7Ym9yZGVyLWJvdHRvbS1jb2xvcjojMDAwfS50b29sdGlwLmJvdHRvbS1yaWdodCAudG9vbHRpcC1hcnJvd3t0b3A6MDtsZWZ0OjVweDttYXJnaW4tdG9wOi01cHg7Ym9yZGVyLXdpZHRoOjAgNXB4IDVweDtib3JkZXItYm90dG9tLWNvbG9yOiMwMDB9LmNsZWFyZml4OmJlZm9yZSwuY2xlYXJmaXg6YWZ0ZXIsLmJ0bi10b29sYmFyOmJlZm9yZSwuYnRuLXRvb2xiYXI6YWZ0ZXIsLmJ0bi1ncm91cC12ZXJ0aWNhbD4uYnRuLWdyb3VwOmJlZm9yZSwuYnRuLWdyb3VwLXZlcnRpY2FsPi5idG4tZ3JvdXA6YWZ0ZXJ7Y29udGVudDpcXFwiIFxcXCI7ZGlzcGxheTp0YWJsZX0uY2xlYXJmaXg6YWZ0ZXIsLmJ0bi10b29sYmFyOmFmdGVyLC5idG4tZ3JvdXAtdmVydGljYWw+LmJ0bi1ncm91cDphZnRlcntjbGVhcjpib3RofS5jZW50ZXItYmxvY2t7ZGlzcGxheTpibG9jazttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvfS5wdWxsLXJpZ2h0e2Zsb2F0OnJpZ2h0ICFpbXBvcnRhbnR9LnB1bGwtbGVmdHtmbG9hdDpsZWZ0ICFpbXBvcnRhbnR9LmhpZGV7ZGlzcGxheTpub25lICFpbXBvcnRhbnR9LnNob3d7ZGlzcGxheTpibG9jayAhaW1wb3J0YW50fS5pbnZpc2libGV7dmlzaWJpbGl0eTpoaWRkZW59LnRleHQtaGlkZXtmb250OjAvMCBhO2NvbG9yOnRyYW5zcGFyZW50O3RleHQtc2hhZG93Om5vbmU7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXI6MH0uaGlkZGVue2Rpc3BsYXk6bm9uZSAhaW1wb3J0YW50fS5hZmZpeHtwb3NpdGlvbjpmaXhlZH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL3NyYy9lZGl0YWJsZS9jc3MvYm9vdHN0cmFwLm1pbi5jc3Ncbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n");

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(14);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(9)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!./bootstrap.min.css\", function() {\n\t\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!./bootstrap.min.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC5taW4uY3NzPzIwNTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC5taW4uY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC5taW4uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC5taW4uY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9lZGl0YWJsZS9jc3MvYm9vdHN0cmFwLm1pbi5jc3Ncbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n");

/***/ }),
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(5)(undefined);\n// imports\n\n\n// module\nexports.push([module.i, \"ul.wysihtml5-toolbar {\\n\\tmargin: 0;\\n\\tpadding: 0;\\n\\tdisplay: block;\\n}\\n\\nul.wysihtml5-toolbar::after {\\n\\tclear: both;\\n\\tdisplay: table;\\n\\tcontent: \\\"\\\";\\n}\\n\\nul.wysihtml5-toolbar > li {\\n\\tfloat: left;\\n\\tdisplay: list-item;\\n\\tlist-style: none;\\n\\tmargin: 0 5px 10px 0;\\n}\\n\\nul.wysihtml5-toolbar a[data-wysihtml5-command=bold] {\\n\\tfont-weight: bold;\\n}\\n\\nul.wysihtml5-toolbar a[data-wysihtml5-command=italic] {\\n\\tfont-style: italic;\\n}\\n\\nul.wysihtml5-toolbar a[data-wysihtml5-command=underline] {\\n\\ttext-decoration: underline;\\n}\\n\\nul.wysihtml5-toolbar a.btn.wysihtml5-command-active {\\n\\tbackground-image: none;\\n\\t-webkit-box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15),0 1px 2px rgba(0, 0, 0, 0.05);\\n\\t-moz-box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15),0 1px 2px rgba(0, 0, 0, 0.05);\\n\\tbox-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15),0 1px 2px rgba(0, 0, 0, 0.05);\\n\\tbackground-color: #E6E6E6;\\n\\tbackground-color: #D9D9D9;\\n\\toutline: 0;\\n}\\n\\nul.wysihtml5-commands-disabled .dropdown-menu {\\n\\tdisplay: none !important;\\n}\\n\\nul.wysihtml5-toolbar div.wysihtml5-colors {\\n  display:block;\\n  width: 50px;\\n  height: 20px;\\n  margin-top: 2px;\\n  margin-left: 5px;\\n  position: absolute;\\n  pointer-events: none;\\n}\\n\\nul.wysihtml5-toolbar a.wysihtml5-colors-title {\\n  padding-left: 70px;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"clear\\\"] {\\n  background: #a38a77 !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"black\\\"] {\\n  background: black !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"silver\\\"] {\\n  background: silver !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"gray\\\"] {\\n  background: gray !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"maroon\\\"] {\\n  background: maroon !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"red\\\"] {\\n  background: red !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"purple\\\"] {\\n  background: purple !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"green\\\"] {\\n  background: green !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"olive\\\"] {\\n  background: olive !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"navy\\\"] {\\n  background: navy !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"blue\\\"] {\\n  background: blue !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"orange\\\"] {\\n  background: orange !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"first\\\"] {\\n\\tbackground: #149D9A !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"second\\\"] {\\n\\tbackground: #E02924 !important;\\n}\\n\\nul.wysihtml5-toolbar div[data-wysihtml5-command-value=\\\"three\\\"] {\\n\\tbackground: #2954A4 !important;\\n}\\n\", \"\"]);\n\n// exports\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC13eXNpaHRtbDUuY3NzPzIyYzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7O0FBR0E7QUFDQSwrQ0FBZ0QsY0FBYyxlQUFlLG1CQUFtQixHQUFHLGlDQUFpQyxnQkFBZ0IsbUJBQW1CLGtCQUFrQixHQUFHLCtCQUErQixnQkFBZ0IsdUJBQXVCLHFCQUFxQix5QkFBeUIsR0FBRyx5REFBeUQsc0JBQXNCLEdBQUcsMkRBQTJELHVCQUF1QixHQUFHLDhEQUE4RCwrQkFBK0IsR0FBRyx5REFBeUQsMkJBQTJCLDBGQUEwRix1RkFBdUYsa0ZBQWtGLDhCQUE4Qiw4QkFBOEIsZUFBZSxHQUFHLG1EQUFtRCw2QkFBNkIsR0FBRywrQ0FBK0Msa0JBQWtCLGdCQUFnQixpQkFBaUIsb0JBQW9CLHFCQUFxQix1QkFBdUIseUJBQXlCLEdBQUcsbURBQW1ELHVCQUF1QixHQUFHLHNFQUFzRSxtQ0FBbUMsR0FBRyxzRUFBc0UsaUNBQWlDLEdBQUcsdUVBQXVFLGtDQUFrQyxHQUFHLHFFQUFxRSxnQ0FBZ0MsR0FBRyx1RUFBdUUsa0NBQWtDLEdBQUcsb0VBQW9FLCtCQUErQixHQUFHLHVFQUF1RSxrQ0FBa0MsR0FBRyxzRUFBc0UsaUNBQWlDLEdBQUcsc0VBQXNFLGlDQUFpQyxHQUFHLHFFQUFxRSxnQ0FBZ0MsR0FBRyxxRUFBcUUsZ0NBQWdDLEdBQUcsdUVBQXVFLGtDQUFrQyxHQUFHLHNFQUFzRSxtQ0FBbUMsR0FBRyx1RUFBdUUsbUNBQW1DLEdBQUcsc0VBQXNFLG1DQUFtQyxHQUFHOztBQUUxM0YiLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHVuZGVmaW5lZCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJ1bC53eXNpaHRtbDUtdG9vbGJhciB7XFxuXFx0bWFyZ2luOiAwO1xcblxcdHBhZGRpbmc6IDA7XFxuXFx0ZGlzcGxheTogYmxvY2s7XFxufVxcblxcbnVsLnd5c2lodG1sNS10b29sYmFyOjphZnRlciB7XFxuXFx0Y2xlYXI6IGJvdGg7XFxuXFx0ZGlzcGxheTogdGFibGU7XFxuXFx0Y29udGVudDogXFxcIlxcXCI7XFxufVxcblxcbnVsLnd5c2lodG1sNS10b29sYmFyID4gbGkge1xcblxcdGZsb2F0OiBsZWZ0O1xcblxcdGRpc3BsYXk6IGxpc3QtaXRlbTtcXG5cXHRsaXN0LXN0eWxlOiBub25lO1xcblxcdG1hcmdpbjogMCA1cHggMTBweCAwO1xcbn1cXG5cXG51bC53eXNpaHRtbDUtdG9vbGJhciBhW2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9Ym9sZF0ge1xcblxcdGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG5cXG51bC53eXNpaHRtbDUtdG9vbGJhciBhW2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9aXRhbGljXSB7XFxuXFx0Zm9udC1zdHlsZTogaXRhbGljO1xcbn1cXG5cXG51bC53eXNpaHRtbDUtdG9vbGJhciBhW2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9dW5kZXJsaW5lXSB7XFxuXFx0dGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XFxufVxcblxcbnVsLnd5c2lodG1sNS10b29sYmFyIGEuYnRuLnd5c2lodG1sNS1jb21tYW5kLWFjdGl2ZSB7XFxuXFx0YmFja2dyb3VuZC1pbWFnZTogbm9uZTtcXG5cXHQtd2Via2l0LWJveC1zaGFkb3c6IGluc2V0IDAgMnB4IDRweCByZ2JhKDAsIDAsIDAsIDAuMTUpLDAgMXB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMDUpO1xcblxcdC1tb3otYm94LXNoYWRvdzogaW5zZXQgMCAycHggNHB4IHJnYmEoMCwgMCwgMCwgMC4xNSksMCAxcHggMnB4IHJnYmEoMCwgMCwgMCwgMC4wNSk7XFxuXFx0Ym94LXNoYWRvdzogaW5zZXQgMCAycHggNHB4IHJnYmEoMCwgMCwgMCwgMC4xNSksMCAxcHggMnB4IHJnYmEoMCwgMCwgMCwgMC4wNSk7XFxuXFx0YmFja2dyb3VuZC1jb2xvcjogI0U2RTZFNjtcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjRDlEOUQ5O1xcblxcdG91dGxpbmU6IDA7XFxufVxcblxcbnVsLnd5c2lodG1sNS1jb21tYW5kcy1kaXNhYmxlZCAuZHJvcGRvd24tbWVudSB7XFxuXFx0ZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xcbn1cXG5cXG51bC53eXNpaHRtbDUtdG9vbGJhciBkaXYud3lzaWh0bWw1LWNvbG9ycyB7XFxuICBkaXNwbGF5OmJsb2NrO1xcbiAgd2lkdGg6IDUwcHg7XFxuICBoZWlnaHQ6IDIwcHg7XFxuICBtYXJnaW4tdG9wOiAycHg7XFxuICBtYXJnaW4tbGVmdDogNXB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbnVsLnd5c2lodG1sNS10b29sYmFyIGEud3lzaWh0bWw1LWNvbG9ycy10aXRsZSB7XFxuICBwYWRkaW5nLWxlZnQ6IDcwcHg7XFxufVxcblxcbnVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPVxcXCJjbGVhclxcXCJdIHtcXG4gIGJhY2tncm91bmQ6ICNhMzhhNzcgIWltcG9ydGFudDtcXG59XFxuXFxudWwud3lzaWh0bWw1LXRvb2xiYXIgZGl2W2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XFxcImJsYWNrXFxcIl0ge1xcbiAgYmFja2dyb3VuZDogYmxhY2sgIWltcG9ydGFudDtcXG59XFxuXFxudWwud3lzaWh0bWw1LXRvb2xiYXIgZGl2W2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XFxcInNpbHZlclxcXCJdIHtcXG4gIGJhY2tncm91bmQ6IHNpbHZlciAhaW1wb3J0YW50O1xcbn1cXG5cXG51bC53eXNpaHRtbDUtdG9vbGJhciBkaXZbZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwiZ3JheVxcXCJdIHtcXG4gIGJhY2tncm91bmQ6IGdyYXkgIWltcG9ydGFudDtcXG59XFxuXFxudWwud3lzaWh0bWw1LXRvb2xiYXIgZGl2W2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XFxcIm1hcm9vblxcXCJdIHtcXG4gIGJhY2tncm91bmQ6IG1hcm9vbiAhaW1wb3J0YW50O1xcbn1cXG5cXG51bC53eXNpaHRtbDUtdG9vbGJhciBkaXZbZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwicmVkXFxcIl0ge1xcbiAgYmFja2dyb3VuZDogcmVkICFpbXBvcnRhbnQ7XFxufVxcblxcbnVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPVxcXCJwdXJwbGVcXFwiXSB7XFxuICBiYWNrZ3JvdW5kOiBwdXJwbGUgIWltcG9ydGFudDtcXG59XFxuXFxudWwud3lzaWh0bWw1LXRvb2xiYXIgZGl2W2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XFxcImdyZWVuXFxcIl0ge1xcbiAgYmFja2dyb3VuZDogZ3JlZW4gIWltcG9ydGFudDtcXG59XFxuXFxudWwud3lzaWh0bWw1LXRvb2xiYXIgZGl2W2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XFxcIm9saXZlXFxcIl0ge1xcbiAgYmFja2dyb3VuZDogb2xpdmUgIWltcG9ydGFudDtcXG59XFxuXFxudWwud3lzaWh0bWw1LXRvb2xiYXIgZGl2W2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9XFxcIm5hdnlcXFwiXSB7XFxuICBiYWNrZ3JvdW5kOiBuYXZ5ICFpbXBvcnRhbnQ7XFxufVxcblxcbnVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPVxcXCJibHVlXFxcIl0ge1xcbiAgYmFja2dyb3VuZDogYmx1ZSAhaW1wb3J0YW50O1xcbn1cXG5cXG51bC53eXNpaHRtbDUtdG9vbGJhciBkaXZbZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwib3JhbmdlXFxcIl0ge1xcbiAgYmFja2dyb3VuZDogb3JhbmdlICFpbXBvcnRhbnQ7XFxufVxcblxcbnVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPVxcXCJmaXJzdFxcXCJdIHtcXG5cXHRiYWNrZ3JvdW5kOiAjMTQ5RDlBICFpbXBvcnRhbnQ7XFxufVxcblxcbnVsLnd5c2lodG1sNS10b29sYmFyIGRpdltkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPVxcXCJzZWNvbmRcXFwiXSB7XFxuXFx0YmFja2dyb3VuZDogI0UwMjkyNCAhaW1wb3J0YW50O1xcbn1cXG5cXG51bC53eXNpaHRtbDUtdG9vbGJhciBkaXZbZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT1cXFwidGhyZWVcXFwiXSB7XFxuXFx0YmFja2dyb3VuZDogIzI5NTRBNCAhaW1wb3J0YW50O1xcbn1cXG5cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL3NyYy9lZGl0YWJsZS9jc3MvYm9vdHN0cmFwLXd5c2lodG1sNS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///19\n");

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(19);\nif(typeof content === 'string') content = [[module.i, content, '']];\n// Prepare cssTransformation\nvar transform;\n\nvar options = {}\noptions.transform = transform\n// add the styles to the DOM\nvar update = __webpack_require__(9)(content, options);\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../../../node_modules/css-loader/index.js!./bootstrap-wysihtml5.css\", function() {\n\t\t\tvar newContent = require(\"!!../../../node_modules/css-loader/index.js!./bootstrap-wysihtml5.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvY3NzL2Jvb3RzdHJhcC13eXNpaHRtbDUuY3NzPzM2MDciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiIyMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC13eXNpaHRtbDUuY3NzXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4vLyBQcmVwYXJlIGNzc1RyYW5zZm9ybWF0aW9uXG52YXIgdHJhbnNmb3JtO1xuXG52YXIgb3B0aW9ucyA9IHt9XG5vcHRpb25zLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVxuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC13eXNpaHRtbDUuY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL2Jvb3RzdHJhcC13eXNpaHRtbDUuY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9lZGl0YWJsZS9jc3MvYm9vdHN0cmFwLXd5c2lodG1sNS5jc3Ncbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///20\n");

/***/ }),
/* 21 */,
/* 22 */
/***/ (function(module, exports) {

eval("var _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _typeof = typeof Symbol === \"function\" && _typeof2(Symbol.iterator) === \"symbol\" ? function (obj) {\n  return typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj === \"undefined\" ? \"undefined\" : _typeof2(obj);\n};\n\nvar wysihtml5 = {\n  version: \"0.3.0\",\n\n  // namespaces\n  commands: {},\n  dom: {},\n  quirks: {},\n  toolbar: {},\n  lang: {},\n  selection: {},\n  views: {},\n\n  INVISIBLE_SPACE: \"\\uFEFF\",\n\n  EMPTY_FUNCTION: function EMPTY_FUNCTION() {},\n\n  ELEMENT_NODE: 1,\n  TEXT_NODE: 3,\n\n  BACKSPACE_KEY: 8,\n  ENTER_KEY: 13,\n  ESCAPE_KEY: 27,\n  SPACE_KEY: 32,\n  DELETE_KEY: 46\n}; /**\n   * @license Rangy, a cross-browser JavaScript range and selection library\n   * http://code.google.com/p/rangy/\n   *\n   * Copyright 2011, Tim Down\n   * Licensed under the MIT license.\n   * Version: 1.2.2\n   * Build date: 13 November 2011\n   */\nwindow['rangy'] = function () {\n\n  var OBJECT = \"object\",\n      FUNCTION = \"function\",\n      UNDEFINED = \"undefined\";\n\n  var domRangeProperties = [\"startContainer\", \"startOffset\", \"endContainer\", \"endOffset\", \"collapsed\", \"commonAncestorContainer\", \"START_TO_START\", \"START_TO_END\", \"END_TO_START\", \"END_TO_END\"];\n\n  var domRangeMethods = [\"setStart\", \"setStartBefore\", \"setStartAfter\", \"setEnd\", \"setEndBefore\", \"setEndAfter\", \"collapse\", \"selectNode\", \"selectNodeContents\", \"compareBoundaryPoints\", \"deleteContents\", \"extractContents\", \"cloneContents\", \"insertNode\", \"surroundContents\", \"cloneRange\", \"toString\", \"detach\"];\n\n  var textRangeProperties = [\"boundingHeight\", \"boundingLeft\", \"boundingTop\", \"boundingWidth\", \"htmlText\", \"text\"];\n\n  // Subset of TextRange's full set of methods that we're interested in\n  var textRangeMethods = [\"collapse\", \"compareEndPoints\", \"duplicate\", \"getBookmark\", \"moveToBookmark\", \"moveToElementText\", \"parentElement\", \"pasteHTML\", \"select\", \"setEndPoint\", \"getBoundingClientRect\"];\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Trio of functions taken from Peter Michaux's article:\n  // http://peter.michaux.ca/articles/feature-detection-state-of-the-art-browser-scripting\n  function isHostMethod(o, p) {\n    var t = _typeof(o[p]);\n    return t == FUNCTION || !!(t == OBJECT && o[p]) || t == \"unknown\";\n  }\n\n  function isHostObject(o, p) {\n    return !!(_typeof(o[p]) == OBJECT && o[p]);\n  }\n\n  function isHostProperty(o, p) {\n    return _typeof(o[p]) != UNDEFINED;\n  }\n\n  // Creates a convenience function to save verbose repeated calls to tests functions\n  function createMultiplePropertyTest(testFunc) {\n    return function (o, props) {\n      var i = props.length;\n      while (i--) {\n        if (!testFunc(o, props[i])) {\n          return false;\n        }\n      }\n      return true;\n    };\n  }\n\n  // Next trio of functions are a convenience to save verbose repeated calls to previous two functions\n  var areHostMethods = createMultiplePropertyTest(isHostMethod);\n  var areHostObjects = createMultiplePropertyTest(isHostObject);\n  var areHostProperties = createMultiplePropertyTest(isHostProperty);\n\n  function isTextRange(range) {\n    return range && areHostMethods(range, textRangeMethods) && areHostProperties(range, textRangeProperties);\n  }\n\n  var api = {\n    version: \"1.2.2\",\n    initialized: false,\n    supported: true,\n\n    util: {\n      isHostMethod: isHostMethod,\n      isHostObject: isHostObject,\n      isHostProperty: isHostProperty,\n      areHostMethods: areHostMethods,\n      areHostObjects: areHostObjects,\n      areHostProperties: areHostProperties,\n      isTextRange: isTextRange\n    },\n\n    features: {},\n\n    modules: {},\n    config: {\n      alertOnWarn: false,\n      preferTextRange: false\n    }\n  };\n\n  function fail(reason) {\n    window.alert(\"Rangy not supported in your browser. Reason: \" + reason);\n    api.initialized = true;\n    api.supported = false;\n  }\n\n  api.fail = fail;\n\n  function warn(msg) {\n    var warningMessage = \"Rangy warning: \" + msg;\n    if (api.config.alertOnWarn) {\n      window.alert(warningMessage);\n    } else if (_typeof(window.console) != UNDEFINED && _typeof(window.console.log) != UNDEFINED) {\n      window.console.log(warningMessage);\n    }\n  }\n\n  api.warn = warn;\n\n  if ({}.hasOwnProperty) {\n    api.util.extend = function (o, props) {\n      for (var i in props) {\n        if (props.hasOwnProperty(i)) {\n          o[i] = props[i];\n        }\n      }\n    };\n  } else {\n    fail(\"hasOwnProperty not supported\");\n  }\n\n  var initListeners = [];\n  var moduleInitializers = [];\n\n  // Initialization\n  function init() {\n    if (api.initialized) {\n      return;\n    }\n    var testRange;\n    var implementsDomRange = false,\n        implementsTextRange = false;\n\n    // First, perform basic feature tests\n\n    if (isHostMethod(document, \"createRange\")) {\n      testRange = document.createRange();\n      if (areHostMethods(testRange, domRangeMethods) && areHostProperties(testRange, domRangeProperties)) {\n        implementsDomRange = true;\n      }\n      testRange.detach();\n    }\n\n    var body = isHostObject(document, \"body\") ? document.body : document.getElementsByTagName(\"body\")[0];\n\n    if (body && isHostMethod(body, \"createTextRange\")) {\n      testRange = body.createTextRange();\n      if (isTextRange(testRange)) {\n        implementsTextRange = true;\n      }\n    }\n\n    if (!implementsDomRange && !implementsTextRange) {\n      fail(\"Neither Range nor TextRange are implemented\");\n    }\n\n    api.initialized = true;\n    api.features = {\n      implementsDomRange: implementsDomRange,\n      implementsTextRange: implementsTextRange\n    };\n\n    // Initialize modules and call init listeners\n    var allListeners = moduleInitializers.concat(initListeners);\n    for (var i = 0, len = allListeners.length; i < len; ++i) {\n      try {\n        allListeners[i](api);\n      } catch (ex) {\n        if (isHostObject(window, \"console\") && isHostMethod(window.console, \"log\")) {\n          window.console.log(\"Init listener threw an exception. Continuing.\", ex);\n        }\n      }\n    }\n  }\n\n  // Allow external scripts to initialize this library in case it's loaded after the document has loaded\n  api.init = init;\n\n  // Execute listener immediately if already initialized\n  api.addInitListener = function (listener) {\n    if (api.initialized) {\n      listener(api);\n    } else {\n      initListeners.push(listener);\n    }\n  };\n\n  var createMissingNativeApiListeners = [];\n\n  api.addCreateMissingNativeApiListener = function (listener) {\n    createMissingNativeApiListeners.push(listener);\n  };\n\n  function createMissingNativeApi(win) {\n    win = win || window;\n    init();\n\n    // Notify listeners\n    for (var i = 0, len = createMissingNativeApiListeners.length; i < len; ++i) {\n      createMissingNativeApiListeners[i](win);\n    }\n  }\n\n  api.createMissingNativeApi = createMissingNativeApi;\n\n  /**\n   * @constructor\n   */\n  function Module(name) {\n    this.name = name;\n    this.initialized = false;\n    this.supported = false;\n  }\n\n  Module.prototype.fail = function (reason) {\n    this.initialized = true;\n    this.supported = false;\n\n    throw new Error(\"Module '\" + this.name + \"' failed to load: \" + reason);\n  };\n\n  Module.prototype.warn = function (msg) {\n    api.warn(\"Module \" + this.name + \": \" + msg);\n  };\n\n  Module.prototype.createError = function (msg) {\n    return new Error(\"Error in Rangy \" + this.name + \" module: \" + msg);\n  };\n\n  api.createModule = function (name, initFunc) {\n    var module = new Module(name);\n    api.modules[name] = module;\n\n    moduleInitializers.push(function (api) {\n      initFunc(api, module);\n      module.initialized = true;\n      module.supported = true;\n    });\n  };\n\n  api.requireModules = function (modules) {\n    for (var i = 0, len = modules.length, module, moduleName; i < len; ++i) {\n      moduleName = modules[i];\n      module = api.modules[moduleName];\n      if (!module || !(module instanceof Module)) {\n        throw new Error(\"Module '\" + moduleName + \"' not found\");\n      }\n      if (!module.supported) {\n        throw new Error(\"Module '\" + moduleName + \"' not supported\");\n      }\n    }\n  };\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Wait for document to load before running tests\n\n  var docReady = false;\n\n  var loadHandler = function loadHandler(e) {\n\n    if (!docReady) {\n      docReady = true;\n      if (!api.initialized) {\n        init();\n      }\n    }\n  };\n\n  // Test whether we have window and document objects that we will need\n  if ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) == UNDEFINED) {\n    fail(\"No window found\");\n    return;\n  }\n  if ((typeof document === \"undefined\" ? \"undefined\" : _typeof(document)) == UNDEFINED) {\n    fail(\"No document found\");\n    return;\n  }\n\n  if (isHostMethod(document, \"addEventListener\")) {\n    document.addEventListener(\"DOMContentLoaded\", loadHandler, false);\n  }\n\n  // Add a fallback in case the DOMContentLoaded event isn't supported\n  if (isHostMethod(window, \"addEventListener\")) {\n    window.addEventListener(\"load\", loadHandler, false);\n  } else if (isHostMethod(window, \"attachEvent\")) {\n    window.attachEvent(\"onload\", loadHandler);\n  } else {\n    fail(\"Window does not have required addEventListener or attachEvent method\");\n  }\n\n  return api;\n}();\nrangy.createModule(\"DomUtil\", function (api, module) {\n\n  var UNDEF = \"undefined\";\n  var util = api.util;\n\n  // Perform feature tests\n  if (!util.areHostMethods(document, [\"createDocumentFragment\", \"createElement\", \"createTextNode\"])) {\n    module.fail(\"document missing a Node creation method\");\n  }\n\n  if (!util.isHostMethod(document, \"getElementsByTagName\")) {\n    module.fail(\"document missing getElementsByTagName method\");\n  }\n\n  var el = document.createElement(\"div\");\n  if (!util.areHostMethods(el, [\"insertBefore\", \"appendChild\", \"cloneNode\"] || !util.areHostObjects(el, [\"previousSibling\", \"nextSibling\", \"childNodes\", \"parentNode\"]))) {\n    module.fail(\"Incomplete Element implementation\");\n  }\n\n  // innerHTML is required for Range's createContextualFragment method\n  if (!util.isHostProperty(el, \"innerHTML\")) {\n    module.fail(\"Element is missing innerHTML property\");\n  }\n\n  var textNode = document.createTextNode(\"test\");\n  if (!util.areHostMethods(textNode, [\"splitText\", \"deleteData\", \"insertData\", \"appendData\", \"cloneNode\"] || !util.areHostObjects(el, [\"previousSibling\", \"nextSibling\", \"childNodes\", \"parentNode\"]) || !util.areHostProperties(textNode, [\"data\"]))) {\n    module.fail(\"Incomplete Text Node implementation\");\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Removed use of indexOf because of a bizarre bug in Opera that is thrown in one of the Acid3 tests. I haven't been\n  // able to replicate it outside of the test. The bug is that indexOf returns -1 when called on an Array that\n  // contains just the document as a single element and the value searched for is the document.\n  var arrayContains = /*Array.prototype.indexOf ?\n                      function(arr, val) {\n                      return arr.indexOf(val) > -1;\n                      }:*/\n\n  function arrayContains(arr, val) {\n    var i = arr.length;\n    while (i--) {\n      if (arr[i] === val) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  // Opera 11 puts HTML elements in the null namespace, it seems, and IE 7 has undefined namespaceURI\n  function isHtmlNamespace(node) {\n    var ns;\n    return _typeof(node.namespaceURI) == UNDEF || (ns = node.namespaceURI) === null || ns == \"http://www.w3.org/1999/xhtml\";\n  }\n\n  function parentElement(node) {\n    var parent = node.parentNode;\n    return parent.nodeType == 1 ? parent : null;\n  }\n\n  function getNodeIndex(node) {\n    var i = 0;\n    while (node = node.previousSibling) {\n      i++;\n    }\n    return i;\n  }\n\n  function getNodeLength(node) {\n    var childNodes;\n    return isCharacterDataNode(node) ? node.length : (childNodes = node.childNodes) ? childNodes.length : 0;\n  }\n\n  function getCommonAncestor(node1, node2) {\n    var ancestors = [],\n        n;\n    for (n = node1; n; n = n.parentNode) {\n      ancestors.push(n);\n    }\n\n    for (n = node2; n; n = n.parentNode) {\n      if (arrayContains(ancestors, n)) {\n        return n;\n      }\n    }\n\n    return null;\n  }\n\n  function isAncestorOf(ancestor, descendant, selfIsAncestor) {\n    var n = selfIsAncestor ? descendant : descendant.parentNode;\n    while (n) {\n      if (n === ancestor) {\n        return true;\n      } else {\n        n = n.parentNode;\n      }\n    }\n    return false;\n  }\n\n  function getClosestAncestorIn(node, ancestor, selfIsAncestor) {\n    var p,\n        n = selfIsAncestor ? node : node.parentNode;\n    while (n) {\n      p = n.parentNode;\n      if (p === ancestor) {\n        return n;\n      }\n      n = p;\n    }\n    return null;\n  }\n\n  function isCharacterDataNode(node) {\n    var t = node.nodeType;\n    return t == 3 || t == 4 || t == 8; // Text, CDataSection or Comment\n  }\n\n  function insertAfter(node, precedingNode) {\n    var nextNode = precedingNode.nextSibling,\n        parent = precedingNode.parentNode;\n    if (nextNode) {\n      parent.insertBefore(node, nextNode);\n    } else {\n      parent.appendChild(node);\n    }\n    return node;\n  }\n\n  // Note that we cannot use splitText() because it is bugridden in IE 9.\n  function splitDataNode(node, index) {\n    var newNode = node.cloneNode(false);\n    newNode.deleteData(0, index);\n    node.deleteData(index, node.length - index);\n    insertAfter(newNode, node);\n    return newNode;\n  }\n\n  function getDocument(node) {\n    if (node.nodeType == 9) {\n      return node;\n    } else if (_typeof(node.ownerDocument) != UNDEF) {\n      return node.ownerDocument;\n    } else if (_typeof(node.document) != UNDEF) {\n      return node.document;\n    } else if (node.parentNode) {\n      return getDocument(node.parentNode);\n    } else {\n      throw new Error(\"getDocument: no document found for node\");\n    }\n  }\n\n  function getWindow(node) {\n    var doc = getDocument(node);\n    if (_typeof(doc.defaultView) != UNDEF) {\n      return doc.defaultView;\n    } else if (_typeof(doc.parentWindow) != UNDEF) {\n      return doc.parentWindow;\n    } else {\n      throw new Error(\"Cannot get a window object for node\");\n    }\n  }\n\n  function getIframeDocument(iframeEl) {\n    if (_typeof(iframeEl.contentDocument) != UNDEF) {\n      return iframeEl.contentDocument;\n    } else if (_typeof(iframeEl.contentWindow) != UNDEF) {\n      return iframeEl.contentWindow.document;\n    } else {\n      throw new Error(\"getIframeWindow: No Document object found for iframe element\");\n    }\n  }\n\n  function getIframeWindow(iframeEl) {\n    if (_typeof(iframeEl.contentWindow) != UNDEF) {\n      return iframeEl.contentWindow;\n    } else if (_typeof(iframeEl.contentDocument) != UNDEF) {\n      return iframeEl.contentDocument.defaultView;\n    } else {\n      throw new Error(\"getIframeWindow: No Window object found for iframe element\");\n    }\n  }\n\n  function getBody(doc) {\n    return util.isHostObject(doc, \"body\") ? doc.body : doc.getElementsByTagName(\"body\")[0];\n  }\n\n  function getRootContainer(node) {\n    var parent;\n    while (parent = node.parentNode) {\n      node = parent;\n    }\n    return node;\n  }\n\n  function comparePoints(nodeA, offsetA, nodeB, offsetB) {\n    // See http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Comparing\n    var nodeC, root, childA, childB, n;\n    if (nodeA == nodeB) {\n\n      // Case 1: nodes are the same\n      return offsetA === offsetB ? 0 : offsetA < offsetB ? -1 : 1;\n    } else if (nodeC = getClosestAncestorIn(nodeB, nodeA, true)) {\n\n      // Case 2: node C (container B or an ancestor) is a child node of A\n      return offsetA <= getNodeIndex(nodeC) ? -1 : 1;\n    } else if (nodeC = getClosestAncestorIn(nodeA, nodeB, true)) {\n\n      // Case 3: node C (container A or an ancestor) is a child node of B\n      return getNodeIndex(nodeC) < offsetB ? -1 : 1;\n    } else {\n\n      // Case 4: containers are siblings or descendants of siblings\n      root = getCommonAncestor(nodeA, nodeB);\n      childA = nodeA === root ? root : getClosestAncestorIn(nodeA, root, true);\n      childB = nodeB === root ? root : getClosestAncestorIn(nodeB, root, true);\n\n      if (childA === childB) {\n        // This shouldn't be possible\n\n        throw new Error(\"comparePoints got to case 4 and childA and childB are the same!\");\n      } else {\n        n = root.firstChild;\n        while (n) {\n          if (n === childA) {\n            return -1;\n          } else if (n === childB) {\n            return 1;\n          }\n          n = n.nextSibling;\n        }\n        throw new Error(\"Should not be here!\");\n      }\n    }\n  }\n\n  function fragmentFromNodeChildren(node) {\n    var fragment = getDocument(node).createDocumentFragment(),\n        child;\n    while (child = node.firstChild) {\n      fragment.appendChild(child);\n    }\n    return fragment;\n  }\n\n  function inspectNode(node) {\n    if (!node) {\n      return \"[No node]\";\n    }\n    if (isCharacterDataNode(node)) {\n      return '\"' + node.data + '\"';\n    } else if (node.nodeType == 1) {\n      var idAttr = node.id ? ' id=\"' + node.id + '\"' : \"\";\n      return \"<\" + node.nodeName + idAttr + \">[\" + node.childNodes.length + \"]\";\n    } else {\n      return node.nodeName;\n    }\n  }\n\n  /**\n   * @constructor\n   */\n  function NodeIterator(root) {\n    this.root = root;\n    this._next = root;\n  }\n\n  NodeIterator.prototype = {\n    _current: null,\n\n    hasNext: function hasNext() {\n      return !!this._next;\n    },\n\n    next: function next() {\n      var n = this._current = this._next;\n      var child, next;\n      if (this._current) {\n        child = n.firstChild;\n        if (child) {\n          this._next = child;\n        } else {\n          next = null;\n          while (n !== this.root && !(next = n.nextSibling)) {\n            n = n.parentNode;\n          }\n          this._next = next;\n        }\n      }\n      return this._current;\n    },\n\n    detach: function detach() {\n      this._current = this._next = this.root = null;\n    }\n  };\n\n  function createIterator(root) {\n    return new NodeIterator(root);\n  }\n\n  /**\n   * @constructor\n   */\n  function DomPosition(node, offset) {\n    this.node = node;\n    this.offset = offset;\n  }\n\n  DomPosition.prototype = {\n    equals: function equals(pos) {\n      return this.node === pos.node & this.offset == pos.offset;\n    },\n\n    inspect: function inspect() {\n      return \"[DomPosition(\" + inspectNode(this.node) + \":\" + this.offset + \")]\";\n    }\n  };\n\n  /**\n   * @constructor\n   */\n  function DOMException(codeName) {\n    this.code = this[codeName];\n    this.codeName = codeName;\n    this.message = \"DOMException: \" + this.codeName;\n  }\n\n  DOMException.prototype = {\n    INDEX_SIZE_ERR: 1,\n    HIERARCHY_REQUEST_ERR: 3,\n    WRONG_DOCUMENT_ERR: 4,\n    NO_MODIFICATION_ALLOWED_ERR: 7,\n    NOT_FOUND_ERR: 8,\n    NOT_SUPPORTED_ERR: 9,\n    INVALID_STATE_ERR: 11\n  };\n\n  DOMException.prototype.toString = function () {\n    return this.message;\n  };\n\n  api.dom = {\n    arrayContains: arrayContains,\n    isHtmlNamespace: isHtmlNamespace,\n    parentElement: parentElement,\n    getNodeIndex: getNodeIndex,\n    getNodeLength: getNodeLength,\n    getCommonAncestor: getCommonAncestor,\n    isAncestorOf: isAncestorOf,\n    getClosestAncestorIn: getClosestAncestorIn,\n    isCharacterDataNode: isCharacterDataNode,\n    insertAfter: insertAfter,\n    splitDataNode: splitDataNode,\n    getDocument: getDocument,\n    getWindow: getWindow,\n    getIframeWindow: getIframeWindow,\n    getIframeDocument: getIframeDocument,\n    getBody: getBody,\n    getRootContainer: getRootContainer,\n    comparePoints: comparePoints,\n    inspectNode: inspectNode,\n    fragmentFromNodeChildren: fragmentFromNodeChildren,\n    createIterator: createIterator,\n    DomPosition: DomPosition\n  };\n\n  api.DOMException = DOMException;\n});rangy.createModule(\"DomRange\", function (api, module) {\n  api.requireModules([\"DomUtil\"]);\n\n  var dom = api.dom;\n  var DomPosition = dom.DomPosition;\n  var DOMException = api.DOMException;\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Utility functions\n\n  function isNonTextPartiallySelected(node, range) {\n    return node.nodeType != 3 && (dom.isAncestorOf(node, range.startContainer, true) || dom.isAncestorOf(node, range.endContainer, true));\n  }\n\n  function getRangeDocument(range) {\n    return dom.getDocument(range.startContainer);\n  }\n\n  function dispatchEvent(range, type, args) {\n    var listeners = range._listeners[type];\n    if (listeners) {\n      for (var i = 0, len = listeners.length; i < len; ++i) {\n        listeners[i].call(range, { target: range, args: args });\n      }\n    }\n  }\n\n  function getBoundaryBeforeNode(node) {\n    return new DomPosition(node.parentNode, dom.getNodeIndex(node));\n  }\n\n  function getBoundaryAfterNode(node) {\n    return new DomPosition(node.parentNode, dom.getNodeIndex(node) + 1);\n  }\n\n  function insertNodeAtPosition(node, n, o) {\n    var firstNodeInserted = node.nodeType == 11 ? node.firstChild : node;\n    if (dom.isCharacterDataNode(n)) {\n      if (o == n.length) {\n        dom.insertAfter(node, n);\n      } else {\n        n.parentNode.insertBefore(node, o == 0 ? n : dom.splitDataNode(n, o));\n      }\n    } else if (o >= n.childNodes.length) {\n      n.appendChild(node);\n    } else {\n      n.insertBefore(node, n.childNodes[o]);\n    }\n    return firstNodeInserted;\n  }\n\n  function cloneSubtree(iterator) {\n    var partiallySelected;\n    for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next();) {\n      partiallySelected = iterator.isPartiallySelectedSubtree();\n\n      node = node.cloneNode(!partiallySelected);\n      if (partiallySelected) {\n        subIterator = iterator.getSubtreeIterator();\n        node.appendChild(cloneSubtree(subIterator));\n        subIterator.detach(true);\n      }\n\n      if (node.nodeType == 10) {\n        // DocumentType\n        throw new DOMException(\"HIERARCHY_REQUEST_ERR\");\n      }\n      frag.appendChild(node);\n    }\n    return frag;\n  }\n\n  function iterateSubtree(rangeIterator, func, iteratorState) {\n    var it, n;\n    iteratorState = iteratorState || { stop: false };\n    for (var node, subRangeIterator; node = rangeIterator.next();) {\n      //log.debug(\"iterateSubtree, partially selected: \" + rangeIterator.isPartiallySelectedSubtree(), nodeToString(node));\n      if (rangeIterator.isPartiallySelectedSubtree()) {\n        // The node is partially selected by the Range, so we can use a new RangeIterator on the portion of the\n        // node selected by the Range.\n        if (func(node) === false) {\n          iteratorState.stop = true;\n          return;\n        } else {\n          subRangeIterator = rangeIterator.getSubtreeIterator();\n          iterateSubtree(subRangeIterator, func, iteratorState);\n          subRangeIterator.detach(true);\n          if (iteratorState.stop) {\n            return;\n          }\n        }\n      } else {\n        // The whole node is selected, so we can use efficient DOM iteration to iterate over the node and its\n        // descendant\n        it = dom.createIterator(node);\n        while (n = it.next()) {\n          if (func(n) === false) {\n            iteratorState.stop = true;\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  function deleteSubtree(iterator) {\n    var subIterator;\n    while (iterator.next()) {\n      if (iterator.isPartiallySelectedSubtree()) {\n        subIterator = iterator.getSubtreeIterator();\n        deleteSubtree(subIterator);\n        subIterator.detach(true);\n      } else {\n        iterator.remove();\n      }\n    }\n  }\n\n  function extractSubtree(iterator) {\n\n    for (var node, frag = getRangeDocument(iterator.range).createDocumentFragment(), subIterator; node = iterator.next();) {\n\n      if (iterator.isPartiallySelectedSubtree()) {\n        node = node.cloneNode(false);\n        subIterator = iterator.getSubtreeIterator();\n        node.appendChild(extractSubtree(subIterator));\n        subIterator.detach(true);\n      } else {\n        iterator.remove();\n      }\n      if (node.nodeType == 10) {\n        // DocumentType\n        throw new DOMException(\"HIERARCHY_REQUEST_ERR\");\n      }\n      frag.appendChild(node);\n    }\n    return frag;\n  }\n\n  function getNodesInRange(range, nodeTypes, filter) {\n    //log.info(\"getNodesInRange, \" + nodeTypes.join(\",\"));\n    var filterNodeTypes = !!(nodeTypes && nodeTypes.length),\n        regex;\n    var filterExists = !!filter;\n    if (filterNodeTypes) {\n      regex = new RegExp(\"^(\" + nodeTypes.join(\"|\") + \")$\");\n    }\n\n    var nodes = [];\n    iterateSubtree(new RangeIterator(range, false), function (node) {\n      if ((!filterNodeTypes || regex.test(node.nodeType)) && (!filterExists || filter(node))) {\n        nodes.push(node);\n      }\n    });\n    return nodes;\n  }\n\n  function _inspect(range) {\n    var name = typeof range.getName == \"undefined\" ? \"Range\" : range.getName();\n    return \"[\" + name + \"(\" + dom.inspectNode(range.startContainer) + \":\" + range.startOffset + \", \" + dom.inspectNode(range.endContainer) + \":\" + range.endOffset + \")]\";\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // RangeIterator code partially borrows from IERange by Tim Ryan (http://github.com/timcameronryan/IERange)\n\n  /**\n   * @constructor\n   */\n  function RangeIterator(range, clonePartiallySelectedTextNodes) {\n    this.range = range;\n    this.clonePartiallySelectedTextNodes = clonePartiallySelectedTextNodes;\n\n    if (!range.collapsed) {\n      this.sc = range.startContainer;\n      this.so = range.startOffset;\n      this.ec = range.endContainer;\n      this.eo = range.endOffset;\n      var root = range.commonAncestorContainer;\n\n      if (this.sc === this.ec && dom.isCharacterDataNode(this.sc)) {\n        this.isSingleCharacterDataNode = true;\n        this._first = this._last = this._next = this.sc;\n      } else {\n        this._first = this._next = this.sc === root && !dom.isCharacterDataNode(this.sc) ? this.sc.childNodes[this.so] : dom.getClosestAncestorIn(this.sc, root, true);\n        this._last = this.ec === root && !dom.isCharacterDataNode(this.ec) ? this.ec.childNodes[this.eo - 1] : dom.getClosestAncestorIn(this.ec, root, true);\n      }\n    }\n  }\n\n  RangeIterator.prototype = {\n    _current: null,\n    _next: null,\n    _first: null,\n    _last: null,\n    isSingleCharacterDataNode: false,\n\n    reset: function reset() {\n      this._current = null;\n      this._next = this._first;\n    },\n\n    hasNext: function hasNext() {\n      return !!this._next;\n    },\n\n    next: function next() {\n      // Move to next node\n      var current = this._current = this._next;\n      if (current) {\n        this._next = current !== this._last ? current.nextSibling : null;\n\n        // Check for partially selected text nodes\n        if (dom.isCharacterDataNode(current) && this.clonePartiallySelectedTextNodes) {\n          if (current === this.ec) {\n\n            (current = current.cloneNode(true)).deleteData(this.eo, current.length - this.eo);\n          }\n          if (this._current === this.sc) {\n\n            (current = current.cloneNode(true)).deleteData(0, this.so);\n          }\n        }\n      }\n\n      return current;\n    },\n\n    remove: function remove() {\n      var current = this._current,\n          start,\n          end;\n\n      if (dom.isCharacterDataNode(current) && (current === this.sc || current === this.ec)) {\n        start = current === this.sc ? this.so : 0;\n        end = current === this.ec ? this.eo : current.length;\n        if (start != end) {\n          current.deleteData(start, end - start);\n        }\n      } else {\n        if (current.parentNode) {\n          current.parentNode.removeChild(current);\n        } else {}\n      }\n    },\n\n    // Checks if the current node is partially selected\n    isPartiallySelectedSubtree: function isPartiallySelectedSubtree() {\n      var current = this._current;\n      return isNonTextPartiallySelected(current, this.range);\n    },\n\n    getSubtreeIterator: function getSubtreeIterator() {\n      var subRange;\n      if (this.isSingleCharacterDataNode) {\n        subRange = this.range.cloneRange();\n        subRange.collapse();\n      } else {\n        subRange = new Range(getRangeDocument(this.range));\n        var current = this._current;\n        var startContainer = current,\n            startOffset = 0,\n            endContainer = current,\n            endOffset = dom.getNodeLength(current);\n\n        if (dom.isAncestorOf(current, this.sc, true)) {\n          startContainer = this.sc;\n          startOffset = this.so;\n        }\n        if (dom.isAncestorOf(current, this.ec, true)) {\n          endContainer = this.ec;\n          endOffset = this.eo;\n        }\n\n        updateBoundaries(subRange, startContainer, startOffset, endContainer, endOffset);\n      }\n      return new RangeIterator(subRange, this.clonePartiallySelectedTextNodes);\n    },\n\n    detach: function detach(detachRange) {\n      if (detachRange) {\n        this.range.detach();\n      }\n      this.range = this._current = this._next = this._first = this._last = this.sc = this.so = this.ec = this.eo = null;\n    }\n  };\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Exceptions\n\n  /**\n   * @constructor\n   */\n  function RangeException(codeName) {\n    this.code = this[codeName];\n    this.codeName = codeName;\n    this.message = \"RangeException: \" + this.codeName;\n  }\n\n  RangeException.prototype = {\n    BAD_BOUNDARYPOINTS_ERR: 1,\n    INVALID_NODE_TYPE_ERR: 2\n  };\n\n  RangeException.prototype.toString = function () {\n    return this.message;\n  };\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  /**\n   * Currently iterates through all nodes in the range on creation until I think of a decent way to do it\n   * TODO: Look into making this a proper iterator, not requiring preloading everything first\n   * @constructor\n   */\n  function RangeNodeIterator(range, nodeTypes, filter) {\n    this.nodes = getNodesInRange(range, nodeTypes, filter);\n    this._next = this.nodes[0];\n    this._position = 0;\n  }\n\n  RangeNodeIterator.prototype = {\n    _current: null,\n\n    hasNext: function hasNext() {\n      return !!this._next;\n    },\n\n    next: function next() {\n      this._current = this._next;\n      this._next = this.nodes[++this._position];\n      return this._current;\n    },\n\n    detach: function detach() {\n      this._current = this._next = this.nodes = null;\n    }\n  };\n\n  var beforeAfterNodeTypes = [1, 3, 4, 5, 7, 8, 10];\n  var rootContainerNodeTypes = [2, 9, 11];\n  var readonlyNodeTypes = [5, 6, 10, 12];\n  var insertableNodeTypes = [1, 3, 4, 5, 7, 8, 10, 11];\n  var surroundNodeTypes = [1, 3, 4, 5, 7, 8];\n\n  function createAncestorFinder(nodeTypes) {\n    return function (node, selfIsAncestor) {\n      var t,\n          n = selfIsAncestor ? node : node.parentNode;\n      while (n) {\n        t = n.nodeType;\n        if (dom.arrayContains(nodeTypes, t)) {\n          return n;\n        }\n        n = n.parentNode;\n      }\n      return null;\n    };\n  }\n\n  var getRootContainer = dom.getRootContainer;\n  var getDocumentOrFragmentContainer = createAncestorFinder([9, 11]);\n  var getReadonlyAncestor = createAncestorFinder(readonlyNodeTypes);\n  var getDocTypeNotationEntityAncestor = createAncestorFinder([6, 10, 12]);\n\n  function assertNoDocTypeNotationEntityAncestor(node, allowSelf) {\n    if (getDocTypeNotationEntityAncestor(node, allowSelf)) {\n      throw new RangeException(\"INVALID_NODE_TYPE_ERR\");\n    }\n  }\n\n  function assertNotDetached(range) {\n    if (!range.startContainer) {\n      throw new DOMException(\"INVALID_STATE_ERR\");\n    }\n  }\n\n  function assertValidNodeType(node, invalidTypes) {\n    if (!dom.arrayContains(invalidTypes, node.nodeType)) {\n      throw new RangeException(\"INVALID_NODE_TYPE_ERR\");\n    }\n  }\n\n  function assertValidOffset(node, offset) {\n    if (offset < 0 || offset > (dom.isCharacterDataNode(node) ? node.length : node.childNodes.length)) {\n      throw new DOMException(\"INDEX_SIZE_ERR\");\n    }\n  }\n\n  function assertSameDocumentOrFragment(node1, node2) {\n    if (getDocumentOrFragmentContainer(node1, true) !== getDocumentOrFragmentContainer(node2, true)) {\n      throw new DOMException(\"WRONG_DOCUMENT_ERR\");\n    }\n  }\n\n  function assertNodeNotReadOnly(node) {\n    if (getReadonlyAncestor(node, true)) {\n      throw new DOMException(\"NO_MODIFICATION_ALLOWED_ERR\");\n    }\n  }\n\n  function assertNode(node, codeName) {\n    if (!node) {\n      throw new DOMException(codeName);\n    }\n  }\n\n  function isOrphan(node) {\n    return !dom.arrayContains(rootContainerNodeTypes, node.nodeType) && !getDocumentOrFragmentContainer(node, true);\n  }\n\n  function isValidOffset(node, offset) {\n    return offset <= (dom.isCharacterDataNode(node) ? node.length : node.childNodes.length);\n  }\n\n  function assertRangeValid(range) {\n    assertNotDetached(range);\n    if (isOrphan(range.startContainer) || isOrphan(range.endContainer) || !isValidOffset(range.startContainer, range.startOffset) || !isValidOffset(range.endContainer, range.endOffset)) {\n      throw new Error(\"Range error: Range is no longer valid after DOM mutation (\" + range.inspect() + \")\");\n    }\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Test the browser's innerHTML support to decide how to implement createContextualFragment\n  var styleEl = document.createElement(\"style\");\n  var htmlParsingConforms = false;\n  try {\n    styleEl.innerHTML = \"<b>x</b>\";\n    htmlParsingConforms = styleEl.firstChild.nodeType == 3; // Opera incorrectly creates an element node\n  } catch (e) {\n    // IE 6 and 7 throw\n  }\n\n  api.features.htmlParsingConforms = htmlParsingConforms;\n\n  var createContextualFragment = htmlParsingConforms ?\n\n  // Implementation as per HTML parsing spec, trusting in the browser's implementation of innerHTML. See\n  // discussion and base code for this implementation at issue 67.\n  // Spec: http://html5.org/specs/dom-parsing.html#extensions-to-the-range-interface\n  // Thanks to Aleks Williams.\n  function (fragmentStr) {\n    // \"Let node the context object's start's node.\"\n    var node = this.startContainer;\n    var doc = dom.getDocument(node);\n\n    // \"If the context object's start's node is null, raise an INVALID_STATE_ERR\n    // exception and abort these steps.\"\n    if (!node) {\n      throw new DOMException(\"INVALID_STATE_ERR\");\n    }\n\n    // \"Let element be as follows, depending on node's interface:\"\n    // Document, Document Fragment: null\n    var el = null;\n\n    // \"Element: node\"\n    if (node.nodeType == 1) {\n      el = node;\n\n      // \"Text, Comment: node's parentElement\"\n    } else if (dom.isCharacterDataNode(node)) {\n      el = dom.parentElement(node);\n    }\n\n    // \"If either element is null or element's ownerDocument is an HTML document\n    // and element's local name is \"html\" and element's namespace is the HTML\n    // namespace\"\n    if (el === null || el.nodeName == \"HTML\" && dom.isHtmlNamespace(dom.getDocument(el).documentElement) && dom.isHtmlNamespace(el)) {\n\n      // \"let element be a new Element with \"body\" as its local name and the HTML\n      // namespace as its namespace.\"\"\n      el = doc.createElement(\"body\");\n    } else {\n      el = el.cloneNode(false);\n    }\n\n    // \"If the node's document is an HTML document: Invoke the HTML fragment parsing algorithm.\"\n    // \"If the node's document is an XML document: Invoke the XML fragment parsing algorithm.\"\n    // \"In either case, the algorithm must be invoked with fragment as the input\n    // and element as the context element.\"\n    el.innerHTML = fragmentStr;\n\n    // \"If this raises an exception, then abort these steps. Otherwise, let new\n    // children be the nodes returned.\"\n\n    // \"Let fragment be a new DocumentFragment.\"\n    // \"Append all new children to fragment.\"\n    // \"Return fragment.\"\n    return dom.fragmentFromNodeChildren(el);\n  } :\n\n  // In this case, innerHTML cannot be trusted, so fall back to a simpler, non-conformant implementation that\n  // previous versions of Rangy used (with the exception of using a body element rather than a div)\n  function (fragmentStr) {\n    assertNotDetached(this);\n    var doc = getRangeDocument(this);\n    var el = doc.createElement(\"body\");\n    el.innerHTML = fragmentStr;\n\n    return dom.fragmentFromNodeChildren(el);\n  };\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  var rangeProperties = [\"startContainer\", \"startOffset\", \"endContainer\", \"endOffset\", \"collapsed\", \"commonAncestorContainer\"];\n\n  var s2s = 0,\n      s2e = 1,\n      e2e = 2,\n      e2s = 3;\n  var n_b = 0,\n      n_a = 1,\n      n_b_a = 2,\n      n_i = 3;\n\n  function RangePrototype() {}\n\n  RangePrototype.prototype = {\n    attachListener: function attachListener(type, listener) {\n      this._listeners[type].push(listener);\n    },\n\n    compareBoundaryPoints: function compareBoundaryPoints(how, range) {\n      assertRangeValid(this);\n      assertSameDocumentOrFragment(this.startContainer, range.startContainer);\n\n      var nodeA, offsetA, nodeB, offsetB;\n      var prefixA = how == e2s || how == s2s ? \"start\" : \"end\";\n      var prefixB = how == s2e || how == s2s ? \"start\" : \"end\";\n      nodeA = this[prefixA + \"Container\"];\n      offsetA = this[prefixA + \"Offset\"];\n      nodeB = range[prefixB + \"Container\"];\n      offsetB = range[prefixB + \"Offset\"];\n      return dom.comparePoints(nodeA, offsetA, nodeB, offsetB);\n    },\n\n    insertNode: function insertNode(node) {\n      assertRangeValid(this);\n      assertValidNodeType(node, insertableNodeTypes);\n      assertNodeNotReadOnly(this.startContainer);\n\n      if (dom.isAncestorOf(node, this.startContainer, true)) {\n        throw new DOMException(\"HIERARCHY_REQUEST_ERR\");\n      }\n\n      // No check for whether the container of the start of the Range is of a type that does not allow\n      // children of the type of node: the browser's DOM implementation should do this for us when we attempt\n      // to add the node\n\n      var firstNodeInserted = insertNodeAtPosition(node, this.startContainer, this.startOffset);\n      this.setStartBefore(firstNodeInserted);\n    },\n\n    cloneContents: function cloneContents() {\n      assertRangeValid(this);\n\n      var clone, frag;\n      if (this.collapsed) {\n        return getRangeDocument(this).createDocumentFragment();\n      } else {\n        if (this.startContainer === this.endContainer && dom.isCharacterDataNode(this.startContainer)) {\n          clone = this.startContainer.cloneNode(true);\n          clone.data = clone.data.slice(this.startOffset, this.endOffset);\n          frag = getRangeDocument(this).createDocumentFragment();\n          frag.appendChild(clone);\n          return frag;\n        } else {\n          var iterator = new RangeIterator(this, true);\n          clone = cloneSubtree(iterator);\n          iterator.detach();\n        }\n        return clone;\n      }\n    },\n\n    canSurroundContents: function canSurroundContents() {\n      assertRangeValid(this);\n      assertNodeNotReadOnly(this.startContainer);\n      assertNodeNotReadOnly(this.endContainer);\n\n      // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n      // no non-text nodes.\n      var iterator = new RangeIterator(this, true);\n      var boundariesInvalid = iterator._first && isNonTextPartiallySelected(iterator._first, this) || iterator._last && isNonTextPartiallySelected(iterator._last, this);\n      iterator.detach();\n      return !boundariesInvalid;\n    },\n\n    surroundContents: function surroundContents(node) {\n      assertValidNodeType(node, surroundNodeTypes);\n\n      if (!this.canSurroundContents()) {\n        throw new RangeException(\"BAD_BOUNDARYPOINTS_ERR\");\n      }\n\n      // Extract the contents\n      var content = this.extractContents();\n\n      // Clear the children of the node\n      if (node.hasChildNodes()) {\n        while (node.lastChild) {\n          node.removeChild(node.lastChild);\n        }\n      }\n\n      // Insert the new node and add the extracted contents\n      insertNodeAtPosition(node, this.startContainer, this.startOffset);\n      node.appendChild(content);\n\n      this.selectNode(node);\n    },\n\n    cloneRange: function cloneRange() {\n      assertRangeValid(this);\n      var range = new Range(getRangeDocument(this));\n      var i = rangeProperties.length,\n          prop;\n      while (i--) {\n        prop = rangeProperties[i];\n        range[prop] = this[prop];\n      }\n      return range;\n    },\n\n    toString: function toString() {\n      assertRangeValid(this);\n      var sc = this.startContainer;\n      if (sc === this.endContainer && dom.isCharacterDataNode(sc)) {\n        return sc.nodeType == 3 || sc.nodeType == 4 ? sc.data.slice(this.startOffset, this.endOffset) : \"\";\n      } else {\n        var textBits = [],\n            iterator = new RangeIterator(this, true);\n\n        iterateSubtree(iterator, function (node) {\n          // Accept only text or CDATA nodes, not comments\n\n          if (node.nodeType == 3 || node.nodeType == 4) {\n            textBits.push(node.data);\n          }\n        });\n        iterator.detach();\n        return textBits.join(\"\");\n      }\n    },\n\n    // The methods below are all non-standard. The following batch were introduced by Mozilla but have since\n    // been removed from Mozilla.\n\n    compareNode: function compareNode(node) {\n      assertRangeValid(this);\n\n      var parent = node.parentNode;\n      var nodeIndex = dom.getNodeIndex(node);\n\n      if (!parent) {\n        throw new DOMException(\"NOT_FOUND_ERR\");\n      }\n\n      var startComparison = this.comparePoint(parent, nodeIndex),\n          endComparison = this.comparePoint(parent, nodeIndex + 1);\n\n      if (startComparison < 0) {\n        // Node starts before\n        return endComparison > 0 ? n_b_a : n_b;\n      } else {\n        return endComparison > 0 ? n_a : n_i;\n      }\n    },\n\n    comparePoint: function comparePoint(node, offset) {\n      assertRangeValid(this);\n      assertNode(node, \"HIERARCHY_REQUEST_ERR\");\n      assertSameDocumentOrFragment(node, this.startContainer);\n\n      if (dom.comparePoints(node, offset, this.startContainer, this.startOffset) < 0) {\n        return -1;\n      } else if (dom.comparePoints(node, offset, this.endContainer, this.endOffset) > 0) {\n        return 1;\n      }\n      return 0;\n    },\n\n    createContextualFragment: createContextualFragment,\n\n    toHtml: function toHtml() {\n      assertRangeValid(this);\n      var container = getRangeDocument(this).createElement(\"div\");\n      container.appendChild(this.cloneContents());\n      return container.innerHTML;\n    },\n\n    // touchingIsIntersecting determines whether this method considers a node that borders a range intersects\n    // with it (as in WebKit) or not (as in Gecko pre-1.9, and the default)\n    intersectsNode: function intersectsNode(node, touchingIsIntersecting) {\n      assertRangeValid(this);\n      assertNode(node, \"NOT_FOUND_ERR\");\n      if (dom.getDocument(node) !== getRangeDocument(this)) {\n        return false;\n      }\n\n      var parent = node.parentNode,\n          offset = dom.getNodeIndex(node);\n      assertNode(parent, \"NOT_FOUND_ERR\");\n\n      var startComparison = dom.comparePoints(parent, offset, this.endContainer, this.endOffset),\n          endComparison = dom.comparePoints(parent, offset + 1, this.startContainer, this.startOffset);\n\n      return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n    },\n\n    isPointInRange: function isPointInRange(node, offset) {\n      assertRangeValid(this);\n      assertNode(node, \"HIERARCHY_REQUEST_ERR\");\n      assertSameDocumentOrFragment(node, this.startContainer);\n\n      return dom.comparePoints(node, offset, this.startContainer, this.startOffset) >= 0 && dom.comparePoints(node, offset, this.endContainer, this.endOffset) <= 0;\n    },\n\n    // The methods below are non-standard and invented by me.\n\n    // Sharing a boundary start-to-end or end-to-start does not count as intersection.\n    intersectsRange: function intersectsRange(range, touchingIsIntersecting) {\n      assertRangeValid(this);\n\n      if (getRangeDocument(range) != getRangeDocument(this)) {\n        throw new DOMException(\"WRONG_DOCUMENT_ERR\");\n      }\n\n      var startComparison = dom.comparePoints(this.startContainer, this.startOffset, range.endContainer, range.endOffset),\n          endComparison = dom.comparePoints(this.endContainer, this.endOffset, range.startContainer, range.startOffset);\n\n      return touchingIsIntersecting ? startComparison <= 0 && endComparison >= 0 : startComparison < 0 && endComparison > 0;\n    },\n\n    intersection: function intersection(range) {\n      if (this.intersectsRange(range)) {\n        var startComparison = dom.comparePoints(this.startContainer, this.startOffset, range.startContainer, range.startOffset),\n            endComparison = dom.comparePoints(this.endContainer, this.endOffset, range.endContainer, range.endOffset);\n\n        var intersectionRange = this.cloneRange();\n\n        if (startComparison == -1) {\n          intersectionRange.setStart(range.startContainer, range.startOffset);\n        }\n        if (endComparison == 1) {\n          intersectionRange.setEnd(range.endContainer, range.endOffset);\n        }\n        return intersectionRange;\n      }\n      return null;\n    },\n\n    union: function union(range) {\n      if (this.intersectsRange(range, true)) {\n        var unionRange = this.cloneRange();\n        if (dom.comparePoints(range.startContainer, range.startOffset, this.startContainer, this.startOffset) == -1) {\n          unionRange.setStart(range.startContainer, range.startOffset);\n        }\n        if (dom.comparePoints(range.endContainer, range.endOffset, this.endContainer, this.endOffset) == 1) {\n          unionRange.setEnd(range.endContainer, range.endOffset);\n        }\n        return unionRange;\n      } else {\n        throw new RangeException(\"Ranges do not intersect\");\n      }\n    },\n\n    containsNode: function containsNode(node, allowPartial) {\n      if (allowPartial) {\n        return this.intersectsNode(node, false);\n      } else {\n        return this.compareNode(node) == n_i;\n      }\n    },\n\n    containsNodeContents: function containsNodeContents(node) {\n      return this.comparePoint(node, 0) >= 0 && this.comparePoint(node, dom.getNodeLength(node)) <= 0;\n    },\n\n    containsRange: function containsRange(range) {\n      return this.intersection(range).equals(range);\n    },\n\n    containsNodeText: function containsNodeText(node) {\n      var nodeRange = this.cloneRange();\n      nodeRange.selectNode(node);\n      var textNodes = nodeRange.getNodes([3]);\n      if (textNodes.length > 0) {\n        nodeRange.setStart(textNodes[0], 0);\n        var lastTextNode = textNodes.pop();\n        nodeRange.setEnd(lastTextNode, lastTextNode.length);\n        var contains = this.containsRange(nodeRange);\n        nodeRange.detach();\n        return contains;\n      } else {\n        return this.containsNodeContents(node);\n      }\n    },\n\n    createNodeIterator: function createNodeIterator(nodeTypes, filter) {\n      assertRangeValid(this);\n      return new RangeNodeIterator(this, nodeTypes, filter);\n    },\n\n    getNodes: function getNodes(nodeTypes, filter) {\n      assertRangeValid(this);\n      return getNodesInRange(this, nodeTypes, filter);\n    },\n\n    getDocument: function getDocument() {\n      return getRangeDocument(this);\n    },\n\n    collapseBefore: function collapseBefore(node) {\n      assertNotDetached(this);\n\n      this.setEndBefore(node);\n      this.collapse(false);\n    },\n\n    collapseAfter: function collapseAfter(node) {\n      assertNotDetached(this);\n\n      this.setStartAfter(node);\n      this.collapse(true);\n    },\n\n    getName: function getName() {\n      return \"DomRange\";\n    },\n\n    equals: function equals(range) {\n      return Range.rangesEqual(this, range);\n    },\n\n    inspect: function inspect() {\n      return _inspect(this);\n    }\n  };\n\n  function copyComparisonConstantsToObject(obj) {\n    obj.START_TO_START = s2s;\n    obj.START_TO_END = s2e;\n    obj.END_TO_END = e2e;\n    obj.END_TO_START = e2s;\n\n    obj.NODE_BEFORE = n_b;\n    obj.NODE_AFTER = n_a;\n    obj.NODE_BEFORE_AND_AFTER = n_b_a;\n    obj.NODE_INSIDE = n_i;\n  }\n\n  function copyComparisonConstants(constructor) {\n    copyComparisonConstantsToObject(constructor);\n    copyComparisonConstantsToObject(constructor.prototype);\n  }\n\n  function createRangeContentRemover(remover, boundaryUpdater) {\n    return function () {\n      assertRangeValid(this);\n\n      var sc = this.startContainer,\n          so = this.startOffset,\n          root = this.commonAncestorContainer;\n\n      var iterator = new RangeIterator(this, true);\n\n      // Work out where to position the range after content removal\n      var node, boundary;\n      if (sc !== root) {\n        node = dom.getClosestAncestorIn(sc, root, true);\n        boundary = getBoundaryAfterNode(node);\n        sc = boundary.node;\n        so = boundary.offset;\n      }\n\n      // Check none of the range is read-only\n      iterateSubtree(iterator, assertNodeNotReadOnly);\n\n      iterator.reset();\n\n      // Remove the content\n      var returnValue = remover(iterator);\n      iterator.detach();\n\n      // Move to the new position\n      boundaryUpdater(this, sc, so, sc, so);\n\n      return returnValue;\n    };\n  }\n\n  function createPrototypeRange(constructor, boundaryUpdater, detacher) {\n    function createBeforeAfterNodeSetter(isBefore, isStart) {\n      return function (node) {\n        assertNotDetached(this);\n        assertValidNodeType(node, beforeAfterNodeTypes);\n        assertValidNodeType(getRootContainer(node), rootContainerNodeTypes);\n\n        var boundary = (isBefore ? getBoundaryBeforeNode : getBoundaryAfterNode)(node);\n        (isStart ? setRangeStart : setRangeEnd)(this, boundary.node, boundary.offset);\n      };\n    }\n\n    function setRangeStart(range, node, offset) {\n      var ec = range.endContainer,\n          eo = range.endOffset;\n      if (node !== range.startContainer || offset !== range.startOffset) {\n        // Check the root containers of the range and the new boundary, and also check whether the new boundary\n        // is after the current end. In either case, collapse the range to the new position\n        if (getRootContainer(node) != getRootContainer(ec) || dom.comparePoints(node, offset, ec, eo) == 1) {\n          ec = node;\n          eo = offset;\n        }\n        boundaryUpdater(range, node, offset, ec, eo);\n      }\n    }\n\n    function setRangeEnd(range, node, offset) {\n      var sc = range.startContainer,\n          so = range.startOffset;\n      if (node !== range.endContainer || offset !== range.endOffset) {\n        // Check the root containers of the range and the new boundary, and also check whether the new boundary\n        // is after the current end. In either case, collapse the range to the new position\n        if (getRootContainer(node) != getRootContainer(sc) || dom.comparePoints(node, offset, sc, so) == -1) {\n          sc = node;\n          so = offset;\n        }\n        boundaryUpdater(range, sc, so, node, offset);\n      }\n    }\n\n    function setRangeStartAndEnd(range, node, offset) {\n      if (node !== range.startContainer || offset !== range.startOffset || node !== range.endContainer || offset !== range.endOffset) {\n        boundaryUpdater(range, node, offset, node, offset);\n      }\n    }\n\n    constructor.prototype = new RangePrototype();\n\n    api.util.extend(constructor.prototype, {\n      setStart: function setStart(node, offset) {\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, true);\n        assertValidOffset(node, offset);\n\n        setRangeStart(this, node, offset);\n      },\n\n      setEnd: function setEnd(node, offset) {\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, true);\n        assertValidOffset(node, offset);\n\n        setRangeEnd(this, node, offset);\n      },\n\n      setStartBefore: createBeforeAfterNodeSetter(true, true),\n      setStartAfter: createBeforeAfterNodeSetter(false, true),\n      setEndBefore: createBeforeAfterNodeSetter(true, false),\n      setEndAfter: createBeforeAfterNodeSetter(false, false),\n\n      collapse: function collapse(isStart) {\n        assertRangeValid(this);\n        if (isStart) {\n          boundaryUpdater(this, this.startContainer, this.startOffset, this.startContainer, this.startOffset);\n        } else {\n          boundaryUpdater(this, this.endContainer, this.endOffset, this.endContainer, this.endOffset);\n        }\n      },\n\n      selectNodeContents: function selectNodeContents(node) {\n        // This doesn't seem well specified: the spec talks only about selecting the node's contents, which\n        // could be taken to mean only its children. However, browsers implement this the same as selectNode for\n        // text nodes, so I shall do likewise\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, true);\n\n        boundaryUpdater(this, node, 0, node, dom.getNodeLength(node));\n      },\n\n      selectNode: function selectNode(node) {\n        assertNotDetached(this);\n        assertNoDocTypeNotationEntityAncestor(node, false);\n        assertValidNodeType(node, beforeAfterNodeTypes);\n\n        var start = getBoundaryBeforeNode(node),\n            end = getBoundaryAfterNode(node);\n        boundaryUpdater(this, start.node, start.offset, end.node, end.offset);\n      },\n\n      extractContents: createRangeContentRemover(extractSubtree, boundaryUpdater),\n\n      deleteContents: createRangeContentRemover(deleteSubtree, boundaryUpdater),\n\n      canSurroundContents: function canSurroundContents() {\n        assertRangeValid(this);\n        assertNodeNotReadOnly(this.startContainer);\n        assertNodeNotReadOnly(this.endContainer);\n\n        // Check if the contents can be surrounded. Specifically, this means whether the range partially selects\n        // no non-text nodes.\n        var iterator = new RangeIterator(this, true);\n        var boundariesInvalid = iterator._first && isNonTextPartiallySelected(iterator._first, this) || iterator._last && isNonTextPartiallySelected(iterator._last, this);\n        iterator.detach();\n        return !boundariesInvalid;\n      },\n\n      detach: function detach() {\n        detacher(this);\n      },\n\n      splitBoundaries: function splitBoundaries() {\n        assertRangeValid(this);\n\n        var sc = this.startContainer,\n            so = this.startOffset,\n            ec = this.endContainer,\n            eo = this.endOffset;\n        var startEndSame = sc === ec;\n\n        if (dom.isCharacterDataNode(ec) && eo > 0 && eo < ec.length) {\n          dom.splitDataNode(ec, eo);\n        }\n\n        if (dom.isCharacterDataNode(sc) && so > 0 && so < sc.length) {\n\n          sc = dom.splitDataNode(sc, so);\n          if (startEndSame) {\n            eo -= so;\n            ec = sc;\n          } else if (ec == sc.parentNode && eo >= dom.getNodeIndex(sc)) {\n            eo++;\n          }\n          so = 0;\n        }\n        boundaryUpdater(this, sc, so, ec, eo);\n      },\n\n      normalizeBoundaries: function normalizeBoundaries() {\n        assertRangeValid(this);\n\n        var sc = this.startContainer,\n            so = this.startOffset,\n            ec = this.endContainer,\n            eo = this.endOffset;\n\n        var mergeForward = function mergeForward(node) {\n          var sibling = node.nextSibling;\n          if (sibling && sibling.nodeType == node.nodeType) {\n            ec = node;\n            eo = node.length;\n            node.appendData(sibling.data);\n            sibling.parentNode.removeChild(sibling);\n          }\n        };\n\n        var mergeBackward = function mergeBackward(node) {\n          var sibling = node.previousSibling;\n          if (sibling && sibling.nodeType == node.nodeType) {\n            sc = node;\n            var nodeLength = node.length;\n            so = sibling.length;\n            node.insertData(0, sibling.data);\n            sibling.parentNode.removeChild(sibling);\n            if (sc == ec) {\n              eo += so;\n              ec = sc;\n            } else if (ec == node.parentNode) {\n              var nodeIndex = dom.getNodeIndex(node);\n              if (eo == nodeIndex) {\n                ec = node;\n                eo = nodeLength;\n              } else if (eo > nodeIndex) {\n                eo--;\n              }\n            }\n          }\n        };\n\n        var normalizeStart = true;\n\n        if (dom.isCharacterDataNode(ec)) {\n          if (ec.length == eo) {\n            mergeForward(ec);\n          }\n        } else {\n          if (eo > 0) {\n            var endNode = ec.childNodes[eo - 1];\n            if (endNode && dom.isCharacterDataNode(endNode)) {\n              mergeForward(endNode);\n            }\n          }\n          normalizeStart = !this.collapsed;\n        }\n\n        if (normalizeStart) {\n          if (dom.isCharacterDataNode(sc)) {\n            if (so == 0) {\n              mergeBackward(sc);\n            }\n          } else {\n            if (so < sc.childNodes.length) {\n              var startNode = sc.childNodes[so];\n              if (startNode && dom.isCharacterDataNode(startNode)) {\n                mergeBackward(startNode);\n              }\n            }\n          }\n        } else {\n          sc = ec;\n          so = eo;\n        }\n\n        boundaryUpdater(this, sc, so, ec, eo);\n      },\n\n      collapseToPoint: function collapseToPoint(node, offset) {\n        assertNotDetached(this);\n\n        assertNoDocTypeNotationEntityAncestor(node, true);\n        assertValidOffset(node, offset);\n\n        setRangeStartAndEnd(this, node, offset);\n      }\n    });\n\n    copyComparisonConstants(constructor);\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  // Updates commonAncestorContainer and collapsed after boundary change\n  function updateCollapsedAndCommonAncestor(range) {\n    range.collapsed = range.startContainer === range.endContainer && range.startOffset === range.endOffset;\n    range.commonAncestorContainer = range.collapsed ? range.startContainer : dom.getCommonAncestor(range.startContainer, range.endContainer);\n  }\n\n  function updateBoundaries(range, startContainer, startOffset, endContainer, endOffset) {\n    var startMoved = range.startContainer !== startContainer || range.startOffset !== startOffset;\n    var endMoved = range.endContainer !== endContainer || range.endOffset !== endOffset;\n\n    range.startContainer = startContainer;\n    range.startOffset = startOffset;\n    range.endContainer = endContainer;\n    range.endOffset = endOffset;\n\n    updateCollapsedAndCommonAncestor(range);\n    dispatchEvent(range, \"boundarychange\", { startMoved: startMoved, endMoved: endMoved });\n  }\n\n  function detach(range) {\n    assertNotDetached(range);\n    range.startContainer = range.startOffset = range.endContainer = range.endOffset = null;\n    range.collapsed = range.commonAncestorContainer = null;\n    dispatchEvent(range, \"detach\", null);\n    range._listeners = null;\n  }\n\n  /**\n   * @constructor\n   */\n  function Range(doc) {\n    this.startContainer = doc;\n    this.startOffset = 0;\n    this.endContainer = doc;\n    this.endOffset = 0;\n    this._listeners = {\n      boundarychange: [],\n      detach: []\n    };\n    updateCollapsedAndCommonAncestor(this);\n  }\n\n  createPrototypeRange(Range, updateBoundaries, detach);\n\n  api.rangePrototype = RangePrototype.prototype;\n\n  Range.rangeProperties = rangeProperties;\n  Range.RangeIterator = RangeIterator;\n  Range.copyComparisonConstants = copyComparisonConstants;\n  Range.createPrototypeRange = createPrototypeRange;\n  Range.inspect = _inspect;\n  Range.getRangeDocument = getRangeDocument;\n  Range.rangesEqual = function (r1, r2) {\n    return r1.startContainer === r2.startContainer && r1.startOffset === r2.startOffset && r1.endContainer === r2.endContainer && r1.endOffset === r2.endOffset;\n  };\n\n  api.DomRange = Range;\n  api.RangeException = RangeException;\n});rangy.createModule(\"WrappedRange\", function (api, module) {\n  api.requireModules([\"DomUtil\", \"DomRange\"]);\n\n  /**\n   * @constructor\n   */\n  var WrappedRange;\n  var dom = api.dom;\n  var DomPosition = dom.DomPosition;\n  var DomRange = api.DomRange;\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  /*\n  This is a workaround for a bug where IE returns the wrong container element from the TextRange's parentElement()\n  method. For example, in the following (where pipes denote the selection boundaries):\n   <ul id=\"ul\"><li id=\"a\">| a </li><li id=\"b\"> b |</li></ul>\n   var range = document.selection.createRange();\n  alert(range.parentElement().id); // Should alert \"ul\" but alerts \"b\"\n   This method returns the common ancestor node of the following:\n  - the parentElement() of the textRange\n  - the parentElement() of the textRange after calling collapse(true)\n  - the parentElement() of the textRange after calling collapse(false)\n   */\n  function getTextRangeContainerElement(textRange) {\n    var parentEl = textRange.parentElement();\n\n    var range = textRange.duplicate();\n    range.collapse(true);\n    var startEl = range.parentElement();\n    range = textRange.duplicate();\n    range.collapse(false);\n    var endEl = range.parentElement();\n    var startEndContainer = startEl == endEl ? startEl : dom.getCommonAncestor(startEl, endEl);\n\n    return startEndContainer == parentEl ? startEndContainer : dom.getCommonAncestor(parentEl, startEndContainer);\n  }\n\n  function textRangeIsCollapsed(textRange) {\n    return textRange.compareEndPoints(\"StartToEnd\", textRange) == 0;\n  }\n\n  // Gets the boundary of a TextRange expressed as a node and an offset within that node. This function started out as\n  // an improved version of code found in Tim Cameron Ryan's IERange (http://code.google.com/p/ierange/) but has\n  // grown, fixing problems with line breaks in preformatted text, adding workaround for IE TextRange bugs, handling\n  // for inputs and images, plus optimizations.\n  function getTextRangeBoundaryPosition(textRange, wholeRangeContainerElement, isStart, isCollapsed) {\n    var workingRange = textRange.duplicate();\n\n    workingRange.collapse(isStart);\n    var containerElement = workingRange.parentElement();\n\n    // Sometimes collapsing a TextRange that's at the start of a text node can move it into the previous node, so\n    // check for that\n    // TODO: Find out when. Workaround for wholeRangeContainerElement may break this\n    if (!dom.isAncestorOf(wholeRangeContainerElement, containerElement, true)) {\n      containerElement = wholeRangeContainerElement;\n    }\n\n    // Deal with nodes that cannot \"contain rich HTML markup\". In practice, this means form inputs, images and\n    // similar. See http://msdn.microsoft.com/en-us/library/aa703950%28VS.85%29.aspx\n    if (!containerElement.canHaveHTML) {\n      return new DomPosition(containerElement.parentNode, dom.getNodeIndex(containerElement));\n    }\n\n    var workingNode = dom.getDocument(containerElement).createElement(\"span\");\n    var comparison,\n        workingComparisonType = isStart ? \"StartToStart\" : \"StartToEnd\";\n    var previousNode, nextNode, boundaryPosition, boundaryNode;\n\n    // Move the working range through the container's children, starting at the end and working backwards, until the\n    // working range reaches or goes past the boundary we're interested in\n    do {\n      containerElement.insertBefore(workingNode, workingNode.previousSibling);\n      workingRange.moveToElementText(workingNode);\n    } while ((comparison = workingRange.compareEndPoints(workingComparisonType, textRange)) > 0 && workingNode.previousSibling);\n\n    // We've now reached or gone past the boundary of the text range we're interested in\n    // so have identified the node we want\n    boundaryNode = workingNode.nextSibling;\n\n    if (comparison == -1 && boundaryNode && dom.isCharacterDataNode(boundaryNode)) {\n      // This is a character data node (text, comment, cdata). The working range is collapsed at the start of the\n      // node containing the text range's boundary, so we move the end of the working range to the boundary point\n      // and measure the length of its text to get the boundary's offset within the node.\n      workingRange.setEndPoint(isStart ? \"EndToStart\" : \"EndToEnd\", textRange);\n\n      var offset;\n\n      if (/[\\r\\n]/.test(boundaryNode.data)) {\n        /*\n        For the particular case of a boundary within a text node containing line breaks (within a <pre> element,\n        for example), we need a slightly complicated approach to get the boundary's offset in IE. The facts:\n         - Each line break is represented as \\r in the text node's data/nodeValue properties\n        - Each line break is represented as \\r\\n in the TextRange's 'text' property\n        - The 'text' property of the TextRange does not contain trailing line breaks\n         To get round the problem presented by the final fact above, we can use the fact that TextRange's\n        moveStart() and moveEnd() methods return the actual number of characters moved, which is not necessarily\n        the same as the number of characters it was instructed to move. The simplest approach is to use this to\n        store the characters moved when moving both the start and end of the range to the start of the document\n        body and subtracting the start offset from the end offset (the \"move-negative-gazillion\" method).\n        However, this is extremely slow when the document is large and the range is near the end of it. Clearly\n        doing the mirror image (i.e. moving the range boundaries to the end of the document) has the same\n        problem.\n         Another approach that works is to use moveStart() to move the start boundary of the range up to the end\n        boundary one character at a time and incrementing a counter with the value returned by the moveStart()\n        call. However, the check for whether the start boundary has reached the end boundary is expensive, so\n        this method is slow (although unlike \"move-negative-gazillion\" is largely unaffected by the location of\n        the range within the document).\n         The method below is a hybrid of the two methods above. It uses the fact that a string containing the\n        TextRange's 'text' property with each \\r\\n converted to a single \\r character cannot be longer than the\n        text of the TextRange, so the start of the range is moved that length initially and then a character at\n        a time to make up for any trailing line breaks not contained in the 'text' property. This has good\n        performance in most situations compared to the previous two methods.\n        */\n        var tempRange = workingRange.duplicate();\n        var rangeLength = tempRange.text.replace(/\\r\\n/g, \"\\r\").length;\n\n        offset = tempRange.moveStart(\"character\", rangeLength);\n        while ((comparison = tempRange.compareEndPoints(\"StartToEnd\", tempRange)) == -1) {\n          offset++;\n          tempRange.moveStart(\"character\", 1);\n        }\n      } else {\n        offset = workingRange.text.length;\n      }\n      boundaryPosition = new DomPosition(boundaryNode, offset);\n    } else {\n\n      // If the boundary immediately follows a character data node and this is the end boundary, we should favour\n      // a position within that, and likewise for a start boundary preceding a character data node\n      previousNode = (isCollapsed || !isStart) && workingNode.previousSibling;\n      nextNode = (isCollapsed || isStart) && workingNode.nextSibling;\n\n      if (nextNode && dom.isCharacterDataNode(nextNode)) {\n        boundaryPosition = new DomPosition(nextNode, 0);\n      } else if (previousNode && dom.isCharacterDataNode(previousNode)) {\n        boundaryPosition = new DomPosition(previousNode, previousNode.length);\n      } else {\n        boundaryPosition = new DomPosition(containerElement, dom.getNodeIndex(workingNode));\n      }\n    }\n\n    // Clean up\n    workingNode.parentNode.removeChild(workingNode);\n\n    return boundaryPosition;\n  }\n\n  // Returns a TextRange representing the boundary of a TextRange expressed as a node and an offset within that node.\n  // This function started out as an optimized version of code found in Tim Cameron Ryan's IERange\n  // (http://code.google.com/p/ierange/)\n  function createBoundaryTextRange(boundaryPosition, isStart) {\n    var boundaryNode,\n        boundaryParent,\n        boundaryOffset = boundaryPosition.offset;\n    var doc = dom.getDocument(boundaryPosition.node);\n    var workingNode,\n        childNodes,\n        workingRange = doc.body.createTextRange();\n    var nodeIsDataNode = dom.isCharacterDataNode(boundaryPosition.node);\n\n    if (nodeIsDataNode) {\n      boundaryNode = boundaryPosition.node;\n      boundaryParent = boundaryNode.parentNode;\n    } else {\n      childNodes = boundaryPosition.node.childNodes;\n      boundaryNode = boundaryOffset < childNodes.length ? childNodes[boundaryOffset] : null;\n      boundaryParent = boundaryPosition.node;\n    }\n\n    // Position the range immediately before the node containing the boundary\n    workingNode = doc.createElement(\"span\");\n\n    // Making the working element non-empty element persuades IE to consider the TextRange boundary to be within the\n    // element rather than immediately before or after it, which is what we want\n    workingNode.innerHTML = \"&#feff;\";\n\n    // insertBefore is supposed to work like appendChild if the second parameter is null. However, a bug report\n    // for IERange suggests that it can crash the browser: http://code.google.com/p/ierange/issues/detail?id=12\n    if (boundaryNode) {\n      boundaryParent.insertBefore(workingNode, boundaryNode);\n    } else {\n      boundaryParent.appendChild(workingNode);\n    }\n\n    workingRange.moveToElementText(workingNode);\n    workingRange.collapse(!isStart);\n\n    // Clean up\n    boundaryParent.removeChild(workingNode);\n\n    // Move the working range to the text offset, if required\n    if (nodeIsDataNode) {\n      workingRange[isStart ? \"moveStart\" : \"moveEnd\"](\"character\", boundaryOffset);\n    }\n\n    return workingRange;\n  }\n\n  /*----------------------------------------------------------------------------------------------------------------*/\n\n  if (api.features.implementsDomRange && (!api.features.implementsTextRange || !api.config.preferTextRange)) {\n    // This is a wrapper around the browser's native DOM Range. It has two aims:\n    // - Provide workarounds for specific browser bugs\n    // - provide convenient extensions, which are inherited from Rangy's DomRange\n\n    (function () {\n      var rangeProto;\n      var rangeProperties = DomRange.rangeProperties;\n      var canSetRangeStartAfterEnd;\n\n      function updateRangeProperties(range) {\n        var i = rangeProperties.length,\n            prop;\n        while (i--) {\n          prop = rangeProperties[i];\n          range[prop] = range.nativeRange[prop];\n        }\n      }\n\n      function updateNativeRange(range, startContainer, startOffset, endContainer, endOffset) {\n        var startMoved = range.startContainer !== startContainer || range.startOffset != startOffset;\n        var endMoved = range.endContainer !== endContainer || range.endOffset != endOffset;\n\n        // Always set both boundaries for the benefit of IE9 (see issue 35)\n        if (startMoved || endMoved) {\n          range.setEnd(endContainer, endOffset);\n          range.setStart(startContainer, startOffset);\n        }\n      }\n\n      function detach(range) {\n        range.nativeRange.detach();\n        range.detached = true;\n        var i = rangeProperties.length,\n            prop;\n        while (i--) {\n          prop = rangeProperties[i];\n          range[prop] = null;\n        }\n      }\n\n      var createBeforeAfterNodeSetter;\n\n      WrappedRange = function WrappedRange(range) {\n        if (!range) {\n          throw new Error(\"Range must be specified\");\n        }\n        this.nativeRange = range;\n        updateRangeProperties(this);\n      };\n\n      DomRange.createPrototypeRange(WrappedRange, updateNativeRange, detach);\n\n      rangeProto = WrappedRange.prototype;\n\n      rangeProto.selectNode = function (node) {\n        this.nativeRange.selectNode(node);\n        updateRangeProperties(this);\n      };\n\n      rangeProto.deleteContents = function () {\n        this.nativeRange.deleteContents();\n        updateRangeProperties(this);\n      };\n\n      rangeProto.extractContents = function () {\n        var frag = this.nativeRange.extractContents();\n        updateRangeProperties(this);\n        return frag;\n      };\n\n      rangeProto.cloneContents = function () {\n        return this.nativeRange.cloneContents();\n      };\n\n      // TODO: Until I can find a way to programmatically trigger the Firefox bug (apparently long-standing, still\n      // present in 3.6.8) that throws \"Index or size is negative or greater than the allowed amount\" for\n      // insertNode in some circumstances, all browsers will have to use the Rangy's own implementation of\n      // insertNode, which works but is almost certainly slower than the native implementation.\n      /*\n                  rangeProto.insertNode = function(node) {\n                      this.nativeRange.insertNode(node);\n                      updateRangeProperties(this);\n                  };\n      */\n\n      rangeProto.surroundContents = function (node) {\n        this.nativeRange.surroundContents(node);\n        updateRangeProperties(this);\n      };\n\n      rangeProto.collapse = function (isStart) {\n        this.nativeRange.collapse(isStart);\n        updateRangeProperties(this);\n      };\n\n      rangeProto.cloneRange = function () {\n        return new WrappedRange(this.nativeRange.cloneRange());\n      };\n\n      rangeProto.refresh = function () {\n        updateRangeProperties(this);\n      };\n\n      rangeProto.toString = function () {\n        return this.nativeRange.toString();\n      };\n\n      // Create test range and node for feature detection\n\n      var testTextNode = document.createTextNode(\"test\");\n      dom.getBody(document).appendChild(testTextNode);\n      var range = document.createRange();\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Test for Firefox 2 bug that prevents moving the start of a Range to a point after its current end and\n      // correct for it\n\n      range.setStart(testTextNode, 0);\n      range.setEnd(testTextNode, 0);\n\n      try {\n        range.setStart(testTextNode, 1);\n        canSetRangeStartAfterEnd = true;\n\n        rangeProto.setStart = function (node, offset) {\n          this.nativeRange.setStart(node, offset);\n          updateRangeProperties(this);\n        };\n\n        rangeProto.setEnd = function (node, offset) {\n          this.nativeRange.setEnd(node, offset);\n          updateRangeProperties(this);\n        };\n\n        createBeforeAfterNodeSetter = function createBeforeAfterNodeSetter(name) {\n          return function (node) {\n            this.nativeRange[name](node);\n            updateRangeProperties(this);\n          };\n        };\n      } catch (ex) {\n\n        canSetRangeStartAfterEnd = false;\n\n        rangeProto.setStart = function (node, offset) {\n          try {\n            this.nativeRange.setStart(node, offset);\n          } catch (ex) {\n            this.nativeRange.setEnd(node, offset);\n            this.nativeRange.setStart(node, offset);\n          }\n          updateRangeProperties(this);\n        };\n\n        rangeProto.setEnd = function (node, offset) {\n          try {\n            this.nativeRange.setEnd(node, offset);\n          } catch (ex) {\n            this.nativeRange.setStart(node, offset);\n            this.nativeRange.setEnd(node, offset);\n          }\n          updateRangeProperties(this);\n        };\n\n        createBeforeAfterNodeSetter = function createBeforeAfterNodeSetter(name, oppositeName) {\n          return function (node) {\n            try {\n              this.nativeRange[name](node);\n            } catch (ex) {\n              this.nativeRange[oppositeName](node);\n              this.nativeRange[name](node);\n            }\n            updateRangeProperties(this);\n          };\n        };\n      }\n\n      rangeProto.setStartBefore = createBeforeAfterNodeSetter(\"setStartBefore\", \"setEndBefore\");\n      rangeProto.setStartAfter = createBeforeAfterNodeSetter(\"setStartAfter\", \"setEndAfter\");\n      rangeProto.setEndBefore = createBeforeAfterNodeSetter(\"setEndBefore\", \"setStartBefore\");\n      rangeProto.setEndAfter = createBeforeAfterNodeSetter(\"setEndAfter\", \"setStartAfter\");\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Test for and correct Firefox 2 behaviour with selectNodeContents on text nodes: it collapses the range to\n      // the 0th character of the text node\n      range.selectNodeContents(testTextNode);\n      if (range.startContainer == testTextNode && range.endContainer == testTextNode && range.startOffset == 0 && range.endOffset == testTextNode.length) {\n        rangeProto.selectNodeContents = function (node) {\n          this.nativeRange.selectNodeContents(node);\n          updateRangeProperties(this);\n        };\n      } else {\n        rangeProto.selectNodeContents = function (node) {\n          this.setStart(node, 0);\n          this.setEnd(node, DomRange.getEndOffset(node));\n        };\n      }\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Test for WebKit bug that has the beahviour of compareBoundaryPoints round the wrong way for constants\n      // START_TO_END and END_TO_START: https://bugs.webkit.org/show_bug.cgi?id=20738\n\n      range.selectNodeContents(testTextNode);\n      range.setEnd(testTextNode, 3);\n\n      var range2 = document.createRange();\n      range2.selectNodeContents(testTextNode);\n      range2.setEnd(testTextNode, 4);\n      range2.setStart(testTextNode, 2);\n\n      if (range.compareBoundaryPoints(range.START_TO_END, range2) == -1 & range.compareBoundaryPoints(range.END_TO_START, range2) == 1) {\n        // This is the wrong way round, so correct for it\n\n\n        rangeProto.compareBoundaryPoints = function (type, range) {\n          range = range.nativeRange || range;\n          if (type == range.START_TO_END) {\n            type = range.END_TO_START;\n          } else if (type == range.END_TO_START) {\n            type = range.START_TO_END;\n          }\n          return this.nativeRange.compareBoundaryPoints(type, range);\n        };\n      } else {\n        rangeProto.compareBoundaryPoints = function (type, range) {\n          return this.nativeRange.compareBoundaryPoints(type, range.nativeRange || range);\n        };\n      }\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Test for existence of createContextualFragment and delegate to it if it exists\n      if (api.util.isHostMethod(range, \"createContextualFragment\")) {\n        rangeProto.createContextualFragment = function (fragmentStr) {\n          return this.nativeRange.createContextualFragment(fragmentStr);\n        };\n      }\n\n      /*--------------------------------------------------------------------------------------------------------*/\n\n      // Clean up\n      dom.getBody(document).removeChild(testTextNode);\n      range.detach();\n      range2.detach();\n    })();\n\n    api.createNativeRange = function (doc) {\n      doc = doc || document;\n      return doc.createRange();\n    };\n  } else if (api.features.implementsTextRange) {\n    // This is a wrapper around a TextRange, providing full DOM Range functionality using rangy's DomRange as a\n    // prototype\n\n    WrappedRange = function WrappedRange(textRange) {\n      this.textRange = textRange;\n      this.refresh();\n    };\n\n    WrappedRange.prototype = new DomRange(document);\n\n    WrappedRange.prototype.refresh = function () {\n      var start, end;\n\n      // TextRange's parentElement() method cannot be trusted. getTextRangeContainerElement() works around that.\n      var rangeContainerElement = getTextRangeContainerElement(this.textRange);\n\n      if (textRangeIsCollapsed(this.textRange)) {\n        end = start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, true);\n      } else {\n\n        start = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, true, false);\n        end = getTextRangeBoundaryPosition(this.textRange, rangeContainerElement, false, false);\n      }\n\n      this.setStart(start.node, start.offset);\n      this.setEnd(end.node, end.offset);\n    };\n\n    DomRange.copyComparisonConstants(WrappedRange);\n\n    // Add WrappedRange as the Range property of the global object to allow expression like Range.END_TO_END to work\n    var globalObj = function () {\n      return this;\n    }();\n    if (typeof globalObj.Range == \"undefined\") {\n      globalObj.Range = WrappedRange;\n    }\n\n    api.createNativeRange = function (doc) {\n      doc = doc || document;\n      return doc.body.createTextRange();\n    };\n  }\n\n  if (api.features.implementsTextRange) {\n    WrappedRange.rangeToTextRange = function (range) {\n      if (range.collapsed) {\n        var tr = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n\n        return tr;\n\n        //return createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n      } else {\n        var startRange = createBoundaryTextRange(new DomPosition(range.startContainer, range.startOffset), true);\n        var endRange = createBoundaryTextRange(new DomPosition(range.endContainer, range.endOffset), false);\n        var textRange = dom.getDocument(range.startContainer).body.createTextRange();\n        textRange.setEndPoint(\"StartToStart\", startRange);\n        textRange.setEndPoint(\"EndToEnd\", endRange);\n        return textRange;\n      }\n    };\n  }\n\n  WrappedRange.prototype.getName = function () {\n    return \"WrappedRange\";\n  };\n\n  api.WrappedRange = WrappedRange;\n\n  api.createRange = function (doc) {\n    doc = doc || document;\n    return new WrappedRange(api.createNativeRange(doc));\n  };\n\n  api.createRangyRange = function (doc) {\n    doc = doc || document;\n    return new DomRange(doc);\n  };\n\n  api.createIframeRange = function (iframeEl) {\n    return api.createRange(dom.getIframeDocument(iframeEl));\n  };\n\n  api.createIframeRangyRange = function (iframeEl) {\n    return api.createRangyRange(dom.getIframeDocument(iframeEl));\n  };\n\n  api.addCreateMissingNativeApiListener(function (win) {\n    var doc = win.document;\n    if (typeof doc.createRange == \"undefined\") {\n      doc.createRange = function () {\n        return api.createRange(this);\n      };\n    }\n    doc = win = null;\n  });\n});rangy.createModule(\"WrappedSelection\", function (api, module) {\n  // This will create a selection object wrapper that follows the Selection object found in the WHATWG draft DOM Range\n  // spec (http://html5.org/specs/dom-range.html)\n\n  api.requireModules([\"DomUtil\", \"DomRange\", \"WrappedRange\"]);\n\n  api.config.checkSelectionRanges = true;\n\n  var BOOLEAN = \"boolean\",\n      windowPropertyName = \"_rangySelection\",\n      dom = api.dom,\n      util = api.util,\n      DomRange = api.DomRange,\n      WrappedRange = api.WrappedRange,\n      DOMException = api.DOMException,\n      DomPosition = dom.DomPosition,\n      getSelection,\n      selectionIsCollapsed,\n      CONTROL = \"Control\";\n\n  function getWinSelection(winParam) {\n    return (winParam || window).getSelection();\n  }\n\n  function getDocSelection(winParam) {\n    return (winParam || window).document.selection;\n  }\n\n  // Test for the Range/TextRange and Selection features required\n  // Test for ability to retrieve selection\n  var implementsWinGetSelection = api.util.isHostMethod(window, \"getSelection\"),\n      implementsDocSelection = api.util.isHostObject(document, \"selection\");\n\n  var useDocumentSelection = implementsDocSelection && (!implementsWinGetSelection || api.config.preferTextRange);\n\n  if (useDocumentSelection) {\n    getSelection = getDocSelection;\n    api.isSelectionValid = function (winParam) {\n      var doc = (winParam || window).document,\n          nativeSel = doc.selection;\n\n      // Check whether the selection TextRange is actually contained within the correct document\n      return nativeSel.type != \"None\" || dom.getDocument(nativeSel.createRange().parentElement()) == doc;\n    };\n  } else if (implementsWinGetSelection) {\n    getSelection = getWinSelection;\n    api.isSelectionValid = function () {\n      return true;\n    };\n  } else {\n    module.fail(\"Neither document.selection or window.getSelection() detected.\");\n  }\n\n  api.getNativeSelection = getSelection;\n\n  var testSelection = getSelection();\n  var testRange = api.createNativeRange(document);\n  var body = dom.getBody(document);\n\n  // Obtaining a range from a selection\n  var selectionHasAnchorAndFocus = util.areHostObjects(testSelection, [\"anchorNode\", \"focusNode\"] && util.areHostProperties(testSelection, [\"anchorOffset\", \"focusOffset\"]));\n  api.features.selectionHasAnchorAndFocus = selectionHasAnchorAndFocus;\n\n  // Test for existence of native selection extend() method\n  var selectionHasExtend = util.isHostMethod(testSelection, \"extend\");\n  api.features.selectionHasExtend = selectionHasExtend;\n\n  // Test if rangeCount exists\n  var selectionHasRangeCount = typeof testSelection.rangeCount == \"number\";\n  api.features.selectionHasRangeCount = selectionHasRangeCount;\n\n  var selectionSupportsMultipleRanges = false;\n  var collapsedNonEditableSelectionsSupported = true;\n\n  if (util.areHostMethods(testSelection, [\"addRange\", \"getRangeAt\", \"removeAllRanges\"]) && typeof testSelection.rangeCount == \"number\" && api.features.implementsDomRange) {\n\n    (function () {\n      var iframe = document.createElement(\"iframe\");\n      body.appendChild(iframe);\n\n      var iframeDoc = dom.getIframeDocument(iframe);\n      iframeDoc.open();\n      iframeDoc.write(\"<html><head></head><body>12</body></html>\");\n      iframeDoc.close();\n\n      var sel = dom.getIframeWindow(iframe).getSelection();\n      var docEl = iframeDoc.documentElement;\n      var iframeBody = docEl.lastChild,\n          textNode = iframeBody.firstChild;\n\n      // Test whether the native selection will allow a collapsed selection within a non-editable element\n      var r1 = iframeDoc.createRange();\n      r1.setStart(textNode, 1);\n      r1.collapse(true);\n      sel.addRange(r1);\n      collapsedNonEditableSelectionsSupported = sel.rangeCount == 1;\n      sel.removeAllRanges();\n\n      // Test whether the native selection is capable of supporting multiple ranges\n      var r2 = r1.cloneRange();\n      r1.setStart(textNode, 0);\n      r2.setEnd(textNode, 2);\n      sel.addRange(r1);\n      sel.addRange(r2);\n\n      selectionSupportsMultipleRanges = sel.rangeCount == 2;\n\n      // Clean up\n      r1.detach();\n      r2.detach();\n\n      body.removeChild(iframe);\n    })();\n  }\n\n  api.features.selectionSupportsMultipleRanges = selectionSupportsMultipleRanges;\n  api.features.collapsedNonEditableSelectionsSupported = collapsedNonEditableSelectionsSupported;\n\n  // ControlRanges\n  var implementsControlRange = false,\n      testControlRange;\n\n  if (body && util.isHostMethod(body, \"createControlRange\")) {\n    testControlRange = body.createControlRange();\n    if (util.areHostProperties(testControlRange, [\"item\", \"add\"])) {\n      implementsControlRange = true;\n    }\n  }\n  api.features.implementsControlRange = implementsControlRange;\n\n  // Selection collapsedness\n  if (selectionHasAnchorAndFocus) {\n    selectionIsCollapsed = function selectionIsCollapsed(sel) {\n      return sel.anchorNode === sel.focusNode && sel.anchorOffset === sel.focusOffset;\n    };\n  } else {\n    selectionIsCollapsed = function selectionIsCollapsed(sel) {\n      return sel.rangeCount ? sel.getRangeAt(sel.rangeCount - 1).collapsed : false;\n    };\n  }\n\n  function updateAnchorAndFocusFromRange(sel, range, backwards) {\n    var anchorPrefix = backwards ? \"end\" : \"start\",\n        focusPrefix = backwards ? \"start\" : \"end\";\n    sel.anchorNode = range[anchorPrefix + \"Container\"];\n    sel.anchorOffset = range[anchorPrefix + \"Offset\"];\n    sel.focusNode = range[focusPrefix + \"Container\"];\n    sel.focusOffset = range[focusPrefix + \"Offset\"];\n  }\n\n  function updateAnchorAndFocusFromNativeSelection(sel) {\n    var nativeSel = sel.nativeSelection;\n    sel.anchorNode = nativeSel.anchorNode;\n    sel.anchorOffset = nativeSel.anchorOffset;\n    sel.focusNode = nativeSel.focusNode;\n    sel.focusOffset = nativeSel.focusOffset;\n  }\n\n  function updateEmptySelection(sel) {\n    sel.anchorNode = sel.focusNode = null;\n    sel.anchorOffset = sel.focusOffset = 0;\n    sel.rangeCount = 0;\n    sel.isCollapsed = true;\n    sel._ranges.length = 0;\n  }\n\n  function getNativeRange(range) {\n    var nativeRange;\n    if (range instanceof DomRange) {\n      nativeRange = range._selectionNativeRange;\n      if (!nativeRange) {\n        nativeRange = api.createNativeRange(dom.getDocument(range.startContainer));\n        nativeRange.setEnd(range.endContainer, range.endOffset);\n        nativeRange.setStart(range.startContainer, range.startOffset);\n        range._selectionNativeRange = nativeRange;\n        range.attachListener(\"detach\", function () {\n\n          this._selectionNativeRange = null;\n        });\n      }\n    } else if (range instanceof WrappedRange) {\n      nativeRange = range.nativeRange;\n    } else if (api.features.implementsDomRange && range instanceof dom.getWindow(range.startContainer).Range) {\n      nativeRange = range;\n    }\n    return nativeRange;\n  }\n\n  function rangeContainsSingleElement(rangeNodes) {\n    if (!rangeNodes.length || rangeNodes[0].nodeType != 1) {\n      return false;\n    }\n    for (var i = 1, len = rangeNodes.length; i < len; ++i) {\n      if (!dom.isAncestorOf(rangeNodes[0], rangeNodes[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  function getSingleElementFromRange(range) {\n    var nodes = range.getNodes();\n    if (!rangeContainsSingleElement(nodes)) {\n      throw new Error(\"getSingleElementFromRange: range \" + range.inspect() + \" did not consist of a single element\");\n    }\n    return nodes[0];\n  }\n\n  function isTextRange(range) {\n    return !!range && typeof range.text != \"undefined\";\n  }\n\n  function updateFromTextRange(sel, range) {\n    // Create a Range from the selected TextRange\n    var wrappedRange = new WrappedRange(range);\n    sel._ranges = [wrappedRange];\n\n    updateAnchorAndFocusFromRange(sel, wrappedRange, false);\n    sel.rangeCount = 1;\n    sel.isCollapsed = wrappedRange.collapsed;\n  }\n\n  function updateControlSelection(sel) {\n    // Update the wrapped selection based on what's now in the native selection\n    sel._ranges.length = 0;\n    if (sel.docSelection.type == \"None\") {\n      updateEmptySelection(sel);\n    } else {\n      var controlRange = sel.docSelection.createRange();\n      if (isTextRange(controlRange)) {\n        // This case (where the selection type is \"Control\" and calling createRange() on the selection returns\n        // a TextRange) can happen in IE 9. It happens, for example, when all elements in the selected\n        // ControlRange have been removed from the ControlRange and removed from the document.\n        updateFromTextRange(sel, controlRange);\n      } else {\n        sel.rangeCount = controlRange.length;\n        var range,\n            doc = dom.getDocument(controlRange.item(0));\n        for (var i = 0; i < sel.rangeCount; ++i) {\n          range = api.createRange(doc);\n          range.selectNode(controlRange.item(i));\n          sel._ranges.push(range);\n        }\n        sel.isCollapsed = sel.rangeCount == 1 && sel._ranges[0].collapsed;\n        updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], false);\n      }\n    }\n  }\n\n  function addRangeToControlSelection(sel, range) {\n    var controlRange = sel.docSelection.createRange();\n    var rangeElement = getSingleElementFromRange(range);\n\n    // Create a new ControlRange containing all the elements in the selected ControlRange plus the element\n    // contained by the supplied range\n    var doc = dom.getDocument(controlRange.item(0));\n    var newControlRange = dom.getBody(doc).createControlRange();\n    for (var i = 0, len = controlRange.length; i < len; ++i) {\n      newControlRange.add(controlRange.item(i));\n    }\n    try {\n      newControlRange.add(rangeElement);\n    } catch (ex) {\n      throw new Error(\"addRange(): Element within the specified Range could not be added to control selection (does it have layout?)\");\n    }\n    newControlRange.select();\n\n    // Update the wrapped selection based on what's now in the native selection\n    updateControlSelection(sel);\n  }\n\n  var getSelectionRangeAt;\n\n  if (util.isHostMethod(testSelection, \"getRangeAt\")) {\n    getSelectionRangeAt = function getSelectionRangeAt(sel, index) {\n      try {\n        return sel.getRangeAt(index);\n      } catch (ex) {\n        return null;\n      }\n    };\n  } else if (selectionHasAnchorAndFocus) {\n    getSelectionRangeAt = function getSelectionRangeAt(sel) {\n      var doc = dom.getDocument(sel.anchorNode);\n      var range = api.createRange(doc);\n      range.setStart(sel.anchorNode, sel.anchorOffset);\n      range.setEnd(sel.focusNode, sel.focusOffset);\n\n      // Handle the case when the selection was selected backwards (from the end to the start in the\n      // document)\n      if (range.collapsed !== this.isCollapsed) {\n        range.setStart(sel.focusNode, sel.focusOffset);\n        range.setEnd(sel.anchorNode, sel.anchorOffset);\n      }\n\n      return range;\n    };\n  }\n\n  /**\n   * @constructor\n   */\n  function WrappedSelection(selection, docSelection, win) {\n    this.nativeSelection = selection;\n    this.docSelection = docSelection;\n    this._ranges = [];\n    this.win = win;\n    this.refresh();\n  }\n\n  api.getSelection = function (win) {\n    win = win || window;\n    var sel = win[windowPropertyName];\n    var nativeSel = getSelection(win),\n        docSel = implementsDocSelection ? getDocSelection(win) : null;\n    if (sel) {\n      sel.nativeSelection = nativeSel;\n      sel.docSelection = docSel;\n      sel.refresh(win);\n    } else {\n      sel = new WrappedSelection(nativeSel, docSel, win);\n      win[windowPropertyName] = sel;\n    }\n    return sel;\n  };\n\n  api.getIframeSelection = function (iframeEl) {\n    return api.getSelection(dom.getIframeWindow(iframeEl));\n  };\n\n  var selProto = WrappedSelection.prototype;\n\n  function createControlSelection(sel, ranges) {\n    // Ensure that the selection becomes of type \"Control\"\n    var doc = dom.getDocument(ranges[0].startContainer);\n    var controlRange = dom.getBody(doc).createControlRange();\n    for (var i = 0, el; i < rangeCount; ++i) {\n      el = getSingleElementFromRange(ranges[i]);\n      try {\n        controlRange.add(el);\n      } catch (ex) {\n        throw new Error(\"setRanges(): Element within the one of the specified Ranges could not be added to control selection (does it have layout?)\");\n      }\n    }\n    controlRange.select();\n\n    // Update the wrapped selection based on what's now in the native selection\n    updateControlSelection(sel);\n  }\n\n  // Selecting a range\n  if (!useDocumentSelection && selectionHasAnchorAndFocus && util.areHostMethods(testSelection, [\"removeAllRanges\", \"addRange\"])) {\n    selProto.removeAllRanges = function () {\n      this.nativeSelection.removeAllRanges();\n      updateEmptySelection(this);\n    };\n\n    var addRangeBackwards = function addRangeBackwards(sel, range) {\n      var doc = DomRange.getRangeDocument(range);\n      var endRange = api.createRange(doc);\n      endRange.collapseToPoint(range.endContainer, range.endOffset);\n      sel.nativeSelection.addRange(getNativeRange(endRange));\n      sel.nativeSelection.extend(range.startContainer, range.startOffset);\n      sel.refresh();\n    };\n\n    if (selectionHasRangeCount) {\n      selProto.addRange = function (range, backwards) {\n        if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n          addRangeToControlSelection(this, range);\n        } else {\n          if (backwards && selectionHasExtend) {\n            addRangeBackwards(this, range);\n          } else {\n            var previousRangeCount;\n            if (selectionSupportsMultipleRanges) {\n              previousRangeCount = this.rangeCount;\n            } else {\n              this.removeAllRanges();\n              previousRangeCount = 0;\n            }\n            this.nativeSelection.addRange(getNativeRange(range));\n\n            // Check whether adding the range was successful\n            this.rangeCount = this.nativeSelection.rangeCount;\n\n            if (this.rangeCount == previousRangeCount + 1) {\n              // The range was added successfully\n\n              // Check whether the range that we added to the selection is reflected in the last range extracted from\n              // the selection\n              if (api.config.checkSelectionRanges) {\n                var nativeRange = getSelectionRangeAt(this.nativeSelection, this.rangeCount - 1);\n                if (nativeRange && !DomRange.rangesEqual(nativeRange, range)) {\n                  // Happens in WebKit with, for example, a selection placed at the start of a text node\n                  range = new WrappedRange(nativeRange);\n                }\n              }\n              this._ranges[this.rangeCount - 1] = range;\n              updateAnchorAndFocusFromRange(this, range, selectionIsBackwards(this.nativeSelection));\n              this.isCollapsed = selectionIsCollapsed(this);\n            } else {\n              // The range was not added successfully. The simplest thing is to refresh\n              this.refresh();\n            }\n          }\n        }\n      };\n    } else {\n      selProto.addRange = function (range, backwards) {\n        if (backwards && selectionHasExtend) {\n          addRangeBackwards(this, range);\n        } else {\n          this.nativeSelection.addRange(getNativeRange(range));\n          this.refresh();\n        }\n      };\n    }\n\n    selProto.setRanges = function (ranges) {\n      if (implementsControlRange && ranges.length > 1) {\n        createControlSelection(this, ranges);\n      } else {\n        this.removeAllRanges();\n        for (var i = 0, len = ranges.length; i < len; ++i) {\n          this.addRange(ranges[i]);\n        }\n      }\n    };\n  } else if (util.isHostMethod(testSelection, \"empty\") && util.isHostMethod(testRange, \"select\") && implementsControlRange && useDocumentSelection) {\n\n    selProto.removeAllRanges = function () {\n      // Added try/catch as fix for issue #21\n      try {\n        this.docSelection.empty();\n\n        // Check for empty() not working (issue #24)\n        if (this.docSelection.type != \"None\") {\n          // Work around failure to empty a control selection by instead selecting a TextRange and then\n          // calling empty()\n          var doc;\n          if (this.anchorNode) {\n            doc = dom.getDocument(this.anchorNode);\n          } else if (this.docSelection.type == CONTROL) {\n            var controlRange = this.docSelection.createRange();\n            if (controlRange.length) {\n              doc = dom.getDocument(controlRange.item(0)).body.createTextRange();\n            }\n          }\n          if (doc) {\n            var textRange = doc.body.createTextRange();\n            textRange.select();\n            this.docSelection.empty();\n          }\n        }\n      } catch (ex) {}\n      updateEmptySelection(this);\n    };\n\n    selProto.addRange = function (range) {\n      if (this.docSelection.type == CONTROL) {\n        addRangeToControlSelection(this, range);\n      } else {\n        WrappedRange.rangeToTextRange(range).select();\n        this._ranges[0] = range;\n        this.rangeCount = 1;\n        this.isCollapsed = this._ranges[0].collapsed;\n        updateAnchorAndFocusFromRange(this, range, false);\n      }\n    };\n\n    selProto.setRanges = function (ranges) {\n      this.removeAllRanges();\n      var rangeCount = ranges.length;\n      if (rangeCount > 1) {\n        createControlSelection(this, ranges);\n      } else if (rangeCount) {\n        this.addRange(ranges[0]);\n      }\n    };\n  } else {\n    module.fail(\"No means of selecting a Range or TextRange was found\");\n    return false;\n  }\n\n  selProto.getRangeAt = function (index) {\n    if (index < 0 || index >= this.rangeCount) {\n      throw new DOMException(\"INDEX_SIZE_ERR\");\n    } else {\n      return this._ranges[index];\n    }\n  };\n\n  var refreshSelection;\n\n  if (useDocumentSelection) {\n    refreshSelection = function refreshSelection(sel) {\n      var range;\n      if (api.isSelectionValid(sel.win)) {\n        range = sel.docSelection.createRange();\n      } else {\n        range = dom.getBody(sel.win.document).createTextRange();\n        range.collapse(true);\n      }\n\n      if (sel.docSelection.type == CONTROL) {\n        updateControlSelection(sel);\n      } else if (isTextRange(range)) {\n        updateFromTextRange(sel, range);\n      } else {\n        updateEmptySelection(sel);\n      }\n    };\n  } else if (util.isHostMethod(testSelection, \"getRangeAt\") && typeof testSelection.rangeCount == \"number\") {\n    refreshSelection = function refreshSelection(sel) {\n      if (implementsControlRange && implementsDocSelection && sel.docSelection.type == CONTROL) {\n        updateControlSelection(sel);\n      } else {\n        sel._ranges.length = sel.rangeCount = sel.nativeSelection.rangeCount;\n        if (sel.rangeCount) {\n          for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n            sel._ranges[i] = new api.WrappedRange(sel.nativeSelection.getRangeAt(i));\n          }\n          updateAnchorAndFocusFromRange(sel, sel._ranges[sel.rangeCount - 1], selectionIsBackwards(sel.nativeSelection));\n          sel.isCollapsed = selectionIsCollapsed(sel);\n        } else {\n          updateEmptySelection(sel);\n        }\n      }\n    };\n  } else if (selectionHasAnchorAndFocus && _typeof(testSelection.isCollapsed) == BOOLEAN && _typeof(testRange.collapsed) == BOOLEAN && api.features.implementsDomRange) {\n    refreshSelection = function refreshSelection(sel) {\n      var range,\n          nativeSel = sel.nativeSelection;\n      if (nativeSel.anchorNode) {\n        range = getSelectionRangeAt(nativeSel, 0);\n        sel._ranges = [range];\n        sel.rangeCount = 1;\n        updateAnchorAndFocusFromNativeSelection(sel);\n        sel.isCollapsed = selectionIsCollapsed(sel);\n      } else {\n        updateEmptySelection(sel);\n      }\n    };\n  } else {\n    module.fail(\"No means of obtaining a Range or TextRange from the user's selection was found\");\n    return false;\n  }\n\n  selProto.refresh = function (checkForChanges) {\n    var oldRanges = checkForChanges ? this._ranges.slice(0) : null;\n    refreshSelection(this);\n    if (checkForChanges) {\n      var i = oldRanges.length;\n      if (i != this._ranges.length) {\n        return false;\n      }\n      while (i--) {\n        if (!DomRange.rangesEqual(oldRanges[i], this._ranges[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n  };\n\n  // Removal of a single range\n  var removeRangeManually = function removeRangeManually(sel, range) {\n    var ranges = sel.getAllRanges(),\n        removed = false;\n    sel.removeAllRanges();\n    for (var i = 0, len = ranges.length; i < len; ++i) {\n      if (removed || range !== ranges[i]) {\n        sel.addRange(ranges[i]);\n      } else {\n        // According to the draft WHATWG Range spec, the same range may be added to the selection multiple\n        // times. removeRange should only remove the first instance, so the following ensures only the first\n        // instance is removed\n        removed = true;\n      }\n    }\n    if (!sel.rangeCount) {\n      updateEmptySelection(sel);\n    }\n  };\n\n  if (implementsControlRange) {\n    selProto.removeRange = function (range) {\n      if (this.docSelection.type == CONTROL) {\n        var controlRange = this.docSelection.createRange();\n        var rangeElement = getSingleElementFromRange(range);\n\n        // Create a new ControlRange containing all the elements in the selected ControlRange minus the\n        // element contained by the supplied range\n        var doc = dom.getDocument(controlRange.item(0));\n        var newControlRange = dom.getBody(doc).createControlRange();\n        var el,\n            removed = false;\n        for (var i = 0, len = controlRange.length; i < len; ++i) {\n          el = controlRange.item(i);\n          if (el !== rangeElement || removed) {\n            newControlRange.add(controlRange.item(i));\n          } else {\n            removed = true;\n          }\n        }\n        newControlRange.select();\n\n        // Update the wrapped selection based on what's now in the native selection\n        updateControlSelection(this);\n      } else {\n        removeRangeManually(this, range);\n      }\n    };\n  } else {\n    selProto.removeRange = function (range) {\n      removeRangeManually(this, range);\n    };\n  }\n\n  // Detecting if a selection is backwards\n  var selectionIsBackwards;\n  if (!useDocumentSelection && selectionHasAnchorAndFocus && api.features.implementsDomRange) {\n    selectionIsBackwards = function selectionIsBackwards(sel) {\n      var backwards = false;\n      if (sel.anchorNode) {\n        backwards = dom.comparePoints(sel.anchorNode, sel.anchorOffset, sel.focusNode, sel.focusOffset) == 1;\n      }\n      return backwards;\n    };\n\n    selProto.isBackwards = function () {\n      return selectionIsBackwards(this);\n    };\n  } else {\n    selectionIsBackwards = selProto.isBackwards = function () {\n      return false;\n    };\n  }\n\n  // Selection text\n  // This is conformant to the new WHATWG DOM Range draft spec but differs from WebKit and Mozilla's implementation\n  selProto.toString = function () {\n\n    var rangeTexts = [];\n    for (var i = 0, len = this.rangeCount; i < len; ++i) {\n      rangeTexts[i] = \"\" + this._ranges[i];\n    }\n    return rangeTexts.join(\"\");\n  };\n\n  function assertNodeInSameDocument(sel, node) {\n    if (sel.anchorNode && dom.getDocument(sel.anchorNode) !== dom.getDocument(node)) {\n      throw new DOMException(\"WRONG_DOCUMENT_ERR\");\n    }\n  }\n\n  // No current browsers conform fully to the HTML 5 draft spec for this method, so Rangy's own method is always used\n  selProto.collapse = function (node, offset) {\n    assertNodeInSameDocument(this, node);\n    var range = api.createRange(dom.getDocument(node));\n    range.collapseToPoint(node, offset);\n    this.removeAllRanges();\n    this.addRange(range);\n    this.isCollapsed = true;\n  };\n\n  selProto.collapseToStart = function () {\n    if (this.rangeCount) {\n      var range = this._ranges[0];\n      this.collapse(range.startContainer, range.startOffset);\n    } else {\n      throw new DOMException(\"INVALID_STATE_ERR\");\n    }\n  };\n\n  selProto.collapseToEnd = function () {\n    if (this.rangeCount) {\n      var range = this._ranges[this.rangeCount - 1];\n      this.collapse(range.endContainer, range.endOffset);\n    } else {\n      throw new DOMException(\"INVALID_STATE_ERR\");\n    }\n  };\n\n  // The HTML 5 spec is very specific on how selectAllChildren should be implemented so the native implementation is\n  // never used by Rangy.\n  selProto.selectAllChildren = function (node) {\n    assertNodeInSameDocument(this, node);\n    var range = api.createRange(dom.getDocument(node));\n    range.selectNodeContents(node);\n    this.removeAllRanges();\n    this.addRange(range);\n  };\n\n  selProto.deleteFromDocument = function () {\n    // Sepcial behaviour required for Control selections\n    if (implementsControlRange && implementsDocSelection && this.docSelection.type == CONTROL) {\n      var controlRange = this.docSelection.createRange();\n      var element;\n      while (controlRange.length) {\n        element = controlRange.item(0);\n        controlRange.remove(element);\n        element.parentNode.removeChild(element);\n      }\n      this.refresh();\n    } else if (this.rangeCount) {\n      var ranges = this.getAllRanges();\n      this.removeAllRanges();\n      for (var i = 0, len = ranges.length; i < len; ++i) {\n        ranges[i].deleteContents();\n      }\n      // The HTML5 spec says nothing about what the selection should contain after calling deleteContents on each\n      // range. Firefox moves the selection to where the final selected range was, so we emulate that\n      this.addRange(ranges[len - 1]);\n    }\n  };\n\n  // The following are non-standard extensions\n  selProto.getAllRanges = function () {\n    return this._ranges.slice(0);\n  };\n\n  selProto.setSingleRange = function (range) {\n    this.setRanges([range]);\n  };\n\n  selProto.containsNode = function (node, allowPartial) {\n    for (var i = 0, len = this._ranges.length; i < len; ++i) {\n      if (this._ranges[i].containsNode(node, allowPartial)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  selProto.toHtml = function () {\n    var html = \"\";\n    if (this.rangeCount) {\n      var container = DomRange.getRangeDocument(this._ranges[0]).createElement(\"div\");\n      for (var i = 0, len = this._ranges.length; i < len; ++i) {\n        container.appendChild(this._ranges[i].cloneContents());\n      }\n      html = container.innerHTML;\n    }\n    return html;\n  };\n\n  function inspect(sel) {\n    var rangeInspects = [];\n    var anchor = new DomPosition(sel.anchorNode, sel.anchorOffset);\n    var focus = new DomPosition(sel.focusNode, sel.focusOffset);\n    var name = typeof sel.getName == \"function\" ? sel.getName() : \"Selection\";\n\n    if (typeof sel.rangeCount != \"undefined\") {\n      for (var i = 0, len = sel.rangeCount; i < len; ++i) {\n        rangeInspects[i] = DomRange.inspect(sel.getRangeAt(i));\n      }\n    }\n    return \"[\" + name + \"(Ranges: \" + rangeInspects.join(\", \") + \")(anchor: \" + anchor.inspect() + \", focus: \" + focus.inspect() + \"]\";\n  }\n\n  selProto.getName = function () {\n    return \"WrappedSelection\";\n  };\n\n  selProto.inspect = function () {\n    return inspect(this);\n  };\n\n  selProto.detach = function () {\n    this.win[windowPropertyName] = null;\n    this.win = this.anchorNode = this.focusNode = null;\n  };\n\n  WrappedSelection.inspect = inspect;\n\n  api.Selection = WrappedSelection;\n\n  api.selectionPrototype = selProto;\n\n  api.addCreateMissingNativeApiListener(function (win) {\n    if (typeof win.getSelection == \"undefined\") {\n      win.getSelection = function () {\n        return api.getSelection(this);\n      };\n    }\n    win = null;\n  });\n});\n/*\n\tBase.js, version 1.1a\n\tCopyright 2006-2010, Dean Edwards\n\tLicense: http://www.opensource.org/licenses/mit-license.php\n*/\n\nvar Base = function Base() {\n  // dummy\n};\n\nBase.extend = function (_instance, _static) {\n  // subclass\n  var extend = Base.prototype.extend;\n\n  // build the prototype\n  Base._prototyping = true;\n  var proto = new this();\n  extend.call(proto, _instance);\n  proto.base = function () {\n    // call this method from any other method to invoke that method's ancestor\n  };\n  delete Base._prototyping;\n\n  // create the wrapper for the constructor function\n  //var constructor = proto.constructor.valueOf(); //-dean\n  var constructor = proto.constructor;\n  var klass = proto.constructor = function () {\n    if (!Base._prototyping) {\n      if (this._constructing || this.constructor == klass) {\n        // instantiation\n        this._constructing = true;\n        constructor.apply(this, arguments);\n        delete this._constructing;\n      } else if (arguments[0] != null) {\n        // casting\n        return (arguments[0].extend || extend).call(arguments[0], proto);\n      }\n    }\n  };\n\n  // build the class interface\n  klass.ancestor = this;\n  klass.extend = this.extend;\n  klass.forEach = this.forEach;\n  klass.implement = this.implement;\n  klass.prototype = proto;\n  klass.toString = this.toString;\n  klass.valueOf = function (type) {\n    //return (type == \"object\") ? klass : constructor; //-dean\n    return type == \"object\" ? klass : constructor.valueOf();\n  };\n  extend.call(klass, _static);\n  // class initialisation\n  if (typeof klass.init == \"function\") klass.init();\n  return klass;\n};\n\nBase.prototype = {\n  extend: function extend(source, value) {\n    if (arguments.length > 1) {\n      // extending with a name/value pair\n      var ancestor = this[source];\n      if (ancestor && typeof value == \"function\" && ( // overriding a method?\n      // the valueOf() comparison is to avoid circular references\n      !ancestor.valueOf || ancestor.valueOf() != value.valueOf()) && /\\bbase\\b/.test(value)) {\n        // get the underlying method\n        var method = value.valueOf();\n        // override\n        value = function value() {\n          var previous = this.base || Base.prototype.base;\n          this.base = ancestor;\n          var returnValue = method.apply(this, arguments);\n          this.base = previous;\n          return returnValue;\n        };\n        // point to the underlying method\n        value.valueOf = function (type) {\n          return type == \"object\" ? value : method;\n        };\n        value.toString = Base.toString;\n      }\n      this[source] = value;\n    } else if (source) {\n      // extending with an object literal\n      var extend = Base.prototype.extend;\n      // if this object has a customised extend method then use it\n      if (!Base._prototyping && typeof this != \"function\") {\n        extend = this.extend || extend;\n      }\n      var proto = { toSource: null };\n      // do the \"toString\" and other methods manually\n      var hidden = [\"constructor\", \"toString\", \"valueOf\"];\n      // if we are prototyping then include the constructor\n      var i = Base._prototyping ? 0 : 1;\n      while (key = hidden[i++]) {\n        if (source[key] != proto[key]) {\n          extend.call(this, key, source[key]);\n        }\n      }\n      // copy each of the source object's properties to this object\n      for (var key in source) {\n        if (!proto[key]) extend.call(this, key, source[key]);\n      }\n    }\n    return this;\n  }\n};\n\n// initialise\nBase = Base.extend({\n  constructor: function constructor() {\n    this.extend(arguments[0]);\n  }\n}, {\n  ancestor: Object,\n  version: \"1.1\",\n\n  forEach: function forEach(object, block, context) {\n    for (var key in object) {\n      if (this.prototype[key] === undefined) {\n        block.call(context, object[key], key, object);\n      }\n    }\n  },\n\n  implement: function implement() {\n    for (var i = 0; i < arguments.length; i++) {\n      if (typeof arguments[i] == \"function\") {\n        // if it's a function, call it\n        arguments[i](this.prototype);\n      } else {\n        // add the interface using the extend method\n        this.prototype.extend(arguments[i]);\n      }\n    }\n    return this;\n  },\n\n  toString: function toString() {\n    return String(this.valueOf());\n  }\n}); /**\n    * Detect browser support for specific features\n    */\nwysihtml5.browser = function () {\n  var userAgent = navigator.userAgent,\n      testElement = document.createElement(\"div\"),\n\n\n  // Browser sniffing is unfortunately needed since some behaviors are impossible to feature detect\n  isIE = userAgent.indexOf(\"MSIE\") !== -1 && userAgent.indexOf(\"Opera\") === -1,\n      isGecko = userAgent.indexOf(\"Gecko\") !== -1 && userAgent.indexOf(\"KHTML\") === -1,\n      isWebKit = userAgent.indexOf(\"AppleWebKit/\") !== -1,\n      isChrome = userAgent.indexOf(\"Chrome/\") !== -1,\n      isOpera = userAgent.indexOf(\"Opera/\") !== -1;\n\n  function iosVersion(userAgent) {\n    return (/ipad|iphone|ipod/.test(userAgent) && userAgent.match(/ os (\\d+).+? like mac os x/) || [, 0])[1];\n  }\n\n  return {\n    // Static variable needed, publicly accessible, to be able override it in unit tests\n    USER_AGENT: userAgent,\n\n    /**\n     * Exclude browsers that are not capable of displaying and handling\n     * contentEditable as desired:\n     *    - iPhone, iPad (tested iOS 4.2.2) and Android (tested 2.2) refuse to make contentEditables focusable\n     *    - IE < 8 create invalid markup and crash randomly from time to time\n     *\n     * @return {Boolean}\n     */\n    supported: function supported() {\n      var userAgent = this.USER_AGENT.toLowerCase(),\n\n\n      // Essential for making html elements editable\n      hasContentEditableSupport = \"contentEditable\" in testElement,\n\n\n      // Following methods are needed in order to interact with the contentEditable area\n      hasEditingApiSupport = document.execCommand && document.queryCommandSupported && document.queryCommandState,\n\n\n      // document selector apis are only supported by IE 8+, Safari 4+, Chrome and Firefox 3.5+\n      hasQuerySelectorSupport = document.querySelector && document.querySelectorAll,\n\n\n      // contentEditable is unusable in mobile browsers (tested iOS 4.2.2, Android 2.2, Opera Mobile, WebOS 3.05)\n      isIncompatibleMobileBrowser = this.isIos() && iosVersion(userAgent) < 5 || userAgent.indexOf(\"opera mobi\") !== -1 || userAgent.indexOf(\"hpwos/\") !== -1;\n\n      return hasContentEditableSupport && hasEditingApiSupport && hasQuerySelectorSupport && !isIncompatibleMobileBrowser;\n    },\n\n    isTouchDevice: function isTouchDevice() {\n      return this.supportsEvent(\"touchmove\");\n    },\n\n    isIos: function isIos() {\n      var userAgent = this.USER_AGENT.toLowerCase();\n      return userAgent.indexOf(\"webkit\") !== -1 && userAgent.indexOf(\"mobile\") !== -1;\n    },\n\n    /**\n     * Whether the browser supports sandboxed iframes\n     * Currently only IE 6+ offers such feature <iframe security=\"restricted\">\n     *\n     * http://msdn.microsoft.com/en-us/library/ms534622(v=vs.85).aspx\n     * http://blogs.msdn.com/b/ie/archive/2008/01/18/using-frames-more-securely.aspx\n     *\n     * HTML5 sandboxed iframes are still buggy and their DOM is not reachable from the outside (except when using postMessage)\n     */\n    supportsSandboxedIframes: function supportsSandboxedIframes() {\n      return isIE;\n    },\n\n    /**\n     * IE6+7 throw a mixed content warning when the src of an iframe\n     * is empty/unset or about:blank\n     * window.querySelector is implemented as of IE8\n     */\n    throwsMixedContentWarningWhenIframeSrcIsEmpty: function throwsMixedContentWarningWhenIframeSrcIsEmpty() {\n      return !(\"querySelector\" in document);\n    },\n\n    /**\n     * Whether the caret is correctly displayed in contentEditable elements\n     * Firefox sometimes shows a huge caret in the beginning after focusing\n     */\n    displaysCaretInEmptyContentEditableCorrectly: function displaysCaretInEmptyContentEditableCorrectly() {\n      return !isGecko;\n    },\n\n    /**\n     * Opera and IE are the only browsers who offer the css value\n     * in the original unit, thx to the currentStyle object\n     * All other browsers provide the computed style in px via window.getComputedStyle\n     */\n    hasCurrentStyleProperty: function hasCurrentStyleProperty() {\n      return \"currentStyle\" in testElement;\n    },\n\n    /**\n     * Whether the browser inserts a <br> when pressing enter in a contentEditable element\n     */\n    insertsLineBreaksOnReturn: function insertsLineBreaksOnReturn() {\n      return isGecko;\n    },\n\n    supportsPlaceholderAttributeOn: function supportsPlaceholderAttributeOn(element) {\n      return \"placeholder\" in element;\n    },\n\n    supportsEvent: function supportsEvent(eventName) {\n      return \"on\" + eventName in testElement || function () {\n        testElement.setAttribute(\"on\" + eventName, \"return;\");\n        return typeof testElement[\"on\" + eventName] === \"function\";\n      }();\n    },\n\n    /**\n     * Opera doesn't correctly fire focus/blur events when clicking in- and outside of iframe\n     */\n    supportsEventsInIframeCorrectly: function supportsEventsInIframeCorrectly() {\n      return !isOpera;\n    },\n\n    /**\n     * Chrome & Safari only fire the ondrop/ondragend/... events when the ondragover event is cancelled\n     * with event.preventDefault\n     * Firefox 3.6 fires those events anyway, but the mozilla doc says that the dragover/dragenter event needs\n     * to be cancelled\n     */\n    firesOnDropOnlyWhenOnDragOverIsCancelled: function firesOnDropOnlyWhenOnDragOverIsCancelled() {\n      return isWebKit || isGecko;\n    },\n\n    /**\n     * Whether the browser supports the event.dataTransfer property in a proper way\n     */\n    supportsDataTransfer: function supportsDataTransfer() {\n      try {\n        // Firefox doesn't support dataTransfer in a safe way, it doesn't strip script code in the html payload (like Chrome does)\n        return isWebKit && (window.Clipboard || window.DataTransfer).prototype.getData;\n      } catch (e) {\n        return false;\n      }\n    },\n\n    /**\n     * Everything below IE9 doesn't know how to treat HTML5 tags\n     *\n     * @param {Object} context The document object on which to check HTML5 support\n     *\n     * @example\n     *    wysihtml5.browser.supportsHTML5Tags(document);\n     */\n    supportsHTML5Tags: function supportsHTML5Tags(context) {\n      var element = context.createElement(\"div\"),\n          html5 = \"<article>foo</article>\";\n      element.innerHTML = html5;\n      return element.innerHTML.toLowerCase() === html5;\n    },\n\n    /**\n     * Checks whether a document supports a certain queryCommand\n     * In particular, Opera needs a reference to a document that has a contentEditable in it's dom tree\n     * in oder to report correct results\n     *\n     * @param {Object} doc Document object on which to check for a query command\n     * @param {String} command The query command to check for\n     * @return {Boolean}\n     *\n     * @example\n     *    wysihtml5.browser.supportsCommand(document, \"bold\");\n     */\n    supportsCommand: function () {\n      // Following commands are supported but contain bugs in some browsers\n      var buggyCommands = {\n        // formatBlock fails with some tags (eg. <blockquote>)\n        \"formatBlock\": isIE,\n        // When inserting unordered or ordered lists in Firefox, Chrome or Safari, the current selection or line gets\n        // converted into a list (<ul><li>...</li></ul>, <ol><li>...</li></ol>)\n        // IE and Opera act a bit different here as they convert the entire content of the current block element into a list\n        \"insertUnorderedList\": isIE || isOpera || isWebKit,\n        \"insertOrderedList\": isIE || isOpera || isWebKit\n      };\n\n      // Firefox throws errors for queryCommandSupported, so we have to build up our own object of supported commands\n      var supported = {\n        \"insertHTML\": isGecko\n      };\n\n      return function (doc, command) {\n        var isBuggy = buggyCommands[command];\n        if (!isBuggy) {\n          // Firefox throws errors when invoking queryCommandSupported or queryCommandEnabled\n          try {\n            return doc.queryCommandSupported(command);\n          } catch (e1) {}\n\n          try {\n            return doc.queryCommandEnabled(command);\n          } catch (e2) {\n            return !!supported[command];\n          }\n        }\n        return false;\n      };\n    }(),\n\n    /**\n     * IE: URLs starting with:\n     *    www., http://, https://, ftp://, gopher://, mailto:, new:, snews:, telnet:, wasis:, file://,\n     *    nntp://, newsrc:, ldap://, ldaps://, outlook:, mic:// and url:\n     * will automatically be auto-linked when either the user inserts them via copy&paste or presses the\n     * space bar when the caret is directly after such an url.\n     * This behavior cannot easily be avoided in IE < 9 since the logic is hardcoded in the mshtml.dll\n     * (related blog post on msdn\n     * http://blogs.msdn.com/b/ieinternals/archive/2009/09/17/prevent-automatic-hyperlinking-in-contenteditable-html.aspx).\n     */\n    doesAutoLinkingInContentEditable: function doesAutoLinkingInContentEditable() {\n      return isIE;\n    },\n\n    /**\n     * As stated above, IE auto links urls typed into contentEditable elements\n     * Since IE9 it's possible to prevent this behavior\n     */\n    canDisableAutoLinking: function canDisableAutoLinking() {\n      return this.supportsCommand(document, \"AutoUrlDetect\");\n    },\n\n    /**\n     * IE leaves an empty paragraph in the contentEditable element after clearing it\n     * Chrome/Safari sometimes an empty <div>\n     */\n    clearsContentEditableCorrectly: function clearsContentEditableCorrectly() {\n      return isGecko || isOpera || isWebKit;\n    },\n\n    /**\n     * IE gives wrong results for getAttribute\n     */\n    supportsGetAttributeCorrectly: function supportsGetAttributeCorrectly() {\n      var td = document.createElement(\"td\");\n      return td.getAttribute(\"rowspan\") != \"1\";\n    },\n\n    /**\n     * When clicking on images in IE, Opera and Firefox, they are selected, which makes it easy to interact with them.\n     * Chrome and Safari both don't support this\n     */\n    canSelectImagesInContentEditable: function canSelectImagesInContentEditable() {\n      return isGecko || isIE || isOpera;\n    },\n\n    /**\n     * When the caret is in an empty list (<ul><li>|</li></ul>) which is the first child in an contentEditable container\n     * pressing backspace doesn't remove the entire list as done in other browsers\n     */\n    clearsListsInContentEditableCorrectly: function clearsListsInContentEditableCorrectly() {\n      return isGecko || isIE || isWebKit;\n    },\n\n    /**\n     * All browsers except Safari and Chrome automatically scroll the range/caret position into view\n     */\n    autoScrollsToCaret: function autoScrollsToCaret() {\n      return !isWebKit;\n    },\n\n    /**\n     * Check whether the browser automatically closes tags that don't need to be opened\n     */\n    autoClosesUnclosedTags: function autoClosesUnclosedTags() {\n      var clonedTestElement = testElement.cloneNode(false),\n          returnValue,\n          innerHTML;\n\n      clonedTestElement.innerHTML = \"<p><div></div>\";\n      innerHTML = clonedTestElement.innerHTML.toLowerCase();\n      returnValue = innerHTML === \"<p></p><div></div>\" || innerHTML === \"<p><div></div></p>\";\n\n      // Cache result by overwriting current function\n      this.autoClosesUnclosedTags = function () {\n        return returnValue;\n      };\n\n      return returnValue;\n    },\n\n    /**\n     * Whether the browser supports the native document.getElementsByClassName which returns live NodeLists\n     */\n    supportsNativeGetElementsByClassName: function supportsNativeGetElementsByClassName() {\n      return String(document.getElementsByClassName).indexOf(\"[native code]\") !== -1;\n    },\n\n    /**\n     * As of now (19.04.2011) only supported by Firefox 4 and Chrome\n     * See https://developer.mozilla.org/en/DOM/Selection/modify\n     */\n    supportsSelectionModify: function supportsSelectionModify() {\n      return \"getSelection\" in window && \"modify\" in window.getSelection();\n    },\n\n    /**\n     * Whether the browser supports the classList object for fast className manipulation\n     * See https://developer.mozilla.org/en/DOM/element.classList\n     */\n    supportsClassList: function supportsClassList() {\n      return \"classList\" in testElement;\n    },\n\n    /**\n     * Opera needs a white space after a <br> in order to position the caret correctly\n     */\n    needsSpaceAfterLineBreak: function needsSpaceAfterLineBreak() {\n      return isOpera;\n    },\n\n    /**\n     * Whether the browser supports the speech api on the given element\n     * See http://mikepultz.com/2011/03/accessing-google-speech-api-chrome-11/\n     *\n     * @example\n     *    var input = document.createElement(\"input\");\n     *    if (wysihtml5.browser.supportsSpeechApiOn(input)) {\n     *      // ...\n     *    }\n     */\n    supportsSpeechApiOn: function supportsSpeechApiOn(input) {\n      var chromeVersion = userAgent.match(/Chrome\\/(\\d+)/) || [, 0];\n      return chromeVersion[1] >= 11 && (\"onwebkitspeechchange\" in input || \"speech\" in input);\n    },\n\n    /**\n     * IE9 crashes when setting a getter via Object.defineProperty on XMLHttpRequest or XDomainRequest\n     * See https://connect.microsoft.com/ie/feedback/details/650112\n     * or try the POC http://tifftiff.de/ie9_crash/\n     */\n    crashesWhenDefineProperty: function crashesWhenDefineProperty(property) {\n      return isIE && (property === \"XMLHttpRequest\" || property === \"XDomainRequest\");\n    },\n\n    /**\n     * IE is the only browser who fires the \"focus\" event not immediately when .focus() is called on an element\n     */\n    doesAsyncFocus: function doesAsyncFocus() {\n      return isIE;\n    },\n\n    /**\n     * In IE it's impssible for the user and for the selection library to set the caret after an <img> when it's the lastChild in the document\n     */\n    hasProblemsSettingCaretAfterImg: function hasProblemsSettingCaretAfterImg() {\n      return isIE;\n    },\n\n    hasUndoInContextMenu: function hasUndoInContextMenu() {\n      return isGecko || isChrome || isOpera;\n    }\n  };\n}();wysihtml5.lang.array = function (arr) {\n  return {\n    /**\n     * Check whether a given object exists in an array\n     *\n     * @example\n     *    wysihtml5.lang.array([1, 2]).contains(1);\n     *    // => true\n     */\n    contains: function contains(needle) {\n      if (arr.indexOf) {\n        return arr.indexOf(needle) !== -1;\n      } else {\n        for (var i = 0, length = arr.length; i < length; i++) {\n          if (arr[i] === needle) {\n            return true;\n          }\n        }\n        return false;\n      }\n    },\n\n    /**\n     * Substract one array from another\n     *\n     * @example\n     *    wysihtml5.lang.array([1, 2, 3, 4]).without([3, 4]);\n     *    // => [1, 2]\n     */\n    without: function without(arrayToSubstract) {\n      arrayToSubstract = wysihtml5.lang.array(arrayToSubstract);\n      var newArr = [],\n          i = 0,\n          length = arr.length;\n      for (; i < length; i++) {\n        if (!arrayToSubstract.contains(arr[i])) {\n          newArr.push(arr[i]);\n        }\n      }\n      return newArr;\n    },\n\n    /**\n     * Return a clean native array\n     * \n     * Following will convert a Live NodeList to a proper Array\n     * @example\n     *    var childNodes = wysihtml5.lang.array(document.body.childNodes).get();\n     */\n    get: function get() {\n      var i = 0,\n          length = arr.length,\n          newArray = [];\n      for (; i < length; i++) {\n        newArray.push(arr[i]);\n      }\n      return newArray;\n    }\n  };\n};wysihtml5.lang.Dispatcher = Base.extend(\n/** @scope wysihtml5.lang.Dialog.prototype */{\n  observe: function observe(eventName, handler) {\n    this.events = this.events || {};\n    this.events[eventName] = this.events[eventName] || [];\n    this.events[eventName].push(handler);\n    return this;\n  },\n\n  on: function on() {\n    return this.observe.apply(this, wysihtml5.lang.array(arguments).get());\n  },\n\n  fire: function fire(eventName, payload) {\n    this.events = this.events || {};\n    var handlers = this.events[eventName] || [],\n        i = 0;\n    for (; i < handlers.length; i++) {\n      handlers[i].call(this, payload);\n    }\n    return this;\n  },\n\n  stopObserving: function stopObserving(eventName, handler) {\n    this.events = this.events || {};\n    var i = 0,\n        handlers,\n        newHandlers;\n    if (eventName) {\n      handlers = this.events[eventName] || [], newHandlers = [];\n      for (; i < handlers.length; i++) {\n        if (handlers[i] !== handler && handler) {\n          newHandlers.push(handlers[i]);\n        }\n      }\n      this.events[eventName] = newHandlers;\n    } else {\n      // Clean up all events\n      this.events = {};\n    }\n    return this;\n  }\n});wysihtml5.lang.object = function (obj) {\n  return {\n    /**\n     * @example\n     *    wysihtml5.lang.object({ foo: 1, bar: 1 }).merge({ bar: 2, baz: 3 }).get();\n     *    // => { foo: 1, bar: 2, baz: 3 }\n     */\n    merge: function merge(otherObj) {\n      for (var i in otherObj) {\n        obj[i] = otherObj[i];\n      }\n      return this;\n    },\n\n    get: function get() {\n      return obj;\n    },\n\n    /**\n     * @example\n     *    wysihtml5.lang.object({ foo: 1 }).clone();\n     *    // => { foo: 1 }\n     */\n    clone: function clone() {\n      var newObj = {},\n          i;\n      for (i in obj) {\n        newObj[i] = obj[i];\n      }\n      return newObj;\n    },\n\n    /**\n     * @example\n     *    wysihtml5.lang.object([]).isArray();\n     *    // => true\n     */\n    isArray: function isArray() {\n      return Object.prototype.toString.call(obj) === \"[object Array]\";\n    }\n  };\n};(function () {\n  var WHITE_SPACE_START = /^\\s+/,\n      WHITE_SPACE_END = /\\s+$/;\n  wysihtml5.lang.string = function (str) {\n    str = String(str);\n    return {\n      /**\n       * @example\n       *    wysihtml5.lang.string(\"   foo   \").trim();\n       *    // => \"foo\"\n       */\n      trim: function trim() {\n        return str.replace(WHITE_SPACE_START, \"\").replace(WHITE_SPACE_END, \"\");\n      },\n\n      /**\n       * @example\n       *    wysihtml5.lang.string(\"Hello #{name}\").interpolate({ name: \"Christopher\" });\n       *    // => \"Hello Christopher\"\n       */\n      interpolate: function interpolate(vars) {\n        for (var i in vars) {\n          str = this.replace(\"#{\" + i + \"}\").by(vars[i]);\n        }\n        return str;\n      },\n\n      /**\n       * @example\n       *    wysihtml5.lang.string(\"Hello Tom\").replace(\"Tom\").with(\"Hans\");\n       *    // => \"Hello Hans\"\n       */\n      replace: function replace(search) {\n        return {\n          by: function by(replace) {\n            return str.split(search).join(replace);\n          }\n        };\n      }\n    };\n  };\n})(); /**\n      * Find urls in descendant text nodes of an element and auto-links them\n      * Inspired by http://james.padolsey.com/javascript/find-and-replace-text-with-javascript/\n      *\n      * @param {Element} element Container element in which to search for urls\n      *\n      * @example\n      *    <div id=\"text-container\">Please click here: www.google.com</div>\n      *    <script>wysihtml5.dom.autoLink(document.getElementById(\"text-container\"));</script>\n      */\n(function (wysihtml5) {\n  var /**\n       * Don't auto-link urls that are contained in the following elements:\n       */\n  IGNORE_URLS_IN = wysihtml5.lang.array([\"CODE\", \"PRE\", \"A\", \"SCRIPT\", \"HEAD\", \"TITLE\", \"STYLE\"]),\n\n\n  /**\n   * revision 1:\n   *    /(\\S+\\.{1}[^\\s\\,\\.\\!]+)/g\n   *\n   * revision 2:\n   *    /(\\b(((https?|ftp):\\/\\/)|(www\\.))[-A-Z0-9+&@#\\/%?=~_|!:,.;\\[\\]]*[-A-Z0-9+&@#\\/%=~_|])/gim\n   *\n   * put this in the beginning if you don't wan't to match within a word\n   *    (^|[\\>\\(\\{\\[\\s\\>])\n   */\n  URL_REG_EXP = /((https?:\\/\\/|www\\.)[^\\s<]{3,})/gi,\n      TRAILING_CHAR_REG_EXP = /([^\\w\\/\\-](,?))$/i,\n      MAX_DISPLAY_LENGTH = 100,\n      BRACKETS = { \")\": \"(\", \"]\": \"[\", \"}\": \"{\" };\n\n  function autoLink(element) {\n    if (_hasParentThatShouldBeIgnored(element)) {\n      return element;\n    }\n\n    if (element === element.ownerDocument.documentElement) {\n      element = element.ownerDocument.body;\n    }\n\n    return _parseNode(element);\n  }\n\n  /**\n   * This is basically a rebuild of\n   * the rails auto_link_urls text helper\n   */\n  function _convertUrlsToLinks(str) {\n    return str.replace(URL_REG_EXP, function (match, url) {\n      var punctuation = (url.match(TRAILING_CHAR_REG_EXP) || [])[1] || \"\",\n          opening = BRACKETS[punctuation];\n      url = url.replace(TRAILING_CHAR_REG_EXP, \"\");\n\n      if (url.split(opening).length > url.split(punctuation).length) {\n        url = url + punctuation;\n        punctuation = \"\";\n      }\n      var realUrl = url,\n          displayUrl = url;\n      if (url.length > MAX_DISPLAY_LENGTH) {\n        displayUrl = displayUrl.substr(0, MAX_DISPLAY_LENGTH) + \"...\";\n      }\n      // Add http prefix if necessary\n      if (realUrl.substr(0, 4) === \"www.\") {\n        realUrl = \"http://\" + realUrl;\n      }\n\n      return '<a href=\"' + realUrl + '\">' + realUrl + '</a>' + punctuation;\n    });\n  }\n\n  /**\n   * Creates or (if already cached) returns a temp element\n   * for the given document object\n   */\n  function _getTempElement(context) {\n    var tempElement = context._wysihtml5_tempElement;\n    if (!tempElement) {\n      tempElement = context._wysihtml5_tempElement = context.createElement(\"div\");\n    }\n    return tempElement;\n  }\n\n  /**\n   * Replaces the original text nodes with the newly auto-linked dom tree\n   */\n  function _wrapMatchesInNode(textNode) {\n    var parentNode = textNode.parentNode,\n        tempElement = _getTempElement(parentNode.ownerDocument);\n\n    // We need to insert an empty/temporary <span /> to fix IE quirks\n    // Elsewise IE would strip white space in the beginning\n    tempElement.innerHTML = \"<span></span>\" + _convertUrlsToLinks(textNode.data);\n    tempElement.removeChild(tempElement.firstChild);\n\n    while (tempElement.firstChild) {\n      // inserts tempElement.firstChild before textNode\n      parentNode.insertBefore(tempElement.firstChild, textNode);\n    }\n    parentNode.removeChild(textNode);\n  }\n\n  function _hasParentThatShouldBeIgnored(node) {\n    var nodeName;\n    while (node.parentNode) {\n      node = node.parentNode;\n      nodeName = node.nodeName;\n      if (IGNORE_URLS_IN.contains(nodeName)) {\n        return true;\n      } else if (nodeName === \"body\") {\n        return false;\n      }\n    }\n    return false;\n  }\n\n  function _parseNode(element) {\n    if (IGNORE_URLS_IN.contains(element.nodeName)) {\n      return;\n    }\n\n    if (element.nodeType === wysihtml5.TEXT_NODE && element.data.match(URL_REG_EXP)) {\n      _wrapMatchesInNode(element);\n      return;\n    }\n\n    var childNodes = wysihtml5.lang.array(element.childNodes).get(),\n        childNodesLength = childNodes.length,\n        i = 0;\n\n    for (; i < childNodesLength; i++) {\n      _parseNode(childNodes[i]);\n    }\n\n    return element;\n  }\n\n  wysihtml5.dom.autoLink = autoLink;\n\n  // Reveal url reg exp to the outside\n  wysihtml5.dom.autoLink.URL_REG_EXP = URL_REG_EXP;\n})(wysihtml5);(function (wysihtml5) {\n  var supportsClassList = wysihtml5.browser.supportsClassList(),\n      api = wysihtml5.dom;\n\n  api.addClass = function (element, className) {\n    if (supportsClassList) {\n      return element.classList.add(className);\n    }\n    if (api.hasClass(element, className)) {\n      return;\n    }\n    element.className += \" \" + className;\n  };\n\n  api.removeClass = function (element, className) {\n    if (supportsClassList) {\n      return element.classList.remove(className);\n    }\n\n    element.className = element.className.replace(new RegExp(\"(^|\\\\s+)\" + className + \"(\\\\s+|$)\"), \" \");\n  };\n\n  api.hasClass = function (element, className) {\n    if (supportsClassList) {\n      return element.classList.contains(className);\n    }\n\n    var elementClassName = element.className;\n    return elementClassName.length > 0 && (elementClassName == className || new RegExp(\"(^|\\\\s)\" + className + \"(\\\\s|$)\").test(elementClassName));\n  };\n})(wysihtml5);\nwysihtml5.dom.contains = function () {\n  var documentElement = document.documentElement;\n  if (documentElement.contains) {\n    return function (container, element) {\n      if (element.nodeType !== wysihtml5.ELEMENT_NODE) {\n        element = element.parentNode;\n      }\n      return container !== element && container.contains(element);\n    };\n  } else if (documentElement.compareDocumentPosition) {\n    return function (container, element) {\n      // https://developer.mozilla.org/en/DOM/Node.compareDocumentPosition\n      return !!(container.compareDocumentPosition(element) & 16);\n    };\n  }\n}(); /**\n     * Converts an HTML fragment/element into a unordered/ordered list\n     *\n     * @param {Element} element The element which should be turned into a list\n     * @param {String} listType The list type in which to convert the tree (either \"ul\" or \"ol\")\n     * @return {Element} The created list\n     *\n     * @example\n     *    <!-- Assume the following dom: -->\n     *    <span id=\"pseudo-list\">\n     *      eminem<br>\n     *      dr. dre\n     *      <div>50 Cent</div>\n     *    </span>\n     *\n     *    <script>\n     *      wysihtml5.dom.convertToList(document.getElementById(\"pseudo-list\"), \"ul\");\n     *    </script>\n     *\n     *    <!-- Will result in: -->\n     *    <ul>\n     *      <li>eminem</li>\n     *      <li>dr. dre</li>\n     *      <li>50 Cent</li>\n     *    </ul>\n     */\nwysihtml5.dom.convertToList = function () {\n  function _createListItem(doc, list) {\n    var listItem = doc.createElement(\"li\");\n    list.appendChild(listItem);\n    return listItem;\n  }\n\n  function _createList(doc, type) {\n    return doc.createElement(type);\n  }\n\n  function convertToList(element, listType) {\n    if (element.nodeName === \"UL\" || element.nodeName === \"OL\" || element.nodeName === \"MENU\") {\n      // Already a list\n      return element;\n    }\n\n    var doc = element.ownerDocument,\n        list = _createList(doc, listType),\n        lineBreaks = element.querySelectorAll(\"br\"),\n        lineBreaksLength = lineBreaks.length,\n        childNodes,\n        childNodesLength,\n        childNode,\n        lineBreak,\n        parentNode,\n        isBlockElement,\n        isLineBreak,\n        currentListItem,\n        i;\n\n    // First find <br> at the end of inline elements and move them behind them\n    for (i = 0; i < lineBreaksLength; i++) {\n      lineBreak = lineBreaks[i];\n      while ((parentNode = lineBreak.parentNode) && parentNode !== element && parentNode.lastChild === lineBreak) {\n        if (wysihtml5.dom.getStyle(\"display\").from(parentNode) === \"block\") {\n          parentNode.removeChild(lineBreak);\n          break;\n        }\n        wysihtml5.dom.insert(lineBreak).after(lineBreak.parentNode);\n      }\n    }\n\n    childNodes = wysihtml5.lang.array(element.childNodes).get();\n    childNodesLength = childNodes.length;\n\n    for (i = 0; i < childNodesLength; i++) {\n      currentListItem = currentListItem || _createListItem(doc, list);\n      childNode = childNodes[i];\n      isBlockElement = wysihtml5.dom.getStyle(\"display\").from(childNode) === \"block\";\n      isLineBreak = childNode.nodeName === \"BR\";\n\n      if (isBlockElement) {\n        // Append blockElement to current <li> if empty, otherwise create a new one\n        currentListItem = currentListItem.firstChild ? _createListItem(doc, list) : currentListItem;\n        currentListItem.appendChild(childNode);\n        currentListItem = null;\n        continue;\n      }\n\n      if (isLineBreak) {\n        // Only create a new list item in the next iteration when the current one has already content\n        currentListItem = currentListItem.firstChild ? null : currentListItem;\n        continue;\n      }\n\n      currentListItem.appendChild(childNode);\n    }\n\n    element.parentNode.replaceChild(list, element);\n    return list;\n  }\n\n  return convertToList;\n}(); /**\n     * Copy a set of attributes from one element to another\n     *\n     * @param {Array} attributesToCopy List of attributes which should be copied\n     * @return {Object} Returns an object which offers the \"from\" method which can be invoked with the element where to\n     *    copy the attributes from., this again returns an object which provides a method named \"to\" which can be invoked \n     *    with the element where to copy the attributes to (see example)\n     *\n     * @example\n     *    var textarea    = document.querySelector(\"textarea\"),\n     *        div         = document.querySelector(\"div[contenteditable=true]\"),\n     *        anotherDiv  = document.querySelector(\"div.preview\");\n     *    wysihtml5.dom.copyAttributes([\"spellcheck\", \"value\", \"placeholder\"]).from(textarea).to(div).andTo(anotherDiv);\n     *\n     */\nwysihtml5.dom.copyAttributes = function (attributesToCopy) {\n  return {\n    from: function from(elementToCopyFrom) {\n      return {\n        to: function to(elementToCopyTo) {\n          var attribute,\n              i = 0,\n              length = attributesToCopy.length;\n          for (; i < length; i++) {\n            attribute = attributesToCopy[i];\n            if (typeof elementToCopyFrom[attribute] !== \"undefined\" && elementToCopyFrom[attribute] !== \"\") {\n              elementToCopyTo[attribute] = elementToCopyFrom[attribute];\n            }\n          }\n          return { andTo: arguments.callee };\n        }\n      };\n    }\n  };\n}; /**\n   * Copy a set of styles from one element to another\n   * Please note that this only works properly across browsers when the element from which to copy the styles\n   * is in the dom\n   *\n   * Interesting article on how to copy styles\n   *\n   * @param {Array} stylesToCopy List of styles which should be copied\n   * @return {Object} Returns an object which offers the \"from\" method which can be invoked with the element where to\n   *    copy the styles from., this again returns an object which provides a method named \"to\" which can be invoked \n   *    with the element where to copy the styles to (see example)\n   *\n   * @example\n   *    var textarea    = document.querySelector(\"textarea\"),\n   *        div         = document.querySelector(\"div[contenteditable=true]\"),\n   *        anotherDiv  = document.querySelector(\"div.preview\");\n   *    wysihtml5.dom.copyStyles([\"overflow-y\", \"width\", \"height\"]).from(textarea).to(div).andTo(anotherDiv);\n   *\n   */\n(function (dom) {\n\n  /**\n   * Mozilla, WebKit and Opera recalculate the computed width when box-sizing: boder-box; is set\n   * So if an element has \"width: 200px; -moz-box-sizing: border-box; border: 1px;\" then \n   * its computed css width will be 198px\n   */\n  var BOX_SIZING_PROPERTIES = [\"-webkit-box-sizing\", \"-moz-box-sizing\", \"-ms-box-sizing\", \"box-sizing\"];\n\n  var shouldIgnoreBoxSizingBorderBox = function shouldIgnoreBoxSizingBorderBox(element) {\n    if (hasBoxSizingBorderBox(element)) {\n      return parseInt(dom.getStyle(\"width\").from(element), 10) < element.offsetWidth;\n    }\n    return false;\n  };\n\n  var hasBoxSizingBorderBox = function hasBoxSizingBorderBox(element) {\n    var i = 0,\n        length = BOX_SIZING_PROPERTIES.length;\n    for (; i < length; i++) {\n      if (dom.getStyle(BOX_SIZING_PROPERTIES[i]).from(element) === \"border-box\") {\n        return BOX_SIZING_PROPERTIES[i];\n      }\n    }\n  };\n\n  dom.copyStyles = function (stylesToCopy) {\n    return {\n      from: function from(element) {\n        if (shouldIgnoreBoxSizingBorderBox(element)) {\n          stylesToCopy = wysihtml5.lang.array(stylesToCopy).without(BOX_SIZING_PROPERTIES);\n        }\n\n        var cssText = \"\",\n            length = stylesToCopy.length,\n            i = 0,\n            property;\n        for (; i < length; i++) {\n          property = stylesToCopy[i];\n          cssText += property + \":\" + dom.getStyle(property).from(element) + \";\";\n        }\n\n        return {\n          to: function to(element) {\n            var height_r = /\\;height\\:/;\n            if (cssText.match(height_r) && element) {\n              list = cssText.split(height_r);\n              height = parseInt(list[1], 10);\n              if (element.offsetHeight > height) {\n                cssText = list[0] + 'height:' + element.offsetHeight + 'px;';\n              }\n            }\n            dom.setStyles(cssText).on(element);\n            return { andTo: arguments.callee };\n          }\n        };\n      }\n    };\n  };\n})(wysihtml5.dom); /**\n                   * Event Delegation\n                   *\n                   * @example\n                   *    wysihtml5.dom.delegate(document.body, \"a\", \"click\", function() {\n                   *      // foo\n                   *    });\n                   */\n(function (wysihtml5) {\n\n  wysihtml5.dom.delegate = function (container, selector, eventName, handler) {\n    return wysihtml5.dom.observe(container, eventName, function (event) {\n      var target = event.target,\n          match = wysihtml5.lang.array(container.querySelectorAll(selector));\n\n      while (target && target !== container) {\n        if (match.contains(target)) {\n          handler.call(target, event);\n          break;\n        }\n        target = target.parentNode;\n      }\n    });\n  };\n})(wysihtml5); /**\n               * Returns the given html wrapped in a div element\n               *\n               * Fixing IE's inability to treat unknown elements (HTML5 section, article, ...) correctly\n               * when inserted via innerHTML\n               * \n               * @param {String} html The html which should be wrapped in a dom element\n               * @param {Obejct} [context] Document object of the context the html belongs to\n               *\n               * @example\n               *    wysihtml5.dom.getAsDom(\"<article>foo</article>\");\n               */\nwysihtml5.dom.getAsDom = function () {\n\n  var _innerHTMLShiv = function _innerHTMLShiv(html, context) {\n    var tempElement = context.createElement(\"div\");\n    tempElement.style.display = \"none\";\n    context.body.appendChild(tempElement);\n    // IE throws an exception when trying to insert <frameset></frameset> via innerHTML\n    try {\n      tempElement.innerHTML = html;\n    } catch (e) {}\n    context.body.removeChild(tempElement);\n    return tempElement;\n  };\n\n  /**\n   * Make sure IE supports HTML5 tags, which is accomplished by simply creating one instance of each element\n   */\n  var _ensureHTML5Compatibility = function _ensureHTML5Compatibility(context) {\n    if (context._wysihtml5_supportsHTML5Tags) {\n      return;\n    }\n    for (var i = 0, length = HTML5_ELEMENTS.length; i < length; i++) {\n      context.createElement(HTML5_ELEMENTS[i]);\n    }\n    context._wysihtml5_supportsHTML5Tags = true;\n  };\n\n  /**\n   * List of html5 tags\n   * taken from http://simon.html5.org/html5-elements\n   */\n  var HTML5_ELEMENTS = [\"abbr\", \"article\", \"aside\", \"audio\", \"bdi\", \"canvas\", \"command\", \"datalist\", \"details\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"keygen\", \"mark\", \"meter\", \"nav\", \"output\", \"progress\", \"rp\", \"rt\", \"ruby\", \"svg\", \"section\", \"source\", \"summary\", \"time\", \"track\", \"video\", \"wbr\"];\n\n  return function (html, context) {\n    context = context || document;\n    var tempElement;\n    if ((typeof html === \"undefined\" ? \"undefined\" : _typeof(html)) === \"object\" && html.nodeType) {\n      tempElement = context.createElement(\"div\");\n      tempElement.appendChild(html);\n    } else if (wysihtml5.browser.supportsHTML5Tags(context)) {\n      tempElement = context.createElement(\"div\");\n      tempElement.innerHTML = html;\n    } else {\n      _ensureHTML5Compatibility(context);\n      tempElement = _innerHTMLShiv(html, context);\n    }\n    return tempElement;\n  };\n}(); /**\n     * Walks the dom tree from the given node up until it finds a match\n     * Designed for optimal performance.\n     *\n     * @param {Element} node The from which to check the parent nodes\n     * @param {Object} matchingSet Object to match against (possible properties: nodeName, className, classRegExp)\n     * @param {Number} [levels] How many parents should the function check up from the current node (defaults to 50)\n     * @return {null|Element} Returns the first element that matched the desiredNodeName(s)\n     * @example\n     *    var listElement = wysihtml5.dom.getParentElement(document.querySelector(\"li\"), { nodeName: [\"MENU\", \"UL\", \"OL\"] });\n     *    // ... or ...\n     *    var unorderedListElement = wysihtml5.dom.getParentElement(document.querySelector(\"li\"), { nodeName: \"UL\" });\n     *    // ... or ...\n     *    var coloredElement = wysihtml5.dom.getParentElement(myTextNode, { nodeName: \"SPAN\", className: \"wysiwyg-color-red\", classRegExp: /wysiwyg-color-[a-z]/g });\n     */\nwysihtml5.dom.getParentElement = function () {\n\n  function _isSameNodeName(nodeName, desiredNodeNames) {\n    if (!desiredNodeNames || !desiredNodeNames.length) {\n      return true;\n    }\n\n    if (typeof desiredNodeNames === \"string\") {\n      return nodeName === desiredNodeNames;\n    } else {\n      return wysihtml5.lang.array(desiredNodeNames).contains(nodeName);\n    }\n  }\n\n  function _isElement(node) {\n    return node.nodeType === wysihtml5.ELEMENT_NODE;\n  }\n\n  function _hasClassName(element, className, classRegExp) {\n    var classNames = (element.className || \"\").match(classRegExp) || [];\n    if (!className) {\n      return !!classNames.length;\n    }\n    return classNames[classNames.length - 1] === className;\n  }\n\n  function _getParentElementWithNodeName(node, nodeName, levels) {\n    while (levels-- && node && node.nodeName !== \"BODY\") {\n      if (_isSameNodeName(node.nodeName, nodeName)) {\n        return node;\n      }\n      node = node.parentNode;\n    }\n    return null;\n  }\n\n  function _getParentElementWithNodeNameAndClassName(node, nodeName, className, classRegExp, levels) {\n    while (levels-- && node && node.nodeName !== \"BODY\") {\n      if (_isElement(node) && _isSameNodeName(node.nodeName, nodeName) && _hasClassName(node, className, classRegExp)) {\n        return node;\n      }\n      node = node.parentNode;\n    }\n    return null;\n  }\n\n  return function (node, matchingSet, levels) {\n    levels = levels || 50; // Go max 50 nodes upwards from current node\n    if (matchingSet.className || matchingSet.classRegExp) {\n      return _getParentElementWithNodeNameAndClassName(node, matchingSet.nodeName, matchingSet.className, matchingSet.classRegExp, levels);\n    } else {\n      return _getParentElementWithNodeName(node, matchingSet.nodeName, levels);\n    }\n  };\n}();\n/**\n * Get element's style for a specific css property\n *\n * @param {Element} element The element on which to retrieve the style\n * @param {String} property The CSS property to retrieve (\"float\", \"display\", \"text-align\", ...)\n *\n * @example\n *    wysihtml5.dom.getStyle(\"display\").from(document.body);\n *    // => \"block\"\n */\nwysihtml5.dom.getStyle = function () {\n  var stylePropertyMapping = {\n    \"float\": \"styleFloat\" in document.createElement(\"div\").style ? \"styleFloat\" : \"cssFloat\"\n  },\n      REG_EXP_CAMELIZE = /\\-[a-z]/g;\n\n  function camelize(str) {\n    return str.replace(REG_EXP_CAMELIZE, function (match) {\n      return match.charAt(1).toUpperCase();\n    });\n  }\n\n  return function (property) {\n    return {\n      from: function from(element) {\n        if (element.nodeType !== wysihtml5.ELEMENT_NODE) {\n          return;\n        }\n\n        var doc = element.ownerDocument,\n            camelizedProperty = stylePropertyMapping[property] || camelize(property),\n            style = element.style,\n            currentStyle = element.currentStyle,\n            styleValue = style[camelizedProperty];\n        if (styleValue) {\n          return styleValue;\n        }\n\n        // currentStyle is no standard and only supported by Opera and IE but it has one important advantage over the standard-compliant\n        // window.getComputedStyle, since it returns css property values in their original unit:\n        // If you set an elements width to \"50%\", window.getComputedStyle will give you it's current width in px while currentStyle\n        // gives you the original \"50%\".\n        // Opera supports both, currentStyle and window.getComputedStyle, that's why checking for currentStyle should have higher prio\n        if (currentStyle) {\n          try {\n            return currentStyle[camelizedProperty];\n          } catch (e) {\n            //ie will occasionally fail for unknown reasons. swallowing exception\n          }\n        }\n\n        var win = doc.defaultView || doc.parentWindow,\n            needsOverflowReset = (property === \"height\" || property === \"width\") && element.nodeName === \"TEXTAREA\",\n            originalOverflow,\n            returnValue;\n\n        if (win.getComputedStyle) {\n          // Chrome and Safari both calculate a wrong width and height for textareas when they have scroll bars\n          // therfore we remove and restore the scrollbar and calculate the value in between\n          if (needsOverflowReset) {\n            originalOverflow = style.overflow;\n            style.overflow = \"hidden\";\n          }\n          returnValue = win.getComputedStyle(element, null).getPropertyValue(property);\n          if (needsOverflowReset) {\n            style.overflow = originalOverflow || \"\";\n          }\n          return returnValue;\n        }\n      }\n    };\n  };\n}(); /**\n     * High performant way to check whether an element with a specific tag name is in the given document\n     * Optimized for being heavily executed\n     * Unleashes the power of live node lists\n     *\n     * @param {Object} doc The document object of the context where to check\n     * @param {String} tagName Upper cased tag name\n     * @example\n     *    wysihtml5.dom.hasElementWithTagName(document, \"IMG\");\n     */\nwysihtml5.dom.hasElementWithTagName = function () {\n  var LIVE_CACHE = {},\n      DOCUMENT_IDENTIFIER = 1;\n\n  function _getDocumentIdentifier(doc) {\n    return doc._wysihtml5_identifier || (doc._wysihtml5_identifier = DOCUMENT_IDENTIFIER++);\n  }\n\n  return function (doc, tagName) {\n    var key = _getDocumentIdentifier(doc) + \":\" + tagName,\n        cacheEntry = LIVE_CACHE[key];\n    if (!cacheEntry) {\n      cacheEntry = LIVE_CACHE[key] = doc.getElementsByTagName(tagName);\n    }\n\n    return cacheEntry.length > 0;\n  };\n}(); /**\n     * High performant way to check whether an element with a specific class name is in the given document\n     * Optimized for being heavily executed\n     * Unleashes the power of live node lists\n     *\n     * @param {Object} doc The document object of the context where to check\n     * @param {String} tagName Upper cased tag name\n     * @example\n     *    wysihtml5.dom.hasElementWithClassName(document, \"foobar\");\n     */\n(function (wysihtml5) {\n  var LIVE_CACHE = {},\n      DOCUMENT_IDENTIFIER = 1;\n\n  function _getDocumentIdentifier(doc) {\n    return doc._wysihtml5_identifier || (doc._wysihtml5_identifier = DOCUMENT_IDENTIFIER++);\n  }\n\n  wysihtml5.dom.hasElementWithClassName = function (doc, className) {\n    // getElementsByClassName is not supported by IE<9\n    // but is sometimes mocked via library code (which then doesn't return live node lists)\n    if (!wysihtml5.browser.supportsNativeGetElementsByClassName()) {\n      return !!doc.querySelector(\".\" + className);\n    }\n\n    var key = _getDocumentIdentifier(doc) + \":\" + className,\n        cacheEntry = LIVE_CACHE[key];\n    if (!cacheEntry) {\n      cacheEntry = LIVE_CACHE[key] = doc.getElementsByClassName(className);\n    }\n\n    return cacheEntry.length > 0;\n  };\n})(wysihtml5);\nwysihtml5.dom.insert = function (elementToInsert) {\n  return {\n    after: function after(element) {\n      element.parentNode.insertBefore(elementToInsert, element.nextSibling);\n    },\n\n    before: function before(element) {\n      element.parentNode.insertBefore(elementToInsert, element);\n    },\n\n    into: function into(element) {\n      element.appendChild(elementToInsert);\n    }\n  };\n};wysihtml5.dom.insertCSS = function (rules) {\n  rules = rules.join(\"\\n\");\n\n  return {\n    into: function into(doc) {\n      var head = doc.head || doc.getElementsByTagName(\"head\")[0],\n          styleElement = doc.createElement(\"style\");\n\n      styleElement.type = \"text/css\";\n\n      if (styleElement.styleSheet) {\n        styleElement.styleSheet.cssText = rules;\n      } else {\n        styleElement.appendChild(doc.createTextNode(rules));\n      }\n\n      if (head) {\n        head.appendChild(styleElement);\n      }\n    }\n  };\n}; /**\n   * Method to set dom events\n   *\n   * @example\n   *    wysihtml5.dom.observe(iframe.contentWindow.document.body, [\"focus\", \"blur\"], function() { ... });\n   */\nwysihtml5.dom.observe = function (element, eventNames, handler) {\n  eventNames = typeof eventNames === \"string\" ? [eventNames] : eventNames;\n\n  var handlerWrapper,\n      eventName,\n      i = 0,\n      length = eventNames.length;\n\n  for (; i < length; i++) {\n    eventName = eventNames[i];\n    if (element.addEventListener) {\n      element.addEventListener(eventName, handler, false);\n    } else {\n      handlerWrapper = function handlerWrapper(event) {\n        if (!(\"target\" in event)) {\n          event.target = event.srcElement;\n        }\n        event.preventDefault = event.preventDefault || function () {\n          this.returnValue = false;\n        };\n        event.stopPropagation = event.stopPropagation || function () {\n          this.cancelBubble = true;\n        };\n        handler.call(element, event);\n      };\n      element.attachEvent(\"on\" + eventName, handlerWrapper);\n    }\n  }\n\n  return {\n    stop: function stop() {\n      var eventName,\n          i = 0,\n          length = eventNames.length;\n      for (; i < length; i++) {\n        eventName = eventNames[i];\n        if (element.removeEventListener) {\n          element.removeEventListener(eventName, handler, false);\n        } else {\n          element.detachEvent(\"on\" + eventName, handlerWrapper);\n        }\n      }\n    }\n  };\n};\n/**\n * HTML Sanitizer\n * Rewrites the HTML based on given rules\n *\n * @param {Element|String} elementOrHtml HTML String to be sanitized OR element whose content should be sanitized\n * @param {Object} [rules] List of rules for rewriting the HTML, if there's no rule for an element it will\n *    be converted to a \"span\". Each rule is a key/value pair where key is the tag to convert, and value the\n *    desired substitution.\n * @param {Object} context Document object in which to parse the html, needed to sandbox the parsing\n *\n * @return {Element|String} Depends on the elementOrHtml parameter. When html then the sanitized html as string elsewise the element.\n *\n * @example\n *    var userHTML = '<div id=\"foo\" onclick=\"alert(1);\"><p><font color=\"red\">foo</font><script>alert(1);</script></p></div>';\n *    wysihtml5.dom.parse(userHTML, {\n *      tags {\n *        p:      \"div\",      // Rename p tags to div tags\n *        font:   \"span\"      // Rename font tags to span tags\n *        div:    true,       // Keep them, also possible (same result when passing: \"div\" or true)\n *        script: undefined   // Remove script elements\n *      }\n *    });\n *    // => <div><div><span>foo bar</span></div></div>\n *\n *    var userHTML = '<table><tbody><tr><td>I'm a table!</td></tr></tbody></table>';\n *    wysihtml5.dom.parse(userHTML);\n *    // => '<span><span><span><span>I'm a table!</span></span></span></span>'\n *\n *    var userHTML = '<div>foobar<br>foobar</div>';\n *    wysihtml5.dom.parse(userHTML, {\n *      tags: {\n *        div: undefined,\n *        br:  true\n *      }\n *    });\n *    // => ''\n *\n *    var userHTML = '<div class=\"red\">foo</div><div class=\"pink\">bar</div>';\n *    wysihtml5.dom.parse(userHTML, {\n *      classes: {\n *        red:    1,\n *        green:  1\n *      },\n *      tags: {\n *        div: {\n *          rename_tag:     \"p\"\n *        }\n *      }\n *    });\n *    // => '<p class=\"red\">foo</p><p>bar</p>'\n */\nwysihtml5.dom.parse = function () {\n\n  /**\n   * It's not possible to use a XMLParser/DOMParser as HTML5 is not always well-formed XML\n   * new DOMParser().parseFromString('<img src=\"foo.gif\">') will cause a parseError since the\n   * node isn't closed\n   *\n   * Therefore we've to use the browser's ordinary HTML parser invoked by setting innerHTML.\n   */\n  var NODE_TYPE_MAPPING = {\n    \"1\": _handleElement,\n    \"3\": _handleText\n  },\n\n\n  // Rename unknown tags to this\n  DEFAULT_NODE_NAME = \"span\",\n      WHITE_SPACE_REG_EXP = /\\s+/,\n      defaultRules = { tags: {}, classes: {} },\n      currentRules = {};\n\n  /**\n   * Iterates over all childs of the element, recreates them, appends them into a document fragment\n   * which later replaces the entire body content\n   */\n  function parse(elementOrHtml, rules, context, cleanUp) {\n    wysihtml5.lang.object(currentRules).merge(defaultRules).merge(rules).get();\n\n    context = context || elementOrHtml.ownerDocument || document;\n    var fragment = context.createDocumentFragment(),\n        isString = typeof elementOrHtml === \"string\",\n        element,\n        newNode,\n        firstChild;\n\n    if (isString) {\n      element = wysihtml5.dom.getAsDom(elementOrHtml, context);\n    } else {\n      element = elementOrHtml;\n    }\n\n    while (element.firstChild) {\n      firstChild = element.firstChild;\n      element.removeChild(firstChild);\n      newNode = _convert(firstChild, cleanUp);\n      if (newNode) {\n        fragment.appendChild(newNode);\n      }\n    }\n\n    // Clear element contents\n    element.innerHTML = \"\";\n\n    // Insert new DOM tree\n    element.appendChild(fragment);\n\n    return isString ? wysihtml5.quirks.getCorrectInnerHTML(element) : element;\n  }\n\n  function _convert(oldNode, cleanUp) {\n    var oldNodeType = oldNode.nodeType,\n        oldChilds = oldNode.childNodes,\n        oldChildsLength = oldChilds.length,\n        newNode,\n        method = NODE_TYPE_MAPPING[oldNodeType],\n        i = 0;\n\n    newNode = method && method(oldNode);\n\n    if (!newNode) {\n      return null;\n    }\n\n    for (i = 0; i < oldChildsLength; i++) {\n      newChild = _convert(oldChilds[i], cleanUp);\n      if (newChild) {\n        newNode.appendChild(newChild);\n      }\n    }\n\n    // Cleanup senseless <span> elements\n    if (cleanUp && newNode.childNodes.length <= 1 && newNode.nodeName.toLowerCase() === DEFAULT_NODE_NAME && !newNode.attributes.length) {\n      return newNode.firstChild;\n    }\n\n    return newNode;\n  }\n\n  function _handleElement(oldNode) {\n    var rule,\n        newNode,\n        endTag,\n        tagRules = currentRules.tags,\n        nodeName = oldNode.nodeName.toLowerCase(),\n        scopeName = oldNode.scopeName;\n\n    /**\n     * We already parsed that element\n     * ignore it! (yes, this sometimes happens in IE8 when the html is invalid)\n     */\n    if (oldNode._wysihtml5) {\n      return null;\n    }\n    oldNode._wysihtml5 = 1;\n\n    if (oldNode.className === \"wysihtml5-temp\") {\n      return null;\n    }\n\n    /**\n     * IE is the only browser who doesn't include the namespace in the\n     * nodeName, that's why we have to prepend it by ourselves\n     * scopeName is a proprietary IE feature\n     * read more here http://msdn.microsoft.com/en-us/library/ms534388(v=vs.85).aspx\n     */\n    if (scopeName && scopeName != \"HTML\") {\n      nodeName = scopeName + \":\" + nodeName;\n    }\n\n    /**\n     * Repair node\n     * IE is a bit bitchy when it comes to invalid nested markup which includes unclosed tags\n     * A <p> doesn't need to be closed according HTML4-5 spec, we simply replace it with a <div> to preserve its content and layout\n     */\n    if (\"outerHTML\" in oldNode) {\n      if (!wysihtml5.browser.autoClosesUnclosedTags() && oldNode.nodeName === \"P\" && oldNode.outerHTML.slice(-4).toLowerCase() !== \"</p>\") {\n        nodeName = \"div\";\n      }\n    }\n\n    if (nodeName in tagRules) {\n      rule = tagRules[nodeName];\n      if (!rule || rule.remove) {\n        return null;\n      }\n\n      rule = typeof rule === \"string\" ? { rename_tag: rule } : rule;\n    } else if (oldNode.firstChild) {\n      rule = { rename_tag: DEFAULT_NODE_NAME };\n    } else {\n      // Remove empty unknown elements\n      return null;\n    }\n\n    newNode = oldNode.ownerDocument.createElement(rule.rename_tag || nodeName);\n    _handleAttributes(oldNode, newNode, rule);\n\n    oldNode = null;\n    return newNode;\n  }\n\n  function _handleAttributes(oldNode, newNode, rule) {\n    var attributes = {},\n\n    // fresh new set of attributes to set on newNode\n    setClass = rule.set_class,\n\n    // classes to set\n    addClass = rule.add_class,\n\n    // add classes based on existing attributes\n    setAttributes = rule.set_attributes,\n\n    // attributes to set on the current node\n    checkAttributes = rule.check_attributes,\n\n    // check/convert values of attributes\n    allowedClasses = currentRules.classes,\n        i = 0,\n        classes = [],\n        newClasses = [],\n        newUniqueClasses = [],\n        oldClasses = [],\n        classesLength,\n        newClassesLength,\n        currentClass,\n        newClass,\n        attributeName,\n        newAttributeValue,\n        method;\n\n    if (setAttributes) {\n      attributes = wysihtml5.lang.object(setAttributes).clone();\n    }\n\n    if (checkAttributes) {\n      for (attributeName in checkAttributes) {\n        method = attributeCheckMethods[checkAttributes[attributeName]];\n        if (!method) {\n          continue;\n        }\n        newAttributeValue = method(_getAttribute(oldNode, attributeName));\n        if (typeof newAttributeValue === \"string\") {\n          attributes[attributeName] = newAttributeValue;\n        }\n      }\n    }\n\n    if (setClass) {\n      classes.push(setClass);\n    }\n\n    if (addClass) {\n      for (attributeName in addClass) {\n        method = addClassMethods[addClass[attributeName]];\n        if (!method) {\n          continue;\n        }\n        newClass = method(_getAttribute(oldNode, attributeName));\n        if (typeof newClass === \"string\") {\n          classes.push(newClass);\n        }\n      }\n    }\n\n    // make sure that wysihtml5 temp class doesn't get stripped out\n    allowedClasses[\"_wysihtml5-temp-placeholder\"] = 1;\n\n    // add old classes last\n    oldClasses = oldNode.getAttribute(\"class\");\n    if (oldClasses) {\n      classes = classes.concat(oldClasses.split(WHITE_SPACE_REG_EXP));\n    }\n    classesLength = classes.length;\n    for (; i < classesLength; i++) {\n      currentClass = classes[i];\n      if (allowedClasses[currentClass]) {\n        newClasses.push(currentClass);\n      }\n    }\n\n    // remove duplicate entries and preserve class specificity\n    newClassesLength = newClasses.length;\n    while (newClassesLength--) {\n      currentClass = newClasses[newClassesLength];\n      if (!wysihtml5.lang.array(newUniqueClasses).contains(currentClass)) {\n        newUniqueClasses.unshift(currentClass);\n      }\n    }\n\n    if (newUniqueClasses.length) {\n      attributes[\"class\"] = newUniqueClasses.join(\" \");\n    }\n\n    // set attributes on newNode\n    for (attributeName in attributes) {\n      // Setting attributes can cause a js error in IE under certain circumstances\n      // eg. on a <img> under https when it's new attribute value is non-https\n      // TODO: Investigate this further and check for smarter handling\n      try {\n        newNode.setAttribute(attributeName, attributes[attributeName]);\n      } catch (e) {}\n    }\n\n    // IE8 sometimes loses the width/height attributes when those are set before the \"src\"\n    // so we make sure to set them again\n    if (attributes.src) {\n      if (typeof attributes.width !== \"undefined\") {\n        newNode.setAttribute(\"width\", attributes.width);\n      }\n      if (typeof attributes.height !== \"undefined\") {\n        newNode.setAttribute(\"height\", attributes.height);\n      }\n    }\n  }\n\n  /**\n   * IE gives wrong results for hasAttribute/getAttribute, for example:\n   *    var td = document.createElement(\"td\");\n   *    td.getAttribute(\"rowspan\"); // => \"1\" in IE\n   *\n   * Therefore we have to check the element's outerHTML for the attribute\n   */\n  var HAS_GET_ATTRIBUTE_BUG = !wysihtml5.browser.supportsGetAttributeCorrectly();\n  function _getAttribute(node, attributeName) {\n    attributeName = attributeName.toLowerCase();\n    var nodeName = node.nodeName;\n    if (nodeName == \"IMG\" && attributeName == \"src\" && _isLoadedImage(node) === true) {\n      // Get 'src' attribute value via object property since this will always contain the\n      // full absolute url (http://...)\n      // this fixes a very annoying bug in firefox (ver 3.6 & 4) and IE 8 where images copied from the same host\n      // will have relative paths, which the sanitizer strips out (see attributeCheckMethods.url)\n      return node.src;\n    } else if (HAS_GET_ATTRIBUTE_BUG && \"outerHTML\" in node) {\n      // Don't trust getAttribute/hasAttribute in IE 6-8, instead check the element's outerHTML\n      var outerHTML = node.outerHTML.toLowerCase(),\n\n\n      // TODO: This might not work for attributes without value: <input disabled>\n      hasAttribute = outerHTML.indexOf(\" \" + attributeName + \"=\") != -1;\n\n      return hasAttribute ? node.getAttribute(attributeName) : null;\n    } else {\n      return node.getAttribute(attributeName);\n    }\n  }\n\n  /**\n   * Check whether the given node is a proper loaded image\n   * FIXME: Returns undefined when unknown (Chrome, Safari)\n   */\n  function _isLoadedImage(node) {\n    try {\n      return node.complete && !node.mozMatchesSelector(\":-moz-broken\");\n    } catch (e) {\n      if (node.complete && node.readyState === \"complete\") {\n        return true;\n      }\n    }\n  }\n\n  function _handleText(oldNode) {\n    return oldNode.ownerDocument.createTextNode(oldNode.data);\n  }\n\n  // ------------ attribute checks ------------ \\\\\n  var attributeCheckMethods = {\n    url: function () {\n      var REG_EXP = /^https?:\\/\\//i;\n      return function (attributeValue) {\n        if (!attributeValue || !attributeValue.match(REG_EXP)) {\n          return null;\n        }\n        return attributeValue.replace(REG_EXP, function (match) {\n          return match.toLowerCase();\n        });\n      };\n    }(),\n\n    alt: function () {\n      var REG_EXP = /[^ a-z0-9_\\-]/gi;\n      return function (attributeValue) {\n        if (!attributeValue) {\n          return \"\";\n        }\n        return attributeValue.replace(REG_EXP, \"\");\n      };\n    }(),\n\n    numbers: function () {\n      var REG_EXP = /\\D/g;\n      return function (attributeValue) {\n        attributeValue = (attributeValue || \"\").replace(REG_EXP, \"\");\n        return attributeValue || null;\n      };\n    }()\n  };\n\n  // ------------ class converter (converts an html attribute to a class name) ------------ \\\\\n  var addClassMethods = {\n    align_img: function () {\n      var mapping = {\n        left: \"wysiwyg-float-left\",\n        right: \"wysiwyg-float-right\"\n      };\n      return function (attributeValue) {\n        return mapping[String(attributeValue).toLowerCase()];\n      };\n    }(),\n\n    align_text: function () {\n      var mapping = {\n        left: \"wysiwyg-text-align-left\",\n        right: \"wysiwyg-text-align-right\",\n        center: \"wysiwyg-text-align-center\",\n        justify: \"wysiwyg-text-align-justify\"\n      };\n      return function (attributeValue) {\n        return mapping[String(attributeValue).toLowerCase()];\n      };\n    }(),\n\n    clear_br: function () {\n      var mapping = {\n        left: \"wysiwyg-clear-left\",\n        right: \"wysiwyg-clear-right\",\n        both: \"wysiwyg-clear-both\",\n        all: \"wysiwyg-clear-both\"\n      };\n      return function (attributeValue) {\n        return mapping[String(attributeValue).toLowerCase()];\n      };\n    }(),\n\n    size_font: function () {\n      var mapping = {\n        \"1\": \"wysiwyg-font-size-xx-small\",\n        \"2\": \"wysiwyg-font-size-small\",\n        \"3\": \"wysiwyg-font-size-medium\",\n        \"4\": \"wysiwyg-font-size-large\",\n        \"5\": \"wysiwyg-font-size-x-large\",\n        \"6\": \"wysiwyg-font-size-xx-large\",\n        \"7\": \"wysiwyg-font-size-xx-large\",\n        \"-\": \"wysiwyg-font-size-smaller\",\n        \"+\": \"wysiwyg-font-size-larger\"\n      };\n      return function (attributeValue) {\n        return mapping[String(attributeValue).charAt(0)];\n      };\n    }()\n  };\n\n  return parse;\n}(); /**\n     * Checks for empty text node childs and removes them\n     *\n     * @param {Element} node The element in which to cleanup\n     * @example\n     *    wysihtml5.dom.removeEmptyTextNodes(element);\n     */\nwysihtml5.dom.removeEmptyTextNodes = function (node) {\n  var childNode,\n      childNodes = wysihtml5.lang.array(node.childNodes).get(),\n      childNodesLength = childNodes.length,\n      i = 0;\n  for (; i < childNodesLength; i++) {\n    childNode = childNodes[i];\n    if (childNode.nodeType === wysihtml5.TEXT_NODE && childNode.data === \"\") {\n      childNode.parentNode.removeChild(childNode);\n    }\n  }\n};\n/**\n * Renames an element (eg. a <div> to a <p>) and keeps its childs\n *\n * @param {Element} element The list element which should be renamed\n * @param {Element} newNodeName The desired tag name\n *\n * @example\n *    <!-- Assume the following dom: -->\n *    <ul id=\"list\">\n *      <li>eminem</li>\n *      <li>dr. dre</li>\n *      <li>50 Cent</li>\n *    </ul>\n *\n *    <script>\n *      wysihtml5.dom.renameElement(document.getElementById(\"list\"), \"ol\");\n *    </script>\n *\n *    <!-- Will result in: -->\n *    <ol>\n *      <li>eminem</li>\n *      <li>dr. dre</li>\n *      <li>50 Cent</li>\n *    </ol>\n */\nwysihtml5.dom.renameElement = function (element, newNodeName) {\n  var newElement = element.ownerDocument.createElement(newNodeName),\n      firstChild;\n  while (firstChild = element.firstChild) {\n    newElement.appendChild(firstChild);\n  }\n  wysihtml5.dom.copyAttributes([\"align\", \"className\"]).from(element).to(newElement);\n  element.parentNode.replaceChild(newElement, element);\n  return newElement;\n}; /**\n   * Takes an element, removes it and replaces it with it's childs\n   * \n   * @param {Object} node The node which to replace with it's child nodes\n   * @example\n   *    <div id=\"foo\">\n   *      <span>hello</span>\n   *    </div>\n   *    <script>\n   *      // Remove #foo and replace with it's children\n   *      wysihtml5.dom.replaceWithChildNodes(document.getElementById(\"foo\"));\n   *    </script>\n   */\nwysihtml5.dom.replaceWithChildNodes = function (node) {\n  if (!node.parentNode) {\n    return;\n  }\n\n  if (!node.firstChild) {\n    node.parentNode.removeChild(node);\n    return;\n  }\n\n  var fragment = node.ownerDocument.createDocumentFragment();\n  while (node.firstChild) {\n    fragment.appendChild(node.firstChild);\n  }\n  node.parentNode.replaceChild(fragment, node);\n  node = fragment = null;\n};\n/**\n * Unwraps an unordered/ordered list\n *\n * @param {Element} element The list element which should be unwrapped\n *\n * @example\n *    <!-- Assume the following dom: -->\n *    <ul id=\"list\">\n *      <li>eminem</li>\n *      <li>dr. dre</li>\n *      <li>50 Cent</li>\n *    </ul>\n *\n *    <script>\n *      wysihtml5.dom.resolveList(document.getElementById(\"list\"));\n *    </script>\n *\n *    <!-- Will result in: -->\n *    eminem<br>\n *    dr. dre<br>\n *    50 Cent<br>\n */\n(function (dom) {\n  function _isBlockElement(node) {\n    return dom.getStyle(\"display\").from(node) === \"block\";\n  }\n\n  function _isLineBreak(node) {\n    return node.nodeName === \"BR\";\n  }\n\n  function _appendLineBreak(element) {\n    var lineBreak = element.ownerDocument.createElement(\"br\");\n    element.appendChild(lineBreak);\n  }\n\n  function resolveList(list) {\n    if (list.nodeName !== \"MENU\" && list.nodeName !== \"UL\" && list.nodeName !== \"OL\") {\n      return;\n    }\n\n    var doc = list.ownerDocument,\n        fragment = doc.createDocumentFragment(),\n        previousSibling = list.previousElementSibling || list.previousSibling,\n        firstChild,\n        lastChild,\n        isLastChild,\n        shouldAppendLineBreak,\n        listItem;\n\n    if (previousSibling && !_isBlockElement(previousSibling)) {\n      _appendLineBreak(fragment);\n    }\n\n    while (listItem = list.firstChild) {\n      lastChild = listItem.lastChild;\n      while (firstChild = listItem.firstChild) {\n        isLastChild = firstChild === lastChild;\n        // This needs to be done before appending it to the fragment, as it otherwise will loose style information\n        shouldAppendLineBreak = isLastChild && !_isBlockElement(firstChild) && !_isLineBreak(firstChild);\n        fragment.appendChild(firstChild);\n        if (shouldAppendLineBreak) {\n          _appendLineBreak(fragment);\n        }\n      }\n\n      listItem.parentNode.removeChild(listItem);\n    }\n    list.parentNode.replaceChild(fragment, list);\n  }\n\n  dom.resolveList = resolveList;\n})(wysihtml5.dom); /**\n                   * Sandbox for executing javascript, parsing css styles and doing dom operations in a secure way\n                   *\n                   * Browser Compatibility:\n                   *  - Secure in MSIE 6+, but only when the user hasn't made changes to his security level \"restricted\"\n                   *  - Partially secure in other browsers (Firefox, Opera, Safari, Chrome, ...)\n                   *\n                   * Please note that this class can't benefit from the HTML5 sandbox attribute for the following reasons:\n                   *    - sandboxing doesn't work correctly with inlined content (src=\"javascript:'<html>...</html>'\")\n                   *    - sandboxing of physical documents causes that the dom isn't accessible anymore from the outside (iframe.contentWindow, ...)\n                   *    - setting the \"allow-same-origin\" flag would fix that, but then still javascript and dom events refuse to fire\n                   *    - therefore the \"allow-scripts\" flag is needed, which then would deactivate any security, as the js executed inside the iframe\n                   *      can do anything as if the sandbox attribute wasn't set\n                   *\n                   * @param {Function} [readyCallback] Method that gets invoked when the sandbox is ready\n                   * @param {Object} [config] Optional parameters\n                   *\n                   * @example\n                   *    new wysihtml5.dom.Sandbox(function(sandbox) {\n                   *      sandbox.getWindow().document.body.innerHTML = '<img src=foo.gif onerror=\"alert(document.cookie)\">';\n                   *    });\n                   */\n(function (wysihtml5) {\n  var /**\n       * Default configuration\n       */\n  doc = document,\n\n\n  /**\n   * Properties to unset/protect on the window object\n   */\n  windowProperties = [\"parent\", \"top\", \"opener\", \"frameElement\", \"frames\", \"localStorage\", \"globalStorage\", \"sessionStorage\", \"indexedDB\"],\n\n\n  /**\n   * Properties on the window object which are set to an empty function\n   */\n  windowProperties2 = [\"open\", \"close\", \"openDialog\", \"showModalDialog\", \"alert\", \"confirm\", \"prompt\", \"openDatabase\", \"postMessage\", \"XMLHttpRequest\", \"XDomainRequest\"],\n\n\n  /**\n   * Properties to unset/protect on the document object\n   */\n  documentProperties = [\"referrer\", \"write\", \"open\", \"close\"];\n\n  wysihtml5.dom.Sandbox = Base.extend(\n  /** @scope wysihtml5.dom.Sandbox.prototype */{\n\n    constructor: function constructor(readyCallback, config) {\n      this.callback = readyCallback || wysihtml5.EMPTY_FUNCTION;\n      this.config = wysihtml5.lang.object({}).merge(config).get();\n      this.iframe = this._createIframe();\n    },\n\n    insertInto: function insertInto(element) {\n      if (typeof element === \"string\") {\n        element = doc.getElementById(element);\n      }\n\n      element.appendChild(this.iframe);\n    },\n\n    getIframe: function getIframe() {\n      return this.iframe;\n    },\n\n    getWindow: function getWindow() {\n      this._readyError();\n    },\n\n    getDocument: function getDocument() {\n      this._readyError();\n    },\n\n    destroy: function destroy() {\n      var iframe = this.getIframe();\n      iframe.parentNode.removeChild(iframe);\n    },\n\n    _readyError: function _readyError() {\n      throw new Error(\"wysihtml5.Sandbox: Sandbox iframe isn't loaded yet\");\n    },\n\n    /**\n     * Creates the sandbox iframe\n     *\n     * Some important notes:\n     *  - We can't use HTML5 sandbox for now:\n     *    setting it causes that the iframe's dom can't be accessed from the outside\n     *    Therefore we need to set the \"allow-same-origin\" flag which enables accessing the iframe's dom\n     *    But then there's another problem, DOM events (focus, blur, change, keypress, ...) aren't fired.\n     *    In order to make this happen we need to set the \"allow-scripts\" flag.\n     *    A combination of allow-scripts and allow-same-origin is almost the same as setting no sandbox attribute at all.\n     *  - Chrome & Safari, doesn't seem to support sandboxing correctly when the iframe's html is inlined (no physical document)\n     *  - IE needs to have the security=\"restricted\" attribute set before the iframe is \n     *    inserted into the dom tree\n     *  - Believe it or not but in IE \"security\" in document.createElement(\"iframe\") is false, even\n     *    though it supports it\n     *  - When an iframe has security=\"restricted\", in IE eval() & execScript() don't work anymore\n     *  - IE doesn't fire the onload event when the content is inlined in the src attribute, therefore we rely\n     *    on the onreadystatechange event\n     */\n    _createIframe: function _createIframe() {\n      var that = this,\n          iframe = doc.createElement(\"iframe\");\n      iframe.className = \"wysihtml5-sandbox\";\n      wysihtml5.dom.setAttributes({\n        \"security\": \"restricted\",\n        \"allowtransparency\": \"true\",\n        \"frameborder\": 0,\n        \"width\": 0,\n        \"height\": 0,\n        \"marginwidth\": 0,\n        \"marginheight\": 0\n      }).on(iframe);\n\n      // Setting the src like this prevents ssl warnings in IE6\n      if (wysihtml5.browser.throwsMixedContentWarningWhenIframeSrcIsEmpty()) {\n        iframe.src = \"javascript:'<html></html>'\";\n      }\n\n      iframe.onload = function () {\n        iframe.onreadystatechange = iframe.onload = null;\n        that._onLoadIframe(iframe);\n      };\n\n      iframe.onreadystatechange = function () {\n        if (/loaded|complete/.test(iframe.readyState)) {\n          iframe.onreadystatechange = iframe.onload = null;\n          that._onLoadIframe(iframe);\n        }\n      };\n\n      return iframe;\n    },\n\n    /**\n     * Callback for when the iframe has finished loading\n     */\n    _onLoadIframe: function _onLoadIframe(iframe) {\n      // don't resume when the iframe got unloaded (eg. by removing it from the dom)\n      if (!wysihtml5.dom.contains(doc.documentElement, iframe)) {\n        return;\n      }\n\n      var that = this,\n          iframeWindow = iframe.contentWindow,\n          iframeDocument = iframe.contentWindow.document,\n          charset = doc.characterSet || doc.charset || \"utf-8\",\n          sandboxHtml = this._getHtml({\n        charset: charset,\n        stylesheets: this.config.stylesheets\n      });\n\n      // Create the basic dom tree including proper DOCTYPE and charset\n      iframeDocument.open(\"text/html\", \"replace\");\n      iframeDocument.write(sandboxHtml);\n      iframeDocument.close();\n\n      this.getWindow = function () {\n        return iframe.contentWindow;\n      };\n      this.getDocument = function () {\n        return iframe.contentWindow.document;\n      };\n\n      // Catch js errors and pass them to the parent's onerror event\n      // addEventListener(\"error\") doesn't work properly in some browsers\n      // TODO: apparently this doesn't work in IE9!\n      iframeWindow.onerror = function (errorMessage, fileName, lineNumber) {\n        throw new Error(\"wysihtml5.Sandbox: \" + errorMessage, fileName, lineNumber);\n      };\n\n      if (!wysihtml5.browser.supportsSandboxedIframes()) {\n        // Unset a bunch of sensitive variables\n        // Please note: This isn't hack safe!  \n        // It more or less just takes care of basic attacks and prevents accidental theft of sensitive information\n        // IE is secure though, which is the most important thing, since IE is the only browser, who\n        // takes over scripts & styles into contentEditable elements when copied from external websites\n        // or applications (Microsoft Word, ...)\n        var i, length;\n        for (i = 0, length = windowProperties.length; i < length; i++) {\n          this._unset(iframeWindow, windowProperties[i]);\n        }\n        for (i = 0, length = windowProperties2.length; i < length; i++) {\n          this._unset(iframeWindow, windowProperties2[i], wysihtml5.EMPTY_FUNCTION);\n        }\n        for (i = 0, length = documentProperties.length; i < length; i++) {\n          this._unset(iframeDocument, documentProperties[i]);\n        }\n        // This doesn't work in Safari 5 \n        // See http://stackoverflow.com/questions/992461/is-it-possible-to-override-document-cookie-in-webkit\n        this._unset(iframeDocument, \"cookie\", \"\", true);\n      }\n\n      this.loaded = true;\n\n      // Trigger the callback\n      setTimeout(function () {\n        that.callback(that);\n      }, 0);\n    },\n\n    _getHtml: function _getHtml(templateVars) {\n      var stylesheets = templateVars.stylesheets,\n          html = \"\",\n          i = 0,\n          length;\n      stylesheets = typeof stylesheets === \"string\" ? [stylesheets] : stylesheets;\n      if (stylesheets) {\n        length = stylesheets.length;\n        for (; i < length; i++) {\n          html += '<link rel=\"stylesheet\" href=\"' + stylesheets[i] + '\">';\n        }\n      }\n      templateVars.stylesheets = html;\n\n      return wysihtml5.lang.string('<!DOCTYPE html><html><head>' + '<meta charset=\"#{charset}\">#{stylesheets}</head>' + '<body></body></html>').interpolate(templateVars);\n    },\n\n    /**\n     * Method to unset/override existing variables\n     * @example\n     *    // Make cookie unreadable and unwritable\n     *    this._unset(document, \"cookie\", \"\", true);\n     */\n    _unset: function _unset(object, property, value, setter) {\n      try {\n        object[property] = value;\n      } catch (e) {}\n\n      try {\n        object.__defineGetter__(property, function () {\n          return value;\n        });\n      } catch (e) {}\n      if (setter) {\n        try {\n          object.__defineSetter__(property, function () {});\n        } catch (e) {}\n      }\n\n      if (!wysihtml5.browser.crashesWhenDefineProperty(property)) {\n        try {\n          var config = {\n            get: function get() {\n              return value;\n            }\n          };\n          if (setter) {\n            config.set = function () {};\n          }\n          Object.defineProperty(object, property, config);\n        } catch (e) {}\n      }\n    }\n  });\n})(wysihtml5);\n(function () {\n  var mapping = {\n    \"className\": \"class\"\n  };\n  wysihtml5.dom.setAttributes = function (attributes) {\n    return {\n      on: function on(element) {\n        for (var i in attributes) {\n          element.setAttribute(mapping[i] || i, attributes[i]);\n        }\n      }\n    };\n  };\n})();wysihtml5.dom.setStyles = function (styles) {\n  return {\n    on: function on(element) {\n      var style = element.style;\n      if (typeof styles === \"string\") {\n        style.cssText += \";\" + styles;\n        return;\n      }\n      for (var i in styles) {\n        if (i === \"float\") {\n          style.cssFloat = styles[i];\n          style.styleFloat = styles[i];\n        } else {\n          style[i] = styles[i];\n        }\n      }\n    }\n  };\n}; /**\n   * Simulate HTML5 placeholder attribute\n   *\n   * Needed since\n   *    - div[contentEditable] elements don't support it\n   *    - older browsers (such as IE8 and Firefox 3.6) don't support it at all\n   *\n   * @param {Object} parent Instance of main wysihtml5.Editor class\n   * @param {Element} view Instance of wysihtml5.views.* class\n   * @param {String} placeholderText\n   *\n   * @example\n   *    wysihtml.dom.simulatePlaceholder(this, composer, \"Foobar\");\n   */\n(function (dom) {\n  dom.simulatePlaceholder = function (editor, view, placeholderText) {\n    var CLASS_NAME = \"placeholder\",\n        unset = function unset() {\n      if (view.hasPlaceholderSet()) {\n        view.clear();\n      }\n      dom.removeClass(view.element, CLASS_NAME);\n    },\n        set = function set() {\n      if (view.isEmpty()) {\n        view.setValue(placeholderText);\n        dom.addClass(view.element, CLASS_NAME);\n      }\n    };\n\n    editor.observe(\"set_placeholder\", set).observe(\"unset_placeholder\", unset).observe(\"focus:composer\", unset).observe(\"paste:composer\", unset).observe(\"blur:composer\", set);\n\n    set();\n  };\n})(wysihtml5.dom);\n(function (dom) {\n  var documentElement = document.documentElement;\n  if (\"textContent\" in documentElement) {\n    dom.setTextContent = function (element, text) {\n      element.textContent = text;\n    };\n\n    dom.getTextContent = function (element) {\n      return element.textContent;\n    };\n  } else if (\"innerText\" in documentElement) {\n    dom.setTextContent = function (element, text) {\n      element.innerText = text;\n    };\n\n    dom.getTextContent = function (element) {\n      return element.innerText;\n    };\n  } else {\n    dom.setTextContent = function (element, text) {\n      element.nodeValue = text;\n    };\n\n    dom.getTextContent = function (element) {\n      return element.nodeValue;\n    };\n  }\n})(wysihtml5.dom);\n\n/**\n * Fix most common html formatting misbehaviors of browsers implementation when inserting\n * content via copy & paste contentEditable\n *\n * @author Christopher Blum\n */\nwysihtml5.quirks.cleanPastedHTML = function () {\n  // TODO: We probably need more rules here\n  var defaultRules = {\n    // When pasting underlined links <a> into a contentEditable, IE thinks, it has to insert <u> to keep the styling\n    \"a u\": wysihtml5.dom.replaceWithChildNodes\n  };\n\n  function cleanPastedHTML(elementOrHtml, rules, context) {\n    rules = rules || defaultRules;\n    context = context || elementOrHtml.ownerDocument || document;\n\n    var element,\n        isString = typeof elementOrHtml === \"string\",\n        method,\n        matches,\n        matchesLength,\n        i,\n        j = 0;\n    if (isString) {\n      element = wysihtml5.dom.getAsDom(elementOrHtml, context);\n    } else {\n      element = elementOrHtml;\n    }\n    if (element.querySelectorAll) {\n      element.innerHTML = element.innerHTML.replace(/\\n/g, '</br>');\n      var els = element.querySelectorAll('style');\n      for (var i = 0; i < els.length; i++) {\n        var el = els[i];\n        el.parentElement.removeChild(el);\n      }\n      var divs = element.querySelectorAll('div');\n      for (var i = 0; i < divs.length; i++) {\n        var div = divs[i];\n        var new_div = document.createElement('p');\n        new_div.innerText = div.innerText;\n        div.replaceWith(new_div);\n      }\n      var p_els = element.querySelectorAll('p');\n      for (var i = 0; i < p_els.length; i++) {\n        var el = p_els[i];\n        if (!$.trim(el.innerText).length) {\n          el.parentElement.removeChild(el);\n        }\n      }\n      var br_els = element.querySelectorAll('br');\n      var i = 0;\n      while (i < br_els.length - 1) {\n        var br = br_els[i];\n        while (br.nextSibling == br_els[i + 1]) {\n          var el = br_els[i + 1];\n          el.parentElement.removeChild(el);\n          i++;\n        }\n        i++;\n      }\n      for (var i = 0; i < br_els.length - 1; i++) {\n        br_els[i];\n      }\n    }\n\n    for (i in rules) {\n      matches = element.querySelectorAll(i);\n      method = rules[i];\n      matchesLength = matches.length;\n      for (; j < matchesLength; j++) {\n        method(matches[j]);\n      }\n    }\n\n    matches = elementOrHtml = rules = null;\n\n    return isString ? element.innerHTML : element;\n  }\n\n  return cleanPastedHTML;\n}(); /**\n     * IE and Opera leave an empty paragraph in the contentEditable element after clearing it\n     *\n     * @param {Object} contentEditableElement The contentEditable element to observe for clearing events\n     * @exaple\n     *    wysihtml5.quirks.ensureProperClearing(myContentEditableElement);\n     */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom;\n\n  wysihtml5.quirks.ensureProperClearing = function () {\n    var clearIfNecessary = function clearIfNecessary(event) {\n      var element = this;\n      setTimeout(function () {\n        var innerHTML = element.innerHTML.toLowerCase();\n        if (innerHTML == \"<p>&nbsp;</p>\" || innerHTML == \"<p>&nbsp;</p><p>&nbsp;</p>\") {\n          element.innerHTML = \"\";\n        }\n      }, 0);\n    };\n\n    return function (composer) {\n      dom.observe(composer.element, [\"cut\", \"keydown\"], clearIfNecessary);\n    };\n  }();\n\n  /**\n   * In Opera when the caret is in the first and only item of a list (<ul><li>|</li></ul>) and the list is the first child of the contentEditable element, it's impossible to delete the list by hitting backspace\n   *\n   * @param {Object} contentEditableElement The contentEditable element to observe for clearing events\n   * @exaple\n   *    wysihtml5.quirks.ensureProperClearing(myContentEditableElement);\n   */\n  wysihtml5.quirks.ensureProperClearingOfLists = function () {\n    var ELEMENTS_THAT_CONTAIN_LI = [\"OL\", \"UL\", \"MENU\"];\n\n    var clearIfNecessary = function clearIfNecessary(element, contentEditableElement) {\n      if (!contentEditableElement.firstChild || !wysihtml5.lang.array(ELEMENTS_THAT_CONTAIN_LI).contains(contentEditableElement.firstChild.nodeName)) {\n        return;\n      }\n\n      var list = dom.getParentElement(element, { nodeName: ELEMENTS_THAT_CONTAIN_LI });\n      if (!list) {\n        return;\n      }\n\n      var listIsFirstChildOfContentEditable = list == contentEditableElement.firstChild;\n      if (!listIsFirstChildOfContentEditable) {\n        return;\n      }\n\n      var hasOnlyOneListItem = list.childNodes.length <= 1;\n      if (!hasOnlyOneListItem) {\n        return;\n      }\n\n      var onlyListItemIsEmpty = list.firstChild ? list.firstChild.innerHTML === \"\" : true;\n      if (!onlyListItemIsEmpty) {\n        return;\n      }\n\n      list.parentNode.removeChild(list);\n    };\n\n    return function (composer) {\n      dom.observe(composer.element, \"keydown\", function (event) {\n        if (event.keyCode !== wysihtml5.BACKSPACE_KEY) {\n          return;\n        }\n\n        var element = composer.selection.getSelectedNode();\n        clearIfNecessary(element, composer.element);\n      });\n    };\n  }();\n})(wysihtml5);\n// See https://bugzilla.mozilla.org/show_bug.cgi?id=664398\n//\n// In Firefox this:\n//      var d = document.createElement(\"div\");\n//      d.innerHTML ='<a href=\"~\"></a>';\n//      d.innerHTML;\n// will result in:\n//      <a href=\"%7E\"></a>\n// which is wrong\n(function (wysihtml5) {\n  var TILDE_ESCAPED = \"%7E\";\n  wysihtml5.quirks.getCorrectInnerHTML = function (element) {\n    var innerHTML = element.innerHTML;\n    if (innerHTML.indexOf(TILDE_ESCAPED) === -1) {\n      return innerHTML;\n    }\n\n    var elementsWithTilde = element.querySelectorAll(\"[href*='~'], [src*='~']\"),\n        url,\n        urlToSearch,\n        length,\n        i;\n    for (i = 0, length = elementsWithTilde.length; i < length; i++) {\n      url = elementsWithTilde[i].href || elementsWithTilde[i].src;\n      urlToSearch = wysihtml5.lang.string(url).replace(\"~\").by(TILDE_ESCAPED);\n      innerHTML = wysihtml5.lang.string(innerHTML).replace(urlToSearch).by(url);\n    }\n    return innerHTML;\n  };\n})(wysihtml5); /**\n               * Some browsers don't insert line breaks when hitting return in a contentEditable element\n               *    - Opera & IE insert new <p> on return\n               *    - Chrome & Safari insert new <div> on return\n               *    - Firefox inserts <br> on return (yippie!)\n               *\n               * @param {Element} element\n               *\n               * @example\n               *    wysihtml5.quirks.insertLineBreakOnReturn(element);\n               */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      USE_NATIVE_LINE_BREAK_WHEN_CARET_INSIDE_TAGS = [\"LI\", \"P\", \"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\"],\n      LIST_TAGS = [\"UL\", \"OL\", \"MENU\"];\n\n  wysihtml5.quirks.insertLineBreakOnReturn = function (composer) {\n    function unwrap(selectedNode) {\n      var parentElement = dom.getParentElement(selectedNode, { nodeName: [\"P\", \"DIV\"] }, 2);\n      if (!parentElement) {\n        return;\n      }\n\n      var invisibleSpace = document.createTextNode(wysihtml5.INVISIBLE_SPACE);\n      dom.insert(invisibleSpace).before(parentElement);\n      dom.replaceWithChildNodes(parentElement);\n      composer.selection.selectNode(invisibleSpace);\n    }\n\n    function keyDown(event) {\n      var keyCode = event.keyCode;\n      if (event.shiftKey || keyCode !== wysihtml5.ENTER_KEY && keyCode !== wysihtml5.BACKSPACE_KEY) {\n        return;\n      }\n\n      var element = event.target,\n          selectedNode = composer.selection.getSelectedNode(),\n          blockElement = dom.getParentElement(selectedNode, { nodeName: USE_NATIVE_LINE_BREAK_WHEN_CARET_INSIDE_TAGS }, 4);\n      if (blockElement) {\n        // Some browsers create <p> elements after leaving a list\n        // check after keydown of backspace and return whether a <p> got inserted and unwrap it\n        if (blockElement.nodeName === \"LI\" && (keyCode === wysihtml5.ENTER_KEY || keyCode === wysihtml5.BACKSPACE_KEY)) {\n          setTimeout(function () {\n            var selectedNode = composer.selection.getSelectedNode(),\n                list,\n                div;\n            if (!selectedNode) {\n              return;\n            }\n\n            list = dom.getParentElement(selectedNode, {\n              nodeName: LIST_TAGS\n            }, 2);\n\n            if (list) {\n              return;\n            }\n\n            unwrap(selectedNode);\n          }, 0);\n        } else if (blockElement.nodeName.match(/H[1-6]/) && keyCode === wysihtml5.ENTER_KEY) {\n          setTimeout(function () {\n            unwrap(composer.selection.getSelectedNode());\n          }, 0);\n        }\n        return;\n      }\n\n      if (keyCode === wysihtml5.ENTER_KEY && !wysihtml5.browser.insertsLineBreaksOnReturn()) {\n        composer.commands.exec(\"insertLineBreak\");\n        event.preventDefault();\n      }\n    }\n\n    // keypress doesn't fire when you hit backspace\n    dom.observe(composer.element.ownerDocument, \"keydown\", keyDown);\n  };\n})(wysihtml5); /**\n               * Force rerendering of a given element\n               * Needed to fix display misbehaviors of IE\n               *\n               * @param {Element} element The element object which needs to be rerendered\n               * @example\n               *    wysihtml5.quirks.redraw(document.body);\n               */\n(function (wysihtml5) {\n  var CLASS_NAME = \"wysihtml5-quirks-redraw\";\n\n  wysihtml5.quirks.redraw = function (element) {\n    wysihtml5.dom.addClass(element, CLASS_NAME);\n    wysihtml5.dom.removeClass(element, CLASS_NAME);\n\n    // Following hack is needed for firefox to make sure that image resize handles are properly removed\n    try {\n      var doc = element.ownerDocument;\n      doc.execCommand(\"italic\", false, null);\n      doc.execCommand(\"italic\", false, null);\n    } catch (e) {}\n  };\n})(wysihtml5); /**\n               * Selection API\n               *\n               * @example\n               *    var selection = new wysihtml5.Selection(editor);\n               */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom;\n\n  function _getCumulativeOffsetTop(element) {\n    var top = 0;\n    if (element.parentNode) {\n      do {\n        top += element.offsetTop || 0;\n        element = element.offsetParent;\n      } while (element);\n    }\n    return top;\n  }\n\n  wysihtml5.Selection = Base.extend(\n  /** @scope wysihtml5.Selection.prototype */{\n    constructor: function constructor(editor) {\n      // Make sure that our external range library is initialized\n      window.rangy.init();\n\n      this.editor = editor;\n      this.composer = editor.composer;\n      this.doc = this.composer.doc;\n    },\n\n    /**\n     * Get the current selection as a bookmark to be able to later restore it\n     *\n     * @return {Object} An object that represents the current selection\n     */\n    getBookmark: function getBookmark() {\n      var range = this.getRange();\n      return range && range.cloneRange();\n    },\n\n    /**\n     * Restore a selection retrieved via wysihtml5.Selection.prototype.getBookmark\n     *\n     * @param {Object} bookmark An object that represents the current selection\n     */\n    setBookmark: function setBookmark(bookmark) {\n      if (!bookmark) {\n        return;\n      }\n\n      this.setSelection(bookmark);\n    },\n\n    /**\n     * Set the caret in front of the given node\n     *\n     * @param {Object} node The element or text node where to position the caret in front of\n     * @example\n     *    selection.setBefore(myElement);\n     */\n    setBefore: function setBefore(node) {\n      var range = rangy.createRange(this.doc);\n      range.setStartBefore(node);\n      range.setEndBefore(node);\n      return this.setSelection(range);\n    },\n\n    /**\n     * Set the caret after the given node\n     *\n     * @param {Object} node The element or text node where to position the caret in front of\n     * @example\n     *    selection.setBefore(myElement);\n     */\n    setAfter: function setAfter(node) {\n      var range = rangy.createRange(this.doc);\n      range.setStartAfter(node);\n      range.setEndAfter(node);\n      return this.setSelection(range);\n    },\n\n    /**\n     * Ability to select/mark nodes\n     *\n     * @param {Element} node The node/element to select\n     * @example\n     *    selection.selectNode(document.getElementById(\"my-image\"));\n     */\n    selectNode: function selectNode(node) {\n      var range = rangy.createRange(this.doc),\n          isElement = node.nodeType === wysihtml5.ELEMENT_NODE,\n          canHaveHTML = \"canHaveHTML\" in node ? node.canHaveHTML : node.nodeName !== \"IMG\",\n          content = isElement ? node.innerHTML : node.data,\n          isEmpty = content === \"\" || content === wysihtml5.INVISIBLE_SPACE,\n          displayStyle = dom.getStyle(\"display\").from(node),\n          isBlockElement = displayStyle === \"block\" || displayStyle === \"list-item\";\n\n      if (isEmpty && isElement && canHaveHTML) {\n        // Make sure that caret is visible in node by inserting a zero width no breaking space\n        try {\n          node.innerHTML = wysihtml5.INVISIBLE_SPACE;\n        } catch (e) {}\n      }\n\n      if (canHaveHTML) {\n        range.selectNodeContents(node);\n      } else {\n        range.selectNode(node);\n      }\n\n      if (canHaveHTML && isEmpty && isElement) {\n        range.collapse(isBlockElement);\n      } else if (canHaveHTML && isEmpty) {\n        range.setStartAfter(node);\n        range.setEndAfter(node);\n      }\n\n      this.setSelection(range);\n    },\n\n    /**\n     * Get the node which contains the selection\n     *\n     * @param {Boolean} [controlRange] (only IE) Whether it should return the selected ControlRange element when the selection type is a \"ControlRange\"\n     * @return {Object} The node that contains the caret\n     * @example\n     *    var nodeThatContainsCaret = selection.getSelectedNode();\n     */\n    getSelectedNode: function getSelectedNode(controlRange) {\n      var selection, range;\n\n      if (controlRange && this.doc.selection && this.doc.selection.type === \"Control\") {\n        range = this.doc.selection.createRange();\n        if (range && range.length) {\n          return range.item(0);\n        }\n      }\n\n      selection = this.getSelection(this.doc);\n      if (selection.focusNode === selection.anchorNode) {\n        return selection.focusNode;\n      } else {\n        range = this.getRange(this.doc);\n        return range ? range.commonAncestorContainer : this.doc.body;\n      }\n    },\n\n    executeAndRestore: function executeAndRestore(method, restoreScrollPosition) {\n      var body = this.doc.body,\n          oldScrollTop = restoreScrollPosition && body.scrollTop,\n          oldScrollLeft = restoreScrollPosition && body.scrollLeft,\n          className = \"_wysihtml5-temp-placeholder\",\n          placeholderHTML = '<span class=\"' + className + '\">' + wysihtml5.INVISIBLE_SPACE + '</span>',\n          range = this.getRange(this.doc),\n          newRange;\n\n      // Nothing selected, execute and say goodbye\n      if (!range) {\n        method(body, body);\n        return;\n      }\n\n      var node = range.createContextualFragment(placeholderHTML);\n      range.insertNode(node);\n\n      // Make sure that a potential error doesn't cause our placeholder element to be left as a placeholder\n      try {\n        method(range.startContainer, range.endContainer);\n      } catch (e3) {\n        setTimeout(function () {\n          throw e3;\n        }, 0);\n      }\n\n      caretPlaceholder = this.doc.querySelector(\".\" + className);\n      if (caretPlaceholder) {\n        newRange = rangy.createRange(this.doc);\n        newRange.selectNode(caretPlaceholder);\n        newRange.deleteContents();\n        this.setSelection(newRange);\n      } else {\n        // fallback for when all hell breaks loose\n        body.focus();\n      }\n\n      if (restoreScrollPosition) {\n        body.scrollTop = oldScrollTop;\n        body.scrollLeft = oldScrollLeft;\n      }\n\n      // Remove it again, just to make sure that the placeholder is definitely out of the dom tree\n      try {\n        caretPlaceholder.parentNode.removeChild(caretPlaceholder);\n      } catch (e4) {}\n    },\n\n    /**\n     * Different approach of preserving the selection (doesn't modify the dom)\n     * Takes all text nodes in the selection and saves the selection position in the first and last one\n     */\n    executeAndRestoreSimple: function executeAndRestoreSimple(method) {\n      var range = this.getRange(),\n          body = this.doc.body,\n          newRange,\n          firstNode,\n          lastNode,\n          textNodes,\n          rangeBackup;\n\n      // Nothing selected, execute and say goodbye\n      if (!range) {\n        method(body, body);\n        return;\n      }\n\n      textNodes = range.getNodes([3]);\n      firstNode = textNodes[0] || range.startContainer;\n      lastNode = textNodes[textNodes.length - 1] || range.endContainer;\n\n      rangeBackup = {\n        collapsed: range.collapsed,\n        startContainer: firstNode,\n        startOffset: firstNode === range.startContainer ? range.startOffset : 0,\n        endContainer: lastNode,\n        endOffset: lastNode === range.endContainer ? range.endOffset : lastNode.length\n      };\n\n      try {\n        method(range.startContainer, range.endContainer);\n      } catch (e) {\n        setTimeout(function () {\n          throw e;\n        }, 0);\n      }\n\n      newRange = rangy.createRange(this.doc);\n      try {\n        newRange.setStart(rangeBackup.startContainer, rangeBackup.startOffset);\n      } catch (e1) {}\n      try {\n        newRange.setEnd(rangeBackup.endContainer, rangeBackup.endOffset);\n      } catch (e2) {}\n      try {\n        this.setSelection(newRange);\n      } catch (e3) {}\n    },\n\n    /**\n     * Insert html at the caret position and move the cursor after the inserted html\n     *\n     * @param {String} html HTML string to insert\n     * @example\n     *    selection.insertHTML(\"<p>foobar</p>\");\n     */\n    insertHTML: function insertHTML(html) {\n      var range = rangy.createRange(this.doc),\n          node = range.createContextualFragment(html),\n          lastChild = node.lastChild;\n      this.insertNode(node);\n      if (lastChild) {\n        this.setAfter(lastChild);\n      }\n    },\n\n    /**\n     * Insert a node at the caret position and move the cursor behind it\n     *\n     * @param {Object} node HTML string to insert\n     * @example\n     *    selection.insertNode(document.createTextNode(\"foobar\"));\n     */\n    insertNode: function insertNode(node) {\n      var range = this.getRange();\n      if (range) {\n        range.insertNode(node);\n      }\n    },\n\n    /**\n     * Wraps current selection with the given node\n     *\n     * @param {Object} node The node to surround the selected elements with\n     */\n    surround: function surround(node) {\n      var range = this.getRange();\n      if (!range) {\n        return;\n      }\n\n      try {\n        // This only works when the range boundaries are not overlapping other elements\n        range.surroundContents(node);\n        this.selectNode(node);\n      } catch (e) {\n        // fallback\n        node.appendChild(range.extractContents());\n        range.insertNode(node);\n      }\n    },\n\n    /**\n     * Scroll the current caret position into the view\n     * FIXME: This is a bit hacky, there might be a smarter way of doing this\n     *\n     * @example\n     *    selection.scrollIntoView();\n     */\n    scrollIntoView: function scrollIntoView() {\n      var doc = this.doc,\n          hasScrollBars = doc.documentElement.scrollHeight > doc.documentElement.offsetHeight,\n          tempElement = doc._wysihtml5ScrollIntoViewElement = doc._wysihtml5ScrollIntoViewElement || function () {\n        var element = doc.createElement(\"span\");\n        // The element needs content in order to be able to calculate it's position properly\n        element.innerHTML = wysihtml5.INVISIBLE_SPACE;\n        return element;\n      }(),\n          offsetTop;\n\n      if (hasScrollBars) {\n        this.insertNode(tempElement);\n        offsetTop = _getCumulativeOffsetTop(tempElement);\n        tempElement.parentNode.removeChild(tempElement);\n        if (offsetTop > doc.body.scrollTop) {\n          doc.body.scrollTop = offsetTop;\n        }\n      }\n    },\n\n    /**\n     * Select line where the caret is in\n     */\n    selectLine: function selectLine() {\n      if (wysihtml5.browser.supportsSelectionModify()) {\n        this._selectLine_W3C();\n      } else if (this.doc.selection) {\n        this._selectLine_MSIE();\n      }\n    },\n\n    /**\n     * See https://developer.mozilla.org/en/DOM/Selection/modify\n     */\n    _selectLine_W3C: function _selectLine_W3C() {\n      var win = this.doc.defaultView,\n          selection = win.getSelection();\n      selection.modify(\"extend\", \"left\", \"lineboundary\");\n      selection.modify(\"extend\", \"right\", \"lineboundary\");\n    },\n\n    _selectLine_MSIE: function _selectLine_MSIE() {\n      var range = this.doc.selection.createRange(),\n          rangeTop = range.boundingTop,\n          rangeHeight = range.boundingHeight,\n          scrollWidth = this.doc.body.scrollWidth,\n          rangeBottom,\n          rangeEnd,\n          measureNode,\n          i,\n          j;\n\n      if (!range.moveToPoint) {\n        return;\n      }\n\n      if (rangeTop === 0) {\n        // Don't know why, but when the selection ends at the end of a line\n        // range.boundingTop is 0\n        measureNode = this.doc.createElement(\"span\");\n        this.insertNode(measureNode);\n        rangeTop = measureNode.offsetTop;\n        measureNode.parentNode.removeChild(measureNode);\n      }\n\n      rangeTop += 1;\n\n      for (i = -10; i < scrollWidth; i += 2) {\n        try {\n          range.moveToPoint(i, rangeTop);\n          break;\n        } catch (e1) {}\n      }\n\n      // Investigate the following in order to handle multi line selections\n      // rangeBottom = rangeTop + (rangeHeight ? (rangeHeight - 1) : 0);\n      rangeBottom = rangeTop;\n      rangeEnd = this.doc.selection.createRange();\n      for (j = scrollWidth; j >= 0; j--) {\n        try {\n          rangeEnd.moveToPoint(j, rangeBottom);\n          break;\n        } catch (e2) {}\n      }\n\n      range.setEndPoint(\"EndToEnd\", rangeEnd);\n      range.select();\n    },\n\n    getText: function getText() {\n      var selection = this.getSelection();\n      return selection ? selection.toString() : \"\";\n    },\n\n    getNodes: function getNodes(nodeType, filter) {\n      var range = this.getRange();\n      if (range) {\n        return range.getNodes([nodeType], filter);\n      } else {\n        return [];\n      }\n    },\n\n    getRange: function getRange() {\n      var selection = this.getSelection();\n      return selection && selection.rangeCount && selection.getRangeAt(0);\n    },\n\n    getSelection: function getSelection() {\n      return rangy.getSelection(this.doc.defaultView || this.doc.parentWindow);\n    },\n\n    setSelection: function setSelection(range) {\n      var win = this.doc.defaultView || this.doc.parentWindow,\n          selection = rangy.getSelection(win);\n      return selection.setSingleRange(range);\n    }\n  });\n})(wysihtml5);\n/**\n * Inspired by the rangy CSS Applier module written by Tim Down and licensed under the MIT license.\n * http://code.google.com/p/rangy/\n *\n * changed in order to be able ...\n *    - to use custom tags\n *    - to detect and replace similar css classes via reg exp\n */\n(function (wysihtml5, rangy) {\n  var defaultTagName = \"span\";\n\n  var REG_EXP_WHITE_SPACE = /\\s+/g;\n\n  function hasClass(el, cssClass, regExp) {\n    if (!el.className) {\n      return false;\n    }\n\n    var matchingClassNames = el.className.match(regExp) || [];\n    return matchingClassNames[matchingClassNames.length - 1] === cssClass;\n  }\n\n  function addClass(el, cssClass, regExp) {\n    if (el.className) {\n      removeClass(el, regExp);\n      el.className += \" \" + cssClass;\n    } else {\n      el.className = cssClass;\n    }\n  }\n\n  function removeClass(el, regExp) {\n    if (el.className) {\n      el.className = el.className.replace(regExp, \"\");\n    }\n  }\n\n  function hasSameClasses(el1, el2) {\n    return el1.className.replace(REG_EXP_WHITE_SPACE, \" \") == el2.className.replace(REG_EXP_WHITE_SPACE, \" \");\n  }\n\n  function replaceWithOwnChildren(el) {\n    var parent = el.parentNode;\n    while (el.firstChild) {\n      parent.insertBefore(el.firstChild, el);\n    }\n    parent.removeChild(el);\n  }\n\n  function elementsHaveSameNonClassAttributes(el1, el2) {\n    if (el1.attributes.length != el2.attributes.length) {\n      return false;\n    }\n    for (var i = 0, len = el1.attributes.length, attr1, attr2, name; i < len; ++i) {\n      attr1 = el1.attributes[i];\n      name = attr1.name;\n      if (name != \"class\") {\n        attr2 = el2.attributes.getNamedItem(name);\n        if (attr1.specified != attr2.specified) {\n          return false;\n        }\n        if (attr1.specified && attr1.nodeValue !== attr2.nodeValue) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  function isSplitPoint(node, offset) {\n    if (rangy.dom.isCharacterDataNode(node)) {\n      if (offset == 0) {\n        return !!node.previousSibling;\n      } else if (offset == node.length) {\n        return !!node.nextSibling;\n      } else {\n        return true;\n      }\n    }\n\n    return offset > 0 && offset < node.childNodes.length;\n  }\n\n  function splitNodeAt(node, descendantNode, descendantOffset) {\n    var newNode;\n    if (rangy.dom.isCharacterDataNode(descendantNode)) {\n      if (descendantOffset == 0) {\n        descendantOffset = rangy.dom.getNodeIndex(descendantNode);\n        descendantNode = descendantNode.parentNode;\n      } else if (descendantOffset == descendantNode.length) {\n        descendantOffset = rangy.dom.getNodeIndex(descendantNode) + 1;\n        descendantNode = descendantNode.parentNode;\n      } else {\n        newNode = rangy.dom.splitDataNode(descendantNode, descendantOffset);\n      }\n    }\n    if (!newNode) {\n      newNode = descendantNode.cloneNode(false);\n      if (newNode.id) {\n        newNode.removeAttribute(\"id\");\n      }\n      var child;\n      while (child = descendantNode.childNodes[descendantOffset]) {\n        newNode.appendChild(child);\n      }\n      rangy.dom.insertAfter(newNode, descendantNode);\n    }\n    return descendantNode == node ? newNode : splitNodeAt(node, newNode.parentNode, rangy.dom.getNodeIndex(newNode));\n  }\n\n  function Merge(firstNode) {\n    this.isElementMerge = firstNode.nodeType == wysihtml5.ELEMENT_NODE;\n    this.firstTextNode = this.isElementMerge ? firstNode.lastChild : firstNode;\n    this.textNodes = [this.firstTextNode];\n  }\n\n  Merge.prototype = {\n    doMerge: function doMerge() {\n      var textBits = [],\n          textNode,\n          parent,\n          text;\n      for (var i = 0, len = this.textNodes.length; i < len; ++i) {\n        textNode = this.textNodes[i];\n        parent = textNode.parentNode;\n        textBits[i] = textNode.data;\n        if (i) {\n          parent.removeChild(textNode);\n          if (!parent.hasChildNodes()) {\n            parent.parentNode.removeChild(parent);\n          }\n        }\n      }\n      this.firstTextNode.data = text = textBits.join(\"\");\n      return text;\n    },\n\n    getLength: function getLength() {\n      var i = this.textNodes.length,\n          len = 0;\n      while (i--) {\n        len += this.textNodes[i].length;\n      }\n      return len;\n    },\n\n    toString: function toString() {\n      var textBits = [];\n      for (var i = 0, len = this.textNodes.length; i < len; ++i) {\n        textBits[i] = \"'\" + this.textNodes[i].data + \"'\";\n      }\n      return \"[Merge(\" + textBits.join(\",\") + \")]\";\n    }\n  };\n\n  function HTMLApplier(tagNames, cssClass, similarClassRegExp, normalize) {\n    this.tagNames = tagNames || [defaultTagName];\n    this.cssClass = cssClass || \"\";\n    this.similarClassRegExp = similarClassRegExp;\n    this.normalize = normalize;\n    this.applyToAnyTagName = false;\n  }\n\n  HTMLApplier.prototype = {\n    getAncestorWithClass: function getAncestorWithClass(node) {\n      var cssClassMatch;\n      while (node) {\n        cssClassMatch = this.cssClass ? hasClass(node, this.cssClass, this.similarClassRegExp) : true;\n        if (node.nodeType == wysihtml5.ELEMENT_NODE && rangy.dom.arrayContains(this.tagNames, node.tagName.toLowerCase()) && cssClassMatch) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n      return false;\n    },\n\n    // Normalizes nodes after applying a CSS class to a Range.\n    postApply: function postApply(textNodes, range) {\n      var firstNode = textNodes[0],\n          lastNode = textNodes[textNodes.length - 1];\n\n      var merges = [],\n          currentMerge;\n\n      var rangeStartNode = firstNode,\n          rangeEndNode = lastNode;\n      var rangeStartOffset = 0,\n          rangeEndOffset = lastNode.length;\n\n      var textNode, precedingTextNode;\n\n      for (var i = 0, len = textNodes.length; i < len; ++i) {\n        textNode = textNodes[i];\n        precedingTextNode = this.getAdjacentMergeableTextNode(textNode.parentNode, false);\n        if (precedingTextNode) {\n          if (!currentMerge) {\n            currentMerge = new Merge(precedingTextNode);\n            merges.push(currentMerge);\n          }\n          currentMerge.textNodes.push(textNode);\n          if (textNode === firstNode) {\n            rangeStartNode = currentMerge.firstTextNode;\n            rangeStartOffset = rangeStartNode.length;\n          }\n          if (textNode === lastNode) {\n            rangeEndNode = currentMerge.firstTextNode;\n            rangeEndOffset = currentMerge.getLength();\n          }\n        } else {\n          currentMerge = null;\n        }\n      }\n\n      // Test whether the first node after the range needs merging\n      var nextTextNode = this.getAdjacentMergeableTextNode(lastNode.parentNode, true);\n      if (nextTextNode) {\n        if (!currentMerge) {\n          currentMerge = new Merge(lastNode);\n          merges.push(currentMerge);\n        }\n        currentMerge.textNodes.push(nextTextNode);\n      }\n\n      // Do the merges\n      if (merges.length) {\n        for (i = 0, len = merges.length; i < len; ++i) {\n          merges[i].doMerge();\n        }\n        // Set the range boundaries\n        range.setStart(rangeStartNode, rangeStartOffset);\n        range.setEnd(rangeEndNode, rangeEndOffset);\n      }\n    },\n\n    getAdjacentMergeableTextNode: function getAdjacentMergeableTextNode(node, forward) {\n      var isTextNode = node.nodeType == wysihtml5.TEXT_NODE;\n      var el = isTextNode ? node.parentNode : node;\n      var adjacentNode;\n      var propName = forward ? \"nextSibling\" : \"previousSibling\";\n      if (isTextNode) {\n        // Can merge if the node's previous/next sibling is a text node\n        adjacentNode = node[propName];\n        if (adjacentNode && adjacentNode.nodeType == wysihtml5.TEXT_NODE) {\n          return adjacentNode;\n        }\n      } else {\n        // Compare element with its sibling\n        adjacentNode = el[propName];\n        if (adjacentNode && this.areElementsMergeable(node, adjacentNode)) {\n          return adjacentNode[forward ? \"firstChild\" : \"lastChild\"];\n        }\n      }\n      return null;\n    },\n\n    areElementsMergeable: function areElementsMergeable(el1, el2) {\n      return rangy.dom.arrayContains(this.tagNames, (el1.tagName || \"\").toLowerCase()) && rangy.dom.arrayContains(this.tagNames, (el2.tagName || \"\").toLowerCase()) && hasSameClasses(el1, el2) && elementsHaveSameNonClassAttributes(el1, el2);\n    },\n\n    createContainer: function createContainer(doc) {\n      var el = doc.createElement(this.tagNames[0]);\n      if (this.cssClass) {\n        el.className = this.cssClass;\n      }\n      return el;\n    },\n\n    applyToTextNode: function applyToTextNode(textNode) {\n      var parent = textNode.parentNode;\n      if (parent.childNodes.length == 1 && rangy.dom.arrayContains(this.tagNames, parent.tagName.toLowerCase())) {\n        if (this.cssClass) {\n          addClass(parent, this.cssClass, this.similarClassRegExp);\n        }\n      } else {\n        var el = this.createContainer(rangy.dom.getDocument(textNode));\n        textNode.parentNode.insertBefore(el, textNode);\n        el.appendChild(textNode);\n      }\n    },\n\n    isRemovable: function isRemovable(el) {\n      return rangy.dom.arrayContains(this.tagNames, el.tagName.toLowerCase()) && wysihtml5.lang.string(el.className).trim() == this.cssClass;\n    },\n\n    undoToTextNode: function undoToTextNode(textNode, range, ancestorWithClass) {\n      if (!range.containsNode(ancestorWithClass)) {\n        // Split out the portion of the ancestor from which we can remove the CSS class\n        var ancestorRange = range.cloneRange();\n        ancestorRange.selectNode(ancestorWithClass);\n\n        if (ancestorRange.isPointInRange(range.endContainer, range.endOffset) && isSplitPoint(range.endContainer, range.endOffset)) {\n          splitNodeAt(ancestorWithClass, range.endContainer, range.endOffset);\n          range.setEndAfter(ancestorWithClass);\n        }\n        if (ancestorRange.isPointInRange(range.startContainer, range.startOffset) && isSplitPoint(range.startContainer, range.startOffset)) {\n          ancestorWithClass = splitNodeAt(ancestorWithClass, range.startContainer, range.startOffset);\n        }\n      }\n\n      if (this.similarClassRegExp) {\n        removeClass(ancestorWithClass, this.similarClassRegExp);\n      }\n      if (this.isRemovable(ancestorWithClass)) {\n        replaceWithOwnChildren(ancestorWithClass);\n      }\n    },\n\n    applyToRange: function applyToRange(range) {\n      var textNodes = range.getNodes([wysihtml5.TEXT_NODE]);\n      if (!textNodes.length) {\n        try {\n          var node = this.createContainer(range.endContainer.ownerDocument);\n          range.surroundContents(node);\n          this.selectNode(range, node);\n          return;\n        } catch (e) {}\n      }\n\n      range.splitBoundaries();\n      textNodes = range.getNodes([wysihtml5.TEXT_NODE]);\n\n      if (textNodes.length) {\n        var textNode;\n\n        for (var i = 0, len = textNodes.length; i < len; ++i) {\n          textNode = textNodes[i];\n          if (!this.getAncestorWithClass(textNode)) {\n            this.applyToTextNode(textNode);\n          }\n        }\n\n        range.setStart(textNodes[0], 0);\n        textNode = textNodes[textNodes.length - 1];\n        range.setEnd(textNode, textNode.length);\n\n        if (this.normalize) {\n          this.postApply(textNodes, range);\n        }\n      }\n    },\n\n    undoToRange: function undoToRange(range) {\n      var textNodes = range.getNodes([wysihtml5.TEXT_NODE]),\n          textNode,\n          ancestorWithClass;\n      if (textNodes.length) {\n        range.splitBoundaries();\n        textNodes = range.getNodes([wysihtml5.TEXT_NODE]);\n      } else {\n        var doc = range.endContainer.ownerDocument,\n            node = doc.createTextNode(wysihtml5.INVISIBLE_SPACE);\n        range.insertNode(node);\n        range.selectNode(node);\n        textNodes = [node];\n      }\n\n      for (var i = 0, len = textNodes.length; i < len; ++i) {\n        textNode = textNodes[i];\n        ancestorWithClass = this.getAncestorWithClass(textNode);\n        if (ancestorWithClass) {\n          this.undoToTextNode(textNode, range, ancestorWithClass);\n        }\n      }\n\n      if (len == 1) {\n        this.selectNode(range, textNodes[0]);\n      } else {\n        range.setStart(textNodes[0], 0);\n        textNode = textNodes[textNodes.length - 1];\n        range.setEnd(textNode, textNode.length);\n\n        if (this.normalize) {\n          this.postApply(textNodes, range);\n        }\n      }\n    },\n\n    selectNode: function selectNode(range, node) {\n      var isElement = node.nodeType === wysihtml5.ELEMENT_NODE,\n          canHaveHTML = \"canHaveHTML\" in node ? node.canHaveHTML : true,\n          content = isElement ? node.innerHTML : node.data,\n          isEmpty = content === \"\" || content === wysihtml5.INVISIBLE_SPACE;\n\n      if (isEmpty && isElement && canHaveHTML) {\n        // Make sure that caret is visible in node by inserting a zero width no breaking space\n        try {\n          node.innerHTML = wysihtml5.INVISIBLE_SPACE;\n        } catch (e) {}\n      }\n      range.selectNodeContents(node);\n      if (isEmpty && isElement) {\n        range.collapse(false);\n      } else if (isEmpty) {\n        range.setStartAfter(node);\n        range.setEndAfter(node);\n      }\n    },\n\n    getTextSelectedByRange: function getTextSelectedByRange(textNode, range) {\n      var textRange = range.cloneRange();\n      textRange.selectNodeContents(textNode);\n\n      var intersectionRange = textRange.intersection(range);\n      var text = intersectionRange ? intersectionRange.toString() : \"\";\n      textRange.detach();\n\n      return text;\n    },\n\n    isAppliedToRange: function isAppliedToRange(range) {\n      var ancestors = [],\n          ancestor,\n          textNodes = range.getNodes([wysihtml5.TEXT_NODE]);\n      if (!textNodes.length) {\n        ancestor = this.getAncestorWithClass(range.startContainer);\n        return ancestor ? [ancestor] : false;\n      }\n\n      for (var i = 0, len = textNodes.length, selectedText; i < len; ++i) {\n        selectedText = this.getTextSelectedByRange(textNodes[i], range);\n        ancestor = this.getAncestorWithClass(textNodes[i]);\n        if (selectedText != \"\" && !ancestor) {\n          return false;\n        } else {\n          ancestors.push(ancestor);\n        }\n      }\n      return ancestors;\n    },\n\n    toggleRange: function toggleRange(range) {\n      if (this.isAppliedToRange(range)) {\n        this.undoToRange(range);\n      } else {\n        this.applyToRange(range);\n      }\n    }\n  };\n\n  wysihtml5.selection.HTMLApplier = HTMLApplier;\n})(wysihtml5, rangy); /**\n                      * Rich Text Query/Formatting Commands\n                      * \n                      * @example\n                      *    var commands = new wysihtml5.Commands(editor);\n                      */\nwysihtml5.Commands = Base.extend(\n/** @scope wysihtml5.Commands.prototype */{\n  constructor: function constructor(editor) {\n    this.editor = editor;\n    this.composer = editor.composer;\n    this.doc = this.composer.doc;\n  },\n\n  /**\n   * Check whether the browser supports the given command\n   *\n   * @param {String} command The command string which to check (eg. \"bold\", \"italic\", \"insertUnorderedList\")\n   * @example\n   *    commands.supports(\"createLink\");\n   */\n  support: function support(command) {\n    return wysihtml5.browser.supportsCommand(this.doc, command);\n  },\n\n  /**\n   * Check whether the browser supports the given command\n   *\n   * @param {String} command The command string which to execute (eg. \"bold\", \"italic\", \"insertUnorderedList\")\n   * @param {String} [value] The command value parameter, needed for some commands (\"createLink\", \"insertImage\", ...), optional for commands that don't require one (\"bold\", \"underline\", ...)\n   * @example\n   *    commands.exec(\"insertImage\", \"http://a1.twimg.com/profile_images/113868655/schrei_twitter_reasonably_small.jpg\");\n   */\n  exec: function exec(command, value) {\n    var obj = wysihtml5.commands[command],\n        args = wysihtml5.lang.array(arguments).get(),\n        method = obj && obj.exec,\n        result = null;\n\n    this.editor.fire(\"beforecommand:composer\");\n\n    if (method) {\n      args.unshift(this.composer);\n      result = method.apply(obj, args);\n    } else {\n      try {\n        // try/catch for buggy firefox\n        result = this.doc.execCommand(command, false, value);\n      } catch (e) {}\n    }\n\n    this.editor.fire(\"aftercommand:composer\");\n    return result;\n  },\n\n  /**\n   * Check whether the current command is active\n   * If the caret is within a bold text, then calling this with command \"bold\" should return true\n   *\n   * @param {String} command The command string which to check (eg. \"bold\", \"italic\", \"insertUnorderedList\")\n   * @param {String} [commandValue] The command value parameter (eg. for \"insertImage\" the image src)\n   * @return {Boolean} Whether the command is active\n   * @example\n   *    var isCurrentSelectionBold = commands.state(\"bold\");\n   */\n  state: function state(command, commandValue) {\n    var obj = wysihtml5.commands[command],\n        args = wysihtml5.lang.array(arguments).get(),\n        method = obj && obj.state;\n    if (method) {\n      args.unshift(this.composer);\n      return method.apply(obj, args);\n    } else {\n      try {\n        // try/catch for buggy firefox\n        return this.doc.queryCommandState(command);\n      } catch (e) {\n        return false;\n      }\n    }\n  },\n\n  /**\n   * Get the current command's value\n   *\n   * @param {String} command The command string which to check (eg. \"formatBlock\")\n   * @return {String} The command value\n   * @example\n   *    var currentBlockElement = commands.value(\"formatBlock\");\n   */\n  value: function value(command) {\n    var obj = wysihtml5.commands[command],\n        method = obj && obj.value;\n    if (method) {\n      return method.call(obj, this.composer, command);\n    } else {\n      try {\n        // try/catch for buggy firefox\n        return this.doc.queryCommandValue(command);\n      } catch (e) {\n        return null;\n      }\n    }\n  }\n});\n(function (wysihtml5) {\n  var undef;\n\n  wysihtml5.commands.bold = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatInline.exec(composer, command, \"b\");\n    },\n\n    state: function state(composer, command, color) {\n      // element.ownerDocument.queryCommandState(\"bold\") results:\n      // firefox: only <b>\n      // chrome:  <b>, <strong>, <h1>, <h2>, ...\n      // ie:      <b>, <strong>\n      // opera:   <b>, <strong>\n      return wysihtml5.commands.formatInline.state(composer, command, \"b\");\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);\n\n(function (wysihtml5) {\n  var undef,\n      NODE_NAME = \"A\",\n      dom = wysihtml5.dom;\n\n  function _removeFormat(composer, anchors) {\n    var length = anchors.length,\n        i = 0,\n        anchor,\n        codeElement,\n        textContent;\n    for (; i < length; i++) {\n      anchor = anchors[i];\n      codeElement = dom.getParentElement(anchor, { nodeName: \"code\" });\n      textContent = dom.getTextContent(anchor);\n\n      // if <a> contains url-like text content, rename it to <code> to prevent re-autolinking\n      // else replace <a> with its childNodes\n      if (textContent.match(dom.autoLink.URL_REG_EXP) && !codeElement) {\n        // <code> element is used to prevent later auto-linking of the content\n        codeElement = dom.renameElement(anchor, \"code\");\n      } else {\n        dom.replaceWithChildNodes(anchor);\n      }\n    }\n  }\n\n  function _format(composer, attributes) {\n    var doc = composer.doc,\n        tempClass = \"_wysihtml5-temp-\" + +new Date(),\n        tempClassRegExp = /non-matching-class/g,\n        i = 0,\n        length,\n        anchors,\n        anchor,\n        hasElementChild,\n        isEmpty,\n        elementToSetCaretAfter,\n        textContent,\n        whiteSpace,\n        j;\n    wysihtml5.commands.formatInline.exec(composer, undef, NODE_NAME, tempClass, tempClassRegExp);\n    anchors = doc.querySelectorAll(NODE_NAME + \".\" + tempClass);\n    length = anchors.length;\n    for (; i < length; i++) {\n      anchor = anchors[i];\n      anchor.removeAttribute(\"class\");\n      for (j in attributes) {\n        anchor.setAttribute(j, attributes[j]);\n      }\n    }\n\n    elementToSetCaretAfter = anchor;\n    if (length === 1) {\n      textContent = dom.getTextContent(anchor);\n      hasElementChild = !!anchor.querySelector(\"*\");\n      isEmpty = textContent === \"\" || textContent === wysihtml5.INVISIBLE_SPACE;\n      if (!hasElementChild && isEmpty) {\n        dom.setTextContent(anchor, attributes.text || anchor.href);\n        whiteSpace = doc.createTextNode(\" \");\n        composer.selection.setAfter(anchor);\n        composer.selection.insertNode(whiteSpace);\n        elementToSetCaretAfter = whiteSpace;\n      }\n    }\n    composer.selection.setAfter(elementToSetCaretAfter);\n  }\n\n  wysihtml5.commands.createLink = {\n    /**\n     * TODO: Use HTMLApplier or formatInline here\n     *\n     * Turns selection into a link\n     * If selection is already a link, it removes the link and wraps it with a <code> element\n     * The <code> element is needed to avoid auto linking\n     * \n     * @example\n     *    // either ...\n     *    wysihtml5.commands.createLink.exec(composer, \"createLink\", \"http://www.google.de\");\n     *    // ... or ...\n     *    wysihtml5.commands.createLink.exec(composer, \"createLink\", { href: \"http://www.google.de\", target: \"_blank\" });\n     */\n    exec: function exec(composer, command, value) {\n      var anchors = this.state(composer, command);\n      if (anchors) {\n        // Selection contains links\n        composer.selection.executeAndRestore(function () {\n          _removeFormat(composer, anchors);\n        });\n      } else {\n        // Create links\n        value = (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? value : { href: value };\n        _format(composer, value);\n      }\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatInline.state(composer, command, \"A\");\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5); /**\n               * document.execCommand(\"fontSize\") will create either inline styles (firefox, chrome) or use font tags\n               * which we don't want\n               * Instead we set a css class\n               */\n(function (wysihtml5) {\n  var undef,\n      REG_EXP = /wysiwyg-font-size-[a-z\\-]+/g;\n\n  wysihtml5.commands.fontSize = {\n    exec: function exec(composer, command, size) {\n      return wysihtml5.commands.formatInline.exec(composer, command, \"span\", \"wysiwyg-font-size-\" + size, REG_EXP);\n    },\n\n    state: function state(composer, command, size) {\n      return wysihtml5.commands.formatInline.state(composer, command, \"span\", \"wysiwyg-font-size-\" + size, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);\n/**\n * document.execCommand(\"foreColor\") will create either inline styles (firefox, chrome) or use font tags\n * which we don't want\n * Instead we set a css class\n */\n(function (wysihtml5) {\n  var undef,\n      REG_EXP = /wysiwyg-color-[a-z]+/g;\n\n  wysihtml5.commands.foreColor = {\n    exec: function exec(composer, command, color) {\n      return wysihtml5.commands.formatInline.exec(composer, command, \"span\", \"wysiwyg-color-\" + color, REG_EXP);\n    },\n\n    state: function state(composer, command, color) {\n      return wysihtml5.commands.formatInline.state(composer, command, \"span\", \"wysiwyg-color-\" + color, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      dom = wysihtml5.dom,\n      DEFAULT_NODE_NAME = \"DIV\",\n\n\n  // Following elements are grouped\n  // when the caret is within a H1 and the H4 is invoked, the H1 should turn into H4\n  // instead of creating a H4 within a H1 which would result in semantically invalid html\n  BLOCK_ELEMENTS_GROUP = [\"H1\", \"H2\", \"H3\", \"H4\", \"H5\", \"H6\", \"P\", \"BLOCKQUOTE\", DEFAULT_NODE_NAME];\n\n  /**\n   * Remove similiar classes (based on classRegExp)\n   * and add the desired class name\n   */\n  function _addClass(element, className, classRegExp) {\n    if (element.className) {\n      _removeClass(element, classRegExp);\n      element.className += \" \" + className;\n    } else {\n      element.className = className;\n    }\n  }\n\n  function _removeClass(element, classRegExp) {\n    element.className = element.className.replace(classRegExp, \"\");\n  }\n\n  /**\n   * Check whether given node is a text node and whether it's empty\n   */\n  function _isBlankTextNode(node) {\n    return node.nodeType === wysihtml5.TEXT_NODE && !wysihtml5.lang.string(node.data).trim();\n  }\n\n  /**\n   * Returns previous sibling node that is not a blank text node\n   */\n  function _getPreviousSiblingThatIsNotBlank(node) {\n    var previousSibling = node.previousSibling;\n    while (previousSibling && _isBlankTextNode(previousSibling)) {\n      previousSibling = previousSibling.previousSibling;\n    }\n    return previousSibling;\n  }\n\n  /**\n   * Returns next sibling node that is not a blank text node\n   */\n  function _getNextSiblingThatIsNotBlank(node) {\n    var nextSibling = node.nextSibling;\n    while (nextSibling && _isBlankTextNode(nextSibling)) {\n      nextSibling = nextSibling.nextSibling;\n    }\n    return nextSibling;\n  }\n\n  /**\n   * Adds line breaks before and after the given node if the previous and next siblings\n   * aren't already causing a visual line break (block element or <br>)\n   */\n  function _addLineBreakBeforeAndAfter(node) {\n    var doc = node.ownerDocument,\n        nextSibling = _getNextSiblingThatIsNotBlank(node),\n        previousSibling = _getPreviousSiblingThatIsNotBlank(node);\n\n    if (nextSibling && !_isLineBreakOrBlockElement(nextSibling)) {\n      node.parentNode.insertBefore(doc.createElement(\"br\"), nextSibling);\n    }\n    if (previousSibling && !_isLineBreakOrBlockElement(previousSibling)) {\n      node.parentNode.insertBefore(doc.createElement(\"br\"), node);\n    }\n  }\n\n  /**\n   * Removes line breaks before and after the given node\n   */\n  function _removeLineBreakBeforeAndAfter(node) {\n    var nextSibling = _getNextSiblingThatIsNotBlank(node),\n        previousSibling = _getPreviousSiblingThatIsNotBlank(node);\n\n    if (nextSibling && _isLineBreak(nextSibling)) {\n      nextSibling.parentNode.removeChild(nextSibling);\n    }\n    if (previousSibling && _isLineBreak(previousSibling)) {\n      previousSibling.parentNode.removeChild(previousSibling);\n    }\n  }\n\n  function _removeLastChildIfLineBreak(node) {\n    var lastChild = node.lastChild;\n    if (lastChild && _isLineBreak(lastChild)) {\n      lastChild.parentNode.removeChild(lastChild);\n    }\n  }\n\n  function _isLineBreak(node) {\n    return node.nodeName === \"BR\";\n  }\n\n  /**\n   * Checks whether the elment causes a visual line break\n   * (<br> or block elements)\n   */\n  function _isLineBreakOrBlockElement(element) {\n    if (_isLineBreak(element)) {\n      return true;\n    }\n\n    if (dom.getStyle(\"display\").from(element) === \"block\") {\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Execute native query command\n   * and if necessary modify the inserted node's className\n   */\n  function _execCommand(doc, command, nodeName, className) {\n    if (className) {\n      var eventListener = dom.observe(doc, \"DOMNodeInserted\", function (event) {\n        var target = event.target,\n            displayStyle;\n        if (target.nodeType !== wysihtml5.ELEMENT_NODE) {\n          return;\n        }\n        displayStyle = dom.getStyle(\"display\").from(target);\n        if (displayStyle.substr(0, 6) !== \"inline\") {\n          // Make sure that only block elements receive the given class\n          target.className += \" \" + className;\n        }\n      });\n    }\n    doc.execCommand(command, false, nodeName);\n    if (eventListener) {\n      eventListener.stop();\n    }\n  }\n\n  function _selectLineAndWrap(composer, element) {\n    composer.selection.selectLine();\n    composer.selection.surround(element);\n    _removeLineBreakBeforeAndAfter(element);\n    _removeLastChildIfLineBreak(element);\n    composer.selection.selectNode(element);\n  }\n\n  function _hasClasses(element) {\n    return !!wysihtml5.lang.string(element.className).trim();\n  }\n\n  wysihtml5.commands.formatBlock = {\n    exec: function exec(composer, command, nodeName, className, classRegExp) {\n      var doc = composer.doc,\n          blockElement = this.state(composer, command, nodeName, className, classRegExp),\n          selectedNode;\n\n      nodeName = typeof nodeName === \"string\" ? nodeName.toUpperCase() : nodeName;\n\n      if (blockElement) {\n        composer.selection.executeAndRestoreSimple(function () {\n          if (classRegExp) {\n            _removeClass(blockElement, classRegExp);\n          }\n          var hasClasses = _hasClasses(blockElement);\n          if (!hasClasses && blockElement.nodeName === (nodeName || DEFAULT_NODE_NAME)) {\n            // Insert a line break afterwards and beforewards when there are siblings\n            // that are not of type line break or block element\n            _addLineBreakBeforeAndAfter(blockElement);\n            dom.replaceWithChildNodes(blockElement);\n          } else if (hasClasses) {\n            // Make sure that styling is kept by renaming the element to <div> and copying over the class name\n            dom.renameElement(blockElement, DEFAULT_NODE_NAME);\n          }\n        });\n        return;\n      }\n\n      // Find similiar block element and rename it (<h2 class=\"foo\"></h2>  =>  <h1 class=\"foo\"></h1>)\n      if (nodeName === null || wysihtml5.lang.array(BLOCK_ELEMENTS_GROUP).contains(nodeName)) {\n        selectedNode = composer.selection.getSelectedNode();\n        blockElement = dom.getParentElement(selectedNode, {\n          nodeName: BLOCK_ELEMENTS_GROUP\n        });\n\n        if (blockElement) {\n          composer.selection.executeAndRestoreSimple(function () {\n            // Rename current block element to new block element and add class\n            if (nodeName) {\n              blockElement = dom.renameElement(blockElement, nodeName);\n            }\n            if (className) {\n              _addClass(blockElement, className, classRegExp);\n            }\n          });\n          return;\n        }\n      }\n\n      if (composer.commands.support(command)) {\n        _execCommand(doc, command, nodeName || DEFAULT_NODE_NAME, className);\n        return;\n      }\n\n      blockElement = doc.createElement(nodeName || DEFAULT_NODE_NAME);\n      if (className) {\n        blockElement.className = className;\n      }\n      _selectLineAndWrap(composer, blockElement);\n    },\n\n    state: function state(composer, command, nodeName, className, classRegExp) {\n      nodeName = typeof nodeName === \"string\" ? nodeName.toUpperCase() : nodeName;\n      var selectedNode = composer.selection.getSelectedNode();\n      return dom.getParentElement(selectedNode, {\n        nodeName: nodeName,\n        className: className,\n        classRegExp: classRegExp\n      });\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5); /**\n               * formatInline scenarios for tag \"B\" (| = caret, |foo| = selected text)\n               *\n               *   #1 caret in unformatted text:\n               *      abcdefg|\n               *   output:\n               *      abcdefg<b>|</b>\n               *   \n               *   #2 unformatted text selected:\n               *      abc|deg|h\n               *   output:\n               *      abc<b>|deg|</b>h\n               *   \n               *   #3 unformatted text selected across boundaries:\n               *      ab|c <span>defg|h</span>\n               *   output:\n               *      ab<b>|c </b><span><b>defg</b>|h</span>\n               *\n               *   #4 formatted text entirely selected\n               *      <b>|abc|</b>\n               *   output:\n               *      |abc|\n               *\n               *   #5 formatted text partially selected\n               *      <b>ab|c|</b>\n               *   output:\n               *      <b>ab</b>|c|\n               *\n               *   #6 formatted text selected across boundaries\n               *      <span>ab|c</span> <b>de|fgh</b>\n               *   output:\n               *      <span>ab|c</span> de|<b>fgh</b>\n               */\n(function (wysihtml5) {\n  var undef,\n\n\n  // Treat <b> as <strong> and vice versa\n  ALIAS_MAPPING = {\n    \"strong\": \"b\",\n    \"em\": \"i\",\n    \"b\": \"strong\",\n    \"i\": \"em\"\n  },\n      htmlApplier = {};\n\n  function _getTagNames(tagName) {\n    var alias = ALIAS_MAPPING[tagName];\n    return alias ? [tagName.toLowerCase(), alias.toLowerCase()] : [tagName.toLowerCase()];\n  }\n\n  function _formatClear(range) {\n    body = $(range.endContainer.ownerDocument.body);\n    $.each(body.children('font'), function () {\n      font_el = $(this);\n      font_el.replaceWith('<span>' + font_el.html() + '</span>');\n    });\n\n    $.each(body.children('span'), function () {\n      span_el = $(this);\n      reduced_dimension(span_el);\n    });\n    not_span_list = $('tbody:first > tr').not('td').toArray();\n    while (not_span_list.length) {\n      not_span_list_item = not_span_list.pop();\n      $.each(not_span_list_item.children(), function () {\n        new_el = $(this);\n        if (new_el.is('span')) {\n          reduced_dimension(new_el);\n        } else {\n          not_span_list.push(new_el);\n        }\n      });\n    }\n    $.each(body.find('span'), function () {\n      el = $(this);\n      if (!$.trim(el.text()).length) {\n        el.remove();\n      }\n    });\n    range.endContainer.ownerDocument.getSelection().empty();\n  }\n\n  // make <span class='a'>123<span class='b'>4</span>5</span> become\n  // <span class='a'>123</span> <span class='b'>4</span> <span class='a'>5</span>\n  function reduced_dimension(span) {\n    if (span.children('span').length) {\n      class_name = $.trim(span.get(0).className);\n      for (var i = 0; i < span.children('span').length; i++) {\n        child_span = $(span.children('span')[i]);\n        reduced_dimension(child_span);\n      }\n\n      console.log(span.parents('span').length);\n      html_text = span.html();\n      if (!class_name.length) {\n        class_name = 'wysiwyg-color-clear';\n      }\n      html_text = html_text.replace(/<span\\ /, '</span><span ');\n      html_text = html_text.replace(/<\\/span>(?![\\s\\S]*<\\/span>[\\s\\S]*$)/i, \"</span><span class='\" + class_name + \"'>\");\n      html_text = \"<span class='\" + class_name + \"'>\" + html_text + \"</span>\";\n      span.replaceWith(html_text);\n    } else {\n      return;\n    }\n  }\n\n  function _getApplier(tagName, className, classRegExp) {\n    var identifier = tagName + \":\" + className;\n    if (!htmlApplier[identifier]) {\n      htmlApplier[identifier] = new wysihtml5.selection.HTMLApplier(_getTagNames(tagName), className, classRegExp, true);\n    }\n    return htmlApplier[identifier];\n  }\n\n  wysihtml5.commands.formatInline = {\n    exec: function exec(composer, command, tagName, className, classRegExp) {\n      var range = composer.selection.getRange();\n      if (!range) {\n        return false;\n      }\n      _getApplier(tagName, className, classRegExp).toggleRange(range);\n      composer.selection.setSelection(range);\n      _formatClear(range);\n    },\n\n    state: function state(composer, command, tagName, className, classRegExp) {\n      var doc = composer.doc,\n          aliasTagName = ALIAS_MAPPING[tagName] || tagName,\n          range;\n\n      // Check whether the document contains a node with the desired tagName\n      if (!wysihtml5.dom.hasElementWithTagName(doc, tagName) && !wysihtml5.dom.hasElementWithTagName(doc, aliasTagName)) {\n        return false;\n      }\n\n      // Check whether the document contains a node with the desired className\n      if (className && !wysihtml5.dom.hasElementWithClassName(doc, className)) {\n        return false;\n      }\n\n      range = composer.selection.getRange();\n      if (!range) {\n        return false;\n      }\n\n      return _getApplier(tagName, className, classRegExp).isAppliedToRange(range);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n\n  wysihtml5.commands.insertHTML = {\n    exec: function exec(composer, command, html) {\n      if (composer.commands.support(command)) {\n        composer.doc.execCommand(command, false, html);\n      } else {\n        composer.selection.insertHTML(html);\n      }\n    },\n\n    state: function state() {\n      return false;\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var NODE_NAME = \"IMG\";\n\n  wysihtml5.commands.insertImage = {\n    /**\n     * Inserts an <img>\n     * If selection is already an image link, it removes it\n     * \n     * @example\n     *    // either ...\n     *    wysihtml5.commands.insertImage.exec(composer, \"insertImage\", \"http://www.google.de/logo.jpg\");\n     *    // ... or ...\n     *    wysihtml5.commands.insertImage.exec(composer, \"insertImage\", { src: \"http://www.google.de/logo.jpg\", title: \"foo\" });\n     */\n    exec: function exec(composer, command, value) {\n      value = (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? value : { src: value };\n\n      var doc = composer.doc,\n          image = this.state(composer),\n          textNode,\n          i,\n          parent;\n\n      if (image) {\n        // Image already selected, set the caret before it and delete it\n        composer.selection.setBefore(image);\n        parent = image.parentNode;\n        parent.removeChild(image);\n\n        // and it's parent <a> too if it hasn't got any other relevant child nodes\n        wysihtml5.dom.removeEmptyTextNodes(parent);\n        if (parent.nodeName === \"A\" && !parent.firstChild) {\n          composer.selection.setAfter(parent);\n          parent.parentNode.removeChild(parent);\n        }\n\n        // firefox and ie sometimes don't remove the image handles, even though the image got removed\n        wysihtml5.quirks.redraw(composer.element);\n        return;\n      }\n\n      image = doc.createElement(NODE_NAME);\n\n      for (i in value) {\n        image[i] = value[i];\n      }\n\n      composer.selection.insertNode(image);\n      if (wysihtml5.browser.hasProblemsSettingCaretAfterImg()) {\n        textNode = doc.createTextNode(wysihtml5.INVISIBLE_SPACE);\n        composer.selection.insertNode(textNode);\n        composer.selection.setAfter(textNode);\n      } else {\n        composer.selection.setAfter(image);\n      }\n    },\n\n    state: function state(composer) {\n      var doc = composer.doc,\n          selectedNode,\n          text,\n          imagesInSelection;\n\n      if (!wysihtml5.dom.hasElementWithTagName(doc, NODE_NAME)) {\n        return false;\n      }\n\n      selectedNode = composer.selection.getSelectedNode();\n      if (!selectedNode) {\n        return false;\n      }\n\n      if (selectedNode.nodeName === NODE_NAME) {\n        // This works perfectly in IE\n        return selectedNode;\n      }\n\n      if (selectedNode.nodeType !== wysihtml5.ELEMENT_NODE) {\n        return false;\n      }\n\n      text = composer.selection.getText();\n      text = wysihtml5.lang.string(text).trim();\n      if (text) {\n        return false;\n      }\n\n      imagesInSelection = composer.selection.getNodes(wysihtml5.ELEMENT_NODE, function (node) {\n        return node.nodeName === \"IMG\";\n      });\n\n      if (imagesInSelection.length !== 1) {\n        return false;\n      }\n\n      return imagesInSelection[0];\n    },\n\n    value: function value(composer) {\n      var image = this.state(composer);\n      return image && image.src;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      LINE_BREAK = \"<br>\" + (wysihtml5.browser.needsSpaceAfterLineBreak() ? \" \" : \"\");\n\n  wysihtml5.commands.insertLineBreak = {\n    exec: function exec(composer, command) {\n      if (composer.commands.support(command)) {\n        composer.doc.execCommand(command, false, null);\n        if (!wysihtml5.browser.autoScrollsToCaret()) {\n          composer.selection.scrollIntoView();\n        }\n      } else {\n        composer.commands.exec(\"insertHTML\", LINE_BREAK);\n      }\n    },\n\n    state: function state() {\n      return false;\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n  //\n  // function _removeFormat(composer, anchors) {\n  //   var length  = anchors.length,\n  //       i       = 0,\n  //       anchor,\n  //       codeElement,\n  //       textContent;\n  //   for (; i<length; i++) {\n  //     anchor      = anchors[i];\n  //     codeElement = dom.getParentElement(anchor, { nodeName: \"code\" });\n  //     textContent = dom.getTextContent(anchor);\n  //\n  //     // if <a> contains url-like text content, rename it to <code> to prevent re-autolinking\n  //     // else replace <a> with its childNodes\n  //     if (textContent.match(dom.autoLink.URL_REG_EXP) && !codeElement) {\n  //       // <code> element is used to prevent later auto-linking of the content\n  //       codeElement = dom.renameElement(anchor, \"code\");\n  //     } else {\n  //       dom.replaceWithChildNodes(anchor);\n  //     }\n  //   }\n  // }\n  //\n  //\n  wysihtml5.commands.clear = {\n    exec: function exec(composer, command) {\n      composer.doc.execCommand('removeFormat');\n      REG_EXP = /wysiwyg-color-[a-z]+/g;\n      wysihtml5.commands.formatInline.exec(composer, command, \"span\", \"\", REG_EXP);\n    }\n  };\n  wysihtml5.commands.insertOrderedList = {\n    exec: function exec(composer, command) {\n      var doc = composer.doc,\n          selectedNode = composer.selection.getSelectedNode(),\n          list = wysihtml5.dom.getParentElement(selectedNode, { nodeName: \"OL\" }),\n          otherList = wysihtml5.dom.getParentElement(selectedNode, { nodeName: \"UL\" }),\n          tempClassName = \"_wysihtml5-temp-\" + new Date().getTime(),\n          isEmpty,\n          tempElement;\n\n      if (composer.commands.support(command)) {\n        doc.execCommand(command, false, null);\n        return;\n      }\n\n      if (list) {\n        // Unwrap list\n        // <ol><li>foo</li><li>bar</li></ol>\n        // becomes:\n        // foo<br>bar<br>\n        composer.selection.executeAndRestoreSimple(function () {\n          wysihtml5.dom.resolveList(list);\n        });\n      } else if (otherList) {\n        // Turn an unordered list into an ordered list\n        // <ul><li>foo</li><li>bar</li></ul>\n        // becomes:\n        // <ol><li>foo</li><li>bar</li></ol>\n        composer.selection.executeAndRestoreSimple(function () {\n          wysihtml5.dom.renameElement(otherList, \"ol\");\n        });\n      } else {\n        // Create list\n        composer.commands.exec(\"formatBlock\", \"div\", tempClassName);\n        tempElement = doc.querySelector(\".\" + tempClassName);\n        isEmpty = tempElement.innerHTML === \"\" || tempElement.innerHTML === wysihtml5.INVISIBLE_SPACE;\n        composer.selection.executeAndRestoreSimple(function () {\n          list = wysihtml5.dom.convertToList(tempElement, \"ol\");\n        });\n        if (isEmpty) {\n          composer.selection.selectNode(list.querySelector(\"li\"));\n        }\n      }\n    },\n\n    state: function state(composer) {\n      var selectedNode = composer.selection.getSelectedNode();\n      return wysihtml5.dom.getParentElement(selectedNode, { nodeName: \"OL\" });\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n\n  wysihtml5.commands.insertUnorderedList = {\n    exec: function exec(composer, command) {\n      var doc = composer.doc,\n          selectedNode = composer.selection.getSelectedNode(),\n          list = wysihtml5.dom.getParentElement(selectedNode, { nodeName: \"UL\" }),\n          otherList = wysihtml5.dom.getParentElement(selectedNode, { nodeName: \"OL\" }),\n          tempClassName = \"_wysihtml5-temp-\" + new Date().getTime(),\n          isEmpty,\n          tempElement;\n\n      if (composer.commands.support(command)) {\n        doc.execCommand(command, false, null);\n        return;\n      }\n\n      if (list) {\n        // Unwrap list\n        // <ul><li>foo</li><li>bar</li></ul>\n        // becomes:\n        // foo<br>bar<br>\n        composer.selection.executeAndRestoreSimple(function () {\n          wysihtml5.dom.resolveList(list);\n        });\n      } else if (otherList) {\n        // Turn an ordered list into an unordered list\n        // <ol><li>foo</li><li>bar</li></ol>\n        // becomes:\n        // <ul><li>foo</li><li>bar</li></ul>\n        composer.selection.executeAndRestoreSimple(function () {\n          wysihtml5.dom.renameElement(otherList, \"ul\");\n        });\n      } else {\n        // Create list\n        composer.commands.exec(\"formatBlock\", \"div\", tempClassName);\n        tempElement = doc.querySelector(\".\" + tempClassName);\n        isEmpty = tempElement.innerHTML === \"\" || tempElement.innerHTML === wysihtml5.INVISIBLE_SPACE;\n        composer.selection.executeAndRestoreSimple(function () {\n          list = wysihtml5.dom.convertToList(tempElement, \"ul\");\n        });\n        if (isEmpty) {\n          composer.selection.selectNode(list.querySelector(\"li\"));\n        }\n      }\n    },\n\n    state: function state(composer) {\n      var selectedNode = composer.selection.getSelectedNode();\n      return wysihtml5.dom.getParentElement(selectedNode, { nodeName: \"UL\" });\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n\n  wysihtml5.commands.italic = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatInline.exec(composer, command, \"i\");\n    },\n\n    state: function state(composer, command, color) {\n      // element.ownerDocument.queryCommandState(\"italic\") results:\n      // firefox: only <i>\n      // chrome:  <i>, <em>, <blockquote>, ...\n      // ie:      <i>, <em>\n      // opera:   only <i>\n      return wysihtml5.commands.formatInline.state(composer, command, \"i\");\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      CLASS_NAME = \"wysiwyg-text-align-center\",\n      REG_EXP = /wysiwyg-text-align-[a-z]+/g;\n\n  wysihtml5.commands.justifyCenter = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatBlock.exec(composer, \"formatBlock\", null, CLASS_NAME, REG_EXP);\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatBlock.state(composer, \"formatBlock\", null, CLASS_NAME, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      CLASS_NAME = \"wysiwyg-text-align-left\",\n      REG_EXP = /wysiwyg-text-align-[a-z]+/g;\n\n  wysihtml5.commands.justifyLeft = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatBlock.exec(composer, \"formatBlock\", null, CLASS_NAME, REG_EXP);\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatBlock.state(composer, \"formatBlock\", null, CLASS_NAME, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef,\n      CLASS_NAME = \"wysiwyg-text-align-right\",\n      REG_EXP = /wysiwyg-text-align-[a-z]+/g;\n\n  wysihtml5.commands.justifyRight = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatBlock.exec(composer, \"formatBlock\", null, CLASS_NAME, REG_EXP);\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatBlock.state(composer, \"formatBlock\", null, CLASS_NAME, REG_EXP);\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5);(function (wysihtml5) {\n  var undef;\n  wysihtml5.commands.underline = {\n    exec: function exec(composer, command) {\n      return wysihtml5.commands.formatInline.exec(composer, command, \"u\");\n    },\n\n    state: function state(composer, command) {\n      return wysihtml5.commands.formatInline.state(composer, command, \"u\");\n    },\n\n    value: function value() {\n      return undef;\n    }\n  };\n})(wysihtml5); /**\n               * Undo Manager for wysihtml5\n               * slightly inspired by http://rniwa.com/editing/undomanager.html#the-undomanager-interface\n               */\n(function (wysihtml5) {\n  var Z_KEY = 90,\n      Y_KEY = 89,\n      BACKSPACE_KEY = 8,\n      DELETE_KEY = 46,\n      MAX_HISTORY_ENTRIES = 40,\n      UNDO_HTML = '<span id=\"_wysihtml5-undo\" class=\"_wysihtml5-temp\">' + wysihtml5.INVISIBLE_SPACE + '</span>',\n      REDO_HTML = '<span id=\"_wysihtml5-redo\" class=\"_wysihtml5-temp\">' + wysihtml5.INVISIBLE_SPACE + '</span>',\n      dom = wysihtml5.dom;\n\n  function cleanTempElements(doc) {\n    var tempElement;\n    while (tempElement = doc.querySelector(\"._wysihtml5-temp\")) {\n      tempElement.parentNode.removeChild(tempElement);\n    }\n  }\n\n  wysihtml5.UndoManager = wysihtml5.lang.Dispatcher.extend(\n  /** @scope wysihtml5.UndoManager.prototype */{\n    constructor: function constructor(editor) {\n      this.editor = editor;\n      this.composer = editor.composer;\n      this.element = this.composer.element;\n      this.history = [this.composer.getValue()];\n      this.position = 1;\n\n      // Undo manager currently only supported in browsers who have the insertHTML command (not IE)\n      if (this.composer.commands.support(\"insertHTML\")) {\n        this._observe();\n      }\n    },\n\n    _observe: function _observe() {\n      var that = this,\n          doc = this.composer.sandbox.getDocument(),\n          lastKey;\n\n      // Catch CTRL+Z and CTRL+Y\n      dom.observe(this.element, \"keydown\", function (event) {\n        if (event.altKey || !event.ctrlKey && !event.metaKey) {\n          return;\n        }\n\n        var keyCode = event.keyCode,\n            isUndo = keyCode === Z_KEY && !event.shiftKey,\n            isRedo = keyCode === Z_KEY && event.shiftKey || keyCode === Y_KEY;\n\n        if (isUndo) {\n          that.undo();\n          event.preventDefault();\n        } else if (isRedo) {\n          that.redo();\n          event.preventDefault();\n        }\n      });\n\n      // Catch delete and backspace\n      dom.observe(this.element, \"keydown\", function (event) {\n        var keyCode = event.keyCode;\n        if (keyCode === lastKey) {\n          return;\n        }\n\n        lastKey = keyCode;\n\n        if (keyCode === BACKSPACE_KEY || keyCode === DELETE_KEY) {\n          that.transact();\n        }\n      });\n\n      // Now this is very hacky:\n      // These days browsers don't offer a undo/redo event which we could hook into\n      // to be notified when the user hits undo/redo in the contextmenu.\n      // Therefore we simply insert two elements as soon as the contextmenu gets opened.\n      // The last element being inserted will be immediately be removed again by a exexCommand(\"undo\")\n      //  => When the second element appears in the dom tree then we know the user clicked \"redo\" in the context menu\n      //  => When the first element disappears from the dom tree then we know the user clicked \"undo\" in the context menu\n      if (wysihtml5.browser.hasUndoInContextMenu()) {\n        var interval,\n            observed,\n            cleanUp = function cleanUp() {\n          cleanTempElements(doc);\n          clearInterval(interval);\n        };\n\n        dom.observe(this.element, \"contextmenu\", function () {\n          cleanUp();\n          that.composer.selection.executeAndRestoreSimple(function () {\n            if (that.element.lastChild) {\n              that.composer.selection.setAfter(that.element.lastChild);\n            }\n\n            // enable undo button in context menu\n            doc.execCommand(\"insertHTML\", false, UNDO_HTML);\n            // enable redo button in context menu\n            doc.execCommand(\"insertHTML\", false, REDO_HTML);\n            doc.execCommand(\"undo\", false, null);\n          });\n\n          interval = setInterval(function () {\n            if (doc.getElementById(\"_wysihtml5-redo\")) {\n              cleanUp();\n              that.redo();\n            }\n          }, 400);\n\n          if (!observed) {\n            observed = true;\n            dom.observe(document, \"mousedown\", cleanUp);\n            dom.observe(doc, [\"mousedown\", \"paste\", \"cut\", \"copy\"], cleanUp);\n          }\n        });\n      }\n\n      this.editor.observe(\"newword:composer\", function () {\n        that.transact();\n      }).observe(\"beforecommand:composer\", function () {\n        that.transact();\n      });\n    },\n\n    transact: function transact() {\n      var previousHtml = this.history[this.position - 1],\n          currentHtml = this.composer.getValue();\n\n      if (currentHtml == previousHtml) {\n        return;\n      }\n\n      var length = this.history.length = this.position;\n      if (length > MAX_HISTORY_ENTRIES) {\n        this.history.shift();\n        this.position--;\n      }\n\n      this.position++;\n      this.history.push(currentHtml);\n    },\n\n    undo: function undo() {\n      this.transact();\n\n      if (this.position <= 1) {\n        return;\n      }\n\n      this.set(this.history[--this.position - 1]);\n      this.editor.fire(\"undo:composer\");\n    },\n\n    redo: function redo() {\n      if (this.position >= this.history.length) {\n        return;\n      }\n\n      this.set(this.history[++this.position - 1]);\n      this.editor.fire(\"redo:composer\");\n    },\n\n    set: function set(html) {\n      this.composer.setValue(html);\n      this.editor.focus(true);\n    }\n  });\n})(wysihtml5);\n/**\n * TODO: the following methods still need unit test coverage\n */\nwysihtml5.views.View = Base.extend(\n/** @scope wysihtml5.views.View.prototype */{\n  constructor: function constructor(parent, textareaElement, config) {\n    this.parent = parent;\n    this.element = textareaElement;\n    this.config = config;\n\n    this._observeViewChange();\n  },\n\n  _observeViewChange: function _observeViewChange() {\n    var that = this;\n    this.parent.observe(\"beforeload\", function () {\n      that.parent.observe(\"change_view\", function (view) {\n        if (view === that.name) {\n          that.parent.currentView = that;\n          that.show();\n          // Using tiny delay here to make sure that the placeholder is set before focusing\n          setTimeout(function () {\n            that.focus();\n          }, 0);\n        } else {\n          that.hide();\n        }\n      });\n    });\n  },\n\n  focus: function focus() {\n    if (this.element.ownerDocument.querySelector(\":focus\") === this.element) {\n      return;\n    }\n\n    try {\n      this.element.focus();\n    } catch (e) {}\n  },\n\n  hide: function hide() {\n    this.element.style.display = \"none\";\n  },\n\n  show: function show() {\n    this.element.style.display = \"\";\n  },\n\n  disable: function disable() {\n    this.element.setAttribute(\"disabled\", \"disabled\");\n  },\n\n  enable: function enable() {\n    this.element.removeAttribute(\"disabled\");\n  }\n});(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      browser = wysihtml5.browser;\n\n  wysihtml5.views.Composer = wysihtml5.views.View.extend(\n  /** @scope wysihtml5.views.Composer.prototype */{\n    name: \"composer\",\n\n    // Needed for firefox in order to display a proper caret in an empty contentEditable\n    CARET_HACK: \"<br>\",\n\n    constructor: function constructor(parent, textareaElement, config) {\n      this.base(parent, textareaElement, config);\n      this.textarea = this.parent.textarea;\n      this._initSandbox();\n    },\n\n    clear: function clear() {\n      this.element.innerHTML = browser.displaysCaretInEmptyContentEditableCorrectly() ? \"\" : this.CARET_HACK;\n    },\n\n    getValue: function getValue(parse) {\n      var value = this.isEmpty() ? \"\" : wysihtml5.quirks.getCorrectInnerHTML(this.element);\n\n      if (parse) {\n        value = this.parent.parse(value);\n      }\n\n      // Replace all \"zero width no breaking space\" chars\n      // which are used as hacks to enable some functionalities\n      // Also remove all CARET hacks that somehow got left\n      value = wysihtml5.lang.string(value).replace(wysihtml5.INVISIBLE_SPACE).by(\"\");\n\n      return value;\n    },\n\n    setValue: function setValue(html, parse) {\n      if (parse) {\n        html = this.parent.parse(html);\n      }\n      this.element.innerHTML = html;\n    },\n\n    show: function show() {\n      this.iframe.style.display = this._displayStyle || \"\";\n\n      // Firefox needs this, otherwise contentEditable becomes uneditable\n      this.disable();\n      this.enable();\n    },\n\n    hide: function hide() {\n      this._displayStyle = dom.getStyle(\"display\").from(this.iframe);\n      if (this._displayStyle === \"none\") {\n        this._displayStyle = null;\n      }\n      this.iframe.style.display = \"none\";\n    },\n\n    disable: function disable() {\n      this.element.removeAttribute(\"contentEditable\");\n      this.base();\n    },\n\n    enable: function enable() {\n      this.element.setAttribute(\"contentEditable\", \"true\");\n      this.base();\n    },\n\n    focus: function focus(setToEnd) {\n      // IE 8 fires the focus event after .focus()\n      // This is needed by our simulate_placeholder.js to work\n      // therefore we clear it ourselves this time\n      if (wysihtml5.browser.doesAsyncFocus() && this.hasPlaceholderSet()) {\n        this.clear();\n      }\n\n      this.base();\n\n      var lastChild = this.element.lastChild;\n      if (setToEnd && lastChild) {\n        if (lastChild.nodeName === \"BR\") {\n          this.selection.setBefore(this.element.lastChild);\n        } else {\n          this.selection.setAfter(this.element.lastChild);\n        }\n      }\n    },\n\n    getTextContent: function getTextContent() {\n      return dom.getTextContent(this.element);\n    },\n\n    hasPlaceholderSet: function hasPlaceholderSet() {\n      return this.getTextContent() == this.textarea.element.getAttribute(\"placeholder\");\n    },\n\n    isEmpty: function isEmpty() {\n      var innerHTML = this.element.innerHTML,\n          elementsWithVisualValue = \"blockquote, ul, ol, img, embed, object, table, iframe, svg, video, audio, button, input, select, textarea\";\n      return innerHTML === \"\" || innerHTML === this.CARET_HACK || this.hasPlaceholderSet() || this.getTextContent() === \"\" && !this.element.querySelector(elementsWithVisualValue);\n    },\n\n    _initSandbox: function _initSandbox() {\n      var that = this;\n\n      this.sandbox = new dom.Sandbox(function () {\n        that._create();\n      }, {\n        stylesheets: this.config.stylesheets\n      });\n      this.iframe = this.sandbox.getIframe();\n\n      // Create hidden field which tells the server after submit, that the user used an wysiwyg editor\n      var hiddenField = document.createElement(\"input\");\n      hiddenField.type = \"hidden\";\n      hiddenField.name = \"_wysihtml5_mode\";\n      hiddenField.value = 1;\n\n      // Store reference to current wysihtml5 instance on the textarea element\n      var textareaElement = this.textarea.element;\n      dom.insert(this.iframe).after(textareaElement);\n      dom.insert(hiddenField).after(textareaElement);\n    },\n\n    _create: function _create() {\n      var that = this;\n\n      this.doc = this.sandbox.getDocument();\n      this.element = this.doc.body;\n      this.textarea = this.parent.textarea;\n      this.element.innerHTML = this.textarea.getValue(true);\n      this.enable();\n\n      // Make sure our selection handler is ready\n      this.selection = new wysihtml5.Selection(this.parent);\n\n      // Make sure commands dispatcher is ready\n      this.commands = new wysihtml5.Commands(this.parent);\n\n      dom.copyAttributes([\"className\", \"spellcheck\", \"title\", \"lang\", \"dir\", \"accessKey\"]).from(this.textarea.element).to(this.element);\n\n      dom.addClass(this.element, this.config.composerClassName);\n\n      // Make the editor look like the original textarea, by syncing styles\n      if (this.config.style) {\n        this.style();\n      }\n\n      this.observe();\n\n      var name = this.config.name;\n      if (name) {\n        dom.addClass(this.element, name);\n        dom.addClass(this.iframe, name);\n      }\n\n      // Simulate html5 placeholder attribute on contentEditable element\n      var placeholderText = typeof this.config.placeholder === \"string\" ? this.config.placeholder : this.textarea.element.getAttribute(\"placeholder\");\n      if (placeholderText) {\n        dom.simulatePlaceholder(this.parent, this, placeholderText);\n      }\n\n      // Make sure that the browser avoids using inline styles whenever possible\n      this.commands.exec(\"styleWithCSS\", false);\n\n      this._initAutoLinking();\n      this._initObjectResizing();\n      this._initUndoManager();\n\n      // Simulate html5 autofocus on contentEditable element\n      if (this.textarea.element.hasAttribute(\"autofocus\") || document.querySelector(\":focus\") == this.textarea.element) {\n        setTimeout(function () {\n          that.focus();\n        }, 100);\n      }\n\n      wysihtml5.quirks.insertLineBreakOnReturn(this);\n\n      // IE sometimes leaves a single paragraph, which can't be removed by the user\n      if (!browser.clearsContentEditableCorrectly()) {\n        wysihtml5.quirks.ensureProperClearing(this);\n      }\n\n      if (!browser.clearsListsInContentEditableCorrectly()) {\n        wysihtml5.quirks.ensureProperClearingOfLists(this);\n      }\n\n      // Set up a sync that makes sure that textarea and editor have the same content\n      if (this.initSync && this.config.sync) {\n        this.initSync();\n      }\n\n      // Okay hide the textarea, we are ready to go\n      this.textarea.hide();\n\n      // Fire global (before-)load event\n      this.parent.fire(\"beforeload\").fire(\"load\");\n    },\n\n    _initAutoLinking: function _initAutoLinking() {\n      var that = this,\n          supportsDisablingOfAutoLinking = browser.canDisableAutoLinking(),\n          supportsAutoLinking = browser.doesAutoLinkingInContentEditable();\n      if (supportsDisablingOfAutoLinking) {\n        this.commands.exec(\"autoUrlDetect\", false);\n      }\n\n      if (!this.config.autoLink) {\n        return;\n      }\n\n      // Only do the auto linking by ourselves when the browser doesn't support auto linking\n      // OR when he supports auto linking but we were able to turn it off (IE9+)\n      if (!supportsAutoLinking || supportsAutoLinking && supportsDisablingOfAutoLinking) {\n        this.parent.observe(\"newword:composer\", function () {\n          that.selection.executeAndRestore(function (startContainer, endContainer) {\n            dom.autoLink(endContainer.parentNode);\n          });\n        });\n      }\n\n      // Assuming we have the following:\n      //  <a href=\"http://www.google.de\">http://www.google.de</a>\n      // If a user now changes the url in the innerHTML we want to make sure that\n      // it's synchronized with the href attribute (as long as the innerHTML is still a url)\n      var // Use a live NodeList to check whether there are any links in the document\n      links = this.sandbox.getDocument().getElementsByTagName(\"a\"),\n\n\n      // The autoLink helper method reveals a reg exp to detect correct urls\n      urlRegExp = dom.autoLink.URL_REG_EXP,\n          getTextContent = function getTextContent(element) {\n        var textContent = wysihtml5.lang.string(dom.getTextContent(element)).trim();\n        if (textContent.substr(0, 4) === \"www.\") {\n          textContent = \"http://\" + textContent;\n        }\n        return textContent;\n      };\n\n      dom.observe(this.element, \"keydown\", function (event) {\n        if (!links.length) {\n          return;\n        }\n\n        var selectedNode = that.selection.getSelectedNode(event.target.ownerDocument),\n            link = dom.getParentElement(selectedNode, { nodeName: \"A\" }, 4),\n            textContent;\n\n        if (!link) {\n          return;\n        }\n\n        textContent = getTextContent(link);\n        // keydown is fired before the actual content is changed\n        // therefore we set a timeout to change the href\n        setTimeout(function () {\n          var newTextContent = getTextContent(link);\n          if (newTextContent === textContent) {\n            return;\n          }\n\n          // Only set href when new href looks like a valid url\n          if (newTextContent.match(urlRegExp)) {\n            link.setAttribute(\"href\", newTextContent);\n          }\n        }, 0);\n      });\n    },\n\n    _initObjectResizing: function _initObjectResizing() {\n      var properties = [\"width\", \"height\"],\n          propertiesLength = properties.length,\n          element = this.element;\n\n      this.commands.exec(\"enableObjectResizing\", this.config.allowObjectResizing);\n\n      if (this.config.allowObjectResizing) {\n        // IE sets inline styles after resizing objects\n        // The following lines make sure that the width/height css properties\n        // are copied over to the width/height attributes\n        if (browser.supportsEvent(\"resizeend\")) {\n          dom.observe(element, \"resizeend\", function (event) {\n            var target = event.target || event.srcElement,\n                style = target.style,\n                i = 0,\n                property;\n            for (; i < propertiesLength; i++) {\n              property = properties[i];\n              if (style[property]) {\n                target.setAttribute(property, parseInt(style[property], 10));\n                style[property] = \"\";\n              }\n            }\n            // After resizing IE sometimes forgets to remove the old resize handles\n            wysihtml5.quirks.redraw(element);\n          });\n        }\n      } else {\n        if (browser.supportsEvent(\"resizestart\")) {\n          dom.observe(element, \"resizestart\", function (event) {\n            event.preventDefault();\n          });\n        }\n      }\n    },\n\n    _initUndoManager: function _initUndoManager() {\n      new wysihtml5.UndoManager(this.parent);\n    }\n  });\n})(wysihtml5);(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      doc = document,\n      win = window,\n      HOST_TEMPLATE = doc.createElement(\"div\"),\n\n\n  /**\n   * Styles to copy from textarea to the composer element\n   */\n  TEXT_FORMATTING = [\"background-color\", \"color\", \"cursor\", \"font-family\", \"font-size\", \"font-style\", \"font-variant\", \"font-weight\", \"line-height\", \"letter-spacing\", \"text-align\", \"text-decoration\", \"text-indent\", \"text-rendering\", \"word-break\", \"word-wrap\", \"word-spacing\"],\n\n\n  /**\n   * Styles to copy from textarea to the iframe\n   */\n  BOX_FORMATTING = [\"background-color\", \"border-collapse\", \"border-bottom-color\", \"border-bottom-style\", \"border-bottom-width\", \"border-left-color\", \"border-left-style\", \"border-left-width\", \"border-right-color\", \"border-right-style\", \"border-right-width\", \"border-top-color\", \"border-top-style\", \"border-top-width\", \"clear\", \"display\", \"float\", \"margin-bottom\", \"margin-left\", \"margin-right\", \"margin-top\", \"outline-color\", \"outline-offset\", \"outline-width\", \"outline-style\", \"padding-left\", \"padding-right\", \"padding-top\", \"padding-bottom\", \"position\", \"top\", \"left\", \"right\", \"bottom\", \"z-index\", \"vertical-align\", \"text-align\", \"-webkit-box-sizing\", \"-moz-box-sizing\", \"-ms-box-sizing\", \"box-sizing\", \"-webkit-box-shadow\", \"-moz-box-shadow\", \"-ms-box-shadow\", \"box-shadow\", \"-webkit-border-top-right-radius\", \"-moz-border-radius-topright\", \"border-top-right-radius\", \"-webkit-border-bottom-right-radius\", \"-moz-border-radius-bottomright\", \"border-bottom-right-radius\", \"-webkit-border-bottom-left-radius\", \"-moz-border-radius-bottomleft\", \"border-bottom-left-radius\", \"-webkit-border-top-left-radius\", \"-moz-border-radius-topleft\", \"border-top-left-radius\", \"width\", \"height\"],\n\n\n  /**\n   * Styles to sync while the window gets resized\n   */\n  RESIZE_STYLE = [\"width\", \"height\", \"top\", \"left\", \"right\", \"bottom\"],\n      ADDITIONAL_CSS_RULES = [\"html             { height: 100%; }\", \"body             { min-height: 100%; padding: 0; margin: 0; margin-top: -1px; padding-top: 1px; white-space: pre-wrap; }\", \"._wysihtml5-temp { display: none; }\", wysihtml5.browser.isGecko ? \"body.placeholder { color: graytext !important; }\" : \"body.placeholder { color: #a9a9a9 !important; }\", \"body[disabled]   { background-color: #eee !important; color: #999 !important; cursor: default !important; }\",\n  // Ensure that user see's broken images and can delete them\n  \"img:-moz-broken  { -moz-force-broken-image-icon: 1; height: 24px; width: 24px; }\"];\n\n  /**\n   * With \"setActive\" IE offers a smart way of focusing elements without scrolling them into view:\n   * http://msdn.microsoft.com/en-us/library/ms536738(v=vs.85).aspx\n   *\n   * Other browsers need a more hacky way: (pssst don't tell my mama)\n   * In order to prevent the element being scrolled into view when focusing it, we simply\n   * move it out of the scrollable area, focus it, and reset it's position\n   */\n  var focusWithoutScrolling = function focusWithoutScrolling(element) {\n    if (element.setActive) {\n      // Following line could cause a js error when the textarea is invisible\n      // See https://github.com/xing/wysihtml5/issues/9\n      try {\n        element.setActive();\n      } catch (e) {}\n    } else {\n      var elementStyle = element.style,\n          originalScrollTop = doc.documentElement.scrollTop || doc.body.scrollTop,\n          originalScrollLeft = doc.documentElement.scrollLeft || doc.body.scrollLeft,\n          originalStyles = {\n        position: elementStyle.position,\n        top: elementStyle.top,\n        left: elementStyle.left,\n        WebkitUserSelect: elementStyle.WebkitUserSelect\n      };\n\n      dom.setStyles({\n        position: \"absolute\",\n        top: \"-99999px\",\n        left: \"-99999px\",\n        // Don't ask why but temporarily setting -webkit-user-select to none makes the whole thing performing smoother\n        WebkitUserSelect: \"none\"\n      }).on(element);\n\n      element.focus();\n\n      dom.setStyles(originalStyles).on(element);\n\n      if (win.scrollTo) {\n        // Some browser extensions unset this method to prevent annoyances\n        // \"Better PopUp Blocker\" for Chrome http://code.google.com/p/betterpopupblocker/source/browse/trunk/blockStart.js#100\n        // Issue: http://code.google.com/p/betterpopupblocker/issues/detail?id=1\n        win.scrollTo(originalScrollLeft, originalScrollTop);\n      }\n    }\n  };\n\n  wysihtml5.views.Composer.prototype.style = function () {\n    var that = this,\n        originalActiveElement = doc.querySelector(\":focus\"),\n        textareaElement = this.textarea.element,\n        hasPlaceholder = textareaElement.hasAttribute(\"placeholder\"),\n        originalPlaceholder = hasPlaceholder && textareaElement.getAttribute(\"placeholder\");\n    this.focusStylesHost = this.focusStylesHost || HOST_TEMPLATE.cloneNode(false);\n    this.blurStylesHost = this.blurStylesHost || HOST_TEMPLATE.cloneNode(false);\n\n    // Remove placeholder before copying (as the placeholder has an affect on the computed style)\n    if (hasPlaceholder) {\n      textareaElement.removeAttribute(\"placeholder\");\n    }\n\n    if (textareaElement === originalActiveElement) {\n      textareaElement.blur();\n    }\n\n    // --------- iframe styles (has to be set before editor styles, otherwise IE9 sets wrong fontFamily on blurStylesHost) ---------\n    dom.copyStyles(BOX_FORMATTING).from(textareaElement).to(this.iframe).andTo(this.blurStylesHost);\n\n    // --------- editor styles ---------\n    dom.copyStyles(TEXT_FORMATTING).from(textareaElement).to(this.element).andTo(this.blurStylesHost);\n\n    // --------- apply standard rules ---------\n    dom.insertCSS(ADDITIONAL_CSS_RULES).into(this.element.ownerDocument);\n\n    // --------- :focus styles ---------\n    focusWithoutScrolling(textareaElement);\n    dom.copyStyles(BOX_FORMATTING).from(textareaElement).to(this.focusStylesHost);\n    dom.copyStyles(TEXT_FORMATTING).from(textareaElement).to(this.focusStylesHost);\n\n    // Make sure that we don't change the display style of the iframe when copying styles oblur/onfocus\n    // this is needed for when the change_view event is fired where the iframe is hidden and then\n    // the blur event fires and re-displays it\n    var boxFormattingStyles = wysihtml5.lang.array(BOX_FORMATTING).without([\"display\"]);\n\n    // --------- restore focus ---------\n    if (originalActiveElement) {\n      originalActiveElement.focus();\n    } else {\n      textareaElement.blur();\n    }\n\n    // --------- restore placeholder ---------\n    if (hasPlaceholder) {\n      textareaElement.setAttribute(\"placeholder\", originalPlaceholder);\n    }\n\n    // When copying styles, we only get the computed style which is never returned in percent unit\n    // Therefore we've to recalculate style onresize\n    if (!wysihtml5.browser.hasCurrentStyleProperty()) {\n      var winObserver = dom.observe(win, \"resize\", function () {\n        // Remove event listener if composer doesn't exist anymore\n        if (!dom.contains(document.documentElement, that.iframe)) {\n          winObserver.stop();\n          return;\n        }\n        var originalTextareaDisplayStyle = dom.getStyle(\"display\").from(textareaElement),\n            originalComposerDisplayStyle = dom.getStyle(\"display\").from(that.iframe);\n        textareaElement.style.display = \"\";\n        that.iframe.style.display = \"none\";\n        dom.copyStyles(RESIZE_STYLE).from(textareaElement).to(that.iframe).andTo(that.focusStylesHost).andTo(that.blurStylesHost);\n        that.iframe.style.display = originalComposerDisplayStyle;\n        textareaElement.style.display = originalTextareaDisplayStyle;\n      });\n    }\n\n    // --------- Sync focus/blur styles ---------\n    this.parent.observe(\"focus:composer\", function () {\n      dom.copyStyles(boxFormattingStyles).from(that.focusStylesHost).to(that.iframe);\n      dom.copyStyles(TEXT_FORMATTING).from(that.focusStylesHost).to(that.element);\n    });\n\n    this.parent.observe(\"blur:composer\", function () {\n      dom.copyStyles(boxFormattingStyles).from(that.blurStylesHost).to(that.iframe);\n      dom.copyStyles(TEXT_FORMATTING).from(that.blurStylesHost).to(that.element);\n    });\n\n    return this;\n  };\n})(wysihtml5); /**\n               * Taking care of events\n               *  - Simulating 'change' event on contentEditable element\n               *  - Handling drag & drop logic\n               *  - Catch paste events\n               *  - Dispatch proprietary newword:composer event\n               *  - Keyboard shortcuts\n               */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      browser = wysihtml5.browser,\n\n\n  /**\n   * Map keyCodes to query commands\n   */\n  shortcuts = {\n    \"66\": \"bold\", // B\n    \"73\": \"italic\", // I\n    \"85\": \"underline\" // U\n  };\n\n  wysihtml5.views.Composer.prototype.observe = function () {\n    var that = this,\n        state = this.getValue(),\n        iframe = this.sandbox.getIframe(),\n        element = this.element,\n        focusBlurElement = browser.supportsEventsInIframeCorrectly() ? element : this.sandbox.getWindow(),\n\n\n    // Firefox < 3.5 doesn't support the drop event, instead it supports a so called \"dragdrop\" event which behaves almost the same\n    pasteEvents = browser.supportsEvent(\"drop\") ? [\"drop\", \"paste\"] : [\"dragdrop\", \"paste\"];\n\n    // --------- destroy:composer event ---------\n    dom.observe(iframe, \"DOMNodeRemoved\", function () {\n      clearInterval(domNodeRemovedInterval);\n      that.parent.fire(\"destroy:composer\");\n    });\n\n    // DOMNodeRemoved event is not supported in IE 8\n    var domNodeRemovedInterval = setInterval(function () {\n      if (!dom.contains(document.documentElement, iframe)) {\n        clearInterval(domNodeRemovedInterval);\n        that.parent.fire(\"destroy:composer\");\n      }\n    }, 250);\n\n    // --------- Focus & blur logic ---------\n    dom.observe(focusBlurElement, \"focus\", function () {\n      that.parent.fire(\"focus\").fire(\"focus:composer\");\n\n      // Delay storing of state until all focus handler are fired\n      // especially the one which resets the placeholder\n      setTimeout(function () {\n        state = that.getValue();\n      }, 0);\n    });\n\n    dom.observe(focusBlurElement, \"blur\", function () {\n      if (state !== that.getValue()) {\n        that.parent.fire(\"change\").fire(\"change:composer\");\n      }\n      that.parent.fire(\"blur\").fire(\"blur:composer\");\n    });\n\n    if (wysihtml5.browser.isIos()) {\n      // When on iPad/iPhone/IPod after clicking outside of editor, the editor loses focus\n      // but the UI still acts as if the editor has focus (blinking caret and onscreen keyboard visible)\n      // We prevent that by focusing a temporary input element which immediately loses focus\n      dom.observe(element, \"blur\", function () {\n        var input = element.ownerDocument.createElement(\"input\"),\n            originalScrollTop = document.documentElement.scrollTop || document.body.scrollTop,\n            originalScrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;\n        try {\n          that.selection.insertNode(input);\n        } catch (e) {\n          element.appendChild(input);\n        }\n        input.focus();\n        input.parentNode.removeChild(input);\n\n        window.scrollTo(originalScrollLeft, originalScrollTop);\n      });\n    }\n\n    // --------- Drag & Drop logic ---------\n    dom.observe(element, \"dragenter\", function () {\n      that.parent.fire(\"unset_placeholder\");\n    });\n\n    if (browser.firesOnDropOnlyWhenOnDragOverIsCancelled()) {\n      dom.observe(element, [\"dragover\", \"dragenter\"], function (event) {\n        event.preventDefault();\n      });\n    }\n\n    dom.observe(element, pasteEvents, function (event) {\n      var dataTransfer = event.dataTransfer,\n          data;\n\n      if (dataTransfer && browser.supportsDataTransfer()) {\n        data = dataTransfer.getData(\"text/html\") || dataTransfer.getData(\"text/plain\");\n      }\n      if (data) {\n        element.focus();\n        that.commands.exec(\"insertHTML\", data);\n        that.parent.fire(\"paste\").fire(\"paste:composer\");\n        event.stopPropagation();\n        event.preventDefault();\n      } else {\n        setTimeout(function () {\n          that.parent.fire(\"paste\").fire(\"paste:composer\");\n        }, 0);\n      }\n    });\n\n    // --------- neword event ------+---\n    dom.observe(element, \"keyup\", function (event) {\n      var keyCode = event.keyCode;\n      if (keyCode === wysihtml5.ENTER_KEY) {\n        that.parent.fire(\"newword:composer\");\n      }\n    });\n\n    this.parent.observe(\"paste:composer\", function () {\n      setTimeout(function () {\n        that.parent.fire(\"newword:composer\");\n      }, 0);\n    });\n\n    // --------- Make sure that images are selected when clicking on them ---------\n    if (!browser.canSelectImagesInContentEditable()) {\n      dom.observe(element, \"mousedown\", function (event) {\n        var target = event.target;\n        if (target.nodeName === \"IMG\") {\n          that.selection.selectNode(target);\n          event.preventDefault();\n        }\n      });\n    }\n\n    // --------- Shortcut logic ---------\n    dom.observe(element, \"keydown\", function (event) {\n      var keyCode = event.keyCode,\n          command = shortcuts[keyCode];\n      if ((event.ctrlKey || event.metaKey) && !event.altKey && command) {\n        that.commands.exec(command);\n        event.preventDefault();\n      }\n    });\n\n    // --------- Make sure that when pressing backspace/delete on selected images deletes the image and it's anchor ---------\n    dom.observe(element, \"keydown\", function (event) {\n      var target = that.selection.getSelectedNode(true),\n          keyCode = event.keyCode,\n          parent;\n      if (target && target.nodeName === \"IMG\" && (keyCode === wysihtml5.BACKSPACE_KEY || keyCode === wysihtml5.DELETE_KEY)) {\n        // 8 => backspace, 46 => delete\n        parent = target.parentNode;\n        // delete the <img>\n        parent.removeChild(target);\n        // and it's parent <a> too if it hasn't got any other child nodes\n        if (parent.nodeName === \"A\" && !parent.firstChild) {\n          parent.parentNode.removeChild(parent);\n        }\n\n        setTimeout(function () {\n          wysihtml5.quirks.redraw(element);\n        }, 0);\n        event.preventDefault();\n      }\n    });\n\n    // --------- Show url in tooltip when hovering links or images ---------\n    var titlePrefixes = {\n      IMG: \"Image: \",\n      A: \"Link: \"\n    };\n\n    dom.observe(element, \"mouseover\", function (event) {\n      var target = event.target,\n          nodeName = target.nodeName,\n          title;\n      if (nodeName !== \"A\" && nodeName !== \"IMG\") {\n        return;\n      }\n      var hasTitle = target.hasAttribute(\"title\");\n      if (!hasTitle) {\n        title = titlePrefixes[nodeName] + (target.getAttribute(\"href\") || target.getAttribute(\"src\"));\n        target.setAttribute(\"title\", title);\n      }\n    });\n  };\n})(wysihtml5); /**\n               * Class that takes care that the value of the composer and the textarea is always in sync\n               */\n(function (wysihtml5) {\n  var INTERVAL = 400;\n\n  wysihtml5.views.Synchronizer = Base.extend(\n  /** @scope wysihtml5.views.Synchronizer.prototype */{\n\n    constructor: function constructor(editor, textarea, composer) {\n      this.editor = editor;\n      this.textarea = textarea;\n      this.composer = composer;\n\n      this._observe();\n    },\n\n    /**\n     * Sync html from composer to textarea\n     * Takes care of placeholders\n     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the textarea\n     */\n    fromComposerToTextarea: function fromComposerToTextarea(shouldParseHtml) {\n      this.textarea.setValue(wysihtml5.lang.string(this.composer.getValue()).trim(), shouldParseHtml);\n    },\n\n    /**\n     * Sync value of textarea to composer\n     * Takes care of placeholders\n     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the composer\n     */\n    fromTextareaToComposer: function fromTextareaToComposer(shouldParseHtml) {\n      var textareaValue = this.textarea.getValue();\n      if (textareaValue) {\n        this.composer.setValue(textareaValue, shouldParseHtml);\n      } else {\n        this.composer.clear();\n        this.editor.fire(\"set_placeholder\");\n      }\n    },\n\n    /**\n     * Invoke syncing based on view state\n     * @param {Boolean} shouldParseHtml Whether the html should be sanitized before inserting it into the composer/textarea\n     */\n    sync: function sync(shouldParseHtml) {\n      if (this.editor.currentView.name === \"textarea\") {\n        this.fromTextareaToComposer(shouldParseHtml);\n      } else {\n        this.fromComposerToTextarea(shouldParseHtml);\n      }\n    },\n\n    /**\n     * Initializes interval-based syncing\n     * also makes sure that on-submit the composer's content is synced with the textarea\n     * immediately when the form gets submitted\n     */\n    _observe: function _observe() {\n      var interval,\n          that = this,\n          form = this.textarea.element.form,\n          startInterval = function startInterval() {\n        interval = setInterval(function () {\n          that.fromComposerToTextarea();\n        }, INTERVAL);\n      },\n          stopInterval = function stopInterval() {\n        clearInterval(interval);\n        interval = null;\n      };\n\n      startInterval();\n\n      if (form) {\n        // If the textarea is in a form make sure that after onreset and onsubmit the composer\n        // has the correct state\n        wysihtml5.dom.observe(form, \"submit\", function () {\n          that.sync(true);\n        });\n        wysihtml5.dom.observe(form, \"reset\", function () {\n          setTimeout(function () {\n            that.fromTextareaToComposer();\n          }, 0);\n        });\n      }\n\n      this.editor.observe(\"change_view\", function (view) {\n        if (view === \"composer\" && !interval) {\n          that.fromTextareaToComposer(true);\n          startInterval();\n        } else if (view === \"textarea\") {\n          that.fromComposerToTextarea(true);\n          stopInterval();\n        }\n      });\n\n      this.editor.observe(\"destroy:composer\", stopInterval);\n    }\n  });\n})(wysihtml5);\nwysihtml5.views.Textarea = wysihtml5.views.View.extend(\n/** @scope wysihtml5.views.Textarea.prototype */{\n  name: \"textarea\",\n\n  constructor: function constructor(parent, textareaElement, config) {\n    this.base(parent, textareaElement, config);\n\n    this._observe();\n  },\n\n  clear: function clear() {\n    this.element.value = \"\";\n  },\n\n  getValue: function getValue(parse) {\n    var value = this.isEmpty() ? \"\" : this.element.value;\n    if (parse) {\n      value = this.parent.parse(value);\n    }\n    return value;\n  },\n\n  setValue: function setValue(html, parse) {\n    if (parse) {\n      html = this.parent.parse(html);\n    }\n    this.element.value = html;\n  },\n\n  hasPlaceholderSet: function hasPlaceholderSet() {\n    var supportsPlaceholder = wysihtml5.browser.supportsPlaceholderAttributeOn(this.element),\n        placeholderText = this.element.getAttribute(\"placeholder\") || null,\n        value = this.element.value,\n        isEmpty = !value;\n    return supportsPlaceholder && isEmpty || value === placeholderText;\n  },\n\n  isEmpty: function isEmpty() {\n    return !wysihtml5.lang.string(this.element.value).trim() || this.hasPlaceholderSet();\n  },\n\n  _observe: function _observe() {\n    var element = this.element,\n        parent = this.parent,\n        eventMapping = {\n      focusin: \"focus\",\n      focusout: \"blur\"\n    },\n\n\n    /**\n     * Calling focus() or blur() on an element doesn't synchronously trigger the attached focus/blur events\n     * This is the case for focusin and focusout, so let's use them whenever possible, kkthxbai\n     */\n    events = wysihtml5.browser.supportsEvent(\"focusin\") ? [\"focusin\", \"focusout\", \"change\"] : [\"focus\", \"blur\", \"change\"];\n\n    parent.observe(\"beforeload\", function () {\n      wysihtml5.dom.observe(element, events, function (event) {\n        var eventName = eventMapping[event.type] || event.type;\n        parent.fire(eventName).fire(eventName + \":textarea\");\n      });\n\n      wysihtml5.dom.observe(element, [\"paste\", \"drop\"], function () {\n        setTimeout(function () {\n          parent.fire(\"paste\").fire(\"paste:textarea\");\n        }, 0);\n      });\n    });\n  }\n}); /**\n    * Toolbar Dialog\n    *\n    * @param {Element} link The toolbar link which causes the dialog to show up\n    * @param {Element} container The dialog container\n    *\n    * @example\n    *    <!-- Toolbar link -->\n    *    <a data-wysihtml5-command=\"insertImage\">insert an image</a>\n    *\n    *    <!-- Dialog -->\n    *    <div data-wysihtml5-dialog=\"insertImage\" style=\"display: none;\">\n    *      <label>\n    *        URL: <input data-wysihtml5-dialog-field=\"src\" value=\"http://\">\n    *      </label>\n    *      <label>\n    *        Alternative text: <input data-wysihtml5-dialog-field=\"alt\" value=\"\">\n    *      </label>\n    *    </div>\n    *\n    *    <script>\n    *      var dialog = new wysihtml5.toolbar.Dialog(\n    *        document.querySelector(\"[data-wysihtml5-command='insertImage']\"),\n    *        document.querySelector(\"[data-wysihtml5-dialog='insertImage']\")\n    *      );\n    *      dialog.observe(\"save\", function(attributes) {\n    *        // do something\n    *      });\n    *    </script>\n    */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom,\n      CLASS_NAME_OPENED = \"wysihtml5-command-dialog-opened\",\n      SELECTOR_FORM_ELEMENTS = \"input, select, textarea\",\n      SELECTOR_FIELDS = \"[data-wysihtml5-dialog-field]\",\n      ATTRIBUTE_FIELDS = \"data-wysihtml5-dialog-field\";\n\n  wysihtml5.toolbar.Dialog = wysihtml5.lang.Dispatcher.extend(\n  /** @scope wysihtml5.toolbar.Dialog.prototype */{\n    constructor: function constructor(link, container) {\n      this.link = link;\n      this.container = container;\n    },\n\n    _observe: function _observe() {\n      if (this._observed) {\n        return;\n      }\n\n      var that = this,\n          callbackWrapper = function callbackWrapper(event) {\n        var attributes = that._serialize();\n        if (attributes == that.elementToChange) {\n          that.fire(\"edit\", attributes);\n        } else {\n          that.fire(\"save\", attributes);\n        }\n        that.hide();\n        event.preventDefault();\n        event.stopPropagation();\n      };\n\n      dom.observe(that.link, \"click\", function (event) {\n        if (dom.hasClass(that.link, CLASS_NAME_OPENED)) {\n          setTimeout(function () {\n            that.hide();\n          }, 0);\n        }\n      });\n\n      dom.observe(this.container, \"keydown\", function (event) {\n        var keyCode = event.keyCode;\n        if (keyCode === wysihtml5.ENTER_KEY) {\n          callbackWrapper(event);\n        }\n        if (keyCode === wysihtml5.ESCAPE_KEY) {\n          // that.hide();\n        }\n      });\n\n      dom.delegate(this.container, \"[data-wysihtml5-dialog-action=save]\", \"click\", callbackWrapper);\n\n      dom.delegate(this.container, \"[data-wysihtml5-dialog-action=cancel]\", \"click\", function (event) {\n        that.fire(\"cancel\");\n        that.hide();\n        event.preventDefault();\n        event.stopPropagation();\n      });\n\n      var formElements = this.container.querySelectorAll(SELECTOR_FORM_ELEMENTS),\n          i = 0,\n          length = formElements.length,\n          _clearInterval = function _clearInterval() {\n        clearInterval(that.interval);\n      };\n      for (; i < length; i++) {\n        dom.observe(formElements[i], \"change\", _clearInterval);\n      }\n\n      this._observed = true;\n    },\n\n    /**\n     * Grabs all fields in the dialog and puts them in key=>value style in an object which\n     * then gets returned\n     */\n    _serialize: function _serialize() {\n      var data = this.elementToChange || {},\n          fields = this.container.querySelectorAll(SELECTOR_FIELDS),\n          length = fields.length,\n          i = 0;\n      for (; i < length; i++) {\n        data[fields[i].getAttribute(ATTRIBUTE_FIELDS)] = fields[i].value;\n      }\n      return data;\n    },\n\n    /**\n     * Takes the attributes of the \"elementToChange\"\n     * and inserts them in their corresponding dialog input fields\n     * \n     * Assume the \"elementToChange\" looks like this:\n     *    <a href=\"http://www.google.com\" target=\"_blank\">foo</a>\n     *\n     * and we have the following dialog:\n     *    <input type=\"text\" data-wysihtml5-dialog-field=\"href\" value=\"\">\n     *    <input type=\"text\" data-wysihtml5-dialog-field=\"target\" value=\"\">\n     * \n     * after calling _interpolate() the dialog will look like this\n     *    <input type=\"text\" data-wysihtml5-dialog-field=\"href\" value=\"http://www.google.com\">\n     *    <input type=\"text\" data-wysihtml5-dialog-field=\"target\" value=\"_blank\">\n     *\n     * Basically it adopted the attribute values into the corresponding input fields\n     *\n     */\n    _interpolate: function _interpolate(avoidHiddenFields) {\n      var field,\n          fieldName,\n          newValue,\n          focusedElement = document.querySelector(\":focus\"),\n          fields = this.container.querySelectorAll(SELECTOR_FIELDS),\n          length = fields.length,\n          i = 0;\n      for (; i < length; i++) {\n        field = fields[i];\n\n        // Never change elements where the user is currently typing in\n        if (field === focusedElement) {\n          continue;\n        }\n\n        // Don't update hidden fields\n        // See https://github.com/xing/wysihtml5/pull/14\n        if (avoidHiddenFields && field.type === \"hidden\") {\n          continue;\n        }\n\n        fieldName = field.getAttribute(ATTRIBUTE_FIELDS);\n        newValue = this.elementToChange ? this.elementToChange[fieldName] || \"\" : field.defaultValue;\n        field.value = newValue;\n      }\n    },\n\n    /**\n     * Show the dialog element\n     */\n    show: function show(elementToChange) {\n      var that = this,\n          firstField = this.container.querySelector(SELECTOR_FORM_ELEMENTS);\n      this.elementToChange = elementToChange;\n      this._observe();\n      this._interpolate();\n      if (elementToChange) {\n        this.interval = setInterval(function () {\n          that._interpolate(true);\n        }, 500);\n      }\n      dom.addClass(this.link, CLASS_NAME_OPENED);\n      this.container.style.display = \"\";\n      this.fire(\"show\");\n      if (firstField && !elementToChange) {\n        try {\n          firstField.focus();\n        } catch (e) {}\n      }\n    },\n\n    /**\n     * Hide the dialog element\n     */\n    hide: function hide() {\n      clearInterval(this.interval);\n      this.elementToChange = null;\n      dom.removeClass(this.link, CLASS_NAME_OPENED);\n      this.container.style.display = \"none\";\n      this.fire(\"hide\");\n    }\n  });\n})(wysihtml5);\n/**\n * Converts speech-to-text and inserts this into the editor\n * As of now (2011/03/25) this only is supported in Chrome >= 11\n *\n * Note that it sends the recorded audio to the google speech recognition api:\n * http://stackoverflow.com/questions/4361826/does-chrome-have-buil-in-speech-recognition-for-input-type-text-x-webkit-speec\n *\n * Current HTML5 draft can be found here\n * http://lists.w3.org/Archives/Public/public-xg-htmlspeech/2011Feb/att-0020/api-draft.html\n * \n * \"Accessing Google Speech API Chrome 11\"\n * http://mikepultz.com/2011/03/accessing-google-speech-api-chrome-11/\n */\n(function (wysihtml5) {\n  var dom = wysihtml5.dom;\n\n  var linkStyles = {\n    position: \"relative\"\n  };\n\n  var wrapperStyles = {\n    left: 0,\n    margin: 0,\n    opacity: 0,\n    overflow: \"hidden\",\n    padding: 0,\n    position: \"absolute\",\n    top: 0,\n    zIndex: 1\n  };\n\n  var inputStyles = {\n    cursor: \"inherit\",\n    fontSize: \"50px\",\n    height: \"50px\",\n    marginTop: \"-25px\",\n    outline: 0,\n    padding: 0,\n    position: \"absolute\",\n    right: \"-4px\",\n    top: \"50%\"\n  };\n\n  var inputAttributes = {\n    \"x-webkit-speech\": \"\",\n    \"speech\": \"\"\n  };\n\n  wysihtml5.toolbar.Speech = function (parent, link) {\n    var input = document.createElement(\"input\");\n    if (!wysihtml5.browser.supportsSpeechApiOn(input)) {\n      link.style.display = \"none\";\n      return;\n    }\n\n    var wrapper = document.createElement(\"div\");\n\n    wysihtml5.lang.object(wrapperStyles).merge({\n      width: link.offsetWidth + \"px\",\n      height: link.offsetHeight + \"px\"\n    });\n\n    dom.insert(input).into(wrapper);\n    dom.insert(wrapper).into(link);\n\n    dom.setStyles(inputStyles).on(input);\n    dom.setAttributes(inputAttributes).on(input);\n\n    dom.setStyles(wrapperStyles).on(wrapper);\n    dom.setStyles(linkStyles).on(link);\n\n    var eventName = \"onwebkitspeechchange\" in input ? \"webkitspeechchange\" : \"speechchange\";\n    dom.observe(input, eventName, function () {\n      parent.execCommand(\"insertText\", input.value);\n      input.value = \"\";\n    });\n\n    dom.observe(input, \"click\", function (event) {\n      if (dom.hasClass(link, \"wysihtml5-command-disabled\")) {\n        event.preventDefault();\n      }\n\n      event.stopPropagation();\n    });\n  };\n})(wysihtml5); /**\n               * Toolbar\n               *\n               * @param {Object} parent Reference to instance of Editor instance\n               * @param {Element} container Reference to the toolbar container element\n               *\n               * @example\n               *    <div id=\"toolbar\">\n               *      <a data-wysihtml5-command=\"createLink\">insert link</a>\n               *      <a data-wysihtml5-command=\"formatBlock\" data-wysihtml5-command-value=\"h1\">insert h1</a>\n               *    </div>\n               *\n               *    <script>\n               *      var toolbar = new wysihtml5.toolbar.Toolbar(editor, document.getElementById(\"toolbar\"));\n               *    </script>\n               */\n(function (wysihtml5) {\n  var CLASS_NAME_COMMAND_DISABLED = \"wysihtml5-command-disabled\",\n      CLASS_NAME_COMMANDS_DISABLED = \"wysihtml5-commands-disabled\",\n      CLASS_NAME_COMMAND_ACTIVE = \"wysihtml5-command-active\",\n      CLASS_NAME_ACTION_ACTIVE = \"wysihtml5-action-active\",\n      dom = wysihtml5.dom;\n\n  wysihtml5.toolbar.Toolbar = Base.extend(\n  /** @scope wysihtml5.toolbar.Toolbar.prototype */{\n    constructor: function constructor(editor, container) {\n      this.editor = editor;\n      this.container = typeof container === \"string\" ? document.getElementById(container) : container;\n      this.composer = editor.composer;\n\n      this._getLinks(\"command\");\n      this._getLinks(\"action\");\n\n      this._observe();\n      this.show();\n\n      var speechInputLinks = this.container.querySelectorAll(\"[data-wysihtml5-command=insertSpeech]\"),\n          length = speechInputLinks.length,\n          i = 0;\n      for (; i < length; i++) {\n        new wysihtml5.toolbar.Speech(this, speechInputLinks[i]);\n      }\n    },\n\n    _getLinks: function _getLinks(type) {\n      var links = this[type + \"Links\"] = wysihtml5.lang.array(this.container.querySelectorAll(\"[data-wysihtml5-\" + type + \"]\")).get(),\n          length = links.length,\n          i = 0,\n          mapping = this[type + \"Mapping\"] = {},\n          link,\n          group,\n          name,\n          value,\n          dialog;\n      for (; i < length; i++) {\n        link = links[i];\n        name = link.getAttribute(\"data-wysihtml5-\" + type);\n        value = link.getAttribute(\"data-wysihtml5-\" + type + \"-value\");\n        group = this.container.querySelector(\"[data-wysihtml5-\" + type + \"-group='\" + name + \"']\");\n        dialog = this._getDialog(link, name);\n\n        mapping[name + \":\" + value] = {\n          link: link,\n          group: group,\n          name: name,\n          value: value,\n          dialog: dialog,\n          state: false\n        };\n      }\n    },\n\n    _getDialog: function _getDialog(link, command) {\n      var that = this,\n          dialogElement = this.container.querySelector(\"[data-wysihtml5-dialog='\" + command + \"']\"),\n          dialog,\n          caretBookmark;\n\n      if (dialogElement) {\n        dialog = new wysihtml5.toolbar.Dialog(link, dialogElement);\n\n        dialog.observe(\"show\", function () {\n          caretBookmark = that.composer.selection.getBookmark();\n\n          that.editor.fire(\"show:dialog\", { command: command, dialogContainer: dialogElement, commandLink: link });\n        });\n\n        dialog.observe(\"save\", function (attributes) {\n          if (caretBookmark) {\n            that.composer.selection.setBookmark(caretBookmark);\n          }\n          that._execCommand(command, attributes);\n\n          that.editor.fire(\"save:dialog\", { command: command, dialogContainer: dialogElement, commandLink: link });\n        });\n\n        dialog.observe(\"cancel\", function () {\n          that.editor.focus(false);\n          that.editor.fire(\"cancel:dialog\", { command: command, dialogContainer: dialogElement, commandLink: link });\n        });\n      }\n      return dialog;\n    },\n\n    /**\n     * @example\n     *    var toolbar = new wysihtml5.Toolbar();\n     *    // Insert a <blockquote> element or wrap current selection in <blockquote>\n     *    toolbar.execCommand(\"formatBlock\", \"blockquote\");\n     */\n    execCommand: function execCommand(command, commandValue) {\n      if (this.commandsDisabled) {\n        return;\n      }\n\n      var commandObj = this.commandMapping[command + \":\" + commandValue];\n\n      // Show dialog when available\n      if (commandObj && commandObj.dialog && !commandObj.state) {\n        commandObj.dialog.show();\n      } else {\n        this._execCommand(command, commandValue);\n      }\n    },\n\n    _execCommand: function _execCommand(command, commandValue) {\n      // Make sure that composer is focussed (false => don't move caret to the end)\n      this.editor.focus(false);\n\n      this.composer.commands.exec(command, commandValue);\n      this._updateLinkStates();\n    },\n\n    execAction: function execAction(action) {\n      var editor = this.editor;\n      switch (action) {\n        case \"change_view\":\n          if (editor.currentView === editor.textarea) {\n            editor.fire(\"change_view\", \"composer\");\n          } else {\n            editor.fire(\"change_view\", \"textarea\");\n          }\n          break;\n      }\n    },\n\n    _observe: function _observe() {\n      var that = this,\n          editor = this.editor,\n          container = this.container,\n          links = this.commandLinks.concat(this.actionLinks),\n          length = links.length,\n          i = 0;\n\n      for (; i < length; i++) {\n        // 'javascript:;' and unselectable=on Needed for IE, but done in all browsers to make sure that all get the same css applied\n        // (you know, a:link { ... } doesn't match anchors with missing href attribute)\n        dom.setAttributes({\n          href: \"javascript:;\",\n          unselectable: \"on\"\n        }).on(links[i]);\n      }\n\n      // Needed for opera\n      dom.delegate(container, \"[data-wysihtml5-command]\", \"mousedown\", function (event) {\n        event.preventDefault();\n      });\n\n      dom.delegate(container, \"[data-wysihtml5-command]\", \"click\", function (event) {\n        var link = this,\n            command = link.getAttribute(\"data-wysihtml5-command\"),\n            commandValue = link.getAttribute(\"data-wysihtml5-command-value\");\n        that.execCommand(command, commandValue);\n        event.preventDefault();\n      });\n\n      dom.delegate(container, \"[data-wysihtml5-action]\", \"click\", function (event) {\n        var action = this.getAttribute(\"data-wysihtml5-action\");\n        that.execAction(action);\n        event.preventDefault();\n      });\n\n      editor.observe(\"focus:composer\", function () {\n        that.bookmark = null;\n        clearInterval(that.interval);\n        that.interval = setInterval(function () {\n          that._updateLinkStates();\n        }, 500);\n      });\n\n      editor.observe(\"blur:composer\", function () {\n        clearInterval(that.interval);\n      });\n\n      editor.observe(\"destroy:composer\", function () {\n        clearInterval(that.interval);\n      });\n\n      editor.observe(\"change_view\", function (currentView) {\n        // Set timeout needed in order to let the blur event fire first\n        setTimeout(function () {\n          that.commandsDisabled = currentView !== \"composer\";\n          that._updateLinkStates();\n          if (that.commandsDisabled) {\n            dom.addClass(container, CLASS_NAME_COMMANDS_DISABLED);\n          } else {\n            dom.removeClass(container, CLASS_NAME_COMMANDS_DISABLED);\n          }\n        }, 0);\n      });\n    },\n\n    _updateLinkStates: function _updateLinkStates() {\n      var element = this.composer.element,\n          commandMapping = this.commandMapping,\n          actionMapping = this.actionMapping,\n          i,\n          state,\n          action,\n          command;\n      // every millisecond counts... this is executed quite often\n      for (i in commandMapping) {\n        command = commandMapping[i];\n        if (this.commandsDisabled) {\n          state = false;\n          dom.removeClass(command.link, CLASS_NAME_COMMAND_ACTIVE);\n          if (command.group) {\n            dom.removeClass(command.group, CLASS_NAME_COMMAND_ACTIVE);\n          }\n          if (command.dialog) {\n            command.dialog.hide();\n          }\n        } else {\n          state = this.composer.commands.state(command.name, command.value);\n          if (wysihtml5.lang.object(state).isArray()) {\n            // Grab first and only object/element in state array, otherwise convert state into boolean\n            // to avoid showing a dialog for multiple selected elements which may have different attributes\n            // eg. when two links with different href are selected, the state will be an array consisting of both link elements\n            // but the dialog interface can only update one\n            state = state.length === 1 ? state[0] : true;\n          }\n          dom.removeClass(command.link, CLASS_NAME_COMMAND_DISABLED);\n          if (command.group) {\n            dom.removeClass(command.group, CLASS_NAME_COMMAND_DISABLED);\n          }\n        }\n\n        if (command.state === state) {\n          continue;\n        }\n\n        command.state = state;\n        if (state) {\n          dom.addClass(command.link, CLASS_NAME_COMMAND_ACTIVE);\n          if (command.group) {\n            dom.addClass(command.group, CLASS_NAME_COMMAND_ACTIVE);\n          }\n          if (command.dialog) {\n            if ((typeof state === \"undefined\" ? \"undefined\" : _typeof(state)) === \"object\") {\n              command.dialog.show(state);\n            } else {\n              command.dialog.hide();\n            }\n          }\n        } else {\n          dom.removeClass(command.link, CLASS_NAME_COMMAND_ACTIVE);\n          if (command.group) {\n            dom.removeClass(command.group, CLASS_NAME_COMMAND_ACTIVE);\n          }\n          if (command.dialog) {\n            command.dialog.hide();\n          }\n        }\n      }\n\n      for (i in actionMapping) {\n        action = actionMapping[i];\n\n        if (action.name === \"change_view\") {\n          action.state = this.editor.currentView === this.editor.textarea;\n          if (action.state) {\n            dom.addClass(action.link, CLASS_NAME_ACTION_ACTIVE);\n          } else {\n            dom.removeClass(action.link, CLASS_NAME_ACTION_ACTIVE);\n          }\n        }\n      }\n    },\n\n    show: function show() {\n      this.container.style.display = \"\";\n    },\n\n    hide: function hide() {\n      this.container.style.display = \"none\";\n    }\n  });\n})(wysihtml5);\n/**\n * WYSIHTML5 Editor\n *\n * @param {Element} textareaElement Reference to the textarea which should be turned into a rich text interface\n * @param {Object} [config] See defaultConfig object below for explanation of each individual config option\n *\n * @events\n *    load\n *    beforeload (for internal use only)\n *    focus\n *    focus:composer\n *    focus:textarea\n *    blur\n *    blur:composer\n *    blur:textarea\n *    change\n *    change:composer\n *    change:textarea\n *    paste\n *    paste:composer\n *    paste:textarea\n *    newword:composer\n *    destroy:composer\n *    undo:composer\n *    redo:composer\n *    beforecommand:composer\n *    aftercommand:composer\n *    change_view\n */\n(function (wysihtml5) {\n  var undef;\n\n  var defaultConfig = {\n    // Give the editor a name, the name will also be set as class name on the iframe and on the iframe's body \n    name: undef,\n    // Whether the editor should look like the textarea (by adopting styles)\n    style: true,\n    // Id of the toolbar element, pass falsey value if you don't want any toolbar logic\n    toolbar: undef,\n    // Whether urls, entered by the user should automatically become clickable-links\n    autoLink: true,\n    // Object which includes parser rules to apply when html gets inserted via copy & paste\n    // See parser_rules/*.js for examples\n    parserRules: { tags: { br: {}, span: {}, div: {}, p: {} }, classes: {} },\n    // Parser method to use when the user inserts content via copy & paste\n    parser: wysihtml5.dom.parse,\n    // Class name which should be set on the contentEditable element in the created sandbox iframe, can be styled via the 'stylesheets' option\n    composerClassName: \"wysihtml5-editor\",\n    // Class name to add to the body when the wysihtml5 editor is supported\n    bodyClassName: \"wysihtml5-supported\",\n    // Array (or single string) of stylesheet urls to be loaded in the editor's iframe\n    stylesheets: [],\n    // Placeholder text to use, defaults to the placeholder attribute on the textarea element\n    placeholderText: undef,\n    // Whether the composer should allow the user to manually resize images, tables etc.\n    allowObjectResizing: true,\n    // Whether the rich text editor should be rendered on touch devices (wysihtml5 >= 0.3.0 comes with basic support for iOS 5)\n    supportTouchDevices: true\n  };\n\n  wysihtml5.Editor = wysihtml5.lang.Dispatcher.extend(\n  /** @scope wysihtml5.Editor.prototype */{\n    constructor: function constructor(textareaElement, config) {\n      this.textareaElement = typeof textareaElement === \"string\" ? document.getElementById(textareaElement) : textareaElement;\n      this.config = wysihtml5.lang.object({}).merge(defaultConfig).merge(config).get();\n      this.textarea = new wysihtml5.views.Textarea(this, this.textareaElement, this.config);\n      this.currentView = this.textarea;\n      this._isCompatible = wysihtml5.browser.supported();\n\n      // Sort out unsupported/unwanted browsers here\n      if (!this._isCompatible || !this.config.supportTouchDevices && wysihtml5.browser.isTouchDevice()) {\n        var that = this;\n        setTimeout(function () {\n          that.fire(\"beforeload\").fire(\"load\");\n        }, 0);\n        return;\n      }\n\n      // Add class name to body, to indicate that the editor is supported\n      wysihtml5.dom.addClass(document.body, this.config.bodyClassName);\n\n      this.composer = new wysihtml5.views.Composer(this, this.textareaElement, this.config);\n      this.currentView = this.composer;\n\n      if (typeof this.config.parser === \"function\") {\n        this._initParser();\n      }\n\n      this.observe(\"beforeload\", function () {\n        this.synchronizer = new wysihtml5.views.Synchronizer(this, this.textarea, this.composer);\n        if (this.config.toolbar) {\n          this.toolbar = new wysihtml5.toolbar.Toolbar(this, this.config.toolbar);\n        }\n      });\n\n      try {\n        console.log(\"Heya! This page is using wysihtml5 for rich text editing. Check out https://github.com/xing/wysihtml5\");\n      } catch (e) {}\n    },\n\n    isCompatible: function isCompatible() {\n      return this._isCompatible;\n    },\n\n    clear: function clear() {\n      this.currentView.clear();\n      return this;\n    },\n\n    getValue: function getValue(parse) {\n      return this.currentView.getValue(parse);\n    },\n\n    setValue: function setValue(html, parse) {\n      if (!html) {\n        return this.clear();\n      }\n      this.currentView.setValue(html, parse);\n      return this;\n    },\n\n    focus: function focus(setToEnd) {\n      this.currentView.focus(setToEnd);\n      return this;\n    },\n\n    /**\n     * Deactivate editor (make it readonly)\n     */\n    disable: function disable() {\n      this.currentView.disable();\n      return this;\n    },\n\n    /**\n     * Activate editor\n     */\n    enable: function enable() {\n      this.currentView.enable();\n      return this;\n    },\n\n    isEmpty: function isEmpty() {\n      return this.currentView.isEmpty();\n    },\n\n    hasPlaceholderSet: function hasPlaceholderSet() {\n      return this.currentView.hasPlaceholderSet();\n    },\n\n    parse: function parse(htmlOrElement) {\n      var returnValue = this.config.parser(htmlOrElement, this.config.parserRules, this.composer.sandbox.getDocument(), true);\n      if ((typeof htmlOrElement === \"undefined\" ? \"undefined\" : _typeof(htmlOrElement)) === \"object\") {\n        wysihtml5.quirks.redraw(htmlOrElement);\n      }\n      return returnValue;\n    },\n\n    /**\n     * Prepare html parser logic\n     *  - Observes for paste and drop\n     */\n    _initParser: function _initParser() {\n      this.observe(\"paste:composer\", function () {\n        var keepScrollPosition = true,\n            that = this;\n        that.composer.selection.executeAndRestore(function () {\n          wysihtml5.quirks.cleanPastedHTML(that.composer.element);\n          that.parse(that.composer.element);\n        }, keepScrollPosition);\n      });\n\n      this.observe(\"paste:textarea\", function () {\n        var value = this.textarea.getValue(),\n            newValue;\n        newValue = this.parse(value);\n        this.textarea.setValue(newValue);\n      });\n    }\n  });\n})(wysihtml5);\n/**\nBootstrap wysihtml5 editor. Based on [bootstrap-wysihtml5](https://github.com/jhollingworth/bootstrap-wysihtml5).  \nYou should include **manually** distributives of `wysihtml5` and `bootstrap-wysihtml5`:\n\n    <link href=\"js/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/bootstrap-wysihtml5-0.0.2.css\" rel=\"stylesheet\" type=\"text/css\"></link>  \n    <script src=\"js/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/wysihtml5-0.3.0.min.js\"></script>  \n    <script src=\"js/inputs-ext/wysihtml5/bootstrap-wysihtml5-0.0.2/bootstrap-wysihtml5-0.0.2.min.js\"></script>\n    \nAnd also include `wysihtml5.js` from `inputs-ext` directory of x-editable:\n      \n    <script src=\"js/inputs-ext/wysihtml5/wysihtml5.js\"></script>  \n\n**Note:** It's better to use fresh bootstrap-wysihtml5 from it's [master branch](https://github.com/jhollingworth/bootstrap-wysihtml5/tree/master/src) as there is update for correct image insertion.    \n    \n@class wysihtml5\n@extends abstractinput\n@final\n@since 1.4.0\n@example\n<div id=\"comments\" data-type=\"wysihtml5\" data-pk=\"1\"><h2>awesome</h2> comment!</div>\n<script>\n$(function(){\n    $('#comments').editable({\n        url: '/post',\n        title: 'Enter comments'\n    });\n});\n</script>\n**/\n(function ($) {\n\n  window.Wysihtml5 = function Wysihtml5(options) {\n    this.init('wysihtml5', options, Wysihtml5.defaults);\n\n    //extend wysihtml5 manually as $.extend not recursive \n    this.options.wysihtml5 = $.extend({}, Wysihtml5.defaults.wysihtml5, options.wysihtml5);\n  };\n\n  window.$.fn.editableutils.inherit(Wysihtml5, window.$.fn.editabletypes.abstractinput);\n\n  $.extend(Wysihtml5.prototype, {\n    render: function render() {\n      var deferred = $.Deferred(),\n          msieOld;\n\n      //generate unique id as it required for wysihtml5\n      this.$input.attr('id', 'textarea_' + new Date().getTime());\n\n      this.setClass();\n      this.setAttr('placeholder');\n\n      //resolve deffered when widget loaded\n      $.extend(this.options.wysihtml5, {\n        events: {\n          load: function load() {\n            deferred.resolve();\n          }\n        }\n      });\n\n      this.$input.wysihtml5(this.options.wysihtml5);\n\n      /*\n       In IE8 wysihtml5 iframe stays on the same line with buttons toolbar (inside popover).\n       The only solution I found is to add <br>. If you fine better way, please send PR.   \n      */\n      msieOld = /msie\\s*(8|7|6)/.test(navigator.userAgent.toLowerCase());\n      if (msieOld) {\n        this.$input.before('<br><br>');\n      }\n\n      return deferred.promise();\n    },\n\n    value2html: function value2html(value, element) {\n      $(element).html(value);\n    },\n\n    html2value: function html2value(html) {\n      return html;\n    },\n\n    value2input: function value2input(value) {\n      this.$input.data(\"wysihtml5\").editor.setValue(value, true);\n    },\n\n    activate: function activate() {\n      this.$input.data(\"wysihtml5\").editor.focus();\n    },\n\n    isEmpty: function isEmpty($element) {\n      if ($.trim($element.html()) === '') {\n        return true;\n      } else if ($.trim($element.text()) !== '') {\n        return false;\n      } else {\n        //e.g. '<img>', '<br>', '<p></p>'\n        return !$element.height() || !$element.width();\n      }\n    }\n  });\n\n  Wysihtml5.defaults = $.extend({}, window.$.fn.editabletypes.abstractinput.defaults, {\n    /**\n    @property tpl\n    @default <textarea></textarea>\n    **/\n    tpl: '<textarea></textarea>',\n    /**\n    @property inputclass\n    @default editable-wysihtml5\n    **/\n    inputclass: 'editable-wysihtml5',\n    /**\n    Placeholder attribute of input. Shown when input is empty.\n     @property placeholder\n    @type string\n    @default null\n    **/\n    placeholder: null,\n    /**\n    Wysihtml5 default options.  \n    See https://github.com/jhollingworth/bootstrap-wysihtml5#options\n     @property wysihtml5\n    @type object\n    @default {stylesheets: false}\n    **/\n    wysihtml5: {\n      stylesheets: false\n    }\n  });\n\n  window.$.fn.editabletypes.wysihtml5 = Wysihtml5;\n})(window.jQuery);\n\n!function ($, wysi) {\n\n  var tpl = {\n    \"font-styles\": function fontStyles(locale, options) {\n      var size = options && options.size ? ' btn-' + options.size : '';\n      return \"<li class='dropdown'>\" + \"<a class='btn btn-default dropdown-toggle\" + size + \"' data-toggle='dropdown' href='#'>\" + \"<i class='fa fa-font'></i>&nbsp;<span class='current-font'>\" + locale.font_styles.normal + \"</span>&nbsp;<b class='caret'></b>\" + \"</a>\" + \"<ul class='dropdown-menu'>\" + \"<li><a data-wysihtml5-command='formatBlock' data-wysihtml5-command-value='div' tabindex='-1'>\" + locale.font_styles.normal + \"</a></li>\" + \"<li><a data-wysihtml5-command='formatBlock' data-wysihtml5-command-value='h1' tabindex='-1'>\" + locale.font_styles.h1 + \"</a></li>\" + \"<li><a data-wysihtml5-command='formatBlock' data-wysihtml5-command-value='h2' tabindex='-1'>\" + locale.font_styles.h2 + \"</a></li>\" + \"<li><a data-wysihtml5-command='formatBlock' data-wysihtml5-command-value='h3' tabindex='-1'>\" + locale.font_styles.h3 + \"</a></li>\" + \"</ul>\" + \"</li>\";\n    },\n\n    \"emphasis\": function emphasis(locale, options) {\n      var size = options && options.size ? ' btn-' + options.size : '';\n      return \"<li>\" + \"<div class='btn-group'>\" + \"<a class='btn btn-default\" + size + \"' data-wysihtml5-command='bold' title='CTRL+B' tabindex='-1'>\" + locale.emphasis.bold + \"</a>\" + \"<a class='btn btn-default\" + size + \"' data-wysihtml5-command='italic' title='CTRL+I' tabindex='-1'>\" + locale.emphasis.italic + \"</a>\" + \"<a class='btn btn-default\" + size + \"' data-wysihtml5-command='underline' title='CTRL+U' tabindex='-1'>\" + locale.emphasis.underline + \"</a>\" + \"</div>\" + \"</li>\";\n    },\n\n    \"lists\": function lists(locale, options) {\n      var size = options && options.size ? ' btn-' + options.size : '';\n      return \"<li>\" + \"<div class='btn-group'>\" + \"<a class='btn btn-default\" + size + \"' data-wysihtml5-command='insertUnorderedList' title='\" + locale.lists.unordered + \"' tabindex='-1'><i class='fa fa-list'></i></a>\" + \"<a class='btn btn-default\" + size + \"' data-wysihtml5-command='insertOrderedList' title='\" + locale.lists.ordered + \"' tabindex='-1'><i class='fa fa-th-list'></i></a>\" + \"<a class='btn btn-default\" + size + \"' data-wysihtml5-command='clear' title='ban' tabindex='-1'><i class='fa fa-ban'></i></a>\" + \"</div>\" + \"</li>\";\n    },\n\n    \"link\": function link(locale, options) {\n      var size = options && options.size ? ' btn-' + options.size : '';\n      return \"<li>\" + \"<div class='bootstrap-wysihtml5-insert-link-modal modal hide fade'>\" + \"<div class='modal-header'>\" + \"<a class='close' data-dismiss='modal'>&times;</a>\" + \"<h3>\" + locale.link.insert + \"</h3>\" + \"</div>\" + \"<div class='modal-body'>\" + \"<input value='http://' class='bootstrap-wysihtml5-insert-link-url input-xlarge'>\" + \"</div>\" + \"<div class='modal-footer'>\" + \"<a href='#' class='btn btn-default' data-dismiss='modal'>\" + locale.link.cancel + \"</a>\" + \"<a href='#' class='btn btn-primary' data-dismiss='modal'>\" + locale.link.insert + \"</a>\" + \"</div>\" + \"</div>\" + \"<a class='btn btn-default\" + size + \"' data-wysihtml5-command='createLink' title='\" + locale.link.insert + \"' tabindex='-1'><i class='fa fa-share'></i></a>\" + \"</li>\";\n    },\n\n    \"image\": function image(locale, options) {\n      var size = options && options.size ? ' btn-' + options.size : '';\n      return \"<li>\" + \"<div class='bootstrap-wysihtml5-insert-image-modal modal hide fade'>\" + \"<div class='modal-header'>\" + \"<a class='close' data-dismiss='modal'>&times;</a>\" + \"<h3>\" + locale.image.insert + \"</h3>\" + \"</div>\" + \"<div class='modal-body'>\" + \"<input value='http://' class='bootstrap-wysihtml5-insert-image-url input-xlarge'>\" + \"</div>\" + \"<div class='modal-footer'>\" + \"<a href='#' class='btn btn-default' data-dismiss='modal'>\" + locale.image.cancel + \"</a>\" + \"<a href='#' class='btn btn-primary' data-dismiss='modal'>\" + locale.image.insert + \"</a>\" + \"</div>\" + \"</div>\" + \"<a class='btn btn-default\" + size + \"' data-wysihtml5-command='insertImage' title='\" + locale.image.insert + \"' tabindex='-1'><i class='fa fa-picture'></i></a>\" + \"</li>\";\n    },\n\n    \"html\": function html(locale, options) {\n      var size = options && options.size ? ' btn-' + options.size : '';\n      return \"<li>\" + \"<div class='btn-group'>\" + \"<a class='btn btn-default\" + size + \"' data-wysihtml5-action='change_view' title='\" + locale.html.edit + \"' tabindex='-1'><i class='fa fa-pencil'></i></a>\" + \"</div>\" + \"</li>\";\n    },\n\n    \"color\": function color(locale, options) {\n      var size = options && options.size ? ' btn-' + options.size : '';\n      return \"<li class='dropdown'>\" + \"<a class='btn btn-default dropdown-toggle\" + size + \"' data-toggle='dropdown' href='#' tabindex='-1'>\" + \"<span class='current-color'>åŽŸè‰²</span>&nbsp;<b class='caret'></b>\" + \"</a>\" + \"<ul class='dropdown-menu'>\" + \"<li><div class='wysihtml5-colors' data-wysihtml5-command-value='clear'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='clear'>\" + locale.colours.clear + \"</a></li>\" + \"<li><div class='wysihtml5-colors' data-wysihtml5-command-value='first'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='first'>\" + locale.colours.first + \"</a></li>\" + \"<li><div class='wysihtml5-colors' data-wysihtml5-command-value='second'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='second'>\" + locale.colours.second + \"</a></li>\" + \"<li><div class='wysihtml5-colors' data-wysihtml5-command-value='three'></div><a class='wysihtml5-colors-title' data-wysihtml5-command='foreColor' data-wysihtml5-command-value='three'>\" + locale.colours.three + \"</a></li>\" + \"</ul>\" + \"</li>\";\n    }\n  };\n\n  var templates = function templates(key, locale, options) {\n    return tpl[key](locale, options);\n  };\n\n  var Wysihtml5 = function Wysihtml5(el, options) {\n    this.el = el;\n    var toolbarOpts = options || defaultOptions;\n    for (var t in toolbarOpts.customTemplates) {\n      tpl[t] = toolbarOpts.customTemplates[t];\n    }\n    this.toolbar = this.createToolbar(el, toolbarOpts);\n    this.editor = this.createEditor(options);\n\n    window.editor = this.editor;\n\n    $('iframe.wysihtml5-sandbox').each(function (i, el) {\n      $(el.contentWindow).off('focus.wysihtml5').on({\n        'focus.wysihtml5': function focusWysihtml5() {\n          $('li.dropdown').removeClass('open');\n        }\n      });\n    });\n  };\n\n  Wysihtml5.prototype = {\n\n    constructor: Wysihtml5,\n\n    createEditor: function createEditor(options) {\n      options = options || {};\n\n      // Add the toolbar to a clone of the options object so multiple instances\n      // of the WYISYWG don't break because \"toolbar\" is already defined\n      options = $.extend(true, {}, options);\n      options.toolbar = this.toolbar[0];\n\n      var editor = new wysihtml5.Editor(this.el[0], options);\n\n      if (options && options.events) {\n        for (var eventName in options.events) {\n          editor.on(eventName, options.events[eventName]);\n        }\n      }\n      return editor;\n    },\n\n    createToolbar: function createToolbar(el, options) {\n      var self = this;\n      var toolbar = $(\"<ul/>\", {\n        'class': \"wysihtml5-toolbar\",\n        'style': \"display:none\"\n      });\n      var culture = options.locale || defaultOptions.locale || \"en\";\n      for (var key in window.$.fn.wysihtml5.defaultOptions) {\n        var value = false;\n\n        if (options[key] !== undefined) {\n          if (options[key] === true) {\n            value = true;\n          }\n        } else {\n          value = defaultOptions[key];\n        }\n\n        if (value === true) {\n          toolbar.append(templates(key, locale[culture], options));\n\n          if (key === \"html\") {\n            this.initHtml(toolbar);\n          }\n\n          if (key === \"link\") {\n            this.initInsertLink(toolbar);\n          }\n\n          if (key === \"image\") {\n            this.initInsertImage(toolbar);\n          }\n        }\n      }\n\n      if (options.toolbar) {\n        for (key in options.toolbar) {\n          toolbar.append(options.toolbar[key]);\n        }\n      }\n\n      toolbar.find(\"a[data-wysihtml5-command='formatBlock']\").click(function (e) {\n        var target = e.target || e.srcElement;\n        var el = $(target);\n        self.toolbar.find('.current-font').text(el.html());\n      });\n\n      toolbar.find(\"a[data-wysihtml5-command='foreColor']\").click(function (e) {\n        var target = e.target || e.srcElement;\n        var el = $(target);\n        self.toolbar.find('.current-color').text(el.html());\n      });\n\n      this.el.before(toolbar);\n\n      return toolbar;\n    },\n\n    initHtml: function initHtml(toolbar) {\n      var changeViewSelector = \"a[data-wysihtml5-action='change_view']\";\n      toolbar.find(changeViewSelector).click(function (e) {\n        toolbar.find('a.btn').not(changeViewSelector).toggleClass('disabled');\n      });\n    },\n\n    initInsertImage: function initInsertImage(toolbar) {\n      var self = this;\n      var insertImageModal = toolbar.find('.bootstrap-wysihtml5-insert-image-modal');\n      var urlInput = insertImageModal.find('.bootstrap-wysihtml5-insert-image-url');\n      var insertButton = insertImageModal.find('a.btn-primary');\n      var initialValue = urlInput.val();\n      var caretBookmark;\n\n      var insertImage = function insertImage() {\n        var url = urlInput.val();\n        urlInput.val(initialValue);\n        self.editor.currentView.element.focus();\n        if (caretBookmark) {\n          self.editor.composer.selection.setBookmark(caretBookmark);\n          caretBookmark = null;\n        }\n        self.editor.composer.commands.exec(\"insertImage\", url);\n      };\n\n      urlInput.keypress(function (e) {\n        if (e.which == 13) {\n          insertImage();\n          insertImageModal.modal('hide');\n        }\n      });\n\n      insertButton.click(insertImage);\n\n      insertImageModal.on('shown', function () {\n        urlInput.focus();\n      });\n\n      insertImageModal.on('hide', function () {\n        self.editor.currentView.element.focus();\n      });\n\n      toolbar.find('a[data-wysihtml5-command=insertImage]').click(function () {\n        var activeButton = $(this).hasClass(\"wysihtml5-command-active\");\n\n        if (!activeButton) {\n          self.editor.currentView.element.focus(false);\n          caretBookmark = self.editor.composer.selection.getBookmark();\n          insertImageModal.appendTo('body').modal('show');\n          insertImageModal.on('click.dismiss.modal', '[data-dismiss=\"modal\"]', function (e) {\n            e.stopPropagation();\n          });\n          return false;\n        } else {\n          return true;\n        }\n      });\n    },\n\n    initInsertLink: function initInsertLink(toolbar) {\n      var self = this;\n      var insertLinkModal = toolbar.find('.bootstrap-wysihtml5-insert-link-modal');\n      var urlInput = insertLinkModal.find('.bootstrap-wysihtml5-insert-link-url');\n      var insertButton = insertLinkModal.find('a.btn-primary');\n      var initialValue = urlInput.val();\n      var caretBookmark;\n\n      var insertLink = function insertLink() {\n        var url = urlInput.val();\n        urlInput.val(initialValue);\n        self.editor.currentView.element.focus();\n        if (caretBookmark) {\n          self.editor.composer.selection.setBookmark(caretBookmark);\n          caretBookmark = null;\n        }\n        self.editor.composer.commands.exec(\"createLink\", {\n          href: url,\n          target: \"_blank\",\n          rel: \"nofollow\"\n        });\n      };\n      var pressedEnter = false;\n\n      urlInput.keypress(function (e) {\n        if (e.which == 13) {\n          insertLink();\n          insertLinkModal.modal('hide');\n        }\n      });\n\n      insertButton.click(insertLink);\n\n      insertLinkModal.on('shown', function () {\n        urlInput.focus();\n      });\n\n      insertLinkModal.on('hide', function () {\n        self.editor.currentView.element.focus();\n      });\n\n      toolbar.find('a[data-wysihtml5-command=createLink]').click(function () {\n        var activeButton = $(this).hasClass(\"wysihtml5-command-active\");\n\n        if (!activeButton) {\n          self.editor.currentView.element.focus(false);\n          caretBookmark = self.editor.composer.selection.getBookmark();\n          insertLinkModal.appendTo('body').modal('show');\n          insertLinkModal.on('click.dismiss.modal', '[data-dismiss=\"modal\"]', function (e) {\n            e.stopPropagation();\n          });\n          return false;\n        } else {\n          return true;\n        }\n      });\n    }\n  };\n\n  // these define our public api\n  var methods = {\n    resetDefaults: function resetDefaults() {\n      window.$.fn.wysihtml5.defaultOptions = $.extend(true, {}, window.$.fn.wysihtml5.defaultOptionsCache);\n    },\n    bypassDefaults: function bypassDefaults(options) {\n      return this.each(function () {\n        var $this = $(this);\n        $this.data('wysihtml5', new Wysihtml5($this, options));\n      });\n    },\n    shallowExtend: function shallowExtend(options) {\n      var settings = $.extend({}, window.$.fn.wysihtml5.defaultOptions, options || {});\n      var that = this;\n      return methods.bypassDefaults.apply(that, [settings]);\n    },\n    deepExtend: function deepExtend(options) {\n      var settings = $.extend(true, {}, window.$.fn.wysihtml5.defaultOptions, options || {});\n      var that = this;\n      return methods.bypassDefaults.apply(that, [settings]);\n    },\n    init: function init(options) {\n      var that = this;\n      return methods.shallowExtend.apply(that, [options]);\n    }\n  };\n\n  window.$.fn.wysihtml5 = function (method) {\n    if (methods[method]) {\n      return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));\n    } else if ((typeof method === \"undefined\" ? \"undefined\" : _typeof(method)) === 'object' || !method) {\n      return methods.init.apply(this, arguments);\n    } else {\n      $.error('Method ' + method + ' does not exist on jQuery.wysihtml5');\n    }\n  };\n\n  window.$.fn.wysihtml5.Constructor = Wysihtml5;\n\n  window.$.fn.wysihtml5.defaultOptions = {\n    \"font-styles\": true,\n    \"color\": false,\n    \"emphasis\": true,\n    \"lists\": true,\n    \"html\": false,\n    \"link\": true,\n    \"image\": true,\n    events: {},\n    parserRules: {\n      classes: {\n        // (path_to_project/lib/css/wysiwyg-color.css)\n        \"wysiwyg-color-clear\": 1,\n        \"wysiwyg-color-first\": 1,\n        \"wysiwyg-color-second\": 1,\n        \"wysiwyg-color-three\": 1\n      },\n      tags: {\n        \"b\": {},\n        \"i\": {},\n        \"br\": {},\n        \"ol\": {},\n        \"ul\": {},\n        \"li\": {},\n        \"h1\": {},\n        \"h2\": {},\n        \"h3\": {},\n        \"blockquote\": {},\n        \"u\": 1,\n        \"img\": {\n          \"check_attributes\": {\n            \"width\": \"numbers\",\n            \"alt\": \"alt\",\n            \"src\": \"url\",\n            \"height\": \"numbers\"\n          }\n        },\n        \"a\": {\n          set_attributes: {\n            target: \"_blank\",\n            rel: \"nofollow\"\n          },\n          check_attributes: {\n            href: \"url\" // important to avoid XSS\n          }\n        },\n        \"span\": 1,\n        \"div\": 1,\n        // to allow save and edit files with code tag hacks\n        \"code\": 1,\n        \"pre\": 1\n      }\n    },\n    stylesheets: [\"./lib/css/wysiwyg-color.css\"], // (path_to_project/lib/css/wysiwyg-color.css)\n    locale: \"en\"\n  };\n\n  if (typeof window.$.fn.wysihtml5.defaultOptionsCache === 'undefined') {\n    window.$.fn.wysihtml5.defaultOptionsCache = $.extend(true, {}, window.$.fn.wysihtml5.defaultOptions);\n  }\n\n  var locale = window.$.fn.wysihtml5.locale = {\n    en: {\n      font_styles: {\n        normal: \"Normal text\",\n        h1: \"Heading 1\",\n        h2: \"Heading 2\",\n        h3: \"Heading 3\"\n      },\n      emphasis: {\n        bold: \"Bold\",\n        italic: \"Italic\",\n        underline: \"Underline\"\n      },\n      lists: {\n        unordered: \"Unordered list\",\n        ordered: \"Ordered list\",\n        outdent: \"Outdent\",\n        indent: \"Indent\"\n      },\n      link: {\n        insert: \"Insert link\",\n        cancel: \"Cancel\"\n      },\n      image: {\n        insert: \"Insert image\",\n        cancel: \"Cancel\"\n      },\n      html: {\n        edit: \"Edit HTML\"\n      },\n      colours: {\n        clear: \"Clear\",\n        first: \"é¦–é€‰\",\n        second: \"æ¬¡é€‰\",\n        three: \"å¤‡é€‰\",\n        black: \"Black\",\n        silver: \"Silver\",\n        gray: \"Grey\",\n        maroon: \"Maroon\",\n        red: \"Red\",\n        purple: \"Purple\",\n        green: \"Green\",\n        olive: \"Olive\",\n        navy: \"Navy\",\n        blue: \"Blue\",\n        orange: \"Orange\"\n      }\n    }\n  };\n}(window.jQuery, window.wysihtml5);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvZWRpdGFibGUvanMvd3lzaWh0bWw1LmpzPzJiYjYiXSwibmFtZXMiOlsiX3R5cGVvZiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwib2JqIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJ3eXNpaHRtbDUiLCJ2ZXJzaW9uIiwiY29tbWFuZHMiLCJkb20iLCJxdWlya3MiLCJ0b29sYmFyIiwibGFuZyIsInNlbGVjdGlvbiIsInZpZXdzIiwiSU5WSVNJQkxFX1NQQUNFIiwiRU1QVFlfRlVOQ1RJT04iLCJFTEVNRU5UX05PREUiLCJURVhUX05PREUiLCJCQUNLU1BBQ0VfS0VZIiwiRU5URVJfS0VZIiwiRVNDQVBFX0tFWSIsIlNQQUNFX0tFWSIsIkRFTEVURV9LRVkiLCJ3aW5kb3ciLCJPQkpFQ1QiLCJGVU5DVElPTiIsIlVOREVGSU5FRCIsImRvbVJhbmdlUHJvcGVydGllcyIsImRvbVJhbmdlTWV0aG9kcyIsInRleHRSYW5nZVByb3BlcnRpZXMiLCJ0ZXh0UmFuZ2VNZXRob2RzIiwiaXNIb3N0TWV0aG9kIiwibyIsInAiLCJ0IiwiaXNIb3N0T2JqZWN0IiwiaXNIb3N0UHJvcGVydHkiLCJjcmVhdGVNdWx0aXBsZVByb3BlcnR5VGVzdCIsInRlc3RGdW5jIiwicHJvcHMiLCJpIiwibGVuZ3RoIiwiYXJlSG9zdE1ldGhvZHMiLCJhcmVIb3N0T2JqZWN0cyIsImFyZUhvc3RQcm9wZXJ0aWVzIiwiaXNUZXh0UmFuZ2UiLCJyYW5nZSIsImFwaSIsImluaXRpYWxpemVkIiwic3VwcG9ydGVkIiwidXRpbCIsImZlYXR1cmVzIiwibW9kdWxlcyIsImNvbmZpZyIsImFsZXJ0T25XYXJuIiwicHJlZmVyVGV4dFJhbmdlIiwiZmFpbCIsInJlYXNvbiIsImFsZXJ0Iiwid2FybiIsIm1zZyIsIndhcm5pbmdNZXNzYWdlIiwiY29uc29sZSIsImxvZyIsImhhc093blByb3BlcnR5IiwiZXh0ZW5kIiwiaW5pdExpc3RlbmVycyIsIm1vZHVsZUluaXRpYWxpemVycyIsImluaXQiLCJ0ZXN0UmFuZ2UiLCJpbXBsZW1lbnRzRG9tUmFuZ2UiLCJpbXBsZW1lbnRzVGV4dFJhbmdlIiwiZG9jdW1lbnQiLCJjcmVhdGVSYW5nZSIsImRldGFjaCIsImJvZHkiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImNyZWF0ZVRleHRSYW5nZSIsImFsbExpc3RlbmVycyIsImNvbmNhdCIsImxlbiIsImV4IiwiYWRkSW5pdExpc3RlbmVyIiwibGlzdGVuZXIiLCJwdXNoIiwiY3JlYXRlTWlzc2luZ05hdGl2ZUFwaUxpc3RlbmVycyIsImFkZENyZWF0ZU1pc3NpbmdOYXRpdmVBcGlMaXN0ZW5lciIsImNyZWF0ZU1pc3NpbmdOYXRpdmVBcGkiLCJ3aW4iLCJNb2R1bGUiLCJuYW1lIiwiRXJyb3IiLCJjcmVhdGVFcnJvciIsImNyZWF0ZU1vZHVsZSIsImluaXRGdW5jIiwibW9kdWxlIiwicmVxdWlyZU1vZHVsZXMiLCJtb2R1bGVOYW1lIiwiZG9jUmVhZHkiLCJsb2FkSGFuZGxlciIsImUiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJyYW5neSIsIlVOREVGIiwiZWwiLCJjcmVhdGVFbGVtZW50IiwidGV4dE5vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsImFycmF5Q29udGFpbnMiLCJhcnIiLCJ2YWwiLCJpc0h0bWxOYW1lc3BhY2UiLCJub2RlIiwibnMiLCJuYW1lc3BhY2VVUkkiLCJwYXJlbnRFbGVtZW50IiwicGFyZW50IiwicGFyZW50Tm9kZSIsIm5vZGVUeXBlIiwiZ2V0Tm9kZUluZGV4IiwicHJldmlvdXNTaWJsaW5nIiwiZ2V0Tm9kZUxlbmd0aCIsImNoaWxkTm9kZXMiLCJpc0NoYXJhY3RlckRhdGFOb2RlIiwiZ2V0Q29tbW9uQW5jZXN0b3IiLCJub2RlMSIsIm5vZGUyIiwiYW5jZXN0b3JzIiwibiIsImlzQW5jZXN0b3JPZiIsImFuY2VzdG9yIiwiZGVzY2VuZGFudCIsInNlbGZJc0FuY2VzdG9yIiwiZ2V0Q2xvc2VzdEFuY2VzdG9ySW4iLCJpbnNlcnRBZnRlciIsInByZWNlZGluZ05vZGUiLCJuZXh0Tm9kZSIsIm5leHRTaWJsaW5nIiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJzcGxpdERhdGFOb2RlIiwiaW5kZXgiLCJuZXdOb2RlIiwiY2xvbmVOb2RlIiwiZGVsZXRlRGF0YSIsImdldERvY3VtZW50Iiwib3duZXJEb2N1bWVudCIsImdldFdpbmRvdyIsImRvYyIsImRlZmF1bHRWaWV3IiwicGFyZW50V2luZG93IiwiZ2V0SWZyYW1lRG9jdW1lbnQiLCJpZnJhbWVFbCIsImNvbnRlbnREb2N1bWVudCIsImNvbnRlbnRXaW5kb3ciLCJnZXRJZnJhbWVXaW5kb3ciLCJnZXRCb2R5IiwiZ2V0Um9vdENvbnRhaW5lciIsImNvbXBhcmVQb2ludHMiLCJub2RlQSIsIm9mZnNldEEiLCJub2RlQiIsIm9mZnNldEIiLCJub2RlQyIsInJvb3QiLCJjaGlsZEEiLCJjaGlsZEIiLCJmaXJzdENoaWxkIiwiZnJhZ21lbnRGcm9tTm9kZUNoaWxkcmVuIiwiZnJhZ21lbnQiLCJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwiY2hpbGQiLCJpbnNwZWN0Tm9kZSIsImRhdGEiLCJpZEF0dHIiLCJpZCIsIm5vZGVOYW1lIiwiTm9kZUl0ZXJhdG9yIiwiX25leHQiLCJfY3VycmVudCIsImhhc05leHQiLCJuZXh0IiwiY3JlYXRlSXRlcmF0b3IiLCJEb21Qb3NpdGlvbiIsIm9mZnNldCIsImVxdWFscyIsInBvcyIsImluc3BlY3QiLCJET01FeGNlcHRpb24iLCJjb2RlTmFtZSIsImNvZGUiLCJtZXNzYWdlIiwiSU5ERVhfU0laRV9FUlIiLCJISUVSQVJDSFlfUkVRVUVTVF9FUlIiLCJXUk9OR19ET0NVTUVOVF9FUlIiLCJOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlIiLCJOT1RfRk9VTkRfRVJSIiwiTk9UX1NVUFBPUlRFRF9FUlIiLCJJTlZBTElEX1NUQVRFX0VSUiIsInRvU3RyaW5nIiwiaXNOb25UZXh0UGFydGlhbGx5U2VsZWN0ZWQiLCJzdGFydENvbnRhaW5lciIsImVuZENvbnRhaW5lciIsImdldFJhbmdlRG9jdW1lbnQiLCJkaXNwYXRjaEV2ZW50IiwidHlwZSIsImFyZ3MiLCJsaXN0ZW5lcnMiLCJfbGlzdGVuZXJzIiwiY2FsbCIsInRhcmdldCIsImdldEJvdW5kYXJ5QmVmb3JlTm9kZSIsImdldEJvdW5kYXJ5QWZ0ZXJOb2RlIiwiaW5zZXJ0Tm9kZUF0UG9zaXRpb24iLCJmaXJzdE5vZGVJbnNlcnRlZCIsImNsb25lU3VidHJlZSIsInBhcnRpYWxseVNlbGVjdGVkIiwiZnJhZyIsInN1Ykl0ZXJhdG9yIiwiaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWUiLCJnZXRTdWJ0cmVlSXRlcmF0b3IiLCJpdGVyYXRlU3VidHJlZSIsInJhbmdlSXRlcmF0b3IiLCJmdW5jIiwiaXRlcmF0b3JTdGF0ZSIsIml0Iiwic3RvcCIsInN1YlJhbmdlSXRlcmF0b3IiLCJkZWxldGVTdWJ0cmVlIiwicmVtb3ZlIiwiZXh0cmFjdFN1YnRyZWUiLCJnZXROb2Rlc0luUmFuZ2UiLCJub2RlVHlwZXMiLCJmaWx0ZXIiLCJmaWx0ZXJOb2RlVHlwZXMiLCJyZWdleCIsImZpbHRlckV4aXN0cyIsIlJlZ0V4cCIsImpvaW4iLCJub2RlcyIsIlJhbmdlSXRlcmF0b3IiLCJ0ZXN0IiwiX2luc3BlY3QiLCJnZXROYW1lIiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJjbG9uZVBhcnRpYWxseVNlbGVjdGVkVGV4dE5vZGVzIiwiY29sbGFwc2VkIiwic2MiLCJzbyIsImVjIiwiZW8iLCJjb21tb25BbmNlc3RvckNvbnRhaW5lciIsImlzU2luZ2xlQ2hhcmFjdGVyRGF0YU5vZGUiLCJfZmlyc3QiLCJfbGFzdCIsInJlc2V0IiwiY3VycmVudCIsInN0YXJ0IiwiZW5kIiwicmVtb3ZlQ2hpbGQiLCJzdWJSYW5nZSIsImNsb25lUmFuZ2UiLCJjb2xsYXBzZSIsIlJhbmdlIiwidXBkYXRlQm91bmRhcmllcyIsImRldGFjaFJhbmdlIiwiUmFuZ2VFeGNlcHRpb24iLCJCQURfQk9VTkRBUllQT0lOVFNfRVJSIiwiSU5WQUxJRF9OT0RFX1RZUEVfRVJSIiwiUmFuZ2VOb2RlSXRlcmF0b3IiLCJfcG9zaXRpb24iLCJiZWZvcmVBZnRlck5vZGVUeXBlcyIsInJvb3RDb250YWluZXJOb2RlVHlwZXMiLCJyZWFkb25seU5vZGVUeXBlcyIsImluc2VydGFibGVOb2RlVHlwZXMiLCJzdXJyb3VuZE5vZGVUeXBlcyIsImNyZWF0ZUFuY2VzdG9yRmluZGVyIiwiZ2V0RG9jdW1lbnRPckZyYWdtZW50Q29udGFpbmVyIiwiZ2V0UmVhZG9ubHlBbmNlc3RvciIsImdldERvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yIiwiYXNzZXJ0Tm9Eb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3RvciIsImFsbG93U2VsZiIsImFzc2VydE5vdERldGFjaGVkIiwiYXNzZXJ0VmFsaWROb2RlVHlwZSIsImludmFsaWRUeXBlcyIsImFzc2VydFZhbGlkT2Zmc2V0IiwiYXNzZXJ0U2FtZURvY3VtZW50T3JGcmFnbWVudCIsImFzc2VydE5vZGVOb3RSZWFkT25seSIsImFzc2VydE5vZGUiLCJpc09ycGhhbiIsImlzVmFsaWRPZmZzZXQiLCJhc3NlcnRSYW5nZVZhbGlkIiwic3R5bGVFbCIsImh0bWxQYXJzaW5nQ29uZm9ybXMiLCJpbm5lckhUTUwiLCJjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQiLCJmcmFnbWVudFN0ciIsImRvY3VtZW50RWxlbWVudCIsInJhbmdlUHJvcGVydGllcyIsInMycyIsInMyZSIsImUyZSIsImUycyIsIm5fYiIsIm5fYSIsIm5fYl9hIiwibl9pIiwiUmFuZ2VQcm90b3R5cGUiLCJhdHRhY2hMaXN0ZW5lciIsImNvbXBhcmVCb3VuZGFyeVBvaW50cyIsImhvdyIsInByZWZpeEEiLCJwcmVmaXhCIiwiaW5zZXJ0Tm9kZSIsInNldFN0YXJ0QmVmb3JlIiwiY2xvbmVDb250ZW50cyIsImNsb25lIiwic2xpY2UiLCJjYW5TdXJyb3VuZENvbnRlbnRzIiwiYm91bmRhcmllc0ludmFsaWQiLCJzdXJyb3VuZENvbnRlbnRzIiwiY29udGVudCIsImV4dHJhY3RDb250ZW50cyIsImhhc0NoaWxkTm9kZXMiLCJsYXN0Q2hpbGQiLCJzZWxlY3ROb2RlIiwicHJvcCIsInRleHRCaXRzIiwiY29tcGFyZU5vZGUiLCJub2RlSW5kZXgiLCJzdGFydENvbXBhcmlzb24iLCJjb21wYXJlUG9pbnQiLCJlbmRDb21wYXJpc29uIiwidG9IdG1sIiwiY29udGFpbmVyIiwiaW50ZXJzZWN0c05vZGUiLCJ0b3VjaGluZ0lzSW50ZXJzZWN0aW5nIiwiaXNQb2ludEluUmFuZ2UiLCJpbnRlcnNlY3RzUmFuZ2UiLCJpbnRlcnNlY3Rpb24iLCJpbnRlcnNlY3Rpb25SYW5nZSIsInNldFN0YXJ0Iiwic2V0RW5kIiwidW5pb24iLCJ1bmlvblJhbmdlIiwiY29udGFpbnNOb2RlIiwiYWxsb3dQYXJ0aWFsIiwiY29udGFpbnNOb2RlQ29udGVudHMiLCJjb250YWluc1JhbmdlIiwiY29udGFpbnNOb2RlVGV4dCIsIm5vZGVSYW5nZSIsInRleHROb2RlcyIsImdldE5vZGVzIiwibGFzdFRleHROb2RlIiwicG9wIiwiY29udGFpbnMiLCJjcmVhdGVOb2RlSXRlcmF0b3IiLCJjb2xsYXBzZUJlZm9yZSIsInNldEVuZEJlZm9yZSIsImNvbGxhcHNlQWZ0ZXIiLCJzZXRTdGFydEFmdGVyIiwicmFuZ2VzRXF1YWwiLCJjb3B5Q29tcGFyaXNvbkNvbnN0YW50c1RvT2JqZWN0IiwiU1RBUlRfVE9fU1RBUlQiLCJTVEFSVF9UT19FTkQiLCJFTkRfVE9fRU5EIiwiRU5EX1RPX1NUQVJUIiwiTk9ERV9CRUZPUkUiLCJOT0RFX0FGVEVSIiwiTk9ERV9CRUZPUkVfQU5EX0FGVEVSIiwiTk9ERV9JTlNJREUiLCJjb3B5Q29tcGFyaXNvbkNvbnN0YW50cyIsImNyZWF0ZVJhbmdlQ29udGVudFJlbW92ZXIiLCJyZW1vdmVyIiwiYm91bmRhcnlVcGRhdGVyIiwiYm91bmRhcnkiLCJyZXR1cm5WYWx1ZSIsImNyZWF0ZVByb3RvdHlwZVJhbmdlIiwiZGV0YWNoZXIiLCJjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIiLCJpc0JlZm9yZSIsImlzU3RhcnQiLCJzZXRSYW5nZVN0YXJ0Iiwic2V0UmFuZ2VFbmQiLCJzZXRSYW5nZVN0YXJ0QW5kRW5kIiwic2V0RW5kQWZ0ZXIiLCJzZWxlY3ROb2RlQ29udGVudHMiLCJkZWxldGVDb250ZW50cyIsInNwbGl0Qm91bmRhcmllcyIsInN0YXJ0RW5kU2FtZSIsIm5vcm1hbGl6ZUJvdW5kYXJpZXMiLCJtZXJnZUZvcndhcmQiLCJzaWJsaW5nIiwiYXBwZW5kRGF0YSIsIm1lcmdlQmFja3dhcmQiLCJub2RlTGVuZ3RoIiwiaW5zZXJ0RGF0YSIsIm5vcm1hbGl6ZVN0YXJ0IiwiZW5kTm9kZSIsInN0YXJ0Tm9kZSIsImNvbGxhcHNlVG9Qb2ludCIsInVwZGF0ZUNvbGxhcHNlZEFuZENvbW1vbkFuY2VzdG9yIiwic3RhcnRNb3ZlZCIsImVuZE1vdmVkIiwiYm91bmRhcnljaGFuZ2UiLCJyYW5nZVByb3RvdHlwZSIsInIxIiwicjIiLCJEb21SYW5nZSIsIldyYXBwZWRSYW5nZSIsImdldFRleHRSYW5nZUNvbnRhaW5lckVsZW1lbnQiLCJ0ZXh0UmFuZ2UiLCJwYXJlbnRFbCIsImR1cGxpY2F0ZSIsInN0YXJ0RWwiLCJlbmRFbCIsInN0YXJ0RW5kQ29udGFpbmVyIiwidGV4dFJhbmdlSXNDb2xsYXBzZWQiLCJjb21wYXJlRW5kUG9pbnRzIiwiZ2V0VGV4dFJhbmdlQm91bmRhcnlQb3NpdGlvbiIsIndob2xlUmFuZ2VDb250YWluZXJFbGVtZW50IiwiaXNDb2xsYXBzZWQiLCJ3b3JraW5nUmFuZ2UiLCJjb250YWluZXJFbGVtZW50IiwiY2FuSGF2ZUhUTUwiLCJ3b3JraW5nTm9kZSIsImNvbXBhcmlzb24iLCJ3b3JraW5nQ29tcGFyaXNvblR5cGUiLCJwcmV2aW91c05vZGUiLCJib3VuZGFyeVBvc2l0aW9uIiwiYm91bmRhcnlOb2RlIiwibW92ZVRvRWxlbWVudFRleHQiLCJzZXRFbmRQb2ludCIsInRlbXBSYW5nZSIsInJhbmdlTGVuZ3RoIiwidGV4dCIsInJlcGxhY2UiLCJtb3ZlU3RhcnQiLCJjcmVhdGVCb3VuZGFyeVRleHRSYW5nZSIsImJvdW5kYXJ5UGFyZW50IiwiYm91bmRhcnlPZmZzZXQiLCJub2RlSXNEYXRhTm9kZSIsInJhbmdlUHJvdG8iLCJjYW5TZXRSYW5nZVN0YXJ0QWZ0ZXJFbmQiLCJ1cGRhdGVSYW5nZVByb3BlcnRpZXMiLCJuYXRpdmVSYW5nZSIsInVwZGF0ZU5hdGl2ZVJhbmdlIiwiZGV0YWNoZWQiLCJyZWZyZXNoIiwidGVzdFRleHROb2RlIiwib3Bwb3NpdGVOYW1lIiwiZ2V0RW5kT2Zmc2V0IiwicmFuZ2UyIiwiY3JlYXRlTmF0aXZlUmFuZ2UiLCJyYW5nZUNvbnRhaW5lckVsZW1lbnQiLCJnbG9iYWxPYmoiLCJyYW5nZVRvVGV4dFJhbmdlIiwidHIiLCJzdGFydFJhbmdlIiwiZW5kUmFuZ2UiLCJjcmVhdGVSYW5neVJhbmdlIiwiY3JlYXRlSWZyYW1lUmFuZ2UiLCJjcmVhdGVJZnJhbWVSYW5neVJhbmdlIiwiY2hlY2tTZWxlY3Rpb25SYW5nZXMiLCJCT09MRUFOIiwid2luZG93UHJvcGVydHlOYW1lIiwiZ2V0U2VsZWN0aW9uIiwic2VsZWN0aW9uSXNDb2xsYXBzZWQiLCJDT05UUk9MIiwiZ2V0V2luU2VsZWN0aW9uIiwid2luUGFyYW0iLCJnZXREb2NTZWxlY3Rpb24iLCJpbXBsZW1lbnRzV2luR2V0U2VsZWN0aW9uIiwiaW1wbGVtZW50c0RvY1NlbGVjdGlvbiIsInVzZURvY3VtZW50U2VsZWN0aW9uIiwiaXNTZWxlY3Rpb25WYWxpZCIsIm5hdGl2ZVNlbCIsImdldE5hdGl2ZVNlbGVjdGlvbiIsInRlc3RTZWxlY3Rpb24iLCJzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cyIsInNlbGVjdGlvbkhhc0V4dGVuZCIsInNlbGVjdGlvbkhhc1JhbmdlQ291bnQiLCJyYW5nZUNvdW50Iiwic2VsZWN0aW9uU3VwcG9ydHNNdWx0aXBsZVJhbmdlcyIsImNvbGxhcHNlZE5vbkVkaXRhYmxlU2VsZWN0aW9uc1N1cHBvcnRlZCIsImlmcmFtZSIsImlmcmFtZURvYyIsIm9wZW4iLCJ3cml0ZSIsImNsb3NlIiwic2VsIiwiZG9jRWwiLCJpZnJhbWVCb2R5IiwiYWRkUmFuZ2UiLCJyZW1vdmVBbGxSYW5nZXMiLCJpbXBsZW1lbnRzQ29udHJvbFJhbmdlIiwidGVzdENvbnRyb2xSYW5nZSIsImNyZWF0ZUNvbnRyb2xSYW5nZSIsImFuY2hvck5vZGUiLCJmb2N1c05vZGUiLCJhbmNob3JPZmZzZXQiLCJmb2N1c09mZnNldCIsImdldFJhbmdlQXQiLCJ1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21SYW5nZSIsImJhY2t3YXJkcyIsImFuY2hvclByZWZpeCIsImZvY3VzUHJlZml4IiwidXBkYXRlQW5jaG9yQW5kRm9jdXNGcm9tTmF0aXZlU2VsZWN0aW9uIiwibmF0aXZlU2VsZWN0aW9uIiwidXBkYXRlRW1wdHlTZWxlY3Rpb24iLCJfcmFuZ2VzIiwiZ2V0TmF0aXZlUmFuZ2UiLCJfc2VsZWN0aW9uTmF0aXZlUmFuZ2UiLCJyYW5nZUNvbnRhaW5zU2luZ2xlRWxlbWVudCIsInJhbmdlTm9kZXMiLCJnZXRTaW5nbGVFbGVtZW50RnJvbVJhbmdlIiwidXBkYXRlRnJvbVRleHRSYW5nZSIsIndyYXBwZWRSYW5nZSIsInVwZGF0ZUNvbnRyb2xTZWxlY3Rpb24iLCJkb2NTZWxlY3Rpb24iLCJjb250cm9sUmFuZ2UiLCJpdGVtIiwiYWRkUmFuZ2VUb0NvbnRyb2xTZWxlY3Rpb24iLCJyYW5nZUVsZW1lbnQiLCJuZXdDb250cm9sUmFuZ2UiLCJhZGQiLCJzZWxlY3QiLCJnZXRTZWxlY3Rpb25SYW5nZUF0IiwiV3JhcHBlZFNlbGVjdGlvbiIsImRvY1NlbCIsImdldElmcmFtZVNlbGVjdGlvbiIsInNlbFByb3RvIiwiY3JlYXRlQ29udHJvbFNlbGVjdGlvbiIsInJhbmdlcyIsImFkZFJhbmdlQmFja3dhcmRzIiwicHJldmlvdXNSYW5nZUNvdW50Iiwic2VsZWN0aW9uSXNCYWNrd2FyZHMiLCJzZXRSYW5nZXMiLCJlbXB0eSIsInJlZnJlc2hTZWxlY3Rpb24iLCJjaGVja0ZvckNoYW5nZXMiLCJvbGRSYW5nZXMiLCJyZW1vdmVSYW5nZU1hbnVhbGx5IiwiZ2V0QWxsUmFuZ2VzIiwicmVtb3ZlZCIsInJlbW92ZVJhbmdlIiwiaXNCYWNrd2FyZHMiLCJyYW5nZVRleHRzIiwiYXNzZXJ0Tm9kZUluU2FtZURvY3VtZW50IiwiY29sbGFwc2VUb1N0YXJ0IiwiY29sbGFwc2VUb0VuZCIsInNlbGVjdEFsbENoaWxkcmVuIiwiZGVsZXRlRnJvbURvY3VtZW50IiwiZWxlbWVudCIsInNldFNpbmdsZVJhbmdlIiwiaHRtbCIsInJhbmdlSW5zcGVjdHMiLCJhbmNob3IiLCJmb2N1cyIsIlNlbGVjdGlvbiIsInNlbGVjdGlvblByb3RvdHlwZSIsIkJhc2UiLCJfaW5zdGFuY2UiLCJfc3RhdGljIiwiX3Byb3RvdHlwaW5nIiwicHJvdG8iLCJiYXNlIiwia2xhc3MiLCJfY29uc3RydWN0aW5nIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJmb3JFYWNoIiwiaW1wbGVtZW50IiwidmFsdWVPZiIsInNvdXJjZSIsInZhbHVlIiwibWV0aG9kIiwicHJldmlvdXMiLCJ0b1NvdXJjZSIsImhpZGRlbiIsImtleSIsIk9iamVjdCIsIm9iamVjdCIsImJsb2NrIiwiY29udGV4dCIsInVuZGVmaW5lZCIsIlN0cmluZyIsImJyb3dzZXIiLCJ1c2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJ0ZXN0RWxlbWVudCIsImlzSUUiLCJpbmRleE9mIiwiaXNHZWNrbyIsImlzV2ViS2l0IiwiaXNDaHJvbWUiLCJpc09wZXJhIiwiaW9zVmVyc2lvbiIsIm1hdGNoIiwiVVNFUl9BR0VOVCIsInRvTG93ZXJDYXNlIiwiaGFzQ29udGVudEVkaXRhYmxlU3VwcG9ydCIsImhhc0VkaXRpbmdBcGlTdXBwb3J0IiwiZXhlY0NvbW1hbmQiLCJxdWVyeUNvbW1hbmRTdXBwb3J0ZWQiLCJxdWVyeUNvbW1hbmRTdGF0ZSIsImhhc1F1ZXJ5U2VsZWN0b3JTdXBwb3J0IiwicXVlcnlTZWxlY3RvciIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpc0luY29tcGF0aWJsZU1vYmlsZUJyb3dzZXIiLCJpc0lvcyIsImlzVG91Y2hEZXZpY2UiLCJzdXBwb3J0c0V2ZW50Iiwic3VwcG9ydHNTYW5kYm94ZWRJZnJhbWVzIiwidGhyb3dzTWl4ZWRDb250ZW50V2FybmluZ1doZW5JZnJhbWVTcmNJc0VtcHR5IiwiZGlzcGxheXNDYXJldEluRW1wdHlDb250ZW50RWRpdGFibGVDb3JyZWN0bHkiLCJoYXNDdXJyZW50U3R5bGVQcm9wZXJ0eSIsImluc2VydHNMaW5lQnJlYWtzT25SZXR1cm4iLCJzdXBwb3J0c1BsYWNlaG9sZGVyQXR0cmlidXRlT24iLCJldmVudE5hbWUiLCJzZXRBdHRyaWJ1dGUiLCJzdXBwb3J0c0V2ZW50c0luSWZyYW1lQ29ycmVjdGx5IiwiZmlyZXNPbkRyb3BPbmx5V2hlbk9uRHJhZ092ZXJJc0NhbmNlbGxlZCIsInN1cHBvcnRzRGF0YVRyYW5zZmVyIiwiQ2xpcGJvYXJkIiwiRGF0YVRyYW5zZmVyIiwiZ2V0RGF0YSIsInN1cHBvcnRzSFRNTDVUYWdzIiwiaHRtbDUiLCJzdXBwb3J0c0NvbW1hbmQiLCJidWdneUNvbW1hbmRzIiwiY29tbWFuZCIsImlzQnVnZ3kiLCJlMSIsInF1ZXJ5Q29tbWFuZEVuYWJsZWQiLCJlMiIsImRvZXNBdXRvTGlua2luZ0luQ29udGVudEVkaXRhYmxlIiwiY2FuRGlzYWJsZUF1dG9MaW5raW5nIiwiY2xlYXJzQ29udGVudEVkaXRhYmxlQ29ycmVjdGx5Iiwic3VwcG9ydHNHZXRBdHRyaWJ1dGVDb3JyZWN0bHkiLCJ0ZCIsImdldEF0dHJpYnV0ZSIsImNhblNlbGVjdEltYWdlc0luQ29udGVudEVkaXRhYmxlIiwiY2xlYXJzTGlzdHNJbkNvbnRlbnRFZGl0YWJsZUNvcnJlY3RseSIsImF1dG9TY3JvbGxzVG9DYXJldCIsImF1dG9DbG9zZXNVbmNsb3NlZFRhZ3MiLCJjbG9uZWRUZXN0RWxlbWVudCIsInN1cHBvcnRzTmF0aXZlR2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJzdXBwb3J0c1NlbGVjdGlvbk1vZGlmeSIsInN1cHBvcnRzQ2xhc3NMaXN0IiwibmVlZHNTcGFjZUFmdGVyTGluZUJyZWFrIiwic3VwcG9ydHNTcGVlY2hBcGlPbiIsImlucHV0IiwiY2hyb21lVmVyc2lvbiIsImNyYXNoZXNXaGVuRGVmaW5lUHJvcGVydHkiLCJwcm9wZXJ0eSIsImRvZXNBc3luY0ZvY3VzIiwiaGFzUHJvYmxlbXNTZXR0aW5nQ2FyZXRBZnRlckltZyIsImhhc1VuZG9JbkNvbnRleHRNZW51IiwiYXJyYXkiLCJuZWVkbGUiLCJ3aXRob3V0IiwiYXJyYXlUb1N1YnN0cmFjdCIsIm5ld0FyciIsImdldCIsIm5ld0FycmF5IiwiRGlzcGF0Y2hlciIsIm9ic2VydmUiLCJoYW5kbGVyIiwiZXZlbnRzIiwib24iLCJmaXJlIiwicGF5bG9hZCIsImhhbmRsZXJzIiwic3RvcE9ic2VydmluZyIsIm5ld0hhbmRsZXJzIiwibWVyZ2UiLCJvdGhlck9iaiIsIm5ld09iaiIsImlzQXJyYXkiLCJXSElURV9TUEFDRV9TVEFSVCIsIldISVRFX1NQQUNFX0VORCIsInN0cmluZyIsInN0ciIsInRyaW0iLCJpbnRlcnBvbGF0ZSIsInZhcnMiLCJieSIsInNlYXJjaCIsInNwbGl0IiwiSUdOT1JFX1VSTFNfSU4iLCJVUkxfUkVHX0VYUCIsIlRSQUlMSU5HX0NIQVJfUkVHX0VYUCIsIk1BWF9ESVNQTEFZX0xFTkdUSCIsIkJSQUNLRVRTIiwiYXV0b0xpbmsiLCJfaGFzUGFyZW50VGhhdFNob3VsZEJlSWdub3JlZCIsIl9wYXJzZU5vZGUiLCJfY29udmVydFVybHNUb0xpbmtzIiwidXJsIiwicHVuY3R1YXRpb24iLCJvcGVuaW5nIiwicmVhbFVybCIsImRpc3BsYXlVcmwiLCJzdWJzdHIiLCJfZ2V0VGVtcEVsZW1lbnQiLCJ0ZW1wRWxlbWVudCIsIl93eXNpaHRtbDVfdGVtcEVsZW1lbnQiLCJfd3JhcE1hdGNoZXNJbk5vZGUiLCJjaGlsZE5vZGVzTGVuZ3RoIiwiYWRkQ2xhc3MiLCJjbGFzc05hbWUiLCJjbGFzc0xpc3QiLCJoYXNDbGFzcyIsInJlbW92ZUNsYXNzIiwiZWxlbWVudENsYXNzTmFtZSIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiY29udmVydFRvTGlzdCIsIl9jcmVhdGVMaXN0SXRlbSIsImxpc3QiLCJsaXN0SXRlbSIsIl9jcmVhdGVMaXN0IiwibGlzdFR5cGUiLCJsaW5lQnJlYWtzIiwibGluZUJyZWFrc0xlbmd0aCIsImNoaWxkTm9kZSIsImxpbmVCcmVhayIsImlzQmxvY2tFbGVtZW50IiwiaXNMaW5lQnJlYWsiLCJjdXJyZW50TGlzdEl0ZW0iLCJnZXRTdHlsZSIsImZyb20iLCJpbnNlcnQiLCJhZnRlciIsInJlcGxhY2VDaGlsZCIsImNvcHlBdHRyaWJ1dGVzIiwiYXR0cmlidXRlc1RvQ29weSIsImVsZW1lbnRUb0NvcHlGcm9tIiwidG8iLCJlbGVtZW50VG9Db3B5VG8iLCJhdHRyaWJ1dGUiLCJhbmRUbyIsImNhbGxlZSIsIkJPWF9TSVpJTkdfUFJPUEVSVElFUyIsInNob3VsZElnbm9yZUJveFNpemluZ0JvcmRlckJveCIsImhhc0JveFNpemluZ0JvcmRlckJveCIsInBhcnNlSW50Iiwib2Zmc2V0V2lkdGgiLCJjb3B5U3R5bGVzIiwic3R5bGVzVG9Db3B5IiwiY3NzVGV4dCIsImhlaWdodF9yIiwiaGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0Iiwic2V0U3R5bGVzIiwiZGVsZWdhdGUiLCJzZWxlY3RvciIsImV2ZW50IiwiZ2V0QXNEb20iLCJfaW5uZXJIVE1MU2hpdiIsInN0eWxlIiwiZGlzcGxheSIsIl9lbnN1cmVIVE1MNUNvbXBhdGliaWxpdHkiLCJfd3lzaWh0bWw1X3N1cHBvcnRzSFRNTDVUYWdzIiwiSFRNTDVfRUxFTUVOVFMiLCJnZXRQYXJlbnRFbGVtZW50IiwiX2lzU2FtZU5vZGVOYW1lIiwiZGVzaXJlZE5vZGVOYW1lcyIsIl9pc0VsZW1lbnQiLCJfaGFzQ2xhc3NOYW1lIiwiY2xhc3NSZWdFeHAiLCJjbGFzc05hbWVzIiwiX2dldFBhcmVudEVsZW1lbnRXaXRoTm9kZU5hbWUiLCJsZXZlbHMiLCJfZ2V0UGFyZW50RWxlbWVudFdpdGhOb2RlTmFtZUFuZENsYXNzTmFtZSIsIm1hdGNoaW5nU2V0Iiwic3R5bGVQcm9wZXJ0eU1hcHBpbmciLCJSRUdfRVhQX0NBTUVMSVpFIiwiY2FtZWxpemUiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsImNhbWVsaXplZFByb3BlcnR5IiwiY3VycmVudFN0eWxlIiwic3R5bGVWYWx1ZSIsIm5lZWRzT3ZlcmZsb3dSZXNldCIsIm9yaWdpbmFsT3ZlcmZsb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwib3ZlcmZsb3ciLCJnZXRQcm9wZXJ0eVZhbHVlIiwiaGFzRWxlbWVudFdpdGhUYWdOYW1lIiwiTElWRV9DQUNIRSIsIkRPQ1VNRU5UX0lERU5USUZJRVIiLCJfZ2V0RG9jdW1lbnRJZGVudGlmaWVyIiwiX3d5c2lodG1sNV9pZGVudGlmaWVyIiwidGFnTmFtZSIsImNhY2hlRW50cnkiLCJoYXNFbGVtZW50V2l0aENsYXNzTmFtZSIsImVsZW1lbnRUb0luc2VydCIsImJlZm9yZSIsImludG8iLCJpbnNlcnRDU1MiLCJydWxlcyIsImhlYWQiLCJzdHlsZUVsZW1lbnQiLCJzdHlsZVNoZWV0IiwiZXZlbnROYW1lcyIsImhhbmRsZXJXcmFwcGVyIiwic3JjRWxlbWVudCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2FuY2VsQnViYmxlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRldGFjaEV2ZW50IiwicGFyc2UiLCJOT0RFX1RZUEVfTUFQUElORyIsIl9oYW5kbGVFbGVtZW50IiwiX2hhbmRsZVRleHQiLCJERUZBVUxUX05PREVfTkFNRSIsIldISVRFX1NQQUNFX1JFR19FWFAiLCJkZWZhdWx0UnVsZXMiLCJ0YWdzIiwiY2xhc3NlcyIsImN1cnJlbnRSdWxlcyIsImVsZW1lbnRPckh0bWwiLCJjbGVhblVwIiwiaXNTdHJpbmciLCJfY29udmVydCIsImdldENvcnJlY3RJbm5lckhUTUwiLCJvbGROb2RlIiwib2xkTm9kZVR5cGUiLCJvbGRDaGlsZHMiLCJvbGRDaGlsZHNMZW5ndGgiLCJuZXdDaGlsZCIsImF0dHJpYnV0ZXMiLCJydWxlIiwiZW5kVGFnIiwidGFnUnVsZXMiLCJzY29wZU5hbWUiLCJfd3lzaWh0bWw1Iiwib3V0ZXJIVE1MIiwicmVuYW1lX3RhZyIsIl9oYW5kbGVBdHRyaWJ1dGVzIiwic2V0Q2xhc3MiLCJzZXRfY2xhc3MiLCJhZGRfY2xhc3MiLCJzZXRBdHRyaWJ1dGVzIiwic2V0X2F0dHJpYnV0ZXMiLCJjaGVja0F0dHJpYnV0ZXMiLCJjaGVja19hdHRyaWJ1dGVzIiwiYWxsb3dlZENsYXNzZXMiLCJuZXdDbGFzc2VzIiwibmV3VW5pcXVlQ2xhc3NlcyIsIm9sZENsYXNzZXMiLCJjbGFzc2VzTGVuZ3RoIiwibmV3Q2xhc3Nlc0xlbmd0aCIsImN1cnJlbnRDbGFzcyIsIm5ld0NsYXNzIiwiYXR0cmlidXRlTmFtZSIsIm5ld0F0dHJpYnV0ZVZhbHVlIiwiYXR0cmlidXRlQ2hlY2tNZXRob2RzIiwiX2dldEF0dHJpYnV0ZSIsImFkZENsYXNzTWV0aG9kcyIsInVuc2hpZnQiLCJzcmMiLCJ3aWR0aCIsIkhBU19HRVRfQVRUUklCVVRFX0JVRyIsIl9pc0xvYWRlZEltYWdlIiwiaGFzQXR0cmlidXRlIiwiY29tcGxldGUiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJyZWFkeVN0YXRlIiwiUkVHX0VYUCIsImF0dHJpYnV0ZVZhbHVlIiwiYWx0IiwibnVtYmVycyIsImFsaWduX2ltZyIsIm1hcHBpbmciLCJsZWZ0IiwicmlnaHQiLCJhbGlnbl90ZXh0IiwiY2VudGVyIiwianVzdGlmeSIsImNsZWFyX2JyIiwiYm90aCIsImFsbCIsInNpemVfZm9udCIsInJlbW92ZUVtcHR5VGV4dE5vZGVzIiwicmVuYW1lRWxlbWVudCIsIm5ld05vZGVOYW1lIiwibmV3RWxlbWVudCIsInJlcGxhY2VXaXRoQ2hpbGROb2RlcyIsIl9pc0Jsb2NrRWxlbWVudCIsIl9pc0xpbmVCcmVhayIsIl9hcHBlbmRMaW5lQnJlYWsiLCJyZXNvbHZlTGlzdCIsInByZXZpb3VzRWxlbWVudFNpYmxpbmciLCJpc0xhc3RDaGlsZCIsInNob3VsZEFwcGVuZExpbmVCcmVhayIsIndpbmRvd1Byb3BlcnRpZXMiLCJ3aW5kb3dQcm9wZXJ0aWVzMiIsImRvY3VtZW50UHJvcGVydGllcyIsIlNhbmRib3giLCJyZWFkeUNhbGxiYWNrIiwiY2FsbGJhY2siLCJfY3JlYXRlSWZyYW1lIiwiaW5zZXJ0SW50byIsImdldEVsZW1lbnRCeUlkIiwiZ2V0SWZyYW1lIiwiX3JlYWR5RXJyb3IiLCJkZXN0cm95IiwidGhhdCIsIm9ubG9hZCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsIl9vbkxvYWRJZnJhbWUiLCJpZnJhbWVXaW5kb3ciLCJpZnJhbWVEb2N1bWVudCIsImNoYXJzZXQiLCJjaGFyYWN0ZXJTZXQiLCJzYW5kYm94SHRtbCIsIl9nZXRIdG1sIiwic3R5bGVzaGVldHMiLCJvbmVycm9yIiwiZXJyb3JNZXNzYWdlIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiX3Vuc2V0IiwibG9hZGVkIiwic2V0VGltZW91dCIsInRlbXBsYXRlVmFycyIsInNldHRlciIsIl9fZGVmaW5lR2V0dGVyX18iLCJfX2RlZmluZVNldHRlcl9fIiwic2V0IiwiZGVmaW5lUHJvcGVydHkiLCJzdHlsZXMiLCJjc3NGbG9hdCIsInN0eWxlRmxvYXQiLCJzaW11bGF0ZVBsYWNlaG9sZGVyIiwiZWRpdG9yIiwidmlldyIsInBsYWNlaG9sZGVyVGV4dCIsIkNMQVNTX05BTUUiLCJ1bnNldCIsImhhc1BsYWNlaG9sZGVyU2V0IiwiY2xlYXIiLCJpc0VtcHR5Iiwic2V0VmFsdWUiLCJzZXRUZXh0Q29udGVudCIsInRleHRDb250ZW50IiwiZ2V0VGV4dENvbnRlbnQiLCJpbm5lclRleHQiLCJub2RlVmFsdWUiLCJjbGVhblBhc3RlZEhUTUwiLCJtYXRjaGVzIiwibWF0Y2hlc0xlbmd0aCIsImoiLCJlbHMiLCJkaXZzIiwiZGl2IiwibmV3X2RpdiIsInJlcGxhY2VXaXRoIiwicF9lbHMiLCIkIiwiYnJfZWxzIiwiYnIiLCJlbnN1cmVQcm9wZXJDbGVhcmluZyIsImNsZWFySWZOZWNlc3NhcnkiLCJjb21wb3NlciIsImVuc3VyZVByb3BlckNsZWFyaW5nT2ZMaXN0cyIsIkVMRU1FTlRTX1RIQVRfQ09OVEFJTl9MSSIsImNvbnRlbnRFZGl0YWJsZUVsZW1lbnQiLCJsaXN0SXNGaXJzdENoaWxkT2ZDb250ZW50RWRpdGFibGUiLCJoYXNPbmx5T25lTGlzdEl0ZW0iLCJvbmx5TGlzdEl0ZW1Jc0VtcHR5Iiwia2V5Q29kZSIsImdldFNlbGVjdGVkTm9kZSIsIlRJTERFX0VTQ0FQRUQiLCJlbGVtZW50c1dpdGhUaWxkZSIsInVybFRvU2VhcmNoIiwiaHJlZiIsIlVTRV9OQVRJVkVfTElORV9CUkVBS19XSEVOX0NBUkVUX0lOU0lERV9UQUdTIiwiTElTVF9UQUdTIiwiaW5zZXJ0TGluZUJyZWFrT25SZXR1cm4iLCJ1bndyYXAiLCJzZWxlY3RlZE5vZGUiLCJpbnZpc2libGVTcGFjZSIsImtleURvd24iLCJzaGlmdEtleSIsImJsb2NrRWxlbWVudCIsImV4ZWMiLCJyZWRyYXciLCJfZ2V0Q3VtdWxhdGl2ZU9mZnNldFRvcCIsInRvcCIsIm9mZnNldFRvcCIsIm9mZnNldFBhcmVudCIsImdldEJvb2ttYXJrIiwiZ2V0UmFuZ2UiLCJzZXRCb29rbWFyayIsImJvb2ttYXJrIiwic2V0U2VsZWN0aW9uIiwic2V0QmVmb3JlIiwic2V0QWZ0ZXIiLCJpc0VsZW1lbnQiLCJkaXNwbGF5U3R5bGUiLCJleGVjdXRlQW5kUmVzdG9yZSIsInJlc3RvcmVTY3JvbGxQb3NpdGlvbiIsIm9sZFNjcm9sbFRvcCIsInNjcm9sbFRvcCIsIm9sZFNjcm9sbExlZnQiLCJzY3JvbGxMZWZ0IiwicGxhY2Vob2xkZXJIVE1MIiwibmV3UmFuZ2UiLCJlMyIsImNhcmV0UGxhY2Vob2xkZXIiLCJlNCIsImV4ZWN1dGVBbmRSZXN0b3JlU2ltcGxlIiwiZmlyc3ROb2RlIiwibGFzdE5vZGUiLCJyYW5nZUJhY2t1cCIsImluc2VydEhUTUwiLCJzdXJyb3VuZCIsInNjcm9sbEludG9WaWV3IiwiaGFzU2Nyb2xsQmFycyIsInNjcm9sbEhlaWdodCIsIl93eXNpaHRtbDVTY3JvbGxJbnRvVmlld0VsZW1lbnQiLCJzZWxlY3RMaW5lIiwiX3NlbGVjdExpbmVfVzNDIiwiX3NlbGVjdExpbmVfTVNJRSIsIm1vZGlmeSIsInJhbmdlVG9wIiwiYm91bmRpbmdUb3AiLCJyYW5nZUhlaWdodCIsImJvdW5kaW5nSGVpZ2h0Iiwic2Nyb2xsV2lkdGgiLCJyYW5nZUJvdHRvbSIsInJhbmdlRW5kIiwibWVhc3VyZU5vZGUiLCJtb3ZlVG9Qb2ludCIsImdldFRleHQiLCJkZWZhdWx0VGFnTmFtZSIsIlJFR19FWFBfV0hJVEVfU1BBQ0UiLCJjc3NDbGFzcyIsInJlZ0V4cCIsIm1hdGNoaW5nQ2xhc3NOYW1lcyIsImhhc1NhbWVDbGFzc2VzIiwiZWwxIiwiZWwyIiwicmVwbGFjZVdpdGhPd25DaGlsZHJlbiIsImVsZW1lbnRzSGF2ZVNhbWVOb25DbGFzc0F0dHJpYnV0ZXMiLCJhdHRyMSIsImF0dHIyIiwiZ2V0TmFtZWRJdGVtIiwic3BlY2lmaWVkIiwiaXNTcGxpdFBvaW50Iiwic3BsaXROb2RlQXQiLCJkZXNjZW5kYW50Tm9kZSIsImRlc2NlbmRhbnRPZmZzZXQiLCJyZW1vdmVBdHRyaWJ1dGUiLCJNZXJnZSIsImlzRWxlbWVudE1lcmdlIiwiZmlyc3RUZXh0Tm9kZSIsImRvTWVyZ2UiLCJnZXRMZW5ndGgiLCJIVE1MQXBwbGllciIsInRhZ05hbWVzIiwic2ltaWxhckNsYXNzUmVnRXhwIiwibm9ybWFsaXplIiwiYXBwbHlUb0FueVRhZ05hbWUiLCJnZXRBbmNlc3RvcldpdGhDbGFzcyIsImNzc0NsYXNzTWF0Y2giLCJwb3N0QXBwbHkiLCJtZXJnZXMiLCJjdXJyZW50TWVyZ2UiLCJyYW5nZVN0YXJ0Tm9kZSIsInJhbmdlRW5kTm9kZSIsInJhbmdlU3RhcnRPZmZzZXQiLCJyYW5nZUVuZE9mZnNldCIsInByZWNlZGluZ1RleHROb2RlIiwiZ2V0QWRqYWNlbnRNZXJnZWFibGVUZXh0Tm9kZSIsIm5leHRUZXh0Tm9kZSIsImZvcndhcmQiLCJpc1RleHROb2RlIiwiYWRqYWNlbnROb2RlIiwicHJvcE5hbWUiLCJhcmVFbGVtZW50c01lcmdlYWJsZSIsImNyZWF0ZUNvbnRhaW5lciIsImFwcGx5VG9UZXh0Tm9kZSIsImlzUmVtb3ZhYmxlIiwidW5kb1RvVGV4dE5vZGUiLCJhbmNlc3RvcldpdGhDbGFzcyIsImFuY2VzdG9yUmFuZ2UiLCJhcHBseVRvUmFuZ2UiLCJ1bmRvVG9SYW5nZSIsImdldFRleHRTZWxlY3RlZEJ5UmFuZ2UiLCJpc0FwcGxpZWRUb1JhbmdlIiwic2VsZWN0ZWRUZXh0IiwidG9nZ2xlUmFuZ2UiLCJDb21tYW5kcyIsInN1cHBvcnQiLCJyZXN1bHQiLCJzdGF0ZSIsImNvbW1hbmRWYWx1ZSIsInF1ZXJ5Q29tbWFuZFZhbHVlIiwidW5kZWYiLCJib2xkIiwiZm9ybWF0SW5saW5lIiwiY29sb3IiLCJOT0RFX05BTUUiLCJfcmVtb3ZlRm9ybWF0IiwiYW5jaG9ycyIsImNvZGVFbGVtZW50IiwiX2Zvcm1hdCIsInRlbXBDbGFzcyIsIkRhdGUiLCJ0ZW1wQ2xhc3NSZWdFeHAiLCJoYXNFbGVtZW50Q2hpbGQiLCJlbGVtZW50VG9TZXRDYXJldEFmdGVyIiwid2hpdGVTcGFjZSIsImNyZWF0ZUxpbmsiLCJmb250U2l6ZSIsInNpemUiLCJmb3JlQ29sb3IiLCJCTE9DS19FTEVNRU5UU19HUk9VUCIsIl9hZGRDbGFzcyIsIl9yZW1vdmVDbGFzcyIsIl9pc0JsYW5rVGV4dE5vZGUiLCJfZ2V0UHJldmlvdXNTaWJsaW5nVGhhdElzTm90QmxhbmsiLCJfZ2V0TmV4dFNpYmxpbmdUaGF0SXNOb3RCbGFuayIsIl9hZGRMaW5lQnJlYWtCZWZvcmVBbmRBZnRlciIsIl9pc0xpbmVCcmVha09yQmxvY2tFbGVtZW50IiwiX3JlbW92ZUxpbmVCcmVha0JlZm9yZUFuZEFmdGVyIiwiX3JlbW92ZUxhc3RDaGlsZElmTGluZUJyZWFrIiwiX2V4ZWNDb21tYW5kIiwiZXZlbnRMaXN0ZW5lciIsIl9zZWxlY3RMaW5lQW5kV3JhcCIsIl9oYXNDbGFzc2VzIiwiZm9ybWF0QmxvY2siLCJoYXNDbGFzc2VzIiwiQUxJQVNfTUFQUElORyIsImh0bWxBcHBsaWVyIiwiX2dldFRhZ05hbWVzIiwiYWxpYXMiLCJfZm9ybWF0Q2xlYXIiLCJlYWNoIiwiY2hpbGRyZW4iLCJmb250X2VsIiwic3Bhbl9lbCIsInJlZHVjZWRfZGltZW5zaW9uIiwibm90X3NwYW5fbGlzdCIsIm5vdCIsInRvQXJyYXkiLCJub3Rfc3Bhbl9saXN0X2l0ZW0iLCJuZXdfZWwiLCJpcyIsImZpbmQiLCJzcGFuIiwiY2xhc3NfbmFtZSIsImNoaWxkX3NwYW4iLCJwYXJlbnRzIiwiaHRtbF90ZXh0IiwiX2dldEFwcGxpZXIiLCJpZGVudGlmaWVyIiwiYWxpYXNUYWdOYW1lIiwiaW5zZXJ0SW1hZ2UiLCJpbWFnZSIsImltYWdlc0luU2VsZWN0aW9uIiwiTElORV9CUkVBSyIsImluc2VydExpbmVCcmVhayIsImluc2VydE9yZGVyZWRMaXN0Iiwib3RoZXJMaXN0IiwidGVtcENsYXNzTmFtZSIsImdldFRpbWUiLCJpbnNlcnRVbm9yZGVyZWRMaXN0IiwiaXRhbGljIiwianVzdGlmeUNlbnRlciIsImp1c3RpZnlMZWZ0IiwianVzdGlmeVJpZ2h0IiwidW5kZXJsaW5lIiwiWl9LRVkiLCJZX0tFWSIsIk1BWF9ISVNUT1JZX0VOVFJJRVMiLCJVTkRPX0hUTUwiLCJSRURPX0hUTUwiLCJjbGVhblRlbXBFbGVtZW50cyIsIlVuZG9NYW5hZ2VyIiwiaGlzdG9yeSIsImdldFZhbHVlIiwicG9zaXRpb24iLCJfb2JzZXJ2ZSIsInNhbmRib3giLCJsYXN0S2V5IiwiYWx0S2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJpc1VuZG8iLCJpc1JlZG8iLCJ1bmRvIiwicmVkbyIsInRyYW5zYWN0IiwiaW50ZXJ2YWwiLCJvYnNlcnZlZCIsImNsZWFySW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInByZXZpb3VzSHRtbCIsImN1cnJlbnRIdG1sIiwic2hpZnQiLCJWaWV3IiwidGV4dGFyZWFFbGVtZW50IiwiX29ic2VydmVWaWV3Q2hhbmdlIiwiY3VycmVudFZpZXciLCJzaG93IiwiaGlkZSIsImRpc2FibGUiLCJlbmFibGUiLCJDb21wb3NlciIsIkNBUkVUX0hBQ0siLCJ0ZXh0YXJlYSIsIl9pbml0U2FuZGJveCIsIl9kaXNwbGF5U3R5bGUiLCJzZXRUb0VuZCIsImVsZW1lbnRzV2l0aFZpc3VhbFZhbHVlIiwiX2NyZWF0ZSIsImhpZGRlbkZpZWxkIiwiY29tcG9zZXJDbGFzc05hbWUiLCJwbGFjZWhvbGRlciIsIl9pbml0QXV0b0xpbmtpbmciLCJfaW5pdE9iamVjdFJlc2l6aW5nIiwiX2luaXRVbmRvTWFuYWdlciIsImluaXRTeW5jIiwic3luYyIsInN1cHBvcnRzRGlzYWJsaW5nT2ZBdXRvTGlua2luZyIsInN1cHBvcnRzQXV0b0xpbmtpbmciLCJsaW5rcyIsInVybFJlZ0V4cCIsImxpbmsiLCJuZXdUZXh0Q29udGVudCIsInByb3BlcnRpZXMiLCJwcm9wZXJ0aWVzTGVuZ3RoIiwiYWxsb3dPYmplY3RSZXNpemluZyIsIkhPU1RfVEVNUExBVEUiLCJURVhUX0ZPUk1BVFRJTkciLCJCT1hfRk9STUFUVElORyIsIlJFU0laRV9TVFlMRSIsIkFERElUSU9OQUxfQ1NTX1JVTEVTIiwiZm9jdXNXaXRob3V0U2Nyb2xsaW5nIiwic2V0QWN0aXZlIiwiZWxlbWVudFN0eWxlIiwib3JpZ2luYWxTY3JvbGxUb3AiLCJvcmlnaW5hbFNjcm9sbExlZnQiLCJvcmlnaW5hbFN0eWxlcyIsIldlYmtpdFVzZXJTZWxlY3QiLCJzY3JvbGxUbyIsIm9yaWdpbmFsQWN0aXZlRWxlbWVudCIsImhhc1BsYWNlaG9sZGVyIiwib3JpZ2luYWxQbGFjZWhvbGRlciIsImZvY3VzU3R5bGVzSG9zdCIsImJsdXJTdHlsZXNIb3N0IiwiYmx1ciIsImJveEZvcm1hdHRpbmdTdHlsZXMiLCJ3aW5PYnNlcnZlciIsIm9yaWdpbmFsVGV4dGFyZWFEaXNwbGF5U3R5bGUiLCJvcmlnaW5hbENvbXBvc2VyRGlzcGxheVN0eWxlIiwic2hvcnRjdXRzIiwiZm9jdXNCbHVyRWxlbWVudCIsInBhc3RlRXZlbnRzIiwiZG9tTm9kZVJlbW92ZWRJbnRlcnZhbCIsImRhdGFUcmFuc2ZlciIsInRpdGxlUHJlZml4ZXMiLCJJTUciLCJBIiwidGl0bGUiLCJoYXNUaXRsZSIsIklOVEVSVkFMIiwiU3luY2hyb25pemVyIiwiZnJvbUNvbXBvc2VyVG9UZXh0YXJlYSIsInNob3VsZFBhcnNlSHRtbCIsImZyb21UZXh0YXJlYVRvQ29tcG9zZXIiLCJ0ZXh0YXJlYVZhbHVlIiwiZm9ybSIsInN0YXJ0SW50ZXJ2YWwiLCJzdG9wSW50ZXJ2YWwiLCJUZXh0YXJlYSIsInN1cHBvcnRzUGxhY2Vob2xkZXIiLCJldmVudE1hcHBpbmciLCJmb2N1c2luIiwiZm9jdXNvdXQiLCJDTEFTU19OQU1FX09QRU5FRCIsIlNFTEVDVE9SX0ZPUk1fRUxFTUVOVFMiLCJTRUxFQ1RPUl9GSUVMRFMiLCJBVFRSSUJVVEVfRklFTERTIiwiRGlhbG9nIiwiX29ic2VydmVkIiwiY2FsbGJhY2tXcmFwcGVyIiwiX3NlcmlhbGl6ZSIsImVsZW1lbnRUb0NoYW5nZSIsImZvcm1FbGVtZW50cyIsIl9jbGVhckludGVydmFsIiwiZmllbGRzIiwiX2ludGVycG9sYXRlIiwiYXZvaWRIaWRkZW5GaWVsZHMiLCJmaWVsZCIsImZpZWxkTmFtZSIsIm5ld1ZhbHVlIiwiZm9jdXNlZEVsZW1lbnQiLCJkZWZhdWx0VmFsdWUiLCJmaXJzdEZpZWxkIiwibGlua1N0eWxlcyIsIndyYXBwZXJTdHlsZXMiLCJtYXJnaW4iLCJvcGFjaXR5IiwicGFkZGluZyIsInpJbmRleCIsImlucHV0U3R5bGVzIiwiY3Vyc29yIiwibWFyZ2luVG9wIiwib3V0bGluZSIsImlucHV0QXR0cmlidXRlcyIsIlNwZWVjaCIsIndyYXBwZXIiLCJDTEFTU19OQU1FX0NPTU1BTkRfRElTQUJMRUQiLCJDTEFTU19OQU1FX0NPTU1BTkRTX0RJU0FCTEVEIiwiQ0xBU1NfTkFNRV9DT01NQU5EX0FDVElWRSIsIkNMQVNTX05BTUVfQUNUSU9OX0FDVElWRSIsIlRvb2xiYXIiLCJfZ2V0TGlua3MiLCJzcGVlY2hJbnB1dExpbmtzIiwiZ3JvdXAiLCJkaWFsb2ciLCJfZ2V0RGlhbG9nIiwiZGlhbG9nRWxlbWVudCIsImNhcmV0Qm9va21hcmsiLCJkaWFsb2dDb250YWluZXIiLCJjb21tYW5kTGluayIsImNvbW1hbmRzRGlzYWJsZWQiLCJjb21tYW5kT2JqIiwiY29tbWFuZE1hcHBpbmciLCJfdXBkYXRlTGlua1N0YXRlcyIsImV4ZWNBY3Rpb24iLCJhY3Rpb24iLCJjb21tYW5kTGlua3MiLCJhY3Rpb25MaW5rcyIsInVuc2VsZWN0YWJsZSIsImFjdGlvbk1hcHBpbmciLCJkZWZhdWx0Q29uZmlnIiwicGFyc2VyUnVsZXMiLCJwYXJzZXIiLCJib2R5Q2xhc3NOYW1lIiwic3VwcG9ydFRvdWNoRGV2aWNlcyIsIkVkaXRvciIsIl9pc0NvbXBhdGlibGUiLCJfaW5pdFBhcnNlciIsInN5bmNocm9uaXplciIsImlzQ29tcGF0aWJsZSIsImh0bWxPckVsZW1lbnQiLCJrZWVwU2Nyb2xsUG9zaXRpb24iLCJXeXNpaHRtbDUiLCJvcHRpb25zIiwiZGVmYXVsdHMiLCJmbiIsImVkaXRhYmxldXRpbHMiLCJpbmhlcml0IiwiZWRpdGFibGV0eXBlcyIsImFic3RyYWN0aW5wdXQiLCJyZW5kZXIiLCJkZWZlcnJlZCIsIkRlZmVycmVkIiwibXNpZU9sZCIsIiRpbnB1dCIsImF0dHIiLCJzZXRBdHRyIiwibG9hZCIsInJlc29sdmUiLCJwcm9taXNlIiwidmFsdWUyaHRtbCIsImh0bWwydmFsdWUiLCJ2YWx1ZTJpbnB1dCIsImFjdGl2YXRlIiwiJGVsZW1lbnQiLCJ0cGwiLCJpbnB1dGNsYXNzIiwialF1ZXJ5Iiwid3lzaSIsImZvbnRTdHlsZXMiLCJsb2NhbGUiLCJmb250X3N0eWxlcyIsIm5vcm1hbCIsImgxIiwiaDIiLCJoMyIsImVtcGhhc2lzIiwibGlzdHMiLCJ1bm9yZGVyZWQiLCJvcmRlcmVkIiwiY2FuY2VsIiwiZWRpdCIsImNvbG91cnMiLCJmaXJzdCIsInNlY29uZCIsInRocmVlIiwidGVtcGxhdGVzIiwidG9vbGJhck9wdHMiLCJkZWZhdWx0T3B0aW9ucyIsImN1c3RvbVRlbXBsYXRlcyIsImNyZWF0ZVRvb2xiYXIiLCJjcmVhdGVFZGl0b3IiLCJvZmYiLCJmb2N1c1d5c2lodG1sNSIsInNlbGYiLCJjdWx0dXJlIiwiYXBwZW5kIiwiaW5pdEh0bWwiLCJpbml0SW5zZXJ0TGluayIsImluaXRJbnNlcnRJbWFnZSIsImNsaWNrIiwiY2hhbmdlVmlld1NlbGVjdG9yIiwidG9nZ2xlQ2xhc3MiLCJpbnNlcnRJbWFnZU1vZGFsIiwidXJsSW5wdXQiLCJpbnNlcnRCdXR0b24iLCJpbml0aWFsVmFsdWUiLCJrZXlwcmVzcyIsIndoaWNoIiwibW9kYWwiLCJhY3RpdmVCdXR0b24iLCJhcHBlbmRUbyIsImluc2VydExpbmtNb2RhbCIsImluc2VydExpbmsiLCJyZWwiLCJwcmVzc2VkRW50ZXIiLCJtZXRob2RzIiwicmVzZXREZWZhdWx0cyIsImRlZmF1bHRPcHRpb25zQ2FjaGUiLCJieXBhc3NEZWZhdWx0cyIsIiR0aGlzIiwic2hhbGxvd0V4dGVuZCIsInNldHRpbmdzIiwiZGVlcEV4dGVuZCIsIkFycmF5IiwiZXJyb3IiLCJDb25zdHJ1Y3RvciIsImVuIiwib3V0ZGVudCIsImluZGVudCIsImJsYWNrIiwic2lsdmVyIiwiZ3JheSIsIm1hcm9vbiIsInJlZCIsInB1cnBsZSIsImdyZWVuIiwib2xpdmUiLCJuYXZ5IiwiYmx1ZSIsIm9yYW5nZSJdLCJtYXBwaW5ncyI6Ijs7QUFBQSxJQUFJQSxVQUFVLE9BQU9DLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0MsU0FBT0EsT0FBT0MsUUFBZCxNQUEyQixRQUEzRCxHQUFzRSxVQUFVQyxHQUFWLEVBQWU7QUFBRSxnQkFBY0EsR0FBZCwwQ0FBY0EsR0FBZDtBQUFvQixDQUEzRyxHQUE4RyxVQUFVQSxHQUFWLEVBQWU7QUFBRSxTQUFPQSxPQUFPLE9BQU9G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V0FITztBQUlYQyxZQUFJO0FBSk8sT0FEWDtBQU9GQyxnQkFBVTtBQUNSN1IsY0FBTSxNQURFO0FBRVJxRSxnQkFBUSxRQUZBO0FBR1JJLG1CQUFXO0FBSEgsT0FQUjtBQVlGcU4sYUFBTztBQUNMQyxtQkFBVyxnQkFETjtBQUVMQyxpQkFBUyxjQUZKO0FBR0xpRCxpQkFBUyxTQUhKO0FBSUxDLGdCQUFRO0FBSkgsT0FaTDtBQWtCRmhOLFlBQU07QUFDSnRmLGdCQUFRLGFBREo7QUFFSnFwQixnQkFBUTtBQUZKLE9BbEJKO0FBc0JGck8sYUFBTztBQUNMaGIsZ0JBQVEsY0FESDtBQUVMcXBCLGdCQUFRO0FBRkgsT0F0Qkw7QUEwQkZ2MEIsWUFBTTtBQUNKdzBCLGNBQU07QUFERixPQTFCSjtBQTZCRkMsZUFBUztBQUNQbmMsZUFBTyxPQURBO0FBRVBvYyxlQUFPLElBRkE7QUFHUEMsZ0JBQVEsSUFIRDtBQUlQQyxlQUFPLElBSkE7QUFLUDZDLGVBQU8sT0FMQTtBQU1QQyxnQkFBUSxRQU5EO0FBT1BDLGNBQU0sTUFQQztBQVFQQyxnQkFBUSxRQVJEO0FBU1BDLGFBQUssS0FURTtBQVVQQyxnQkFBUSxRQVZEO0FBV1BDLGVBQU8sT0FYQTtBQVlQQyxlQUFPLE9BWkE7QUFhUEMsY0FBTSxNQWJDO0FBY1BDLGNBQU0sTUFkQztBQWVQQyxnQkFBUTtBQWZEO0FBN0JQO0FBRHNDLEdBQTVDO0FBaURELENBM1pBLENBMlpDejVDLE9BQU9nMUMsTUEzWlIsRUEyWmdCaDFDLE9BQU9sQixTQTNadkIsQ0FBRCIsImZpbGUiOiIyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIHd5c2lodG1sNSA9IHtcbiAgdmVyc2lvbjogXCIwLjMuMFwiLFxuXG4gIC8vIG5hbWVzcGFjZXNcbiAgY29tbWFuZHM6IHt9LFxuICBkb206IHt9LFxuICBxdWlya3M6IHt9LFxuICB0b29sYmFyOiB7fSxcbiAgbGFuZzoge30sXG4gIHNlbGVjdGlvbjoge30sXG4gIHZpZXdzOiB7fSxcblxuICBJTlZJU0lCTEVfU1BBQ0U6IFwiXFx1RkVGRlwiLFxuXG4gIEVNUFRZX0ZVTkNUSU9OOiBmdW5jdGlvbiBFTVBUWV9GVU5DVElPTigpIHt9LFxuXG4gIEVMRU1FTlRfTk9ERTogMSxcbiAgVEVYVF9OT0RFOiAzLFxuXG4gIEJBQ0tTUEFDRV9LRVk6IDgsXG4gIEVOVEVSX0tFWTogMTMsXG4gIEVTQ0FQRV9LRVk6IDI3LFxuICBTUEFDRV9LRVk6IDMyLFxuICBERUxFVEVfS0VZOiA0NlxufTsgLyoqXG4gICAqIEBsaWNlbnNlIFJhbmd5LCBhIGNyb3NzLWJyb3dzZXIgSmF2YVNjcmlwdCByYW5nZSBhbmQgc2VsZWN0aW9uIGxpYnJhcnlcbiAgICogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Jhbmd5L1xuICAgKlxuICAgKiBDb3B5cmlnaHQgMjAxMSwgVGltIERvd25cbiAgICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICAgKiBWZXJzaW9uOiAxLjIuMlxuICAgKiBCdWlsZCBkYXRlOiAxMyBOb3ZlbWJlciAyMDExXG4gICAqL1xud2luZG93WydyYW5neSddID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBPQkpFQ1QgPSBcIm9iamVjdFwiLFxuICAgICAgRlVOQ1RJT04gPSBcImZ1bmN0aW9uXCIsXG4gICAgICBVTkRFRklORUQgPSBcInVuZGVmaW5lZFwiO1xuXG4gIHZhciBkb21SYW5nZVByb3BlcnRpZXMgPSBbXCJzdGFydENvbnRhaW5lclwiLCBcInN0YXJ0T2Zmc2V0XCIsIFwiZW5kQ29udGFpbmVyXCIsIFwiZW5kT2Zmc2V0XCIsIFwiY29sbGFwc2VkXCIsIFwiY29tbW9uQW5jZXN0b3JDb250YWluZXJcIiwgXCJTVEFSVF9UT19TVEFSVFwiLCBcIlNUQVJUX1RPX0VORFwiLCBcIkVORF9UT19TVEFSVFwiLCBcIkVORF9UT19FTkRcIl07XG5cbiAgdmFyIGRvbVJhbmdlTWV0aG9kcyA9IFtcInNldFN0YXJ0XCIsIFwic2V0U3RhcnRCZWZvcmVcIiwgXCJzZXRTdGFydEFmdGVyXCIsIFwic2V0RW5kXCIsIFwic2V0RW5kQmVmb3JlXCIsIFwic2V0RW5kQWZ0ZXJcIiwgXCJjb2xsYXBzZVwiLCBcInNlbGVjdE5vZGVcIiwgXCJzZWxlY3ROb2RlQ29udGVudHNcIiwgXCJjb21wYXJlQm91bmRhcnlQb2ludHNcIiwgXCJkZWxldGVDb250ZW50c1wiLCBcImV4dHJhY3RDb250ZW50c1wiLCBcImNsb25lQ29udGVudHNcIiwgXCJpbnNlcnROb2RlXCIsIFwic3Vycm91bmRDb250ZW50c1wiLCBcImNsb25lUmFuZ2VcIiwgXCJ0b1N0cmluZ1wiLCBcImRldGFjaFwiXTtcblxuICB2YXIgdGV4dFJhbmdlUHJvcGVydGllcyA9IFtcImJvdW5kaW5nSGVpZ2h0XCIsIFwiYm91bmRpbmdMZWZ0XCIsIFwiYm91bmRpbmdUb3BcIiwgXCJib3VuZGluZ1dpZHRoXCIsIFwiaHRtbFRleHRcIiwgXCJ0ZXh0XCJdO1xuXG4gIC8vIFN1YnNldCBvZiBUZXh0UmFuZ2UncyBmdWxsIHNldCBvZiBtZXRob2RzIHRoYXQgd2UncmUgaW50ZXJlc3RlZCBpblxuICB2YXIgdGV4dFJhbmdlTWV0aG9kcyA9IFtcImNvbGxhcHNlXCIsIFwiY29tcGFyZUVuZFBvaW50c1wiLCBcImR1cGxpY2F0ZVwiLCBcImdldEJvb2ttYXJrXCIsIFwibW92ZVRvQm9va21hcmtcIiwgXCJtb3ZlVG9FbGVtZW50VGV4dFwiLCBcInBhcmVudEVsZW1lbnRcIiwgXCJwYXN0ZUhUTUxcIiwgXCJzZWxlY3RcIiwgXCJzZXRFbmRQb2ludFwiLCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiXTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIFRyaW8gb2YgZnVuY3Rpb25zIHRha2VuIGZyb20gUGV0ZXIgTWljaGF1eCdzIGFydGljbGU6XG4gIC8vIGh0dHA6Ly9wZXRlci5taWNoYXV4LmNhL2FydGljbGVzL2ZlYXR1cmUtZGV0ZWN0aW9uLXN0YXRlLW9mLXRoZS1hcnQtYnJvd3Nlci1zY3JpcHRpbmdcbiAgZnVuY3Rpb24gaXNIb3N0TWV0aG9kKG8sIHApIHtcbiAgICB2YXIgdCA9IF90eXBlb2Yob1twXSk7XG4gICAgcmV0dXJuIHQgPT0gRlVOQ1RJT04gfHwgISEodCA9PSBPQkpFQ1QgJiYgb1twXSkgfHwgdCA9PSBcInVua25vd25cIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSG9zdE9iamVjdChvLCBwKSB7XG4gICAgcmV0dXJuICEhKF90eXBlb2Yob1twXSkgPT0gT0JKRUNUICYmIG9bcF0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNIb3N0UHJvcGVydHkobywgcCkge1xuICAgIHJldHVybiBfdHlwZW9mKG9bcF0pICE9IFVOREVGSU5FRDtcbiAgfVxuXG4gIC8vIENyZWF0ZXMgYSBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBzYXZlIHZlcmJvc2UgcmVwZWF0ZWQgY2FsbHMgdG8gdGVzdHMgZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIGNyZWF0ZU11bHRpcGxlUHJvcGVydHlUZXN0KHRlc3RGdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvLCBwcm9wcykge1xuICAgICAgdmFyIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmICghdGVzdEZ1bmMobywgcHJvcHNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gTmV4dCB0cmlvIG9mIGZ1bmN0aW9ucyBhcmUgYSBjb252ZW5pZW5jZSB0byBzYXZlIHZlcmJvc2UgcmVwZWF0ZWQgY2FsbHMgdG8gcHJldmlvdXMgdHdvIGZ1bmN0aW9uc1xuICB2YXIgYXJlSG9zdE1ldGhvZHMgPSBjcmVhdGVNdWx0aXBsZVByb3BlcnR5VGVzdChpc0hvc3RNZXRob2QpO1xuICB2YXIgYXJlSG9zdE9iamVjdHMgPSBjcmVhdGVNdWx0aXBsZVByb3BlcnR5VGVzdChpc0hvc3RPYmplY3QpO1xuICB2YXIgYXJlSG9zdFByb3BlcnRpZXMgPSBjcmVhdGVNdWx0aXBsZVByb3BlcnR5VGVzdChpc0hvc3RQcm9wZXJ0eSk7XG5cbiAgZnVuY3Rpb24gaXNUZXh0UmFuZ2UocmFuZ2UpIHtcbiAgICByZXR1cm4gcmFuZ2UgJiYgYXJlSG9zdE1ldGhvZHMocmFuZ2UsIHRleHRSYW5nZU1ldGhvZHMpICYmIGFyZUhvc3RQcm9wZXJ0aWVzKHJhbmdlLCB0ZXh0UmFuZ2VQcm9wZXJ0aWVzKTtcbiAgfVxuXG4gIHZhciBhcGkgPSB7XG4gICAgdmVyc2lvbjogXCIxLjIuMlwiLFxuICAgIGluaXRpYWxpemVkOiBmYWxzZSxcbiAgICBzdXBwb3J0ZWQ6IHRydWUsXG5cbiAgICB1dGlsOiB7XG4gICAgICBpc0hvc3RNZXRob2Q6IGlzSG9zdE1ldGhvZCxcbiAgICAgIGlzSG9zdE9iamVjdDogaXNIb3N0T2JqZWN0LFxuICAgICAgaXNIb3N0UHJvcGVydHk6IGlzSG9zdFByb3BlcnR5LFxuICAgICAgYXJlSG9zdE1ldGhvZHM6IGFyZUhvc3RNZXRob2RzLFxuICAgICAgYXJlSG9zdE9iamVjdHM6IGFyZUhvc3RPYmplY3RzLFxuICAgICAgYXJlSG9zdFByb3BlcnRpZXM6IGFyZUhvc3RQcm9wZXJ0aWVzLFxuICAgICAgaXNUZXh0UmFuZ2U6IGlzVGV4dFJhbmdlXG4gICAgfSxcblxuICAgIGZlYXR1cmVzOiB7fSxcblxuICAgIG1vZHVsZXM6IHt9LFxuICAgIGNvbmZpZzoge1xuICAgICAgYWxlcnRPbldhcm46IGZhbHNlLFxuICAgICAgcHJlZmVyVGV4dFJhbmdlOiBmYWxzZVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBmYWlsKHJlYXNvbikge1xuICAgIHdpbmRvdy5hbGVydChcIlJhbmd5IG5vdCBzdXBwb3J0ZWQgaW4geW91ciBicm93c2VyLiBSZWFzb246IFwiICsgcmVhc29uKTtcbiAgICBhcGkuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIGFwaS5zdXBwb3J0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGFwaS5mYWlsID0gZmFpbDtcblxuICBmdW5jdGlvbiB3YXJuKG1zZykge1xuICAgIHZhciB3YXJuaW5nTWVzc2FnZSA9IFwiUmFuZ3kgd2FybmluZzogXCIgKyBtc2c7XG4gICAgaWYgKGFwaS5jb25maWcuYWxlcnRPbldhcm4pIHtcbiAgICAgIHdpbmRvdy5hbGVydCh3YXJuaW5nTWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKHdpbmRvdy5jb25zb2xlKSAhPSBVTkRFRklORUQgJiYgX3R5cGVvZih3aW5kb3cuY29uc29sZS5sb2cpICE9IFVOREVGSU5FRCkge1xuICAgICAgd2luZG93LmNvbnNvbGUubG9nKHdhcm5pbmdNZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICBhcGkud2FybiA9IHdhcm47XG5cbiAgaWYgKHt9Lmhhc093blByb3BlcnR5KSB7XG4gICAgYXBpLnV0aWwuZXh0ZW5kID0gZnVuY3Rpb24gKG8sIHByb3BzKSB7XG4gICAgICBmb3IgKHZhciBpIGluIHByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIG9baV0gPSBwcm9wc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZmFpbChcImhhc093blByb3BlcnR5IG5vdCBzdXBwb3J0ZWRcIik7XG4gIH1cblxuICB2YXIgaW5pdExpc3RlbmVycyA9IFtdO1xuICB2YXIgbW9kdWxlSW5pdGlhbGl6ZXJzID0gW107XG5cbiAgLy8gSW5pdGlhbGl6YXRpb25cbiAgZnVuY3Rpb24gaW5pdCgpIHtcbiAgICBpZiAoYXBpLmluaXRpYWxpemVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0ZXN0UmFuZ2U7XG4gICAgdmFyIGltcGxlbWVudHNEb21SYW5nZSA9IGZhbHNlLFxuICAgICAgICBpbXBsZW1lbnRzVGV4dFJhbmdlID0gZmFsc2U7XG5cbiAgICAvLyBGaXJzdCwgcGVyZm9ybSBiYXNpYyBmZWF0dXJlIHRlc3RzXG5cbiAgICBpZiAoaXNIb3N0TWV0aG9kKGRvY3VtZW50LCBcImNyZWF0ZVJhbmdlXCIpKSB7XG4gICAgICB0ZXN0UmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgaWYgKGFyZUhvc3RNZXRob2RzKHRlc3RSYW5nZSwgZG9tUmFuZ2VNZXRob2RzKSAmJiBhcmVIb3N0UHJvcGVydGllcyh0ZXN0UmFuZ2UsIGRvbVJhbmdlUHJvcGVydGllcykpIHtcbiAgICAgICAgaW1wbGVtZW50c0RvbVJhbmdlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRlc3RSYW5nZS5kZXRhY2goKTtcbiAgICB9XG5cbiAgICB2YXIgYm9keSA9IGlzSG9zdE9iamVjdChkb2N1bWVudCwgXCJib2R5XCIpID8gZG9jdW1lbnQuYm9keSA6IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiYm9keVwiKVswXTtcblxuICAgIGlmIChib2R5ICYmIGlzSG9zdE1ldGhvZChib2R5LCBcImNyZWF0ZVRleHRSYW5nZVwiKSkge1xuICAgICAgdGVzdFJhbmdlID0gYm9keS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgIGlmIChpc1RleHRSYW5nZSh0ZXN0UmFuZ2UpKSB7XG4gICAgICAgIGltcGxlbWVudHNUZXh0UmFuZ2UgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaW1wbGVtZW50c0RvbVJhbmdlICYmICFpbXBsZW1lbnRzVGV4dFJhbmdlKSB7XG4gICAgICBmYWlsKFwiTmVpdGhlciBSYW5nZSBub3IgVGV4dFJhbmdlIGFyZSBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG5cbiAgICBhcGkuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIGFwaS5mZWF0dXJlcyA9IHtcbiAgICAgIGltcGxlbWVudHNEb21SYW5nZTogaW1wbGVtZW50c0RvbVJhbmdlLFxuICAgICAgaW1wbGVtZW50c1RleHRSYW5nZTogaW1wbGVtZW50c1RleHRSYW5nZVxuICAgIH07XG5cbiAgICAvLyBJbml0aWFsaXplIG1vZHVsZXMgYW5kIGNhbGwgaW5pdCBsaXN0ZW5lcnNcbiAgICB2YXIgYWxsTGlzdGVuZXJzID0gbW9kdWxlSW5pdGlhbGl6ZXJzLmNvbmNhdChpbml0TGlzdGVuZXJzKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYWxsTGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhbGxMaXN0ZW5lcnNbaV0oYXBpKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGlmIChpc0hvc3RPYmplY3Qod2luZG93LCBcImNvbnNvbGVcIikgJiYgaXNIb3N0TWV0aG9kKHdpbmRvdy5jb25zb2xlLCBcImxvZ1wiKSkge1xuICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhcIkluaXQgbGlzdGVuZXIgdGhyZXcgYW4gZXhjZXB0aW9uLiBDb250aW51aW5nLlwiLCBleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBbGxvdyBleHRlcm5hbCBzY3JpcHRzIHRvIGluaXRpYWxpemUgdGhpcyBsaWJyYXJ5IGluIGNhc2UgaXQncyBsb2FkZWQgYWZ0ZXIgdGhlIGRvY3VtZW50IGhhcyBsb2FkZWRcbiAgYXBpLmluaXQgPSBpbml0O1xuXG4gIC8vIEV4ZWN1dGUgbGlzdGVuZXIgaW1tZWRpYXRlbHkgaWYgYWxyZWFkeSBpbml0aWFsaXplZFxuICBhcGkuYWRkSW5pdExpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgaWYgKGFwaS5pbml0aWFsaXplZCkge1xuICAgICAgbGlzdGVuZXIoYXBpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNyZWF0ZU1pc3NpbmdOYXRpdmVBcGlMaXN0ZW5lcnMgPSBbXTtcblxuICBhcGkuYWRkQ3JlYXRlTWlzc2luZ05hdGl2ZUFwaUxpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgY3JlYXRlTWlzc2luZ05hdGl2ZUFwaUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVNaXNzaW5nTmF0aXZlQXBpKHdpbikge1xuICAgIHdpbiA9IHdpbiB8fCB3aW5kb3c7XG4gICAgaW5pdCgpO1xuXG4gICAgLy8gTm90aWZ5IGxpc3RlbmVyc1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjcmVhdGVNaXNzaW5nTmF0aXZlQXBpTGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjcmVhdGVNaXNzaW5nTmF0aXZlQXBpTGlzdGVuZXJzW2ldKHdpbik7XG4gICAgfVxuICB9XG5cbiAgYXBpLmNyZWF0ZU1pc3NpbmdOYXRpdmVBcGkgPSBjcmVhdGVNaXNzaW5nTmF0aXZlQXBpO1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIE1vZHVsZShuYW1lKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XG4gICAgdGhpcy5zdXBwb3J0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIE1vZHVsZS5wcm90b3R5cGUuZmFpbCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB0aGlzLnN1cHBvcnRlZCA9IGZhbHNlO1xuXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kdWxlICdcIiArIHRoaXMubmFtZSArIFwiJyBmYWlsZWQgdG8gbG9hZDogXCIgKyByZWFzb24pO1xuICB9O1xuXG4gIE1vZHVsZS5wcm90b3R5cGUud2FybiA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICBhcGkud2FybihcIk1vZHVsZSBcIiArIHRoaXMubmFtZSArIFwiOiBcIiArIG1zZyk7XG4gIH07XG5cbiAgTW9kdWxlLnByb3RvdHlwZS5jcmVhdGVFcnJvciA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiRXJyb3IgaW4gUmFuZ3kgXCIgKyB0aGlzLm5hbWUgKyBcIiBtb2R1bGU6IFwiICsgbXNnKTtcbiAgfTtcblxuICBhcGkuY3JlYXRlTW9kdWxlID0gZnVuY3Rpb24gKG5hbWUsIGluaXRGdW5jKSB7XG4gICAgdmFyIG1vZHVsZSA9IG5ldyBNb2R1bGUobmFtZSk7XG4gICAgYXBpLm1vZHVsZXNbbmFtZV0gPSBtb2R1bGU7XG5cbiAgICBtb2R1bGVJbml0aWFsaXplcnMucHVzaChmdW5jdGlvbiAoYXBpKSB7XG4gICAgICBpbml0RnVuYyhhcGksIG1vZHVsZSk7XG4gICAgICBtb2R1bGUuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgbW9kdWxlLnN1cHBvcnRlZCA9IHRydWU7XG4gICAgfSk7XG4gIH07XG5cbiAgYXBpLnJlcXVpcmVNb2R1bGVzID0gZnVuY3Rpb24gKG1vZHVsZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbW9kdWxlcy5sZW5ndGgsIG1vZHVsZSwgbW9kdWxlTmFtZTsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBtb2R1bGVOYW1lID0gbW9kdWxlc1tpXTtcbiAgICAgIG1vZHVsZSA9IGFwaS5tb2R1bGVzW21vZHVsZU5hbWVdO1xuICAgICAgaWYgKCFtb2R1bGUgfHwgIShtb2R1bGUgaW5zdGFuY2VvZiBNb2R1bGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZHVsZSAnXCIgKyBtb2R1bGVOYW1lICsgXCInIG5vdCBmb3VuZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghbW9kdWxlLnN1cHBvcnRlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNb2R1bGUgJ1wiICsgbW9kdWxlTmFtZSArIFwiJyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGxvYWQgYmVmb3JlIHJ1bm5pbmcgdGVzdHNcblxuICB2YXIgZG9jUmVhZHkgPSBmYWxzZTtcblxuICB2YXIgbG9hZEhhbmRsZXIgPSBmdW5jdGlvbiBsb2FkSGFuZGxlcihlKSB7XG5cbiAgICBpZiAoIWRvY1JlYWR5KSB7XG4gICAgICBkb2NSZWFkeSA9IHRydWU7XG4gICAgICBpZiAoIWFwaS5pbml0aWFsaXplZCkge1xuICAgICAgICBpbml0KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFRlc3Qgd2hldGhlciB3ZSBoYXZlIHdpbmRvdyBhbmQgZG9jdW1lbnQgb2JqZWN0cyB0aGF0IHdlIHdpbGwgbmVlZFxuICBpZiAoKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih3aW5kb3cpKSA9PSBVTkRFRklORUQpIHtcbiAgICBmYWlsKFwiTm8gd2luZG93IGZvdW5kXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGRvY3VtZW50KSkgPT0gVU5ERUZJTkVEKSB7XG4gICAgZmFpbChcIk5vIGRvY3VtZW50IGZvdW5kXCIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpc0hvc3RNZXRob2QoZG9jdW1lbnQsIFwiYWRkRXZlbnRMaXN0ZW5lclwiKSkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsIGxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gIH1cblxuICAvLyBBZGQgYSBmYWxsYmFjayBpbiBjYXNlIHRoZSBET01Db250ZW50TG9hZGVkIGV2ZW50IGlzbid0IHN1cHBvcnRlZFxuICBpZiAoaXNIb3N0TWV0aG9kKHdpbmRvdywgXCJhZGRFdmVudExpc3RlbmVyXCIpKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAoaXNIb3N0TWV0aG9kKHdpbmRvdywgXCJhdHRhY2hFdmVudFwiKSkge1xuICAgIHdpbmRvdy5hdHRhY2hFdmVudChcIm9ubG9hZFwiLCBsb2FkSGFuZGxlcik7XG4gIH0gZWxzZSB7XG4gICAgZmFpbChcIldpbmRvdyBkb2VzIG5vdCBoYXZlIHJlcXVpcmVkIGFkZEV2ZW50TGlzdGVuZXIgb3IgYXR0YWNoRXZlbnQgbWV0aG9kXCIpO1xuICB9XG5cbiAgcmV0dXJuIGFwaTtcbn0oKTtcbnJhbmd5LmNyZWF0ZU1vZHVsZShcIkRvbVV0aWxcIiwgZnVuY3Rpb24gKGFwaSwgbW9kdWxlKSB7XG5cbiAgdmFyIFVOREVGID0gXCJ1bmRlZmluZWRcIjtcbiAgdmFyIHV0aWwgPSBhcGkudXRpbDtcblxuICAvLyBQZXJmb3JtIGZlYXR1cmUgdGVzdHNcbiAgaWYgKCF1dGlsLmFyZUhvc3RNZXRob2RzKGRvY3VtZW50LCBbXCJjcmVhdGVEb2N1bWVudEZyYWdtZW50XCIsIFwiY3JlYXRlRWxlbWVudFwiLCBcImNyZWF0ZVRleHROb2RlXCJdKSkge1xuICAgIG1vZHVsZS5mYWlsKFwiZG9jdW1lbnQgbWlzc2luZyBhIE5vZGUgY3JlYXRpb24gbWV0aG9kXCIpO1xuICB9XG5cbiAgaWYgKCF1dGlsLmlzSG9zdE1ldGhvZChkb2N1bWVudCwgXCJnZXRFbGVtZW50c0J5VGFnTmFtZVwiKSkge1xuICAgIG1vZHVsZS5mYWlsKFwiZG9jdW1lbnQgbWlzc2luZyBnZXRFbGVtZW50c0J5VGFnTmFtZSBtZXRob2RcIik7XG4gIH1cblxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBpZiAoIXV0aWwuYXJlSG9zdE1ldGhvZHMoZWwsIFtcImluc2VydEJlZm9yZVwiLCBcImFwcGVuZENoaWxkXCIsIFwiY2xvbmVOb2RlXCJdIHx8ICF1dGlsLmFyZUhvc3RPYmplY3RzKGVsLCBbXCJwcmV2aW91c1NpYmxpbmdcIiwgXCJuZXh0U2libGluZ1wiLCBcImNoaWxkTm9kZXNcIiwgXCJwYXJlbnROb2RlXCJdKSkpIHtcbiAgICBtb2R1bGUuZmFpbChcIkluY29tcGxldGUgRWxlbWVudCBpbXBsZW1lbnRhdGlvblwiKTtcbiAgfVxuXG4gIC8vIGlubmVySFRNTCBpcyByZXF1aXJlZCBmb3IgUmFuZ2UncyBjcmVhdGVDb250ZXh0dWFsRnJhZ21lbnQgbWV0aG9kXG4gIGlmICghdXRpbC5pc0hvc3RQcm9wZXJ0eShlbCwgXCJpbm5lckhUTUxcIikpIHtcbiAgICBtb2R1bGUuZmFpbChcIkVsZW1lbnQgaXMgbWlzc2luZyBpbm5lckhUTUwgcHJvcGVydHlcIik7XG4gIH1cblxuICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcInRlc3RcIik7XG4gIGlmICghdXRpbC5hcmVIb3N0TWV0aG9kcyh0ZXh0Tm9kZSwgW1wic3BsaXRUZXh0XCIsIFwiZGVsZXRlRGF0YVwiLCBcImluc2VydERhdGFcIiwgXCJhcHBlbmREYXRhXCIsIFwiY2xvbmVOb2RlXCJdIHx8ICF1dGlsLmFyZUhvc3RPYmplY3RzKGVsLCBbXCJwcmV2aW91c1NpYmxpbmdcIiwgXCJuZXh0U2libGluZ1wiLCBcImNoaWxkTm9kZXNcIiwgXCJwYXJlbnROb2RlXCJdKSB8fCAhdXRpbC5hcmVIb3N0UHJvcGVydGllcyh0ZXh0Tm9kZSwgW1wiZGF0YVwiXSkpKSB7XG4gICAgbW9kdWxlLmZhaWwoXCJJbmNvbXBsZXRlIFRleHQgTm9kZSBpbXBsZW1lbnRhdGlvblwiKTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLy8gUmVtb3ZlZCB1c2Ugb2YgaW5kZXhPZiBiZWNhdXNlIG9mIGEgYml6YXJyZSBidWcgaW4gT3BlcmEgdGhhdCBpcyB0aHJvd24gaW4gb25lIG9mIHRoZSBBY2lkMyB0ZXN0cy4gSSBoYXZlbid0IGJlZW5cbiAgLy8gYWJsZSB0byByZXBsaWNhdGUgaXQgb3V0c2lkZSBvZiB0aGUgdGVzdC4gVGhlIGJ1ZyBpcyB0aGF0IGluZGV4T2YgcmV0dXJucyAtMSB3aGVuIGNhbGxlZCBvbiBhbiBBcnJheSB0aGF0XG4gIC8vIGNvbnRhaW5zIGp1c3QgdGhlIGRvY3VtZW50IGFzIGEgc2luZ2xlIGVsZW1lbnQgYW5kIHRoZSB2YWx1ZSBzZWFyY2hlZCBmb3IgaXMgdGhlIGRvY3VtZW50LlxuICB2YXIgYXJyYXlDb250YWlucyA9IC8qQXJyYXkucHJvdG90eXBlLmluZGV4T2YgP1xuICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGFyciwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyci5pbmRleE9mKHZhbCkgPiAtMTtcbiAgICAgICAgICAgICAgICAgICAgICB9OiovXG5cbiAgZnVuY3Rpb24gYXJyYXlDb250YWlucyhhcnIsIHZhbCkge1xuICAgIHZhciBpID0gYXJyLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBpZiAoYXJyW2ldID09PSB2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvLyBPcGVyYSAxMSBwdXRzIEhUTUwgZWxlbWVudHMgaW4gdGhlIG51bGwgbmFtZXNwYWNlLCBpdCBzZWVtcywgYW5kIElFIDcgaGFzIHVuZGVmaW5lZCBuYW1lc3BhY2VVUklcbiAgZnVuY3Rpb24gaXNIdG1sTmFtZXNwYWNlKG5vZGUpIHtcbiAgICB2YXIgbnM7XG4gICAgcmV0dXJuIF90eXBlb2Yobm9kZS5uYW1lc3BhY2VVUkkpID09IFVOREVGIHx8IChucyA9IG5vZGUubmFtZXNwYWNlVVJJKSA9PT0gbnVsbCB8fCBucyA9PSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcmVudEVsZW1lbnQobm9kZSkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgcmV0dXJuIHBhcmVudC5ub2RlVHlwZSA9PSAxID8gcGFyZW50IDogbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5vZGVJbmRleChub2RlKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROb2RlTGVuZ3RoKG5vZGUpIHtcbiAgICB2YXIgY2hpbGROb2RlcztcbiAgICByZXR1cm4gaXNDaGFyYWN0ZXJEYXRhTm9kZShub2RlKSA/IG5vZGUubGVuZ3RoIDogKGNoaWxkTm9kZXMgPSBub2RlLmNoaWxkTm9kZXMpID8gY2hpbGROb2Rlcy5sZW5ndGggOiAwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q29tbW9uQW5jZXN0b3Iobm9kZTEsIG5vZGUyKSB7XG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdLFxuICAgICAgICBuO1xuICAgIGZvciAobiA9IG5vZGUxOyBuOyBuID0gbi5wYXJlbnROb2RlKSB7XG4gICAgICBhbmNlc3RvcnMucHVzaChuKTtcbiAgICB9XG5cbiAgICBmb3IgKG4gPSBub2RlMjsgbjsgbiA9IG4ucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKGFycmF5Q29udGFpbnMoYW5jZXN0b3JzLCBuKSkge1xuICAgICAgICByZXR1cm4gbjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzQW5jZXN0b3JPZihhbmNlc3RvciwgZGVzY2VuZGFudCwgc2VsZklzQW5jZXN0b3IpIHtcbiAgICB2YXIgbiA9IHNlbGZJc0FuY2VzdG9yID8gZGVzY2VuZGFudCA6IGRlc2NlbmRhbnQucGFyZW50Tm9kZTtcbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKG4gPT09IGFuY2VzdG9yKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IG4ucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2xvc2VzdEFuY2VzdG9ySW4obm9kZSwgYW5jZXN0b3IsIHNlbGZJc0FuY2VzdG9yKSB7XG4gICAgdmFyIHAsXG4gICAgICAgIG4gPSBzZWxmSXNBbmNlc3RvciA/IG5vZGUgOiBub2RlLnBhcmVudE5vZGU7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIHAgPSBuLnBhcmVudE5vZGU7XG4gICAgICBpZiAocCA9PT0gYW5jZXN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9XG4gICAgICBuID0gcDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBpc0NoYXJhY3RlckRhdGFOb2RlKG5vZGUpIHtcbiAgICB2YXIgdCA9IG5vZGUubm9kZVR5cGU7XG4gICAgcmV0dXJuIHQgPT0gMyB8fCB0ID09IDQgfHwgdCA9PSA4OyAvLyBUZXh0LCBDRGF0YVNlY3Rpb24gb3IgQ29tbWVudFxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0QWZ0ZXIobm9kZSwgcHJlY2VkaW5nTm9kZSkge1xuICAgIHZhciBuZXh0Tm9kZSA9IHByZWNlZGluZ05vZGUubmV4dFNpYmxpbmcsXG4gICAgICAgIHBhcmVudCA9IHByZWNlZGluZ05vZGUucGFyZW50Tm9kZTtcbiAgICBpZiAobmV4dE5vZGUpIHtcbiAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobm9kZSwgbmV4dE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLy8gTm90ZSB0aGF0IHdlIGNhbm5vdCB1c2Ugc3BsaXRUZXh0KCkgYmVjYXVzZSBpdCBpcyBidWdyaWRkZW4gaW4gSUUgOS5cbiAgZnVuY3Rpb24gc3BsaXREYXRhTm9kZShub2RlLCBpbmRleCkge1xuICAgIHZhciBuZXdOb2RlID0gbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgIG5ld05vZGUuZGVsZXRlRGF0YSgwLCBpbmRleCk7XG4gICAgbm9kZS5kZWxldGVEYXRhKGluZGV4LCBub2RlLmxlbmd0aCAtIGluZGV4KTtcbiAgICBpbnNlcnRBZnRlcihuZXdOb2RlLCBub2RlKTtcbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERvY3VtZW50KG5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSA5KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKF90eXBlb2Yobm9kZS5vd25lckRvY3VtZW50KSAhPSBVTkRFRikge1xuICAgICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudDtcbiAgICB9IGVsc2UgaWYgKF90eXBlb2Yobm9kZS5kb2N1bWVudCkgIT0gVU5ERUYpIHtcbiAgICAgIHJldHVybiBub2RlLmRvY3VtZW50O1xuICAgIH0gZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICByZXR1cm4gZ2V0RG9jdW1lbnQobm9kZS5wYXJlbnROb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0RG9jdW1lbnQ6IG5vIGRvY3VtZW50IGZvdW5kIGZvciBub2RlXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gICAgdmFyIGRvYyA9IGdldERvY3VtZW50KG5vZGUpO1xuICAgIGlmIChfdHlwZW9mKGRvYy5kZWZhdWx0VmlldykgIT0gVU5ERUYpIHtcbiAgICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXc7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKGRvYy5wYXJlbnRXaW5kb3cpICE9IFVOREVGKSB7XG4gICAgICByZXR1cm4gZG9jLnBhcmVudFdpbmRvdztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBhIHdpbmRvdyBvYmplY3QgZm9yIG5vZGVcIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SWZyYW1lRG9jdW1lbnQoaWZyYW1lRWwpIHtcbiAgICBpZiAoX3R5cGVvZihpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQpICE9IFVOREVGKSB7XG4gICAgICByZXR1cm4gaWZyYW1lRWwuY29udGVudERvY3VtZW50O1xuICAgIH0gZWxzZSBpZiAoX3R5cGVvZihpZnJhbWVFbC5jb250ZW50V2luZG93KSAhPSBVTkRFRikge1xuICAgICAgcmV0dXJuIGlmcmFtZUVsLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImdldElmcmFtZVdpbmRvdzogTm8gRG9jdW1lbnQgb2JqZWN0IGZvdW5kIGZvciBpZnJhbWUgZWxlbWVudFwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRJZnJhbWVXaW5kb3coaWZyYW1lRWwpIHtcbiAgICBpZiAoX3R5cGVvZihpZnJhbWVFbC5jb250ZW50V2luZG93KSAhPSBVTkRFRikge1xuICAgICAgcmV0dXJuIGlmcmFtZUVsLmNvbnRlbnRXaW5kb3c7XG4gICAgfSBlbHNlIGlmIChfdHlwZW9mKGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudCkgIT0gVU5ERUYpIHtcbiAgICAgIHJldHVybiBpZnJhbWVFbC5jb250ZW50RG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImdldElmcmFtZVdpbmRvdzogTm8gV2luZG93IG9iamVjdCBmb3VuZCBmb3IgaWZyYW1lIGVsZW1lbnRcIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Qm9keShkb2MpIHtcbiAgICByZXR1cm4gdXRpbC5pc0hvc3RPYmplY3QoZG9jLCBcImJvZHlcIikgPyBkb2MuYm9keSA6IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJvZHlcIilbMF07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSb290Q29udGFpbmVyKG5vZGUpIHtcbiAgICB2YXIgcGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQgPSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGFyZVBvaW50cyhub2RlQSwgb2Zmc2V0QSwgbm9kZUIsIG9mZnNldEIpIHtcbiAgICAvLyBTZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItVHJhdmVyc2FsLVJhbmdlL3Jhbmdlcy5odG1sI0xldmVsLTItUmFuZ2UtQ29tcGFyaW5nXG4gICAgdmFyIG5vZGVDLCByb290LCBjaGlsZEEsIGNoaWxkQiwgbjtcbiAgICBpZiAobm9kZUEgPT0gbm9kZUIpIHtcblxuICAgICAgLy8gQ2FzZSAxOiBub2RlcyBhcmUgdGhlIHNhbWVcbiAgICAgIHJldHVybiBvZmZzZXRBID09PSBvZmZzZXRCID8gMCA6IG9mZnNldEEgPCBvZmZzZXRCID8gLTEgOiAxO1xuICAgIH0gZWxzZSBpZiAobm9kZUMgPSBnZXRDbG9zZXN0QW5jZXN0b3JJbihub2RlQiwgbm9kZUEsIHRydWUpKSB7XG5cbiAgICAgIC8vIENhc2UgMjogbm9kZSBDIChjb250YWluZXIgQiBvciBhbiBhbmNlc3RvcikgaXMgYSBjaGlsZCBub2RlIG9mIEFcbiAgICAgIHJldHVybiBvZmZzZXRBIDw9IGdldE5vZGVJbmRleChub2RlQykgPyAtMSA6IDE7XG4gICAgfSBlbHNlIGlmIChub2RlQyA9IGdldENsb3Nlc3RBbmNlc3RvckluKG5vZGVBLCBub2RlQiwgdHJ1ZSkpIHtcblxuICAgICAgLy8gQ2FzZSAzOiBub2RlIEMgKGNvbnRhaW5lciBBIG9yIGFuIGFuY2VzdG9yKSBpcyBhIGNoaWxkIG5vZGUgb2YgQlxuICAgICAgcmV0dXJuIGdldE5vZGVJbmRleChub2RlQykgPCBvZmZzZXRCID8gLTEgOiAxO1xuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIENhc2UgNDogY29udGFpbmVycyBhcmUgc2libGluZ3Mgb3IgZGVzY2VuZGFudHMgb2Ygc2libGluZ3NcbiAgICAgIHJvb3QgPSBnZXRDb21tb25BbmNlc3Rvcihub2RlQSwgbm9kZUIpO1xuICAgICAgY2hpbGRBID0gbm9kZUEgPT09IHJvb3QgPyByb290IDogZ2V0Q2xvc2VzdEFuY2VzdG9ySW4obm9kZUEsIHJvb3QsIHRydWUpO1xuICAgICAgY2hpbGRCID0gbm9kZUIgPT09IHJvb3QgPyByb290IDogZ2V0Q2xvc2VzdEFuY2VzdG9ySW4obm9kZUIsIHJvb3QsIHRydWUpO1xuXG4gICAgICBpZiAoY2hpbGRBID09PSBjaGlsZEIpIHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgYmUgcG9zc2libGVcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb21wYXJlUG9pbnRzIGdvdCB0byBjYXNlIDQgYW5kIGNoaWxkQSBhbmQgY2hpbGRCIGFyZSB0aGUgc2FtZSFcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gcm9vdC5maXJzdENoaWxkO1xuICAgICAgICB3aGlsZSAobikge1xuICAgICAgICAgIGlmIChuID09PSBjaGlsZEEpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG4gPT09IGNoaWxkQikge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIG4gPSBuLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNob3VsZCBub3QgYmUgaGVyZSFcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZnJhZ21lbnRGcm9tTm9kZUNoaWxkcmVuKG5vZGUpIHtcbiAgICB2YXIgZnJhZ21lbnQgPSBnZXREb2N1bWVudChub2RlKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgIGNoaWxkO1xuICAgIHdoaWxlIChjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBpbnNwZWN0Tm9kZShub2RlKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICByZXR1cm4gXCJbTm8gbm9kZV1cIjtcbiAgICB9XG4gICAgaWYgKGlzQ2hhcmFjdGVyRGF0YU5vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiAnXCInICsgbm9kZS5kYXRhICsgJ1wiJztcbiAgICB9IGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgdmFyIGlkQXR0ciA9IG5vZGUuaWQgPyAnIGlkPVwiJyArIG5vZGUuaWQgKyAnXCInIDogXCJcIjtcbiAgICAgIHJldHVybiBcIjxcIiArIG5vZGUubm9kZU5hbWUgKyBpZEF0dHIgKyBcIj5bXCIgKyBub2RlLmNoaWxkTm9kZXMubGVuZ3RoICsgXCJdXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVOYW1lO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIE5vZGVJdGVyYXRvcihyb290KSB7XG4gICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICB0aGlzLl9uZXh0ID0gcm9vdDtcbiAgfVxuXG4gIE5vZGVJdGVyYXRvci5wcm90b3R5cGUgPSB7XG4gICAgX2N1cnJlbnQ6IG51bGwsXG5cbiAgICBoYXNOZXh0OiBmdW5jdGlvbiBoYXNOZXh0KCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5fbmV4dDtcbiAgICB9LFxuXG4gICAgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHZhciBuID0gdGhpcy5fY3VycmVudCA9IHRoaXMuX25leHQ7XG4gICAgICB2YXIgY2hpbGQsIG5leHQ7XG4gICAgICBpZiAodGhpcy5fY3VycmVudCkge1xuICAgICAgICBjaGlsZCA9IG4uZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgdGhpcy5fbmV4dCA9IGNoaWxkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSBudWxsO1xuICAgICAgICAgIHdoaWxlIChuICE9PSB0aGlzLnJvb3QgJiYgIShuZXh0ID0gbi5uZXh0U2libGluZykpIHtcbiAgICAgICAgICAgIG4gPSBuLnBhcmVudE5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX25leHQgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY3VycmVudDtcbiAgICB9LFxuXG4gICAgZGV0YWNoOiBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fbmV4dCA9IHRoaXMucm9vdCA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUl0ZXJhdG9yKHJvb3QpIHtcbiAgICByZXR1cm4gbmV3IE5vZGVJdGVyYXRvcihyb290KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIERvbVBvc2l0aW9uKG5vZGUsIG9mZnNldCkge1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gIH1cblxuICBEb21Qb3NpdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHMocG9zKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlID09PSBwb3Mubm9kZSAmIHRoaXMub2Zmc2V0ID09IHBvcy5vZmZzZXQ7XG4gICAgfSxcblxuICAgIGluc3BlY3Q6IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gICAgICByZXR1cm4gXCJbRG9tUG9zaXRpb24oXCIgKyBpbnNwZWN0Tm9kZSh0aGlzLm5vZGUpICsgXCI6XCIgKyB0aGlzLm9mZnNldCArIFwiKV1cIjtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gRE9NRXhjZXB0aW9uKGNvZGVOYW1lKSB7XG4gICAgdGhpcy5jb2RlID0gdGhpc1tjb2RlTmFtZV07XG4gICAgdGhpcy5jb2RlTmFtZSA9IGNvZGVOYW1lO1xuICAgIHRoaXMubWVzc2FnZSA9IFwiRE9NRXhjZXB0aW9uOiBcIiArIHRoaXMuY29kZU5hbWU7XG4gIH1cblxuICBET01FeGNlcHRpb24ucHJvdG90eXBlID0ge1xuICAgIElOREVYX1NJWkVfRVJSOiAxLFxuICAgIEhJRVJBUkNIWV9SRVFVRVNUX0VSUjogMyxcbiAgICBXUk9OR19ET0NVTUVOVF9FUlI6IDQsXG4gICAgTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSOiA3LFxuICAgIE5PVF9GT1VORF9FUlI6IDgsXG4gICAgTk9UX1NVUFBPUlRFRF9FUlI6IDksXG4gICAgSU5WQUxJRF9TVEFURV9FUlI6IDExXG4gIH07XG5cbiAgRE9NRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICB9O1xuXG4gIGFwaS5kb20gPSB7XG4gICAgYXJyYXlDb250YWluczogYXJyYXlDb250YWlucyxcbiAgICBpc0h0bWxOYW1lc3BhY2U6IGlzSHRtbE5hbWVzcGFjZSxcbiAgICBwYXJlbnRFbGVtZW50OiBwYXJlbnRFbGVtZW50LFxuICAgIGdldE5vZGVJbmRleDogZ2V0Tm9kZUluZGV4LFxuICAgIGdldE5vZGVMZW5ndGg6IGdldE5vZGVMZW5ndGgsXG4gICAgZ2V0Q29tbW9uQW5jZXN0b3I6IGdldENvbW1vbkFuY2VzdG9yLFxuICAgIGlzQW5jZXN0b3JPZjogaXNBbmNlc3Rvck9mLFxuICAgIGdldENsb3Nlc3RBbmNlc3RvckluOiBnZXRDbG9zZXN0QW5jZXN0b3JJbixcbiAgICBpc0NoYXJhY3RlckRhdGFOb2RlOiBpc0NoYXJhY3RlckRhdGFOb2RlLFxuICAgIGluc2VydEFmdGVyOiBpbnNlcnRBZnRlcixcbiAgICBzcGxpdERhdGFOb2RlOiBzcGxpdERhdGFOb2RlLFxuICAgIGdldERvY3VtZW50OiBnZXREb2N1bWVudCxcbiAgICBnZXRXaW5kb3c6IGdldFdpbmRvdyxcbiAgICBnZXRJZnJhbWVXaW5kb3c6IGdldElmcmFtZVdpbmRvdyxcbiAgICBnZXRJZnJhbWVEb2N1bWVudDogZ2V0SWZyYW1lRG9jdW1lbnQsXG4gICAgZ2V0Qm9keTogZ2V0Qm9keSxcbiAgICBnZXRSb290Q29udGFpbmVyOiBnZXRSb290Q29udGFpbmVyLFxuICAgIGNvbXBhcmVQb2ludHM6IGNvbXBhcmVQb2ludHMsXG4gICAgaW5zcGVjdE5vZGU6IGluc3BlY3ROb2RlLFxuICAgIGZyYWdtZW50RnJvbU5vZGVDaGlsZHJlbjogZnJhZ21lbnRGcm9tTm9kZUNoaWxkcmVuLFxuICAgIGNyZWF0ZUl0ZXJhdG9yOiBjcmVhdGVJdGVyYXRvcixcbiAgICBEb21Qb3NpdGlvbjogRG9tUG9zaXRpb25cbiAgfTtcblxuICBhcGkuRE9NRXhjZXB0aW9uID0gRE9NRXhjZXB0aW9uO1xufSk7cmFuZ3kuY3JlYXRlTW9kdWxlKFwiRG9tUmFuZ2VcIiwgZnVuY3Rpb24gKGFwaSwgbW9kdWxlKSB7XG4gIGFwaS5yZXF1aXJlTW9kdWxlcyhbXCJEb21VdGlsXCJdKTtcblxuICB2YXIgZG9tID0gYXBpLmRvbTtcbiAgdmFyIERvbVBvc2l0aW9uID0gZG9tLkRvbVBvc2l0aW9uO1xuICB2YXIgRE9NRXhjZXB0aW9uID0gYXBpLkRPTUV4Y2VwdGlvbjtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIFV0aWxpdHkgZnVuY3Rpb25zXG5cbiAgZnVuY3Rpb24gaXNOb25UZXh0UGFydGlhbGx5U2VsZWN0ZWQobm9kZSwgcmFuZ2UpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSAhPSAzICYmIChkb20uaXNBbmNlc3Rvck9mKG5vZGUsIHJhbmdlLnN0YXJ0Q29udGFpbmVyLCB0cnVlKSB8fCBkb20uaXNBbmNlc3Rvck9mKG5vZGUsIHJhbmdlLmVuZENvbnRhaW5lciwgdHJ1ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UmFuZ2VEb2N1bWVudChyYW5nZSkge1xuICAgIHJldHVybiBkb20uZ2V0RG9jdW1lbnQocmFuZ2Uuc3RhcnRDb250YWluZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlzcGF0Y2hFdmVudChyYW5nZSwgdHlwZSwgYXJncykge1xuICAgIHZhciBsaXN0ZW5lcnMgPSByYW5nZS5fbGlzdGVuZXJzW3R5cGVdO1xuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgbGlzdGVuZXJzW2ldLmNhbGwocmFuZ2UsIHsgdGFyZ2V0OiByYW5nZSwgYXJnczogYXJncyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCb3VuZGFyeUJlZm9yZU5vZGUobm9kZSkge1xuICAgIHJldHVybiBuZXcgRG9tUG9zaXRpb24obm9kZS5wYXJlbnROb2RlLCBkb20uZ2V0Tm9kZUluZGV4KG5vZGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJvdW5kYXJ5QWZ0ZXJOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IERvbVBvc2l0aW9uKG5vZGUucGFyZW50Tm9kZSwgZG9tLmdldE5vZGVJbmRleChub2RlKSArIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0Tm9kZUF0UG9zaXRpb24obm9kZSwgbiwgbykge1xuICAgIHZhciBmaXJzdE5vZGVJbnNlcnRlZCA9IG5vZGUubm9kZVR5cGUgPT0gMTEgPyBub2RlLmZpcnN0Q2hpbGQgOiBub2RlO1xuICAgIGlmIChkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShuKSkge1xuICAgICAgaWYgKG8gPT0gbi5sZW5ndGgpIHtcbiAgICAgICAgZG9tLmluc2VydEFmdGVyKG5vZGUsIG4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCBvID09IDAgPyBuIDogZG9tLnNwbGl0RGF0YU5vZGUobiwgbykpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobyA+PSBuLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBuLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuLmluc2VydEJlZm9yZShub2RlLCBuLmNoaWxkTm9kZXNbb10pO1xuICAgIH1cbiAgICByZXR1cm4gZmlyc3ROb2RlSW5zZXJ0ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBjbG9uZVN1YnRyZWUoaXRlcmF0b3IpIHtcbiAgICB2YXIgcGFydGlhbGx5U2VsZWN0ZWQ7XG4gICAgZm9yICh2YXIgbm9kZSwgZnJhZyA9IGdldFJhbmdlRG9jdW1lbnQoaXRlcmF0b3IucmFuZ2UpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSwgc3ViSXRlcmF0b3I7IG5vZGUgPSBpdGVyYXRvci5uZXh0KCk7KSB7XG4gICAgICBwYXJ0aWFsbHlTZWxlY3RlZCA9IGl0ZXJhdG9yLmlzUGFydGlhbGx5U2VsZWN0ZWRTdWJ0cmVlKCk7XG5cbiAgICAgIG5vZGUgPSBub2RlLmNsb25lTm9kZSghcGFydGlhbGx5U2VsZWN0ZWQpO1xuICAgICAgaWYgKHBhcnRpYWxseVNlbGVjdGVkKSB7XG4gICAgICAgIHN1Ykl0ZXJhdG9yID0gaXRlcmF0b3IuZ2V0U3VidHJlZUl0ZXJhdG9yKCk7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2xvbmVTdWJ0cmVlKHN1Ykl0ZXJhdG9yKSk7XG4gICAgICAgIHN1Ykl0ZXJhdG9yLmRldGFjaCh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMTApIHtcbiAgICAgICAgLy8gRG9jdW1lbnRUeXBlXG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJISUVSQVJDSFlfUkVRVUVTVF9FUlJcIik7XG4gICAgICB9XG4gICAgICBmcmFnLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGl0ZXJhdGVTdWJ0cmVlKHJhbmdlSXRlcmF0b3IsIGZ1bmMsIGl0ZXJhdG9yU3RhdGUpIHtcbiAgICB2YXIgaXQsIG47XG4gICAgaXRlcmF0b3JTdGF0ZSA9IGl0ZXJhdG9yU3RhdGUgfHwgeyBzdG9wOiBmYWxzZSB9O1xuICAgIGZvciAodmFyIG5vZGUsIHN1YlJhbmdlSXRlcmF0b3I7IG5vZGUgPSByYW5nZUl0ZXJhdG9yLm5leHQoKTspIHtcbiAgICAgIC8vbG9nLmRlYnVnKFwiaXRlcmF0ZVN1YnRyZWUsIHBhcnRpYWxseSBzZWxlY3RlZDogXCIgKyByYW5nZUl0ZXJhdG9yLmlzUGFydGlhbGx5U2VsZWN0ZWRTdWJ0cmVlKCksIG5vZGVUb1N0cmluZyhub2RlKSk7XG4gICAgICBpZiAocmFuZ2VJdGVyYXRvci5pc1BhcnRpYWxseVNlbGVjdGVkU3VidHJlZSgpKSB7XG4gICAgICAgIC8vIFRoZSBub2RlIGlzIHBhcnRpYWxseSBzZWxlY3RlZCBieSB0aGUgUmFuZ2UsIHNvIHdlIGNhbiB1c2UgYSBuZXcgUmFuZ2VJdGVyYXRvciBvbiB0aGUgcG9ydGlvbiBvZiB0aGVcbiAgICAgICAgLy8gbm9kZSBzZWxlY3RlZCBieSB0aGUgUmFuZ2UuXG4gICAgICAgIGlmIChmdW5jKG5vZGUpID09PSBmYWxzZSkge1xuICAgICAgICAgIGl0ZXJhdG9yU3RhdGUuc3RvcCA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1YlJhbmdlSXRlcmF0b3IgPSByYW5nZUl0ZXJhdG9yLmdldFN1YnRyZWVJdGVyYXRvcigpO1xuICAgICAgICAgIGl0ZXJhdGVTdWJ0cmVlKHN1YlJhbmdlSXRlcmF0b3IsIGZ1bmMsIGl0ZXJhdG9yU3RhdGUpO1xuICAgICAgICAgIHN1YlJhbmdlSXRlcmF0b3IuZGV0YWNoKHRydWUpO1xuICAgICAgICAgIGlmIChpdGVyYXRvclN0YXRlLnN0b3ApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSB3aG9sZSBub2RlIGlzIHNlbGVjdGVkLCBzbyB3ZSBjYW4gdXNlIGVmZmljaWVudCBET00gaXRlcmF0aW9uIHRvIGl0ZXJhdGUgb3ZlciB0aGUgbm9kZSBhbmQgaXRzXG4gICAgICAgIC8vIGRlc2NlbmRhbnRcbiAgICAgICAgaXQgPSBkb20uY3JlYXRlSXRlcmF0b3Iobm9kZSk7XG4gICAgICAgIHdoaWxlIChuID0gaXQubmV4dCgpKSB7XG4gICAgICAgICAgaWYgKGZ1bmMobikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBpdGVyYXRvclN0YXRlLnN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVN1YnRyZWUoaXRlcmF0b3IpIHtcbiAgICB2YXIgc3ViSXRlcmF0b3I7XG4gICAgd2hpbGUgKGl0ZXJhdG9yLm5leHQoKSkge1xuICAgICAgaWYgKGl0ZXJhdG9yLmlzUGFydGlhbGx5U2VsZWN0ZWRTdWJ0cmVlKCkpIHtcbiAgICAgICAgc3ViSXRlcmF0b3IgPSBpdGVyYXRvci5nZXRTdWJ0cmVlSXRlcmF0b3IoKTtcbiAgICAgICAgZGVsZXRlU3VidHJlZShzdWJJdGVyYXRvcik7XG4gICAgICAgIHN1Ykl0ZXJhdG9yLmRldGFjaCh0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdG9yLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RTdWJ0cmVlKGl0ZXJhdG9yKSB7XG5cbiAgICBmb3IgKHZhciBub2RlLCBmcmFnID0gZ2V0UmFuZ2VEb2N1bWVudChpdGVyYXRvci5yYW5nZSkuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBzdWJJdGVyYXRvcjsgbm9kZSA9IGl0ZXJhdG9yLm5leHQoKTspIHtcblxuICAgICAgaWYgKGl0ZXJhdG9yLmlzUGFydGlhbGx5U2VsZWN0ZWRTdWJ0cmVlKCkpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICAgICAgc3ViSXRlcmF0b3IgPSBpdGVyYXRvci5nZXRTdWJ0cmVlSXRlcmF0b3IoKTtcbiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChleHRyYWN0U3VidHJlZShzdWJJdGVyYXRvcikpO1xuICAgICAgICBzdWJJdGVyYXRvci5kZXRhY2godHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEwKSB7XG4gICAgICAgIC8vIERvY3VtZW50VHlwZVxuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSElFUkFSQ0hZX1JFUVVFU1RfRVJSXCIpO1xuICAgICAgfVxuICAgICAgZnJhZy5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWc7XG4gIH1cblxuICBmdW5jdGlvbiBnZXROb2Rlc0luUmFuZ2UocmFuZ2UsIG5vZGVUeXBlcywgZmlsdGVyKSB7XG4gICAgLy9sb2cuaW5mbyhcImdldE5vZGVzSW5SYW5nZSwgXCIgKyBub2RlVHlwZXMuam9pbihcIixcIikpO1xuICAgIHZhciBmaWx0ZXJOb2RlVHlwZXMgPSAhIShub2RlVHlwZXMgJiYgbm9kZVR5cGVzLmxlbmd0aCksXG4gICAgICAgIHJlZ2V4O1xuICAgIHZhciBmaWx0ZXJFeGlzdHMgPSAhIWZpbHRlcjtcbiAgICBpZiAoZmlsdGVyTm9kZVR5cGVzKSB7XG4gICAgICByZWdleCA9IG5ldyBSZWdFeHAoXCJeKFwiICsgbm9kZVR5cGVzLmpvaW4oXCJ8XCIpICsgXCIpJFwiKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZXMgPSBbXTtcbiAgICBpdGVyYXRlU3VidHJlZShuZXcgUmFuZ2VJdGVyYXRvcihyYW5nZSwgZmFsc2UpLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgaWYgKCghZmlsdGVyTm9kZVR5cGVzIHx8IHJlZ2V4LnRlc3Qobm9kZS5ub2RlVHlwZSkpICYmICghZmlsdGVyRXhpc3RzIHx8IGZpbHRlcihub2RlKSkpIHtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZXM7XG4gIH1cblxuICBmdW5jdGlvbiBfaW5zcGVjdChyYW5nZSkge1xuICAgIHZhciBuYW1lID0gdHlwZW9mIHJhbmdlLmdldE5hbWUgPT0gXCJ1bmRlZmluZWRcIiA/IFwiUmFuZ2VcIiA6IHJhbmdlLmdldE5hbWUoKTtcbiAgICByZXR1cm4gXCJbXCIgKyBuYW1lICsgXCIoXCIgKyBkb20uaW5zcGVjdE5vZGUocmFuZ2Uuc3RhcnRDb250YWluZXIpICsgXCI6XCIgKyByYW5nZS5zdGFydE9mZnNldCArIFwiLCBcIiArIGRvbS5pbnNwZWN0Tm9kZShyYW5nZS5lbmRDb250YWluZXIpICsgXCI6XCIgKyByYW5nZS5lbmRPZmZzZXQgKyBcIildXCI7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIFJhbmdlSXRlcmF0b3IgY29kZSBwYXJ0aWFsbHkgYm9ycm93cyBmcm9tIElFUmFuZ2UgYnkgVGltIFJ5YW4gKGh0dHA6Ly9naXRodWIuY29tL3RpbWNhbWVyb25yeWFuL0lFUmFuZ2UpXG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gUmFuZ2VJdGVyYXRvcihyYW5nZSwgY2xvbmVQYXJ0aWFsbHlTZWxlY3RlZFRleHROb2Rlcykge1xuICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICB0aGlzLmNsb25lUGFydGlhbGx5U2VsZWN0ZWRUZXh0Tm9kZXMgPSBjbG9uZVBhcnRpYWxseVNlbGVjdGVkVGV4dE5vZGVzO1xuXG4gICAgaWYgKCFyYW5nZS5jb2xsYXBzZWQpIHtcbiAgICAgIHRoaXMuc2MgPSByYW5nZS5zdGFydENvbnRhaW5lcjtcbiAgICAgIHRoaXMuc28gPSByYW5nZS5zdGFydE9mZnNldDtcbiAgICAgIHRoaXMuZWMgPSByYW5nZS5lbmRDb250YWluZXI7XG4gICAgICB0aGlzLmVvID0gcmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgdmFyIHJvb3QgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcblxuICAgICAgaWYgKHRoaXMuc2MgPT09IHRoaXMuZWMgJiYgZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUodGhpcy5zYykpIHtcbiAgICAgICAgdGhpcy5pc1NpbmdsZUNoYXJhY3RlckRhdGFOb2RlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZmlyc3QgPSB0aGlzLl9sYXN0ID0gdGhpcy5fbmV4dCA9IHRoaXMuc2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9maXJzdCA9IHRoaXMuX25leHQgPSB0aGlzLnNjID09PSByb290ICYmICFkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZSh0aGlzLnNjKSA/IHRoaXMuc2MuY2hpbGROb2Rlc1t0aGlzLnNvXSA6IGRvbS5nZXRDbG9zZXN0QW5jZXN0b3JJbih0aGlzLnNjLCByb290LCB0cnVlKTtcbiAgICAgICAgdGhpcy5fbGFzdCA9IHRoaXMuZWMgPT09IHJvb3QgJiYgIWRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKHRoaXMuZWMpID8gdGhpcy5lYy5jaGlsZE5vZGVzW3RoaXMuZW8gLSAxXSA6IGRvbS5nZXRDbG9zZXN0QW5jZXN0b3JJbih0aGlzLmVjLCByb290LCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBSYW5nZUl0ZXJhdG9yLnByb3RvdHlwZSA9IHtcbiAgICBfY3VycmVudDogbnVsbCxcbiAgICBfbmV4dDogbnVsbCxcbiAgICBfZmlyc3Q6IG51bGwsXG4gICAgX2xhc3Q6IG51bGwsXG4gICAgaXNTaW5nbGVDaGFyYWN0ZXJEYXRhTm9kZTogZmFsc2UsXG5cbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLl9jdXJyZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX25leHQgPSB0aGlzLl9maXJzdDtcbiAgICB9LFxuXG4gICAgaGFzTmV4dDogZnVuY3Rpb24gaGFzTmV4dCgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuX25leHQ7XG4gICAgfSxcblxuICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAvLyBNb3ZlIHRvIG5leHQgbm9kZVxuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50ID0gdGhpcy5fbmV4dDtcbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIHRoaXMuX25leHQgPSBjdXJyZW50ICE9PSB0aGlzLl9sYXN0ID8gY3VycmVudC5uZXh0U2libGluZyA6IG51bGw7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIHBhcnRpYWxseSBzZWxlY3RlZCB0ZXh0IG5vZGVzXG4gICAgICAgIGlmIChkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShjdXJyZW50KSAmJiB0aGlzLmNsb25lUGFydGlhbGx5U2VsZWN0ZWRUZXh0Tm9kZXMpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5lYykge1xuXG4gICAgICAgICAgICAoY3VycmVudCA9IGN1cnJlbnQuY2xvbmVOb2RlKHRydWUpKS5kZWxldGVEYXRhKHRoaXMuZW8sIGN1cnJlbnQubGVuZ3RoIC0gdGhpcy5lbyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50ID09PSB0aGlzLnNjKSB7XG5cbiAgICAgICAgICAgIChjdXJyZW50ID0gY3VycmVudC5jbG9uZU5vZGUodHJ1ZSkpLmRlbGV0ZURhdGEoMCwgdGhpcy5zbyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fY3VycmVudCxcbiAgICAgICAgICBzdGFydCxcbiAgICAgICAgICBlbmQ7XG5cbiAgICAgIGlmIChkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShjdXJyZW50KSAmJiAoY3VycmVudCA9PT0gdGhpcy5zYyB8fCBjdXJyZW50ID09PSB0aGlzLmVjKSkge1xuICAgICAgICBzdGFydCA9IGN1cnJlbnQgPT09IHRoaXMuc2MgPyB0aGlzLnNvIDogMDtcbiAgICAgICAgZW5kID0gY3VycmVudCA9PT0gdGhpcy5lYyA/IHRoaXMuZW8gOiBjdXJyZW50Lmxlbmd0aDtcbiAgICAgICAgaWYgKHN0YXJ0ICE9IGVuZCkge1xuICAgICAgICAgIGN1cnJlbnQuZGVsZXRlRGF0YShzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY3VycmVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgY3VycmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGN1cnJlbnQpO1xuICAgICAgICB9IGVsc2Uge31cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gQ2hlY2tzIGlmIHRoZSBjdXJyZW50IG5vZGUgaXMgcGFydGlhbGx5IHNlbGVjdGVkXG4gICAgaXNQYXJ0aWFsbHlTZWxlY3RlZFN1YnRyZWU6IGZ1bmN0aW9uIGlzUGFydGlhbGx5U2VsZWN0ZWRTdWJ0cmVlKCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9jdXJyZW50O1xuICAgICAgcmV0dXJuIGlzTm9uVGV4dFBhcnRpYWxseVNlbGVjdGVkKGN1cnJlbnQsIHRoaXMucmFuZ2UpO1xuICAgIH0sXG5cbiAgICBnZXRTdWJ0cmVlSXRlcmF0b3I6IGZ1bmN0aW9uIGdldFN1YnRyZWVJdGVyYXRvcigpIHtcbiAgICAgIHZhciBzdWJSYW5nZTtcbiAgICAgIGlmICh0aGlzLmlzU2luZ2xlQ2hhcmFjdGVyRGF0YU5vZGUpIHtcbiAgICAgICAgc3ViUmFuZ2UgPSB0aGlzLnJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgICAgc3ViUmFuZ2UuY29sbGFwc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN1YlJhbmdlID0gbmV3IFJhbmdlKGdldFJhbmdlRG9jdW1lbnQodGhpcy5yYW5nZSkpO1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX2N1cnJlbnQ7XG4gICAgICAgIHZhciBzdGFydENvbnRhaW5lciA9IGN1cnJlbnQsXG4gICAgICAgICAgICBzdGFydE9mZnNldCA9IDAsXG4gICAgICAgICAgICBlbmRDb250YWluZXIgPSBjdXJyZW50LFxuICAgICAgICAgICAgZW5kT2Zmc2V0ID0gZG9tLmdldE5vZGVMZW5ndGgoY3VycmVudCk7XG5cbiAgICAgICAgaWYgKGRvbS5pc0FuY2VzdG9yT2YoY3VycmVudCwgdGhpcy5zYywgdHJ1ZSkpIHtcbiAgICAgICAgICBzdGFydENvbnRhaW5lciA9IHRoaXMuc2M7XG4gICAgICAgICAgc3RhcnRPZmZzZXQgPSB0aGlzLnNvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb20uaXNBbmNlc3Rvck9mKGN1cnJlbnQsIHRoaXMuZWMsIHRydWUpKSB7XG4gICAgICAgICAgZW5kQ29udGFpbmVyID0gdGhpcy5lYztcbiAgICAgICAgICBlbmRPZmZzZXQgPSB0aGlzLmVvO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlQm91bmRhcmllcyhzdWJSYW5nZSwgc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJhbmdlSXRlcmF0b3Ioc3ViUmFuZ2UsIHRoaXMuY2xvbmVQYXJ0aWFsbHlTZWxlY3RlZFRleHROb2Rlcyk7XG4gICAgfSxcblxuICAgIGRldGFjaDogZnVuY3Rpb24gZGV0YWNoKGRldGFjaFJhbmdlKSB7XG4gICAgICBpZiAoZGV0YWNoUmFuZ2UpIHtcbiAgICAgICAgdGhpcy5yYW5nZS5kZXRhY2goKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLl9jdXJyZW50ID0gdGhpcy5fbmV4dCA9IHRoaXMuX2ZpcnN0ID0gdGhpcy5fbGFzdCA9IHRoaXMuc2MgPSB0aGlzLnNvID0gdGhpcy5lYyA9IHRoaXMuZW8gPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEV4Y2VwdGlvbnNcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBSYW5nZUV4Y2VwdGlvbihjb2RlTmFtZSkge1xuICAgIHRoaXMuY29kZSA9IHRoaXNbY29kZU5hbWVdO1xuICAgIHRoaXMuY29kZU5hbWUgPSBjb2RlTmFtZTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBcIlJhbmdlRXhjZXB0aW9uOiBcIiArIHRoaXMuY29kZU5hbWU7XG4gIH1cblxuICBSYW5nZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgQkFEX0JPVU5EQVJZUE9JTlRTX0VSUjogMSxcbiAgICBJTlZBTElEX05PREVfVFlQRV9FUlI6IDJcbiAgfTtcblxuICBSYW5nZUV4Y2VwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgfTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDdXJyZW50bHkgaXRlcmF0ZXMgdGhyb3VnaCBhbGwgbm9kZXMgaW4gdGhlIHJhbmdlIG9uIGNyZWF0aW9uIHVudGlsIEkgdGhpbmsgb2YgYSBkZWNlbnQgd2F5IHRvIGRvIGl0XG4gICAqIFRPRE86IExvb2sgaW50byBtYWtpbmcgdGhpcyBhIHByb3BlciBpdGVyYXRvciwgbm90IHJlcXVpcmluZyBwcmVsb2FkaW5nIGV2ZXJ5dGhpbmcgZmlyc3RcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBSYW5nZU5vZGVJdGVyYXRvcihyYW5nZSwgbm9kZVR5cGVzLCBmaWx0ZXIpIHtcbiAgICB0aGlzLm5vZGVzID0gZ2V0Tm9kZXNJblJhbmdlKHJhbmdlLCBub2RlVHlwZXMsIGZpbHRlcik7XG4gICAgdGhpcy5fbmV4dCA9IHRoaXMubm9kZXNbMF07XG4gICAgdGhpcy5fcG9zaXRpb24gPSAwO1xuICB9XG5cbiAgUmFuZ2VOb2RlSXRlcmF0b3IucHJvdG90eXBlID0ge1xuICAgIF9jdXJyZW50OiBudWxsLFxuXG4gICAgaGFzTmV4dDogZnVuY3Rpb24gaGFzTmV4dCgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuX25leHQ7XG4gICAgfSxcblxuICAgIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB0aGlzLl9jdXJyZW50ID0gdGhpcy5fbmV4dDtcbiAgICAgIHRoaXMuX25leHQgPSB0aGlzLm5vZGVzWysrdGhpcy5fcG9zaXRpb25dO1xuICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnQ7XG4gICAgfSxcblxuICAgIGRldGFjaDogZnVuY3Rpb24gZGV0YWNoKCkge1xuICAgICAgdGhpcy5fY3VycmVudCA9IHRoaXMuX25leHQgPSB0aGlzLm5vZGVzID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGJlZm9yZUFmdGVyTm9kZVR5cGVzID0gWzEsIDMsIDQsIDUsIDcsIDgsIDEwXTtcbiAgdmFyIHJvb3RDb250YWluZXJOb2RlVHlwZXMgPSBbMiwgOSwgMTFdO1xuICB2YXIgcmVhZG9ubHlOb2RlVHlwZXMgPSBbNSwgNiwgMTAsIDEyXTtcbiAgdmFyIGluc2VydGFibGVOb2RlVHlwZXMgPSBbMSwgMywgNCwgNSwgNywgOCwgMTAsIDExXTtcbiAgdmFyIHN1cnJvdW5kTm9kZVR5cGVzID0gWzEsIDMsIDQsIDUsIDcsIDhdO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFuY2VzdG9yRmluZGVyKG5vZGVUeXBlcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSwgc2VsZklzQW5jZXN0b3IpIHtcbiAgICAgIHZhciB0LFxuICAgICAgICAgIG4gPSBzZWxmSXNBbmNlc3RvciA/IG5vZGUgOiBub2RlLnBhcmVudE5vZGU7XG4gICAgICB3aGlsZSAobikge1xuICAgICAgICB0ID0gbi5ub2RlVHlwZTtcbiAgICAgICAgaWYgKGRvbS5hcnJheUNvbnRhaW5zKG5vZGVUeXBlcywgdCkpIHtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgICBuID0gbi5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBnZXRSb290Q29udGFpbmVyID0gZG9tLmdldFJvb3RDb250YWluZXI7XG4gIHZhciBnZXREb2N1bWVudE9yRnJhZ21lbnRDb250YWluZXIgPSBjcmVhdGVBbmNlc3RvckZpbmRlcihbOSwgMTFdKTtcbiAgdmFyIGdldFJlYWRvbmx5QW5jZXN0b3IgPSBjcmVhdGVBbmNlc3RvckZpbmRlcihyZWFkb25seU5vZGVUeXBlcyk7XG4gIHZhciBnZXREb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3RvciA9IGNyZWF0ZUFuY2VzdG9yRmluZGVyKFs2LCAxMCwgMTJdKTtcblxuICBmdW5jdGlvbiBhc3NlcnROb0RvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yKG5vZGUsIGFsbG93U2VsZikge1xuICAgIGlmIChnZXREb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3Rvcihub2RlLCBhbGxvd1NlbGYpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFeGNlcHRpb24oXCJJTlZBTElEX05PREVfVFlQRV9FUlJcIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm90RGV0YWNoZWQocmFuZ2UpIHtcbiAgICBpZiAoIXJhbmdlLnN0YXJ0Q29udGFpbmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSU5WQUxJRF9TVEFURV9FUlJcIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0VmFsaWROb2RlVHlwZShub2RlLCBpbnZhbGlkVHlwZXMpIHtcbiAgICBpZiAoIWRvbS5hcnJheUNvbnRhaW5zKGludmFsaWRUeXBlcywgbm9kZS5ub2RlVHlwZSkpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUV4Y2VwdGlvbihcIklOVkFMSURfTk9ERV9UWVBFX0VSUlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnRWYWxpZE9mZnNldChub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiAoZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUobm9kZSkgPyBub2RlLmxlbmd0aCA6IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSU5ERVhfU0laRV9FUlJcIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0U2FtZURvY3VtZW50T3JGcmFnbWVudChub2RlMSwgbm9kZTIpIHtcbiAgICBpZiAoZ2V0RG9jdW1lbnRPckZyYWdtZW50Q29udGFpbmVyKG5vZGUxLCB0cnVlKSAhPT0gZ2V0RG9jdW1lbnRPckZyYWdtZW50Q29udGFpbmVyKG5vZGUyLCB0cnVlKSkge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIldST05HX0RPQ1VNRU5UX0VSUlwiKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NlcnROb2RlTm90UmVhZE9ubHkobm9kZSkge1xuICAgIGlmIChnZXRSZWFkb25seUFuY2VzdG9yKG5vZGUsIHRydWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGUobm9kZSwgY29kZU5hbWUpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oY29kZU5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT3JwaGFuKG5vZGUpIHtcbiAgICByZXR1cm4gIWRvbS5hcnJheUNvbnRhaW5zKHJvb3RDb250YWluZXJOb2RlVHlwZXMsIG5vZGUubm9kZVR5cGUpICYmICFnZXREb2N1bWVudE9yRnJhZ21lbnRDb250YWluZXIobm9kZSwgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1ZhbGlkT2Zmc2V0KG5vZGUsIG9mZnNldCkge1xuICAgIHJldHVybiBvZmZzZXQgPD0gKGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKG5vZGUpID8gbm9kZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydFJhbmdlVmFsaWQocmFuZ2UpIHtcbiAgICBhc3NlcnROb3REZXRhY2hlZChyYW5nZSk7XG4gICAgaWYgKGlzT3JwaGFuKHJhbmdlLnN0YXJ0Q29udGFpbmVyKSB8fCBpc09ycGhhbihyYW5nZS5lbmRDb250YWluZXIpIHx8ICFpc1ZhbGlkT2Zmc2V0KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCkgfHwgIWlzVmFsaWRPZmZzZXQocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZSBlcnJvcjogUmFuZ2UgaXMgbm8gbG9uZ2VyIHZhbGlkIGFmdGVyIERPTSBtdXRhdGlvbiAoXCIgKyByYW5nZS5pbnNwZWN0KCkgKyBcIilcIik7XG4gICAgfVxuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBUZXN0IHRoZSBicm93c2VyJ3MgaW5uZXJIVE1MIHN1cHBvcnQgdG8gZGVjaWRlIGhvdyB0byBpbXBsZW1lbnQgY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50XG4gIHZhciBzdHlsZUVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICB2YXIgaHRtbFBhcnNpbmdDb25mb3JtcyA9IGZhbHNlO1xuICB0cnkge1xuICAgIHN0eWxlRWwuaW5uZXJIVE1MID0gXCI8Yj54PC9iPlwiO1xuICAgIGh0bWxQYXJzaW5nQ29uZm9ybXMgPSBzdHlsZUVsLmZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMzsgLy8gT3BlcmEgaW5jb3JyZWN0bHkgY3JlYXRlcyBhbiBlbGVtZW50IG5vZGVcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElFIDYgYW5kIDcgdGhyb3dcbiAgfVxuXG4gIGFwaS5mZWF0dXJlcy5odG1sUGFyc2luZ0NvbmZvcm1zID0gaHRtbFBhcnNpbmdDb25mb3JtcztcblxuICB2YXIgY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50ID0gaHRtbFBhcnNpbmdDb25mb3JtcyA/XG5cbiAgLy8gSW1wbGVtZW50YXRpb24gYXMgcGVyIEhUTUwgcGFyc2luZyBzcGVjLCB0cnVzdGluZyBpbiB0aGUgYnJvd3NlcidzIGltcGxlbWVudGF0aW9uIG9mIGlubmVySFRNTC4gU2VlXG4gIC8vIGRpc2N1c3Npb24gYW5kIGJhc2UgY29kZSBmb3IgdGhpcyBpbXBsZW1lbnRhdGlvbiBhdCBpc3N1ZSA2Ny5cbiAgLy8gU3BlYzogaHR0cDovL2h0bWw1Lm9yZy9zcGVjcy9kb20tcGFyc2luZy5odG1sI2V4dGVuc2lvbnMtdG8tdGhlLXJhbmdlLWludGVyZmFjZVxuICAvLyBUaGFua3MgdG8gQWxla3MgV2lsbGlhbXMuXG4gIGZ1bmN0aW9uIChmcmFnbWVudFN0cikge1xuICAgIC8vIFwiTGV0IG5vZGUgdGhlIGNvbnRleHQgb2JqZWN0J3Mgc3RhcnQncyBub2RlLlwiXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Q29udGFpbmVyO1xuICAgIHZhciBkb2MgPSBkb20uZ2V0RG9jdW1lbnQobm9kZSk7XG5cbiAgICAvLyBcIklmIHRoZSBjb250ZXh0IG9iamVjdCdzIHN0YXJ0J3Mgbm9kZSBpcyBudWxsLCByYWlzZSBhbiBJTlZBTElEX1NUQVRFX0VSUlxuICAgIC8vIGV4Y2VwdGlvbiBhbmQgYWJvcnQgdGhlc2Ugc3RlcHMuXCJcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJJTlZBTElEX1NUQVRFX0VSUlwiKTtcbiAgICB9XG5cbiAgICAvLyBcIkxldCBlbGVtZW50IGJlIGFzIGZvbGxvd3MsIGRlcGVuZGluZyBvbiBub2RlJ3MgaW50ZXJmYWNlOlwiXG4gICAgLy8gRG9jdW1lbnQsIERvY3VtZW50IEZyYWdtZW50OiBudWxsXG4gICAgdmFyIGVsID0gbnVsbDtcblxuICAgIC8vIFwiRWxlbWVudDogbm9kZVwiXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgZWwgPSBub2RlO1xuXG4gICAgICAvLyBcIlRleHQsIENvbW1lbnQ6IG5vZGUncyBwYXJlbnRFbGVtZW50XCJcbiAgICB9IGVsc2UgaWYgKGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKG5vZGUpKSB7XG4gICAgICBlbCA9IGRvbS5wYXJlbnRFbGVtZW50KG5vZGUpO1xuICAgIH1cblxuICAgIC8vIFwiSWYgZWl0aGVyIGVsZW1lbnQgaXMgbnVsbCBvciBlbGVtZW50J3Mgb3duZXJEb2N1bWVudCBpcyBhbiBIVE1MIGRvY3VtZW50XG4gICAgLy8gYW5kIGVsZW1lbnQncyBsb2NhbCBuYW1lIGlzIFwiaHRtbFwiIGFuZCBlbGVtZW50J3MgbmFtZXNwYWNlIGlzIHRoZSBIVE1MXG4gICAgLy8gbmFtZXNwYWNlXCJcbiAgICBpZiAoZWwgPT09IG51bGwgfHwgZWwubm9kZU5hbWUgPT0gXCJIVE1MXCIgJiYgZG9tLmlzSHRtbE5hbWVzcGFjZShkb20uZ2V0RG9jdW1lbnQoZWwpLmRvY3VtZW50RWxlbWVudCkgJiYgZG9tLmlzSHRtbE5hbWVzcGFjZShlbCkpIHtcblxuICAgICAgLy8gXCJsZXQgZWxlbWVudCBiZSBhIG5ldyBFbGVtZW50IHdpdGggXCJib2R5XCIgYXMgaXRzIGxvY2FsIG5hbWUgYW5kIHRoZSBIVE1MXG4gICAgICAvLyBuYW1lc3BhY2UgYXMgaXRzIG5hbWVzcGFjZS5cIlwiXG4gICAgICBlbCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiYm9keVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwgPSBlbC5jbG9uZU5vZGUoZmFsc2UpO1xuICAgIH1cblxuICAgIC8vIFwiSWYgdGhlIG5vZGUncyBkb2N1bWVudCBpcyBhbiBIVE1MIGRvY3VtZW50OiBJbnZva2UgdGhlIEhUTUwgZnJhZ21lbnQgcGFyc2luZyBhbGdvcml0aG0uXCJcbiAgICAvLyBcIklmIHRoZSBub2RlJ3MgZG9jdW1lbnQgaXMgYW4gWE1MIGRvY3VtZW50OiBJbnZva2UgdGhlIFhNTCBmcmFnbWVudCBwYXJzaW5nIGFsZ29yaXRobS5cIlxuICAgIC8vIFwiSW4gZWl0aGVyIGNhc2UsIHRoZSBhbGdvcml0aG0gbXVzdCBiZSBpbnZva2VkIHdpdGggZnJhZ21lbnQgYXMgdGhlIGlucHV0XG4gICAgLy8gYW5kIGVsZW1lbnQgYXMgdGhlIGNvbnRleHQgZWxlbWVudC5cIlxuICAgIGVsLmlubmVySFRNTCA9IGZyYWdtZW50U3RyO1xuXG4gICAgLy8gXCJJZiB0aGlzIHJhaXNlcyBhbiBleGNlcHRpb24sIHRoZW4gYWJvcnQgdGhlc2Ugc3RlcHMuIE90aGVyd2lzZSwgbGV0IG5ld1xuICAgIC8vIGNoaWxkcmVuIGJlIHRoZSBub2RlcyByZXR1cm5lZC5cIlxuXG4gICAgLy8gXCJMZXQgZnJhZ21lbnQgYmUgYSBuZXcgRG9jdW1lbnRGcmFnbWVudC5cIlxuICAgIC8vIFwiQXBwZW5kIGFsbCBuZXcgY2hpbGRyZW4gdG8gZnJhZ21lbnQuXCJcbiAgICAvLyBcIlJldHVybiBmcmFnbWVudC5cIlxuICAgIHJldHVybiBkb20uZnJhZ21lbnRGcm9tTm9kZUNoaWxkcmVuKGVsKTtcbiAgfSA6XG5cbiAgLy8gSW4gdGhpcyBjYXNlLCBpbm5lckhUTUwgY2Fubm90IGJlIHRydXN0ZWQsIHNvIGZhbGwgYmFjayB0byBhIHNpbXBsZXIsIG5vbi1jb25mb3JtYW50IGltcGxlbWVudGF0aW9uIHRoYXRcbiAgLy8gcHJldmlvdXMgdmVyc2lvbnMgb2YgUmFuZ3kgdXNlZCAod2l0aCB0aGUgZXhjZXB0aW9uIG9mIHVzaW5nIGEgYm9keSBlbGVtZW50IHJhdGhlciB0aGFuIGEgZGl2KVxuICBmdW5jdGlvbiAoZnJhZ21lbnRTdHIpIHtcbiAgICBhc3NlcnROb3REZXRhY2hlZCh0aGlzKTtcbiAgICB2YXIgZG9jID0gZ2V0UmFuZ2VEb2N1bWVudCh0aGlzKTtcbiAgICB2YXIgZWwgPSBkb2MuY3JlYXRlRWxlbWVudChcImJvZHlcIik7XG4gICAgZWwuaW5uZXJIVE1MID0gZnJhZ21lbnRTdHI7XG5cbiAgICByZXR1cm4gZG9tLmZyYWdtZW50RnJvbU5vZGVDaGlsZHJlbihlbCk7XG4gIH07XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICB2YXIgcmFuZ2VQcm9wZXJ0aWVzID0gW1wic3RhcnRDb250YWluZXJcIiwgXCJzdGFydE9mZnNldFwiLCBcImVuZENvbnRhaW5lclwiLCBcImVuZE9mZnNldFwiLCBcImNvbGxhcHNlZFwiLCBcImNvbW1vbkFuY2VzdG9yQ29udGFpbmVyXCJdO1xuXG4gIHZhciBzMnMgPSAwLFxuICAgICAgczJlID0gMSxcbiAgICAgIGUyZSA9IDIsXG4gICAgICBlMnMgPSAzO1xuICB2YXIgbl9iID0gMCxcbiAgICAgIG5fYSA9IDEsXG4gICAgICBuX2JfYSA9IDIsXG4gICAgICBuX2kgPSAzO1xuXG4gIGZ1bmN0aW9uIFJhbmdlUHJvdG90eXBlKCkge31cblxuICBSYW5nZVByb3RvdHlwZS5wcm90b3R5cGUgPSB7XG4gICAgYXR0YWNoTGlzdGVuZXI6IGZ1bmN0aW9uIGF0dGFjaExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgfSxcblxuICAgIGNvbXBhcmVCb3VuZGFyeVBvaW50czogZnVuY3Rpb24gY29tcGFyZUJvdW5kYXJ5UG9pbnRzKGhvdywgcmFuZ2UpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICBhc3NlcnRTYW1lRG9jdW1lbnRPckZyYWdtZW50KHRoaXMuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0Q29udGFpbmVyKTtcblxuICAgICAgdmFyIG5vZGVBLCBvZmZzZXRBLCBub2RlQiwgb2Zmc2V0QjtcbiAgICAgIHZhciBwcmVmaXhBID0gaG93ID09IGUycyB8fCBob3cgPT0gczJzID8gXCJzdGFydFwiIDogXCJlbmRcIjtcbiAgICAgIHZhciBwcmVmaXhCID0gaG93ID09IHMyZSB8fCBob3cgPT0gczJzID8gXCJzdGFydFwiIDogXCJlbmRcIjtcbiAgICAgIG5vZGVBID0gdGhpc1twcmVmaXhBICsgXCJDb250YWluZXJcIl07XG4gICAgICBvZmZzZXRBID0gdGhpc1twcmVmaXhBICsgXCJPZmZzZXRcIl07XG4gICAgICBub2RlQiA9IHJhbmdlW3ByZWZpeEIgKyBcIkNvbnRhaW5lclwiXTtcbiAgICAgIG9mZnNldEIgPSByYW5nZVtwcmVmaXhCICsgXCJPZmZzZXRcIl07XG4gICAgICByZXR1cm4gZG9tLmNvbXBhcmVQb2ludHMobm9kZUEsIG9mZnNldEEsIG5vZGVCLCBvZmZzZXRCKTtcbiAgICB9LFxuXG4gICAgaW5zZXJ0Tm9kZTogZnVuY3Rpb24gaW5zZXJ0Tm9kZShub2RlKSB7XG4gICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgYXNzZXJ0VmFsaWROb2RlVHlwZShub2RlLCBpbnNlcnRhYmxlTm9kZVR5cGVzKTtcbiAgICAgIGFzc2VydE5vZGVOb3RSZWFkT25seSh0aGlzLnN0YXJ0Q29udGFpbmVyKTtcblxuICAgICAgaWYgKGRvbS5pc0FuY2VzdG9yT2Yobm9kZSwgdGhpcy5zdGFydENvbnRhaW5lciwgdHJ1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbihcIkhJRVJBUkNIWV9SRVFVRVNUX0VSUlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm8gY2hlY2sgZm9yIHdoZXRoZXIgdGhlIGNvbnRhaW5lciBvZiB0aGUgc3RhcnQgb2YgdGhlIFJhbmdlIGlzIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFsbG93XG4gICAgICAvLyBjaGlsZHJlbiBvZiB0aGUgdHlwZSBvZiBub2RlOiB0aGUgYnJvd3NlcidzIERPTSBpbXBsZW1lbnRhdGlvbiBzaG91bGQgZG8gdGhpcyBmb3IgdXMgd2hlbiB3ZSBhdHRlbXB0XG4gICAgICAvLyB0byBhZGQgdGhlIG5vZGVcblxuICAgICAgdmFyIGZpcnN0Tm9kZUluc2VydGVkID0gaW5zZXJ0Tm9kZUF0UG9zaXRpb24obm9kZSwgdGhpcy5zdGFydENvbnRhaW5lciwgdGhpcy5zdGFydE9mZnNldCk7XG4gICAgICB0aGlzLnNldFN0YXJ0QmVmb3JlKGZpcnN0Tm9kZUluc2VydGVkKTtcbiAgICB9LFxuXG4gICAgY2xvbmVDb250ZW50czogZnVuY3Rpb24gY2xvbmVDb250ZW50cygpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG5cbiAgICAgIHZhciBjbG9uZSwgZnJhZztcbiAgICAgIGlmICh0aGlzLmNvbGxhcHNlZCkge1xuICAgICAgICByZXR1cm4gZ2V0UmFuZ2VEb2N1bWVudCh0aGlzKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5zdGFydENvbnRhaW5lciA9PT0gdGhpcy5lbmRDb250YWluZXIgJiYgZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUodGhpcy5zdGFydENvbnRhaW5lcikpIHtcbiAgICAgICAgICBjbG9uZSA9IHRoaXMuc3RhcnRDb250YWluZXIuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgIGNsb25lLmRhdGEgPSBjbG9uZS5kYXRhLnNsaWNlKHRoaXMuc3RhcnRPZmZzZXQsIHRoaXMuZW5kT2Zmc2V0KTtcbiAgICAgICAgICBmcmFnID0gZ2V0UmFuZ2VEb2N1bWVudCh0aGlzKS5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgICAgZnJhZy5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgICAgICAgcmV0dXJuIGZyYWc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gbmV3IFJhbmdlSXRlcmF0b3IodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgY2xvbmUgPSBjbG9uZVN1YnRyZWUoaXRlcmF0b3IpO1xuICAgICAgICAgIGl0ZXJhdG9yLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9uZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY2FuU3Vycm91bmRDb250ZW50czogZnVuY3Rpb24gY2FuU3Vycm91bmRDb250ZW50cygpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICBhc3NlcnROb2RlTm90UmVhZE9ubHkodGhpcy5zdGFydENvbnRhaW5lcik7XG4gICAgICBhc3NlcnROb2RlTm90UmVhZE9ubHkodGhpcy5lbmRDb250YWluZXIpO1xuXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY29udGVudHMgY2FuIGJlIHN1cnJvdW5kZWQuIFNwZWNpZmljYWxseSwgdGhpcyBtZWFucyB3aGV0aGVyIHRoZSByYW5nZSBwYXJ0aWFsbHkgc2VsZWN0c1xuICAgICAgLy8gbm8gbm9uLXRleHQgbm9kZXMuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgUmFuZ2VJdGVyYXRvcih0aGlzLCB0cnVlKTtcbiAgICAgIHZhciBib3VuZGFyaWVzSW52YWxpZCA9IGl0ZXJhdG9yLl9maXJzdCAmJiBpc05vblRleHRQYXJ0aWFsbHlTZWxlY3RlZChpdGVyYXRvci5fZmlyc3QsIHRoaXMpIHx8IGl0ZXJhdG9yLl9sYXN0ICYmIGlzTm9uVGV4dFBhcnRpYWxseVNlbGVjdGVkKGl0ZXJhdG9yLl9sYXN0LCB0aGlzKTtcbiAgICAgIGl0ZXJhdG9yLmRldGFjaCgpO1xuICAgICAgcmV0dXJuICFib3VuZGFyaWVzSW52YWxpZDtcbiAgICB9LFxuXG4gICAgc3Vycm91bmRDb250ZW50czogZnVuY3Rpb24gc3Vycm91bmRDb250ZW50cyhub2RlKSB7XG4gICAgICBhc3NlcnRWYWxpZE5vZGVUeXBlKG5vZGUsIHN1cnJvdW5kTm9kZVR5cGVzKTtcblxuICAgICAgaWYgKCF0aGlzLmNhblN1cnJvdW5kQ29udGVudHMoKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFeGNlcHRpb24oXCJCQURfQk9VTkRBUllQT0lOVFNfRVJSXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBFeHRyYWN0IHRoZSBjb250ZW50c1xuICAgICAgdmFyIGNvbnRlbnQgPSB0aGlzLmV4dHJhY3RDb250ZW50cygpO1xuXG4gICAgICAvLyBDbGVhciB0aGUgY2hpbGRyZW4gb2YgdGhlIG5vZGVcbiAgICAgIGlmIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUubGFzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJbnNlcnQgdGhlIG5ldyBub2RlIGFuZCBhZGQgdGhlIGV4dHJhY3RlZCBjb250ZW50c1xuICAgICAgaW5zZXJ0Tm9kZUF0UG9zaXRpb24obm9kZSwgdGhpcy5zdGFydENvbnRhaW5lciwgdGhpcy5zdGFydE9mZnNldCk7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuXG4gICAgICB0aGlzLnNlbGVjdE5vZGUobm9kZSk7XG4gICAgfSxcblxuICAgIGNsb25lUmFuZ2U6IGZ1bmN0aW9uIGNsb25lUmFuZ2UoKSB7XG4gICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgdmFyIHJhbmdlID0gbmV3IFJhbmdlKGdldFJhbmdlRG9jdW1lbnQodGhpcykpO1xuICAgICAgdmFyIGkgPSByYW5nZVByb3BlcnRpZXMubGVuZ3RoLFxuICAgICAgICAgIHByb3A7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHByb3AgPSByYW5nZVByb3BlcnRpZXNbaV07XG4gICAgICAgIHJhbmdlW3Byb3BdID0gdGhpc1twcm9wXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByYW5nZTtcbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgIHZhciBzYyA9IHRoaXMuc3RhcnRDb250YWluZXI7XG4gICAgICBpZiAoc2MgPT09IHRoaXMuZW5kQ29udGFpbmVyICYmIGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKHNjKSkge1xuICAgICAgICByZXR1cm4gc2Mubm9kZVR5cGUgPT0gMyB8fCBzYy5ub2RlVHlwZSA9PSA0ID8gc2MuZGF0YS5zbGljZSh0aGlzLnN0YXJ0T2Zmc2V0LCB0aGlzLmVuZE9mZnNldCkgOiBcIlwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRleHRCaXRzID0gW10sXG4gICAgICAgICAgICBpdGVyYXRvciA9IG5ldyBSYW5nZUl0ZXJhdG9yKHRoaXMsIHRydWUpO1xuXG4gICAgICAgIGl0ZXJhdGVTdWJ0cmVlKGl0ZXJhdG9yLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIC8vIEFjY2VwdCBvbmx5IHRleHQgb3IgQ0RBVEEgbm9kZXMsIG5vdCBjb21tZW50c1xuXG4gICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyB8fCBub2RlLm5vZGVUeXBlID09IDQpIHtcbiAgICAgICAgICAgIHRleHRCaXRzLnB1c2gobm9kZS5kYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpdGVyYXRvci5kZXRhY2goKTtcbiAgICAgICAgcmV0dXJuIHRleHRCaXRzLmpvaW4oXCJcIik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFRoZSBtZXRob2RzIGJlbG93IGFyZSBhbGwgbm9uLXN0YW5kYXJkLiBUaGUgZm9sbG93aW5nIGJhdGNoIHdlcmUgaW50cm9kdWNlZCBieSBNb3ppbGxhIGJ1dCBoYXZlIHNpbmNlXG4gICAgLy8gYmVlbiByZW1vdmVkIGZyb20gTW96aWxsYS5cblxuICAgIGNvbXBhcmVOb2RlOiBmdW5jdGlvbiBjb21wYXJlTm9kZShub2RlKSB7XG4gICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuXG4gICAgICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgdmFyIG5vZGVJbmRleCA9IGRvbS5nZXROb2RlSW5kZXgobm9kZSk7XG5cbiAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJOT1RfRk9VTkRfRVJSXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRDb21wYXJpc29uID0gdGhpcy5jb21wYXJlUG9pbnQocGFyZW50LCBub2RlSW5kZXgpLFxuICAgICAgICAgIGVuZENvbXBhcmlzb24gPSB0aGlzLmNvbXBhcmVQb2ludChwYXJlbnQsIG5vZGVJbmRleCArIDEpO1xuXG4gICAgICBpZiAoc3RhcnRDb21wYXJpc29uIDwgMCkge1xuICAgICAgICAvLyBOb2RlIHN0YXJ0cyBiZWZvcmVcbiAgICAgICAgcmV0dXJuIGVuZENvbXBhcmlzb24gPiAwID8gbl9iX2EgOiBuX2I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZW5kQ29tcGFyaXNvbiA+IDAgPyBuX2EgOiBuX2k7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvbXBhcmVQb2ludDogZnVuY3Rpb24gY29tcGFyZVBvaW50KG5vZGUsIG9mZnNldCkge1xuICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgIGFzc2VydE5vZGUobm9kZSwgXCJISUVSQVJDSFlfUkVRVUVTVF9FUlJcIik7XG4gICAgICBhc3NlcnRTYW1lRG9jdW1lbnRPckZyYWdtZW50KG5vZGUsIHRoaXMuc3RhcnRDb250YWluZXIpO1xuXG4gICAgICBpZiAoZG9tLmNvbXBhcmVQb2ludHMobm9kZSwgb2Zmc2V0LCB0aGlzLnN0YXJ0Q29udGFpbmVyLCB0aGlzLnN0YXJ0T2Zmc2V0KSA8IDApIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChkb20uY29tcGFyZVBvaW50cyhub2RlLCBvZmZzZXQsIHRoaXMuZW5kQ29udGFpbmVyLCB0aGlzLmVuZE9mZnNldCkgPiAwKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIGNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudDogY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50LFxuXG4gICAgdG9IdG1sOiBmdW5jdGlvbiB0b0h0bWwoKSB7XG4gICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgdmFyIGNvbnRhaW5lciA9IGdldFJhbmdlRG9jdW1lbnQodGhpcykuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmNsb25lQ29udGVudHMoKSk7XG4gICAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTDtcbiAgICB9LFxuXG4gICAgLy8gdG91Y2hpbmdJc0ludGVyc2VjdGluZyBkZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBtZXRob2QgY29uc2lkZXJzIGEgbm9kZSB0aGF0IGJvcmRlcnMgYSByYW5nZSBpbnRlcnNlY3RzXG4gICAgLy8gd2l0aCBpdCAoYXMgaW4gV2ViS2l0KSBvciBub3QgKGFzIGluIEdlY2tvIHByZS0xLjksIGFuZCB0aGUgZGVmYXVsdClcbiAgICBpbnRlcnNlY3RzTm9kZTogZnVuY3Rpb24gaW50ZXJzZWN0c05vZGUobm9kZSwgdG91Y2hpbmdJc0ludGVyc2VjdGluZykge1xuICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcbiAgICAgIGFzc2VydE5vZGUobm9kZSwgXCJOT1RfRk9VTkRfRVJSXCIpO1xuICAgICAgaWYgKGRvbS5nZXREb2N1bWVudChub2RlKSAhPT0gZ2V0UmFuZ2VEb2N1bWVudCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGUsXG4gICAgICAgICAgb2Zmc2V0ID0gZG9tLmdldE5vZGVJbmRleChub2RlKTtcbiAgICAgIGFzc2VydE5vZGUocGFyZW50LCBcIk5PVF9GT1VORF9FUlJcIik7XG5cbiAgICAgIHZhciBzdGFydENvbXBhcmlzb24gPSBkb20uY29tcGFyZVBvaW50cyhwYXJlbnQsIG9mZnNldCwgdGhpcy5lbmRDb250YWluZXIsIHRoaXMuZW5kT2Zmc2V0KSxcbiAgICAgICAgICBlbmRDb21wYXJpc29uID0gZG9tLmNvbXBhcmVQb2ludHMocGFyZW50LCBvZmZzZXQgKyAxLCB0aGlzLnN0YXJ0Q29udGFpbmVyLCB0aGlzLnN0YXJ0T2Zmc2V0KTtcblxuICAgICAgcmV0dXJuIHRvdWNoaW5nSXNJbnRlcnNlY3RpbmcgPyBzdGFydENvbXBhcmlzb24gPD0gMCAmJiBlbmRDb21wYXJpc29uID49IDAgOiBzdGFydENvbXBhcmlzb24gPCAwICYmIGVuZENvbXBhcmlzb24gPiAwO1xuICAgIH0sXG5cbiAgICBpc1BvaW50SW5SYW5nZTogZnVuY3Rpb24gaXNQb2ludEluUmFuZ2Uobm9kZSwgb2Zmc2V0KSB7XG4gICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgYXNzZXJ0Tm9kZShub2RlLCBcIkhJRVJBUkNIWV9SRVFVRVNUX0VSUlwiKTtcbiAgICAgIGFzc2VydFNhbWVEb2N1bWVudE9yRnJhZ21lbnQobm9kZSwgdGhpcy5zdGFydENvbnRhaW5lcik7XG5cbiAgICAgIHJldHVybiBkb20uY29tcGFyZVBvaW50cyhub2RlLCBvZmZzZXQsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpID49IDAgJiYgZG9tLmNvbXBhcmVQb2ludHMobm9kZSwgb2Zmc2V0LCB0aGlzLmVuZENvbnRhaW5lciwgdGhpcy5lbmRPZmZzZXQpIDw9IDA7XG4gICAgfSxcblxuICAgIC8vIFRoZSBtZXRob2RzIGJlbG93IGFyZSBub24tc3RhbmRhcmQgYW5kIGludmVudGVkIGJ5IG1lLlxuXG4gICAgLy8gU2hhcmluZyBhIGJvdW5kYXJ5IHN0YXJ0LXRvLWVuZCBvciBlbmQtdG8tc3RhcnQgZG9lcyBub3QgY291bnQgYXMgaW50ZXJzZWN0aW9uLlxuICAgIGludGVyc2VjdHNSYW5nZTogZnVuY3Rpb24gaW50ZXJzZWN0c1JhbmdlKHJhbmdlLCB0b3VjaGluZ0lzSW50ZXJzZWN0aW5nKSB7XG4gICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuXG4gICAgICBpZiAoZ2V0UmFuZ2VEb2N1bWVudChyYW5nZSkgIT0gZ2V0UmFuZ2VEb2N1bWVudCh0aGlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiV1JPTkdfRE9DVU1FTlRfRVJSXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRDb21wYXJpc29uID0gZG9tLmNvbXBhcmVQb2ludHModGhpcy5zdGFydENvbnRhaW5lciwgdGhpcy5zdGFydE9mZnNldCwgcmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpLFxuICAgICAgICAgIGVuZENvbXBhcmlzb24gPSBkb20uY29tcGFyZVBvaW50cyh0aGlzLmVuZENvbnRhaW5lciwgdGhpcy5lbmRPZmZzZXQsIHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCk7XG5cbiAgICAgIHJldHVybiB0b3VjaGluZ0lzSW50ZXJzZWN0aW5nID8gc3RhcnRDb21wYXJpc29uIDw9IDAgJiYgZW5kQ29tcGFyaXNvbiA+PSAwIDogc3RhcnRDb21wYXJpc29uIDwgMCAmJiBlbmRDb21wYXJpc29uID4gMDtcbiAgICB9LFxuXG4gICAgaW50ZXJzZWN0aW9uOiBmdW5jdGlvbiBpbnRlcnNlY3Rpb24ocmFuZ2UpIHtcbiAgICAgIGlmICh0aGlzLmludGVyc2VjdHNSYW5nZShyYW5nZSkpIHtcbiAgICAgICAgdmFyIHN0YXJ0Q29tcGFyaXNvbiA9IGRvbS5jb21wYXJlUG9pbnRzKHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQsIHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCksXG4gICAgICAgICAgICBlbmRDb21wYXJpc29uID0gZG9tLmNvbXBhcmVQb2ludHModGhpcy5lbmRDb250YWluZXIsIHRoaXMuZW5kT2Zmc2V0LCByYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCk7XG5cbiAgICAgICAgdmFyIGludGVyc2VjdGlvblJhbmdlID0gdGhpcy5jbG9uZVJhbmdlKCk7XG5cbiAgICAgICAgaWYgKHN0YXJ0Q29tcGFyaXNvbiA9PSAtMSkge1xuICAgICAgICAgIGludGVyc2VjdGlvblJhbmdlLnNldFN0YXJ0KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZENvbXBhcmlzb24gPT0gMSkge1xuICAgICAgICAgIGludGVyc2VjdGlvblJhbmdlLnNldEVuZChyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvblJhbmdlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIHVuaW9uOiBmdW5jdGlvbiB1bmlvbihyYW5nZSkge1xuICAgICAgaWYgKHRoaXMuaW50ZXJzZWN0c1JhbmdlKHJhbmdlLCB0cnVlKSkge1xuICAgICAgICB2YXIgdW5pb25SYW5nZSA9IHRoaXMuY2xvbmVSYW5nZSgpO1xuICAgICAgICBpZiAoZG9tLmNvbXBhcmVQb2ludHMocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0LCB0aGlzLnN0YXJ0Q29udGFpbmVyLCB0aGlzLnN0YXJ0T2Zmc2V0KSA9PSAtMSkge1xuICAgICAgICAgIHVuaW9uUmFuZ2Uuc2V0U3RhcnQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9tLmNvbXBhcmVQb2ludHMocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQsIHRoaXMuZW5kQ29udGFpbmVyLCB0aGlzLmVuZE9mZnNldCkgPT0gMSkge1xuICAgICAgICAgIHVuaW9uUmFuZ2Uuc2V0RW5kKHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5pb25SYW5nZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUV4Y2VwdGlvbihcIlJhbmdlcyBkbyBub3QgaW50ZXJzZWN0XCIpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb250YWluc05vZGU6IGZ1bmN0aW9uIGNvbnRhaW5zTm9kZShub2RlLCBhbGxvd1BhcnRpYWwpIHtcbiAgICAgIGlmIChhbGxvd1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0c05vZGUobm9kZSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZU5vZGUobm9kZSkgPT0gbl9pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb250YWluc05vZGVDb250ZW50czogZnVuY3Rpb24gY29udGFpbnNOb2RlQ29udGVudHMobm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVBvaW50KG5vZGUsIDApID49IDAgJiYgdGhpcy5jb21wYXJlUG9pbnQobm9kZSwgZG9tLmdldE5vZGVMZW5ndGgobm9kZSkpIDw9IDA7XG4gICAgfSxcblxuICAgIGNvbnRhaW5zUmFuZ2U6IGZ1bmN0aW9uIGNvbnRhaW5zUmFuZ2UocmFuZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmludGVyc2VjdGlvbihyYW5nZSkuZXF1YWxzKHJhbmdlKTtcbiAgICB9LFxuXG4gICAgY29udGFpbnNOb2RlVGV4dDogZnVuY3Rpb24gY29udGFpbnNOb2RlVGV4dChub2RlKSB7XG4gICAgICB2YXIgbm9kZVJhbmdlID0gdGhpcy5jbG9uZVJhbmdlKCk7XG4gICAgICBub2RlUmFuZ2Uuc2VsZWN0Tm9kZShub2RlKTtcbiAgICAgIHZhciB0ZXh0Tm9kZXMgPSBub2RlUmFuZ2UuZ2V0Tm9kZXMoWzNdKTtcbiAgICAgIGlmICh0ZXh0Tm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBub2RlUmFuZ2Uuc2V0U3RhcnQodGV4dE5vZGVzWzBdLCAwKTtcbiAgICAgICAgdmFyIGxhc3RUZXh0Tm9kZSA9IHRleHROb2Rlcy5wb3AoKTtcbiAgICAgICAgbm9kZVJhbmdlLnNldEVuZChsYXN0VGV4dE5vZGUsIGxhc3RUZXh0Tm9kZS5sZW5ndGgpO1xuICAgICAgICB2YXIgY29udGFpbnMgPSB0aGlzLmNvbnRhaW5zUmFuZ2Uobm9kZVJhbmdlKTtcbiAgICAgICAgbm9kZVJhbmdlLmRldGFjaCgpO1xuICAgICAgICByZXR1cm4gY29udGFpbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWluc05vZGVDb250ZW50cyhub2RlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY3JlYXRlTm9kZUl0ZXJhdG9yOiBmdW5jdGlvbiBjcmVhdGVOb2RlSXRlcmF0b3Iobm9kZVR5cGVzLCBmaWx0ZXIpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICByZXR1cm4gbmV3IFJhbmdlTm9kZUl0ZXJhdG9yKHRoaXMsIG5vZGVUeXBlcywgZmlsdGVyKTtcbiAgICB9LFxuXG4gICAgZ2V0Tm9kZXM6IGZ1bmN0aW9uIGdldE5vZGVzKG5vZGVUeXBlcywgZmlsdGVyKSB7XG4gICAgICBhc3NlcnRSYW5nZVZhbGlkKHRoaXMpO1xuICAgICAgcmV0dXJuIGdldE5vZGVzSW5SYW5nZSh0aGlzLCBub2RlVHlwZXMsIGZpbHRlcik7XG4gICAgfSxcblxuICAgIGdldERvY3VtZW50OiBmdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcbiAgICAgIHJldHVybiBnZXRSYW5nZURvY3VtZW50KHRoaXMpO1xuICAgIH0sXG5cbiAgICBjb2xsYXBzZUJlZm9yZTogZnVuY3Rpb24gY29sbGFwc2VCZWZvcmUobm9kZSkge1xuICAgICAgYXNzZXJ0Tm90RGV0YWNoZWQodGhpcyk7XG5cbiAgICAgIHRoaXMuc2V0RW5kQmVmb3JlKG5vZGUpO1xuICAgICAgdGhpcy5jb2xsYXBzZShmYWxzZSk7XG4gICAgfSxcblxuICAgIGNvbGxhcHNlQWZ0ZXI6IGZ1bmN0aW9uIGNvbGxhcHNlQWZ0ZXIobm9kZSkge1xuICAgICAgYXNzZXJ0Tm90RGV0YWNoZWQodGhpcyk7XG5cbiAgICAgIHRoaXMuc2V0U3RhcnRBZnRlcihub2RlKTtcbiAgICAgIHRoaXMuY29sbGFwc2UodHJ1ZSk7XG4gICAgfSxcblxuICAgIGdldE5hbWU6IGZ1bmN0aW9uIGdldE5hbWUoKSB7XG4gICAgICByZXR1cm4gXCJEb21SYW5nZVwiO1xuICAgIH0sXG5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uIGVxdWFscyhyYW5nZSkge1xuICAgICAgcmV0dXJuIFJhbmdlLnJhbmdlc0VxdWFsKHRoaXMsIHJhbmdlKTtcbiAgICB9LFxuXG4gICAgaW5zcGVjdDogZnVuY3Rpb24gaW5zcGVjdCgpIHtcbiAgICAgIHJldHVybiBfaW5zcGVjdCh0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY29weUNvbXBhcmlzb25Db25zdGFudHNUb09iamVjdChvYmopIHtcbiAgICBvYmouU1RBUlRfVE9fU1RBUlQgPSBzMnM7XG4gICAgb2JqLlNUQVJUX1RPX0VORCA9IHMyZTtcbiAgICBvYmouRU5EX1RPX0VORCA9IGUyZTtcbiAgICBvYmouRU5EX1RPX1NUQVJUID0gZTJzO1xuXG4gICAgb2JqLk5PREVfQkVGT1JFID0gbl9iO1xuICAgIG9iai5OT0RFX0FGVEVSID0gbl9hO1xuICAgIG9iai5OT0RFX0JFRk9SRV9BTkRfQUZURVIgPSBuX2JfYTtcbiAgICBvYmouTk9ERV9JTlNJREUgPSBuX2k7XG4gIH1cblxuICBmdW5jdGlvbiBjb3B5Q29tcGFyaXNvbkNvbnN0YW50cyhjb25zdHJ1Y3Rvcikge1xuICAgIGNvcHlDb21wYXJpc29uQ29uc3RhbnRzVG9PYmplY3QoY29uc3RydWN0b3IpO1xuICAgIGNvcHlDb21wYXJpc29uQ29uc3RhbnRzVG9PYmplY3QoY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlQ29udGVudFJlbW92ZXIocmVtb3ZlciwgYm91bmRhcnlVcGRhdGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG5cbiAgICAgIHZhciBzYyA9IHRoaXMuc3RhcnRDb250YWluZXIsXG4gICAgICAgICAgc28gPSB0aGlzLnN0YXJ0T2Zmc2V0LFxuICAgICAgICAgIHJvb3QgPSB0aGlzLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gICAgICB2YXIgaXRlcmF0b3IgPSBuZXcgUmFuZ2VJdGVyYXRvcih0aGlzLCB0cnVlKTtcblxuICAgICAgLy8gV29yayBvdXQgd2hlcmUgdG8gcG9zaXRpb24gdGhlIHJhbmdlIGFmdGVyIGNvbnRlbnQgcmVtb3ZhbFxuICAgICAgdmFyIG5vZGUsIGJvdW5kYXJ5O1xuICAgICAgaWYgKHNjICE9PSByb290KSB7XG4gICAgICAgIG5vZGUgPSBkb20uZ2V0Q2xvc2VzdEFuY2VzdG9ySW4oc2MsIHJvb3QsIHRydWUpO1xuICAgICAgICBib3VuZGFyeSA9IGdldEJvdW5kYXJ5QWZ0ZXJOb2RlKG5vZGUpO1xuICAgICAgICBzYyA9IGJvdW5kYXJ5Lm5vZGU7XG4gICAgICAgIHNvID0gYm91bmRhcnkub2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBub25lIG9mIHRoZSByYW5nZSBpcyByZWFkLW9ubHlcbiAgICAgIGl0ZXJhdGVTdWJ0cmVlKGl0ZXJhdG9yLCBhc3NlcnROb2RlTm90UmVhZE9ubHkpO1xuXG4gICAgICBpdGVyYXRvci5yZXNldCgpO1xuXG4gICAgICAvLyBSZW1vdmUgdGhlIGNvbnRlbnRcbiAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHJlbW92ZXIoaXRlcmF0b3IpO1xuICAgICAgaXRlcmF0b3IuZGV0YWNoKCk7XG5cbiAgICAgIC8vIE1vdmUgdG8gdGhlIG5ldyBwb3NpdGlvblxuICAgICAgYm91bmRhcnlVcGRhdGVyKHRoaXMsIHNjLCBzbywgc2MsIHNvKTtcblxuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcm90b3R5cGVSYW5nZShjb25zdHJ1Y3RvciwgYm91bmRhcnlVcGRhdGVyLCBkZXRhY2hlcikge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUJlZm9yZUFmdGVyTm9kZVNldHRlcihpc0JlZm9yZSwgaXNTdGFydCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGFzc2VydE5vdERldGFjaGVkKHRoaXMpO1xuICAgICAgICBhc3NlcnRWYWxpZE5vZGVUeXBlKG5vZGUsIGJlZm9yZUFmdGVyTm9kZVR5cGVzKTtcbiAgICAgICAgYXNzZXJ0VmFsaWROb2RlVHlwZShnZXRSb290Q29udGFpbmVyKG5vZGUpLCByb290Q29udGFpbmVyTm9kZVR5cGVzKTtcblxuICAgICAgICB2YXIgYm91bmRhcnkgPSAoaXNCZWZvcmUgPyBnZXRCb3VuZGFyeUJlZm9yZU5vZGUgOiBnZXRCb3VuZGFyeUFmdGVyTm9kZSkobm9kZSk7XG4gICAgICAgIChpc1N0YXJ0ID8gc2V0UmFuZ2VTdGFydCA6IHNldFJhbmdlRW5kKSh0aGlzLCBib3VuZGFyeS5ub2RlLCBib3VuZGFyeS5vZmZzZXQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRSYW5nZVN0YXJ0KHJhbmdlLCBub2RlLCBvZmZzZXQpIHtcbiAgICAgIHZhciBlYyA9IHJhbmdlLmVuZENvbnRhaW5lcixcbiAgICAgICAgICBlbyA9IHJhbmdlLmVuZE9mZnNldDtcbiAgICAgIGlmIChub2RlICE9PSByYW5nZS5zdGFydENvbnRhaW5lciB8fCBvZmZzZXQgIT09IHJhbmdlLnN0YXJ0T2Zmc2V0KSB7XG4gICAgICAgIC8vIENoZWNrIHRoZSByb290IGNvbnRhaW5lcnMgb2YgdGhlIHJhbmdlIGFuZCB0aGUgbmV3IGJvdW5kYXJ5LCBhbmQgYWxzbyBjaGVjayB3aGV0aGVyIHRoZSBuZXcgYm91bmRhcnlcbiAgICAgICAgLy8gaXMgYWZ0ZXIgdGhlIGN1cnJlbnQgZW5kLiBJbiBlaXRoZXIgY2FzZSwgY29sbGFwc2UgdGhlIHJhbmdlIHRvIHRoZSBuZXcgcG9zaXRpb25cbiAgICAgICAgaWYgKGdldFJvb3RDb250YWluZXIobm9kZSkgIT0gZ2V0Um9vdENvbnRhaW5lcihlYykgfHwgZG9tLmNvbXBhcmVQb2ludHMobm9kZSwgb2Zmc2V0LCBlYywgZW8pID09IDEpIHtcbiAgICAgICAgICBlYyA9IG5vZGU7XG4gICAgICAgICAgZW8gPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgYm91bmRhcnlVcGRhdGVyKHJhbmdlLCBub2RlLCBvZmZzZXQsIGVjLCBlbyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0UmFuZ2VFbmQocmFuZ2UsIG5vZGUsIG9mZnNldCkge1xuICAgICAgdmFyIHNjID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsXG4gICAgICAgICAgc28gPSByYW5nZS5zdGFydE9mZnNldDtcbiAgICAgIGlmIChub2RlICE9PSByYW5nZS5lbmRDb250YWluZXIgfHwgb2Zmc2V0ICE9PSByYW5nZS5lbmRPZmZzZXQpIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIHJvb3QgY29udGFpbmVycyBvZiB0aGUgcmFuZ2UgYW5kIHRoZSBuZXcgYm91bmRhcnksIGFuZCBhbHNvIGNoZWNrIHdoZXRoZXIgdGhlIG5ldyBib3VuZGFyeVxuICAgICAgICAvLyBpcyBhZnRlciB0aGUgY3VycmVudCBlbmQuIEluIGVpdGhlciBjYXNlLCBjb2xsYXBzZSB0aGUgcmFuZ2UgdG8gdGhlIG5ldyBwb3NpdGlvblxuICAgICAgICBpZiAoZ2V0Um9vdENvbnRhaW5lcihub2RlKSAhPSBnZXRSb290Q29udGFpbmVyKHNjKSB8fCBkb20uY29tcGFyZVBvaW50cyhub2RlLCBvZmZzZXQsIHNjLCBzbykgPT0gLTEpIHtcbiAgICAgICAgICBzYyA9IG5vZGU7XG4gICAgICAgICAgc28gPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgYm91bmRhcnlVcGRhdGVyKHJhbmdlLCBzYywgc28sIG5vZGUsIG9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0UmFuZ2VTdGFydEFuZEVuZChyYW5nZSwgbm9kZSwgb2Zmc2V0KSB7XG4gICAgICBpZiAobm9kZSAhPT0gcmFuZ2Uuc3RhcnRDb250YWluZXIgfHwgb2Zmc2V0ICE9PSByYW5nZS5zdGFydE9mZnNldCB8fCBub2RlICE9PSByYW5nZS5lbmRDb250YWluZXIgfHwgb2Zmc2V0ICE9PSByYW5nZS5lbmRPZmZzZXQpIHtcbiAgICAgICAgYm91bmRhcnlVcGRhdGVyKHJhbmdlLCBub2RlLCBvZmZzZXQsIG5vZGUsIG9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IucHJvdG90eXBlID0gbmV3IFJhbmdlUHJvdG90eXBlKCk7XG5cbiAgICBhcGkudXRpbC5leHRlbmQoY29uc3RydWN0b3IucHJvdG90eXBlLCB7XG4gICAgICBzZXRTdGFydDogZnVuY3Rpb24gc2V0U3RhcnQobm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgIGFzc2VydE5vdERldGFjaGVkKHRoaXMpO1xuICAgICAgICBhc3NlcnROb0RvY1R5cGVOb3RhdGlvbkVudGl0eUFuY2VzdG9yKG5vZGUsIHRydWUpO1xuICAgICAgICBhc3NlcnRWYWxpZE9mZnNldChub2RlLCBvZmZzZXQpO1xuXG4gICAgICAgIHNldFJhbmdlU3RhcnQodGhpcywgbm9kZSwgb2Zmc2V0KTtcbiAgICAgIH0sXG5cbiAgICAgIHNldEVuZDogZnVuY3Rpb24gc2V0RW5kKG5vZGUsIG9mZnNldCkge1xuICAgICAgICBhc3NlcnROb3REZXRhY2hlZCh0aGlzKTtcbiAgICAgICAgYXNzZXJ0Tm9Eb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3Rvcihub2RlLCB0cnVlKTtcbiAgICAgICAgYXNzZXJ0VmFsaWRPZmZzZXQobm9kZSwgb2Zmc2V0KTtcblxuICAgICAgICBzZXRSYW5nZUVuZCh0aGlzLCBub2RlLCBvZmZzZXQpO1xuICAgICAgfSxcblxuICAgICAgc2V0U3RhcnRCZWZvcmU6IGNyZWF0ZUJlZm9yZUFmdGVyTm9kZVNldHRlcih0cnVlLCB0cnVlKSxcbiAgICAgIHNldFN0YXJ0QWZ0ZXI6IGNyZWF0ZUJlZm9yZUFmdGVyTm9kZVNldHRlcihmYWxzZSwgdHJ1ZSksXG4gICAgICBzZXRFbmRCZWZvcmU6IGNyZWF0ZUJlZm9yZUFmdGVyTm9kZVNldHRlcih0cnVlLCBmYWxzZSksXG4gICAgICBzZXRFbmRBZnRlcjogY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKGZhbHNlLCBmYWxzZSksXG5cbiAgICAgIGNvbGxhcHNlOiBmdW5jdGlvbiBjb2xsYXBzZShpc1N0YXJ0KSB7XG4gICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICAgIGlmIChpc1N0YXJ0KSB7XG4gICAgICAgICAgYm91bmRhcnlVcGRhdGVyKHRoaXMsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQsIHRoaXMuc3RhcnRDb250YWluZXIsIHRoaXMuc3RhcnRPZmZzZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJvdW5kYXJ5VXBkYXRlcih0aGlzLCB0aGlzLmVuZENvbnRhaW5lciwgdGhpcy5lbmRPZmZzZXQsIHRoaXMuZW5kQ29udGFpbmVyLCB0aGlzLmVuZE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIHNlbGVjdE5vZGVDb250ZW50czogZnVuY3Rpb24gc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpIHtcbiAgICAgICAgLy8gVGhpcyBkb2Vzbid0IHNlZW0gd2VsbCBzcGVjaWZpZWQ6IHRoZSBzcGVjIHRhbGtzIG9ubHkgYWJvdXQgc2VsZWN0aW5nIHRoZSBub2RlJ3MgY29udGVudHMsIHdoaWNoXG4gICAgICAgIC8vIGNvdWxkIGJlIHRha2VuIHRvIG1lYW4gb25seSBpdHMgY2hpbGRyZW4uIEhvd2V2ZXIsIGJyb3dzZXJzIGltcGxlbWVudCB0aGlzIHRoZSBzYW1lIGFzIHNlbGVjdE5vZGUgZm9yXG4gICAgICAgIC8vIHRleHQgbm9kZXMsIHNvIEkgc2hhbGwgZG8gbGlrZXdpc2VcbiAgICAgICAgYXNzZXJ0Tm90RGV0YWNoZWQodGhpcyk7XG4gICAgICAgIGFzc2VydE5vRG9jVHlwZU5vdGF0aW9uRW50aXR5QW5jZXN0b3Iobm9kZSwgdHJ1ZSk7XG5cbiAgICAgICAgYm91bmRhcnlVcGRhdGVyKHRoaXMsIG5vZGUsIDAsIG5vZGUsIGRvbS5nZXROb2RlTGVuZ3RoKG5vZGUpKTtcbiAgICAgIH0sXG5cbiAgICAgIHNlbGVjdE5vZGU6IGZ1bmN0aW9uIHNlbGVjdE5vZGUobm9kZSkge1xuICAgICAgICBhc3NlcnROb3REZXRhY2hlZCh0aGlzKTtcbiAgICAgICAgYXNzZXJ0Tm9Eb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3Rvcihub2RlLCBmYWxzZSk7XG4gICAgICAgIGFzc2VydFZhbGlkTm9kZVR5cGUobm9kZSwgYmVmb3JlQWZ0ZXJOb2RlVHlwZXMpO1xuXG4gICAgICAgIHZhciBzdGFydCA9IGdldEJvdW5kYXJ5QmVmb3JlTm9kZShub2RlKSxcbiAgICAgICAgICAgIGVuZCA9IGdldEJvdW5kYXJ5QWZ0ZXJOb2RlKG5vZGUpO1xuICAgICAgICBib3VuZGFyeVVwZGF0ZXIodGhpcywgc3RhcnQubm9kZSwgc3RhcnQub2Zmc2V0LCBlbmQubm9kZSwgZW5kLm9mZnNldCk7XG4gICAgICB9LFxuXG4gICAgICBleHRyYWN0Q29udGVudHM6IGNyZWF0ZVJhbmdlQ29udGVudFJlbW92ZXIoZXh0cmFjdFN1YnRyZWUsIGJvdW5kYXJ5VXBkYXRlciksXG5cbiAgICAgIGRlbGV0ZUNvbnRlbnRzOiBjcmVhdGVSYW5nZUNvbnRlbnRSZW1vdmVyKGRlbGV0ZVN1YnRyZWUsIGJvdW5kYXJ5VXBkYXRlciksXG5cbiAgICAgIGNhblN1cnJvdW5kQ29udGVudHM6IGZ1bmN0aW9uIGNhblN1cnJvdW5kQ29udGVudHMoKSB7XG4gICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG4gICAgICAgIGFzc2VydE5vZGVOb3RSZWFkT25seSh0aGlzLnN0YXJ0Q29udGFpbmVyKTtcbiAgICAgICAgYXNzZXJ0Tm9kZU5vdFJlYWRPbmx5KHRoaXMuZW5kQ29udGFpbmVyKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGVudHMgY2FuIGJlIHN1cnJvdW5kZWQuIFNwZWNpZmljYWxseSwgdGhpcyBtZWFucyB3aGV0aGVyIHRoZSByYW5nZSBwYXJ0aWFsbHkgc2VsZWN0c1xuICAgICAgICAvLyBubyBub24tdGV4dCBub2Rlcy5cbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gbmV3IFJhbmdlSXRlcmF0b3IodGhpcywgdHJ1ZSk7XG4gICAgICAgIHZhciBib3VuZGFyaWVzSW52YWxpZCA9IGl0ZXJhdG9yLl9maXJzdCAmJiBpc05vblRleHRQYXJ0aWFsbHlTZWxlY3RlZChpdGVyYXRvci5fZmlyc3QsIHRoaXMpIHx8IGl0ZXJhdG9yLl9sYXN0ICYmIGlzTm9uVGV4dFBhcnRpYWxseVNlbGVjdGVkKGl0ZXJhdG9yLl9sYXN0LCB0aGlzKTtcbiAgICAgICAgaXRlcmF0b3IuZGV0YWNoKCk7XG4gICAgICAgIHJldHVybiAhYm91bmRhcmllc0ludmFsaWQ7XG4gICAgICB9LFxuXG4gICAgICBkZXRhY2g6IGZ1bmN0aW9uIGRldGFjaCgpIHtcbiAgICAgICAgZGV0YWNoZXIodGhpcyk7XG4gICAgICB9LFxuXG4gICAgICBzcGxpdEJvdW5kYXJpZXM6IGZ1bmN0aW9uIHNwbGl0Qm91bmRhcmllcygpIHtcbiAgICAgICAgYXNzZXJ0UmFuZ2VWYWxpZCh0aGlzKTtcblxuICAgICAgICB2YXIgc2MgPSB0aGlzLnN0YXJ0Q29udGFpbmVyLFxuICAgICAgICAgICAgc28gPSB0aGlzLnN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgZWMgPSB0aGlzLmVuZENvbnRhaW5lcixcbiAgICAgICAgICAgIGVvID0gdGhpcy5lbmRPZmZzZXQ7XG4gICAgICAgIHZhciBzdGFydEVuZFNhbWUgPSBzYyA9PT0gZWM7XG5cbiAgICAgICAgaWYgKGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKGVjKSAmJiBlbyA+IDAgJiYgZW8gPCBlYy5sZW5ndGgpIHtcbiAgICAgICAgICBkb20uc3BsaXREYXRhTm9kZShlYywgZW8pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKHNjKSAmJiBzbyA+IDAgJiYgc28gPCBzYy5sZW5ndGgpIHtcblxuICAgICAgICAgIHNjID0gZG9tLnNwbGl0RGF0YU5vZGUoc2MsIHNvKTtcbiAgICAgICAgICBpZiAoc3RhcnRFbmRTYW1lKSB7XG4gICAgICAgICAgICBlbyAtPSBzbztcbiAgICAgICAgICAgIGVjID0gc2M7XG4gICAgICAgICAgfSBlbHNlIGlmIChlYyA9PSBzYy5wYXJlbnROb2RlICYmIGVvID49IGRvbS5nZXROb2RlSW5kZXgoc2MpKSB7XG4gICAgICAgICAgICBlbysrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzbyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgYm91bmRhcnlVcGRhdGVyKHRoaXMsIHNjLCBzbywgZWMsIGVvKTtcbiAgICAgIH0sXG5cbiAgICAgIG5vcm1hbGl6ZUJvdW5kYXJpZXM6IGZ1bmN0aW9uIG5vcm1hbGl6ZUJvdW5kYXJpZXMoKSB7XG4gICAgICAgIGFzc2VydFJhbmdlVmFsaWQodGhpcyk7XG5cbiAgICAgICAgdmFyIHNjID0gdGhpcy5zdGFydENvbnRhaW5lcixcbiAgICAgICAgICAgIHNvID0gdGhpcy5zdGFydE9mZnNldCxcbiAgICAgICAgICAgIGVjID0gdGhpcy5lbmRDb250YWluZXIsXG4gICAgICAgICAgICBlbyA9IHRoaXMuZW5kT2Zmc2V0O1xuXG4gICAgICAgIHZhciBtZXJnZUZvcndhcmQgPSBmdW5jdGlvbiBtZXJnZUZvcndhcmQobm9kZSkge1xuICAgICAgICAgIHZhciBzaWJsaW5nID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICBpZiAoc2libGluZyAmJiBzaWJsaW5nLm5vZGVUeXBlID09IG5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGVjID0gbm9kZTtcbiAgICAgICAgICAgIGVvID0gbm9kZS5sZW5ndGg7XG4gICAgICAgICAgICBub2RlLmFwcGVuZERhdGEoc2libGluZy5kYXRhKTtcbiAgICAgICAgICAgIHNpYmxpbmcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG1lcmdlQmFja3dhcmQgPSBmdW5jdGlvbiBtZXJnZUJhY2t3YXJkKG5vZGUpIHtcbiAgICAgICAgICB2YXIgc2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgIGlmIChzaWJsaW5nICYmIHNpYmxpbmcubm9kZVR5cGUgPT0gbm9kZS5ub2RlVHlwZSkge1xuICAgICAgICAgICAgc2MgPSBub2RlO1xuICAgICAgICAgICAgdmFyIG5vZGVMZW5ndGggPSBub2RlLmxlbmd0aDtcbiAgICAgICAgICAgIHNvID0gc2libGluZy5sZW5ndGg7XG4gICAgICAgICAgICBub2RlLmluc2VydERhdGEoMCwgc2libGluZy5kYXRhKTtcbiAgICAgICAgICAgIHNpYmxpbmcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzaWJsaW5nKTtcbiAgICAgICAgICAgIGlmIChzYyA9PSBlYykge1xuICAgICAgICAgICAgICBlbyArPSBzbztcbiAgICAgICAgICAgICAgZWMgPSBzYztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZWMgPT0gbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgIHZhciBub2RlSW5kZXggPSBkb20uZ2V0Tm9kZUluZGV4KG5vZGUpO1xuICAgICAgICAgICAgICBpZiAoZW8gPT0gbm9kZUluZGV4KSB7XG4gICAgICAgICAgICAgICAgZWMgPSBub2RlO1xuICAgICAgICAgICAgICAgIGVvID0gbm9kZUxlbmd0aDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbyA+IG5vZGVJbmRleCkge1xuICAgICAgICAgICAgICAgIGVvLS07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG5vcm1hbGl6ZVN0YXJ0ID0gdHJ1ZTtcblxuICAgICAgICBpZiAoZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUoZWMpKSB7XG4gICAgICAgICAgaWYgKGVjLmxlbmd0aCA9PSBlbykge1xuICAgICAgICAgICAgbWVyZ2VGb3J3YXJkKGVjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGVvID4gMCkge1xuICAgICAgICAgICAgdmFyIGVuZE5vZGUgPSBlYy5jaGlsZE5vZGVzW2VvIC0gMV07XG4gICAgICAgICAgICBpZiAoZW5kTm9kZSAmJiBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShlbmROb2RlKSkge1xuICAgICAgICAgICAgICBtZXJnZUZvcndhcmQoZW5kTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vcm1hbGl6ZVN0YXJ0ID0gIXRoaXMuY29sbGFwc2VkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vcm1hbGl6ZVN0YXJ0KSB7XG4gICAgICAgICAgaWYgKGRvbS5pc0NoYXJhY3RlckRhdGFOb2RlKHNjKSkge1xuICAgICAgICAgICAgaWYgKHNvID09IDApIHtcbiAgICAgICAgICAgICAgbWVyZ2VCYWNrd2FyZChzYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzbyA8IHNjLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHZhciBzdGFydE5vZGUgPSBzYy5jaGlsZE5vZGVzW3NvXTtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0Tm9kZSAmJiBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShzdGFydE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VCYWNrd2FyZChzdGFydE5vZGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjID0gZWM7XG4gICAgICAgICAgc28gPSBlbztcbiAgICAgICAgfVxuXG4gICAgICAgIGJvdW5kYXJ5VXBkYXRlcih0aGlzLCBzYywgc28sIGVjLCBlbyk7XG4gICAgICB9LFxuXG4gICAgICBjb2xsYXBzZVRvUG9pbnQ6IGZ1bmN0aW9uIGNvbGxhcHNlVG9Qb2ludChub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgYXNzZXJ0Tm90RGV0YWNoZWQodGhpcyk7XG5cbiAgICAgICAgYXNzZXJ0Tm9Eb2NUeXBlTm90YXRpb25FbnRpdHlBbmNlc3Rvcihub2RlLCB0cnVlKTtcbiAgICAgICAgYXNzZXJ0VmFsaWRPZmZzZXQobm9kZSwgb2Zmc2V0KTtcblxuICAgICAgICBzZXRSYW5nZVN0YXJ0QW5kRW5kKHRoaXMsIG5vZGUsIG9mZnNldCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb3B5Q29tcGFyaXNvbkNvbnN0YW50cyhjb25zdHJ1Y3Rvcik7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIFVwZGF0ZXMgY29tbW9uQW5jZXN0b3JDb250YWluZXIgYW5kIGNvbGxhcHNlZCBhZnRlciBib3VuZGFyeSBjaGFuZ2VcbiAgZnVuY3Rpb24gdXBkYXRlQ29sbGFwc2VkQW5kQ29tbW9uQW5jZXN0b3IocmFuZ2UpIHtcbiAgICByYW5nZS5jb2xsYXBzZWQgPSByYW5nZS5zdGFydENvbnRhaW5lciA9PT0gcmFuZ2UuZW5kQ29udGFpbmVyICYmIHJhbmdlLnN0YXJ0T2Zmc2V0ID09PSByYW5nZS5lbmRPZmZzZXQ7XG4gICAgcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSByYW5nZS5jb2xsYXBzZWQgPyByYW5nZS5zdGFydENvbnRhaW5lciA6IGRvbS5nZXRDb21tb25BbmNlc3RvcihyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2UuZW5kQ29udGFpbmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUJvdW5kYXJpZXMocmFuZ2UsIHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCwgZW5kQ29udGFpbmVyLCBlbmRPZmZzZXQpIHtcbiAgICB2YXIgc3RhcnRNb3ZlZCA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyICE9PSBzdGFydENvbnRhaW5lciB8fCByYW5nZS5zdGFydE9mZnNldCAhPT0gc3RhcnRPZmZzZXQ7XG4gICAgdmFyIGVuZE1vdmVkID0gcmFuZ2UuZW5kQ29udGFpbmVyICE9PSBlbmRDb250YWluZXIgfHwgcmFuZ2UuZW5kT2Zmc2V0ICE9PSBlbmRPZmZzZXQ7XG5cbiAgICByYW5nZS5zdGFydENvbnRhaW5lciA9IHN0YXJ0Q29udGFpbmVyO1xuICAgIHJhbmdlLnN0YXJ0T2Zmc2V0ID0gc3RhcnRPZmZzZXQ7XG4gICAgcmFuZ2UuZW5kQ29udGFpbmVyID0gZW5kQ29udGFpbmVyO1xuICAgIHJhbmdlLmVuZE9mZnNldCA9IGVuZE9mZnNldDtcblxuICAgIHVwZGF0ZUNvbGxhcHNlZEFuZENvbW1vbkFuY2VzdG9yKHJhbmdlKTtcbiAgICBkaXNwYXRjaEV2ZW50KHJhbmdlLCBcImJvdW5kYXJ5Y2hhbmdlXCIsIHsgc3RhcnRNb3ZlZDogc3RhcnRNb3ZlZCwgZW5kTW92ZWQ6IGVuZE1vdmVkIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoKHJhbmdlKSB7XG4gICAgYXNzZXJ0Tm90RGV0YWNoZWQocmFuZ2UpO1xuICAgIHJhbmdlLnN0YXJ0Q29udGFpbmVyID0gcmFuZ2Uuc3RhcnRPZmZzZXQgPSByYW5nZS5lbmRDb250YWluZXIgPSByYW5nZS5lbmRPZmZzZXQgPSBudWxsO1xuICAgIHJhbmdlLmNvbGxhcHNlZCA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gbnVsbDtcbiAgICBkaXNwYXRjaEV2ZW50KHJhbmdlLCBcImRldGFjaFwiLCBudWxsKTtcbiAgICByYW5nZS5fbGlzdGVuZXJzID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFJhbmdlKGRvYykge1xuICAgIHRoaXMuc3RhcnRDb250YWluZXIgPSBkb2M7XG4gICAgdGhpcy5zdGFydE9mZnNldCA9IDA7XG4gICAgdGhpcy5lbmRDb250YWluZXIgPSBkb2M7XG4gICAgdGhpcy5lbmRPZmZzZXQgPSAwO1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHtcbiAgICAgIGJvdW5kYXJ5Y2hhbmdlOiBbXSxcbiAgICAgIGRldGFjaDogW11cbiAgICB9O1xuICAgIHVwZGF0ZUNvbGxhcHNlZEFuZENvbW1vbkFuY2VzdG9yKHRoaXMpO1xuICB9XG5cbiAgY3JlYXRlUHJvdG90eXBlUmFuZ2UoUmFuZ2UsIHVwZGF0ZUJvdW5kYXJpZXMsIGRldGFjaCk7XG5cbiAgYXBpLnJhbmdlUHJvdG90eXBlID0gUmFuZ2VQcm90b3R5cGUucHJvdG90eXBlO1xuXG4gIFJhbmdlLnJhbmdlUHJvcGVydGllcyA9IHJhbmdlUHJvcGVydGllcztcbiAgUmFuZ2UuUmFuZ2VJdGVyYXRvciA9IFJhbmdlSXRlcmF0b3I7XG4gIFJhbmdlLmNvcHlDb21wYXJpc29uQ29uc3RhbnRzID0gY29weUNvbXBhcmlzb25Db25zdGFudHM7XG4gIFJhbmdlLmNyZWF0ZVByb3RvdHlwZVJhbmdlID0gY3JlYXRlUHJvdG90eXBlUmFuZ2U7XG4gIFJhbmdlLmluc3BlY3QgPSBfaW5zcGVjdDtcbiAgUmFuZ2UuZ2V0UmFuZ2VEb2N1bWVudCA9IGdldFJhbmdlRG9jdW1lbnQ7XG4gIFJhbmdlLnJhbmdlc0VxdWFsID0gZnVuY3Rpb24gKHIxLCByMikge1xuICAgIHJldHVybiByMS5zdGFydENvbnRhaW5lciA9PT0gcjIuc3RhcnRDb250YWluZXIgJiYgcjEuc3RhcnRPZmZzZXQgPT09IHIyLnN0YXJ0T2Zmc2V0ICYmIHIxLmVuZENvbnRhaW5lciA9PT0gcjIuZW5kQ29udGFpbmVyICYmIHIxLmVuZE9mZnNldCA9PT0gcjIuZW5kT2Zmc2V0O1xuICB9O1xuXG4gIGFwaS5Eb21SYW5nZSA9IFJhbmdlO1xuICBhcGkuUmFuZ2VFeGNlcHRpb24gPSBSYW5nZUV4Y2VwdGlvbjtcbn0pO3Jhbmd5LmNyZWF0ZU1vZHVsZShcIldyYXBwZWRSYW5nZVwiLCBmdW5jdGlvbiAoYXBpLCBtb2R1bGUpIHtcbiAgYXBpLnJlcXVpcmVNb2R1bGVzKFtcIkRvbVV0aWxcIiwgXCJEb21SYW5nZVwiXSk7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgdmFyIFdyYXBwZWRSYW5nZTtcbiAgdmFyIGRvbSA9IGFwaS5kb207XG4gIHZhciBEb21Qb3NpdGlvbiA9IGRvbS5Eb21Qb3NpdGlvbjtcbiAgdmFyIERvbVJhbmdlID0gYXBpLkRvbVJhbmdlO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLypcbiAgVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIGEgYnVnIHdoZXJlIElFIHJldHVybnMgdGhlIHdyb25nIGNvbnRhaW5lciBlbGVtZW50IGZyb20gdGhlIFRleHRSYW5nZSdzIHBhcmVudEVsZW1lbnQoKVxuICBtZXRob2QuIEZvciBleGFtcGxlLCBpbiB0aGUgZm9sbG93aW5nICh3aGVyZSBwaXBlcyBkZW5vdGUgdGhlIHNlbGVjdGlvbiBib3VuZGFyaWVzKTpcbiAgIDx1bCBpZD1cInVsXCI+PGxpIGlkPVwiYVwiPnwgYSA8L2xpPjxsaSBpZD1cImJcIj4gYiB8PC9saT48L3VsPlxuICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gIGFsZXJ0KHJhbmdlLnBhcmVudEVsZW1lbnQoKS5pZCk7IC8vIFNob3VsZCBhbGVydCBcInVsXCIgYnV0IGFsZXJ0cyBcImJcIlxuICAgVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgY29tbW9uIGFuY2VzdG9yIG5vZGUgb2YgdGhlIGZvbGxvd2luZzpcbiAgLSB0aGUgcGFyZW50RWxlbWVudCgpIG9mIHRoZSB0ZXh0UmFuZ2VcbiAgLSB0aGUgcGFyZW50RWxlbWVudCgpIG9mIHRoZSB0ZXh0UmFuZ2UgYWZ0ZXIgY2FsbGluZyBjb2xsYXBzZSh0cnVlKVxuICAtIHRoZSBwYXJlbnRFbGVtZW50KCkgb2YgdGhlIHRleHRSYW5nZSBhZnRlciBjYWxsaW5nIGNvbGxhcHNlKGZhbHNlKVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0VGV4dFJhbmdlQ29udGFpbmVyRWxlbWVudCh0ZXh0UmFuZ2UpIHtcbiAgICB2YXIgcGFyZW50RWwgPSB0ZXh0UmFuZ2UucGFyZW50RWxlbWVudCgpO1xuXG4gICAgdmFyIHJhbmdlID0gdGV4dFJhbmdlLmR1cGxpY2F0ZSgpO1xuICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgIHZhciBzdGFydEVsID0gcmFuZ2UucGFyZW50RWxlbWVudCgpO1xuICAgIHJhbmdlID0gdGV4dFJhbmdlLmR1cGxpY2F0ZSgpO1xuICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICB2YXIgZW5kRWwgPSByYW5nZS5wYXJlbnRFbGVtZW50KCk7XG4gICAgdmFyIHN0YXJ0RW5kQ29udGFpbmVyID0gc3RhcnRFbCA9PSBlbmRFbCA/IHN0YXJ0RWwgOiBkb20uZ2V0Q29tbW9uQW5jZXN0b3Ioc3RhcnRFbCwgZW5kRWwpO1xuXG4gICAgcmV0dXJuIHN0YXJ0RW5kQ29udGFpbmVyID09IHBhcmVudEVsID8gc3RhcnRFbmRDb250YWluZXIgOiBkb20uZ2V0Q29tbW9uQW5jZXN0b3IocGFyZW50RWwsIHN0YXJ0RW5kQ29udGFpbmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRleHRSYW5nZUlzQ29sbGFwc2VkKHRleHRSYW5nZSkge1xuICAgIHJldHVybiB0ZXh0UmFuZ2UuY29tcGFyZUVuZFBvaW50cyhcIlN0YXJ0VG9FbmRcIiwgdGV4dFJhbmdlKSA9PSAwO1xuICB9XG5cbiAgLy8gR2V0cyB0aGUgYm91bmRhcnkgb2YgYSBUZXh0UmFuZ2UgZXhwcmVzc2VkIGFzIGEgbm9kZSBhbmQgYW4gb2Zmc2V0IHdpdGhpbiB0aGF0IG5vZGUuIFRoaXMgZnVuY3Rpb24gc3RhcnRlZCBvdXQgYXNcbiAgLy8gYW4gaW1wcm92ZWQgdmVyc2lvbiBvZiBjb2RlIGZvdW5kIGluIFRpbSBDYW1lcm9uIFJ5YW4ncyBJRVJhbmdlIChodHRwOi8vY29kZS5nb29nbGUuY29tL3AvaWVyYW5nZS8pIGJ1dCBoYXNcbiAgLy8gZ3Jvd24sIGZpeGluZyBwcm9ibGVtcyB3aXRoIGxpbmUgYnJlYWtzIGluIHByZWZvcm1hdHRlZCB0ZXh0LCBhZGRpbmcgd29ya2Fyb3VuZCBmb3IgSUUgVGV4dFJhbmdlIGJ1Z3MsIGhhbmRsaW5nXG4gIC8vIGZvciBpbnB1dHMgYW5kIGltYWdlcywgcGx1cyBvcHRpbWl6YXRpb25zLlxuICBmdW5jdGlvbiBnZXRUZXh0UmFuZ2VCb3VuZGFyeVBvc2l0aW9uKHRleHRSYW5nZSwgd2hvbGVSYW5nZUNvbnRhaW5lckVsZW1lbnQsIGlzU3RhcnQsIGlzQ29sbGFwc2VkKSB7XG4gICAgdmFyIHdvcmtpbmdSYW5nZSA9IHRleHRSYW5nZS5kdXBsaWNhdGUoKTtcblxuICAgIHdvcmtpbmdSYW5nZS5jb2xsYXBzZShpc1N0YXJ0KTtcbiAgICB2YXIgY29udGFpbmVyRWxlbWVudCA9IHdvcmtpbmdSYW5nZS5wYXJlbnRFbGVtZW50KCk7XG5cbiAgICAvLyBTb21ldGltZXMgY29sbGFwc2luZyBhIFRleHRSYW5nZSB0aGF0J3MgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dCBub2RlIGNhbiBtb3ZlIGl0IGludG8gdGhlIHByZXZpb3VzIG5vZGUsIHNvXG4gICAgLy8gY2hlY2sgZm9yIHRoYXRcbiAgICAvLyBUT0RPOiBGaW5kIG91dCB3aGVuLiBXb3JrYXJvdW5kIGZvciB3aG9sZVJhbmdlQ29udGFpbmVyRWxlbWVudCBtYXkgYnJlYWsgdGhpc1xuICAgIGlmICghZG9tLmlzQW5jZXN0b3JPZih3aG9sZVJhbmdlQ29udGFpbmVyRWxlbWVudCwgY29udGFpbmVyRWxlbWVudCwgdHJ1ZSkpIHtcbiAgICAgIGNvbnRhaW5lckVsZW1lbnQgPSB3aG9sZVJhbmdlQ29udGFpbmVyRWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBEZWFsIHdpdGggbm9kZXMgdGhhdCBjYW5ub3QgXCJjb250YWluIHJpY2ggSFRNTCBtYXJrdXBcIi4gSW4gcHJhY3RpY2UsIHRoaXMgbWVhbnMgZm9ybSBpbnB1dHMsIGltYWdlcyBhbmRcbiAgICAvLyBzaW1pbGFyLiBTZWUgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2FhNzAzOTUwJTI4VlMuODUlMjkuYXNweFxuICAgIGlmICghY29udGFpbmVyRWxlbWVudC5jYW5IYXZlSFRNTCkge1xuICAgICAgcmV0dXJuIG5ldyBEb21Qb3NpdGlvbihjb250YWluZXJFbGVtZW50LnBhcmVudE5vZGUsIGRvbS5nZXROb2RlSW5kZXgoY29udGFpbmVyRWxlbWVudCkpO1xuICAgIH1cblxuICAgIHZhciB3b3JraW5nTm9kZSA9IGRvbS5nZXREb2N1bWVudChjb250YWluZXJFbGVtZW50KS5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICB2YXIgY29tcGFyaXNvbixcbiAgICAgICAgd29ya2luZ0NvbXBhcmlzb25UeXBlID0gaXNTdGFydCA/IFwiU3RhcnRUb1N0YXJ0XCIgOiBcIlN0YXJ0VG9FbmRcIjtcbiAgICB2YXIgcHJldmlvdXNOb2RlLCBuZXh0Tm9kZSwgYm91bmRhcnlQb3NpdGlvbiwgYm91bmRhcnlOb2RlO1xuXG4gICAgLy8gTW92ZSB0aGUgd29ya2luZyByYW5nZSB0aHJvdWdoIHRoZSBjb250YWluZXIncyBjaGlsZHJlbiwgc3RhcnRpbmcgYXQgdGhlIGVuZCBhbmQgd29ya2luZyBiYWNrd2FyZHMsIHVudGlsIHRoZVxuICAgIC8vIHdvcmtpbmcgcmFuZ2UgcmVhY2hlcyBvciBnb2VzIHBhc3QgdGhlIGJvdW5kYXJ5IHdlJ3JlIGludGVyZXN0ZWQgaW5cbiAgICBkbyB7XG4gICAgICBjb250YWluZXJFbGVtZW50Lmluc2VydEJlZm9yZSh3b3JraW5nTm9kZSwgd29ya2luZ05vZGUucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgIHdvcmtpbmdSYW5nZS5tb3ZlVG9FbGVtZW50VGV4dCh3b3JraW5nTm9kZSk7XG4gICAgfSB3aGlsZSAoKGNvbXBhcmlzb24gPSB3b3JraW5nUmFuZ2UuY29tcGFyZUVuZFBvaW50cyh3b3JraW5nQ29tcGFyaXNvblR5cGUsIHRleHRSYW5nZSkpID4gMCAmJiB3b3JraW5nTm9kZS5wcmV2aW91c1NpYmxpbmcpO1xuXG4gICAgLy8gV2UndmUgbm93IHJlYWNoZWQgb3IgZ29uZSBwYXN0IHRoZSBib3VuZGFyeSBvZiB0aGUgdGV4dCByYW5nZSB3ZSdyZSBpbnRlcmVzdGVkIGluXG4gICAgLy8gc28gaGF2ZSBpZGVudGlmaWVkIHRoZSBub2RlIHdlIHdhbnRcbiAgICBib3VuZGFyeU5vZGUgPSB3b3JraW5nTm9kZS5uZXh0U2libGluZztcblxuICAgIGlmIChjb21wYXJpc29uID09IC0xICYmIGJvdW5kYXJ5Tm9kZSAmJiBkb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShib3VuZGFyeU5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgY2hhcmFjdGVyIGRhdGEgbm9kZSAodGV4dCwgY29tbWVudCwgY2RhdGEpLiBUaGUgd29ya2luZyByYW5nZSBpcyBjb2xsYXBzZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAgLy8gbm9kZSBjb250YWluaW5nIHRoZSB0ZXh0IHJhbmdlJ3MgYm91bmRhcnksIHNvIHdlIG1vdmUgdGhlIGVuZCBvZiB0aGUgd29ya2luZyByYW5nZSB0byB0aGUgYm91bmRhcnkgcG9pbnRcbiAgICAgIC8vIGFuZCBtZWFzdXJlIHRoZSBsZW5ndGggb2YgaXRzIHRleHQgdG8gZ2V0IHRoZSBib3VuZGFyeSdzIG9mZnNldCB3aXRoaW4gdGhlIG5vZGUuXG4gICAgICB3b3JraW5nUmFuZ2Uuc2V0RW5kUG9pbnQoaXNTdGFydCA/IFwiRW5kVG9TdGFydFwiIDogXCJFbmRUb0VuZFwiLCB0ZXh0UmFuZ2UpO1xuXG4gICAgICB2YXIgb2Zmc2V0O1xuXG4gICAgICBpZiAoL1tcXHJcXG5dLy50ZXN0KGJvdW5kYXJ5Tm9kZS5kYXRhKSkge1xuICAgICAgICAvKlxuICAgICAgICBGb3IgdGhlIHBhcnRpY3VsYXIgY2FzZSBvZiBhIGJvdW5kYXJ5IHdpdGhpbiBhIHRleHQgbm9kZSBjb250YWluaW5nIGxpbmUgYnJlYWtzICh3aXRoaW4gYSA8cHJlPiBlbGVtZW50LFxuICAgICAgICBmb3IgZXhhbXBsZSksIHdlIG5lZWQgYSBzbGlnaHRseSBjb21wbGljYXRlZCBhcHByb2FjaCB0byBnZXQgdGhlIGJvdW5kYXJ5J3Mgb2Zmc2V0IGluIElFLiBUaGUgZmFjdHM6XG4gICAgICAgICAtIEVhY2ggbGluZSBicmVhayBpcyByZXByZXNlbnRlZCBhcyBcXHIgaW4gdGhlIHRleHQgbm9kZSdzIGRhdGEvbm9kZVZhbHVlIHByb3BlcnRpZXNcbiAgICAgICAgLSBFYWNoIGxpbmUgYnJlYWsgaXMgcmVwcmVzZW50ZWQgYXMgXFxyXFxuIGluIHRoZSBUZXh0UmFuZ2UncyAndGV4dCcgcHJvcGVydHlcbiAgICAgICAgLSBUaGUgJ3RleHQnIHByb3BlcnR5IG9mIHRoZSBUZXh0UmFuZ2UgZG9lcyBub3QgY29udGFpbiB0cmFpbGluZyBsaW5lIGJyZWFrc1xuICAgICAgICAgVG8gZ2V0IHJvdW5kIHRoZSBwcm9ibGVtIHByZXNlbnRlZCBieSB0aGUgZmluYWwgZmFjdCBhYm92ZSwgd2UgY2FuIHVzZSB0aGUgZmFjdCB0aGF0IFRleHRSYW5nZSdzXG4gICAgICAgIG1vdmVTdGFydCgpIGFuZCBtb3ZlRW5kKCkgbWV0aG9kcyByZXR1cm4gdGhlIGFjdHVhbCBudW1iZXIgb2YgY2hhcmFjdGVycyBtb3ZlZCwgd2hpY2ggaXMgbm90IG5lY2Vzc2FyaWx5XG4gICAgICAgIHRoZSBzYW1lIGFzIHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBpdCB3YXMgaW5zdHJ1Y3RlZCB0byBtb3ZlLiBUaGUgc2ltcGxlc3QgYXBwcm9hY2ggaXMgdG8gdXNlIHRoaXMgdG9cbiAgICAgICAgc3RvcmUgdGhlIGNoYXJhY3RlcnMgbW92ZWQgd2hlbiBtb3ZpbmcgYm90aCB0aGUgc3RhcnQgYW5kIGVuZCBvZiB0aGUgcmFuZ2UgdG8gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudFxuICAgICAgICBib2R5IGFuZCBzdWJ0cmFjdGluZyB0aGUgc3RhcnQgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZmZzZXQgKHRoZSBcIm1vdmUtbmVnYXRpdmUtZ2F6aWxsaW9uXCIgbWV0aG9kKS5cbiAgICAgICAgSG93ZXZlciwgdGhpcyBpcyBleHRyZW1lbHkgc2xvdyB3aGVuIHRoZSBkb2N1bWVudCBpcyBsYXJnZSBhbmQgdGhlIHJhbmdlIGlzIG5lYXIgdGhlIGVuZCBvZiBpdC4gQ2xlYXJseVxuICAgICAgICBkb2luZyB0aGUgbWlycm9yIGltYWdlIChpLmUuIG1vdmluZyB0aGUgcmFuZ2UgYm91bmRhcmllcyB0byB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudCkgaGFzIHRoZSBzYW1lXG4gICAgICAgIHByb2JsZW0uXG4gICAgICAgICBBbm90aGVyIGFwcHJvYWNoIHRoYXQgd29ya3MgaXMgdG8gdXNlIG1vdmVTdGFydCgpIHRvIG1vdmUgdGhlIHN0YXJ0IGJvdW5kYXJ5IG9mIHRoZSByYW5nZSB1cCB0byB0aGUgZW5kXG4gICAgICAgIGJvdW5kYXJ5IG9uZSBjaGFyYWN0ZXIgYXQgYSB0aW1lIGFuZCBpbmNyZW1lbnRpbmcgYSBjb3VudGVyIHdpdGggdGhlIHZhbHVlIHJldHVybmVkIGJ5IHRoZSBtb3ZlU3RhcnQoKVxuICAgICAgICBjYWxsLiBIb3dldmVyLCB0aGUgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHN0YXJ0IGJvdW5kYXJ5IGhhcyByZWFjaGVkIHRoZSBlbmQgYm91bmRhcnkgaXMgZXhwZW5zaXZlLCBzb1xuICAgICAgICB0aGlzIG1ldGhvZCBpcyBzbG93IChhbHRob3VnaCB1bmxpa2UgXCJtb3ZlLW5lZ2F0aXZlLWdhemlsbGlvblwiIGlzIGxhcmdlbHkgdW5hZmZlY3RlZCBieSB0aGUgbG9jYXRpb24gb2ZcbiAgICAgICAgdGhlIHJhbmdlIHdpdGhpbiB0aGUgZG9jdW1lbnQpLlxuICAgICAgICAgVGhlIG1ldGhvZCBiZWxvdyBpcyBhIGh5YnJpZCBvZiB0aGUgdHdvIG1ldGhvZHMgYWJvdmUuIEl0IHVzZXMgdGhlIGZhY3QgdGhhdCBhIHN0cmluZyBjb250YWluaW5nIHRoZVxuICAgICAgICBUZXh0UmFuZ2UncyAndGV4dCcgcHJvcGVydHkgd2l0aCBlYWNoIFxcclxcbiBjb252ZXJ0ZWQgdG8gYSBzaW5nbGUgXFxyIGNoYXJhY3RlciBjYW5ub3QgYmUgbG9uZ2VyIHRoYW4gdGhlXG4gICAgICAgIHRleHQgb2YgdGhlIFRleHRSYW5nZSwgc28gdGhlIHN0YXJ0IG9mIHRoZSByYW5nZSBpcyBtb3ZlZCB0aGF0IGxlbmd0aCBpbml0aWFsbHkgYW5kIHRoZW4gYSBjaGFyYWN0ZXIgYXRcbiAgICAgICAgYSB0aW1lIHRvIG1ha2UgdXAgZm9yIGFueSB0cmFpbGluZyBsaW5lIGJyZWFrcyBub3QgY29udGFpbmVkIGluIHRoZSAndGV4dCcgcHJvcGVydHkuIFRoaXMgaGFzIGdvb2RcbiAgICAgICAgcGVyZm9ybWFuY2UgaW4gbW9zdCBzaXR1YXRpb25zIGNvbXBhcmVkIHRvIHRoZSBwcmV2aW91cyB0d28gbWV0aG9kcy5cbiAgICAgICAgKi9cbiAgICAgICAgdmFyIHRlbXBSYW5nZSA9IHdvcmtpbmdSYW5nZS5kdXBsaWNhdGUoKTtcbiAgICAgICAgdmFyIHJhbmdlTGVuZ3RoID0gdGVtcFJhbmdlLnRleHQucmVwbGFjZSgvXFxyXFxuL2csIFwiXFxyXCIpLmxlbmd0aDtcblxuICAgICAgICBvZmZzZXQgPSB0ZW1wUmFuZ2UubW92ZVN0YXJ0KFwiY2hhcmFjdGVyXCIsIHJhbmdlTGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKChjb21wYXJpc29uID0gdGVtcFJhbmdlLmNvbXBhcmVFbmRQb2ludHMoXCJTdGFydFRvRW5kXCIsIHRlbXBSYW5nZSkpID09IC0xKSB7XG4gICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgdGVtcFJhbmdlLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ID0gd29ya2luZ1JhbmdlLnRleHQubGVuZ3RoO1xuICAgICAgfVxuICAgICAgYm91bmRhcnlQb3NpdGlvbiA9IG5ldyBEb21Qb3NpdGlvbihib3VuZGFyeU5vZGUsIG9mZnNldCk7XG4gICAgfSBlbHNlIHtcblxuICAgICAgLy8gSWYgdGhlIGJvdW5kYXJ5IGltbWVkaWF0ZWx5IGZvbGxvd3MgYSBjaGFyYWN0ZXIgZGF0YSBub2RlIGFuZCB0aGlzIGlzIHRoZSBlbmQgYm91bmRhcnksIHdlIHNob3VsZCBmYXZvdXJcbiAgICAgIC8vIGEgcG9zaXRpb24gd2l0aGluIHRoYXQsIGFuZCBsaWtld2lzZSBmb3IgYSBzdGFydCBib3VuZGFyeSBwcmVjZWRpbmcgYSBjaGFyYWN0ZXIgZGF0YSBub2RlXG4gICAgICBwcmV2aW91c05vZGUgPSAoaXNDb2xsYXBzZWQgfHwgIWlzU3RhcnQpICYmIHdvcmtpbmdOb2RlLnByZXZpb3VzU2libGluZztcbiAgICAgIG5leHROb2RlID0gKGlzQ29sbGFwc2VkIHx8IGlzU3RhcnQpICYmIHdvcmtpbmdOb2RlLm5leHRTaWJsaW5nO1xuXG4gICAgICBpZiAobmV4dE5vZGUgJiYgZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUobmV4dE5vZGUpKSB7XG4gICAgICAgIGJvdW5kYXJ5UG9zaXRpb24gPSBuZXcgRG9tUG9zaXRpb24obmV4dE5vZGUsIDApO1xuICAgICAgfSBlbHNlIGlmIChwcmV2aW91c05vZGUgJiYgZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUocHJldmlvdXNOb2RlKSkge1xuICAgICAgICBib3VuZGFyeVBvc2l0aW9uID0gbmV3IERvbVBvc2l0aW9uKHByZXZpb3VzTm9kZSwgcHJldmlvdXNOb2RlLmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBib3VuZGFyeVBvc2l0aW9uID0gbmV3IERvbVBvc2l0aW9uKGNvbnRhaW5lckVsZW1lbnQsIGRvbS5nZXROb2RlSW5kZXgod29ya2luZ05vZGUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDbGVhbiB1cFxuICAgIHdvcmtpbmdOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQod29ya2luZ05vZGUpO1xuXG4gICAgcmV0dXJuIGJvdW5kYXJ5UG9zaXRpb247XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgVGV4dFJhbmdlIHJlcHJlc2VudGluZyB0aGUgYm91bmRhcnkgb2YgYSBUZXh0UmFuZ2UgZXhwcmVzc2VkIGFzIGEgbm9kZSBhbmQgYW4gb2Zmc2V0IHdpdGhpbiB0aGF0IG5vZGUuXG4gIC8vIFRoaXMgZnVuY3Rpb24gc3RhcnRlZCBvdXQgYXMgYW4gb3B0aW1pemVkIHZlcnNpb24gb2YgY29kZSBmb3VuZCBpbiBUaW0gQ2FtZXJvbiBSeWFuJ3MgSUVSYW5nZVxuICAvLyAoaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2llcmFuZ2UvKVxuICBmdW5jdGlvbiBjcmVhdGVCb3VuZGFyeVRleHRSYW5nZShib3VuZGFyeVBvc2l0aW9uLCBpc1N0YXJ0KSB7XG4gICAgdmFyIGJvdW5kYXJ5Tm9kZSxcbiAgICAgICAgYm91bmRhcnlQYXJlbnQsXG4gICAgICAgIGJvdW5kYXJ5T2Zmc2V0ID0gYm91bmRhcnlQb3NpdGlvbi5vZmZzZXQ7XG4gICAgdmFyIGRvYyA9IGRvbS5nZXREb2N1bWVudChib3VuZGFyeVBvc2l0aW9uLm5vZGUpO1xuICAgIHZhciB3b3JraW5nTm9kZSxcbiAgICAgICAgY2hpbGROb2RlcyxcbiAgICAgICAgd29ya2luZ1JhbmdlID0gZG9jLmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgdmFyIG5vZGVJc0RhdGFOb2RlID0gZG9tLmlzQ2hhcmFjdGVyRGF0YU5vZGUoYm91bmRhcnlQb3NpdGlvbi5ub2RlKTtcblxuICAgIGlmIChub2RlSXNEYXRhTm9kZSkge1xuICAgICAgYm91bmRhcnlOb2RlID0gYm91bmRhcnlQb3NpdGlvbi5ub2RlO1xuICAgICAgYm91bmRhcnlQYXJlbnQgPSBib3VuZGFyeU5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGROb2RlcyA9IGJvdW5kYXJ5UG9zaXRpb24ubm9kZS5jaGlsZE5vZGVzO1xuICAgICAgYm91bmRhcnlOb2RlID0gYm91bmRhcnlPZmZzZXQgPCBjaGlsZE5vZGVzLmxlbmd0aCA/IGNoaWxkTm9kZXNbYm91bmRhcnlPZmZzZXRdIDogbnVsbDtcbiAgICAgIGJvdW5kYXJ5UGFyZW50ID0gYm91bmRhcnlQb3NpdGlvbi5ub2RlO1xuICAgIH1cblxuICAgIC8vIFBvc2l0aW9uIHRoZSByYW5nZSBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIG5vZGUgY29udGFpbmluZyB0aGUgYm91bmRhcnlcbiAgICB3b3JraW5nTm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcblxuICAgIC8vIE1ha2luZyB0aGUgd29ya2luZyBlbGVtZW50IG5vbi1lbXB0eSBlbGVtZW50IHBlcnN1YWRlcyBJRSB0byBjb25zaWRlciB0aGUgVGV4dFJhbmdlIGJvdW5kYXJ5IHRvIGJlIHdpdGhpbiB0aGVcbiAgICAvLyBlbGVtZW50IHJhdGhlciB0aGFuIGltbWVkaWF0ZWx5IGJlZm9yZSBvciBhZnRlciBpdCwgd2hpY2ggaXMgd2hhdCB3ZSB3YW50XG4gICAgd29ya2luZ05vZGUuaW5uZXJIVE1MID0gXCImI2ZlZmY7XCI7XG5cbiAgICAvLyBpbnNlcnRCZWZvcmUgaXMgc3VwcG9zZWQgdG8gd29yayBsaWtlIGFwcGVuZENoaWxkIGlmIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIG51bGwuIEhvd2V2ZXIsIGEgYnVnIHJlcG9ydFxuICAgIC8vIGZvciBJRVJhbmdlIHN1Z2dlc3RzIHRoYXQgaXQgY2FuIGNyYXNoIHRoZSBicm93c2VyOiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvaWVyYW5nZS9pc3N1ZXMvZGV0YWlsP2lkPTEyXG4gICAgaWYgKGJvdW5kYXJ5Tm9kZSkge1xuICAgICAgYm91bmRhcnlQYXJlbnQuaW5zZXJ0QmVmb3JlKHdvcmtpbmdOb2RlLCBib3VuZGFyeU5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGFyeVBhcmVudC5hcHBlbmRDaGlsZCh3b3JraW5nTm9kZSk7XG4gICAgfVxuXG4gICAgd29ya2luZ1JhbmdlLm1vdmVUb0VsZW1lbnRUZXh0KHdvcmtpbmdOb2RlKTtcbiAgICB3b3JraW5nUmFuZ2UuY29sbGFwc2UoIWlzU3RhcnQpO1xuXG4gICAgLy8gQ2xlYW4gdXBcbiAgICBib3VuZGFyeVBhcmVudC5yZW1vdmVDaGlsZCh3b3JraW5nTm9kZSk7XG5cbiAgICAvLyBNb3ZlIHRoZSB3b3JraW5nIHJhbmdlIHRvIHRoZSB0ZXh0IG9mZnNldCwgaWYgcmVxdWlyZWRcbiAgICBpZiAobm9kZUlzRGF0YU5vZGUpIHtcbiAgICAgIHdvcmtpbmdSYW5nZVtpc1N0YXJ0ID8gXCJtb3ZlU3RhcnRcIiA6IFwibW92ZUVuZFwiXShcImNoYXJhY3RlclwiLCBib3VuZGFyeU9mZnNldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtpbmdSYW5nZTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgaWYgKGFwaS5mZWF0dXJlcy5pbXBsZW1lbnRzRG9tUmFuZ2UgJiYgKCFhcGkuZmVhdHVyZXMuaW1wbGVtZW50c1RleHRSYW5nZSB8fCAhYXBpLmNvbmZpZy5wcmVmZXJUZXh0UmFuZ2UpKSB7XG4gICAgLy8gVGhpcyBpcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBicm93c2VyJ3MgbmF0aXZlIERPTSBSYW5nZS4gSXQgaGFzIHR3byBhaW1zOlxuICAgIC8vIC0gUHJvdmlkZSB3b3JrYXJvdW5kcyBmb3Igc3BlY2lmaWMgYnJvd3NlciBidWdzXG4gICAgLy8gLSBwcm92aWRlIGNvbnZlbmllbnQgZXh0ZW5zaW9ucywgd2hpY2ggYXJlIGluaGVyaXRlZCBmcm9tIFJhbmd5J3MgRG9tUmFuZ2VcblxuICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmFuZ2VQcm90bztcbiAgICAgIHZhciByYW5nZVByb3BlcnRpZXMgPSBEb21SYW5nZS5yYW5nZVByb3BlcnRpZXM7XG4gICAgICB2YXIgY2FuU2V0UmFuZ2VTdGFydEFmdGVyRW5kO1xuXG4gICAgICBmdW5jdGlvbiB1cGRhdGVSYW5nZVByb3BlcnRpZXMocmFuZ2UpIHtcbiAgICAgICAgdmFyIGkgPSByYW5nZVByb3BlcnRpZXMubGVuZ3RoLFxuICAgICAgICAgICAgcHJvcDtcbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgIHByb3AgPSByYW5nZVByb3BlcnRpZXNbaV07XG4gICAgICAgICAgcmFuZ2VbcHJvcF0gPSByYW5nZS5uYXRpdmVSYW5nZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB1cGRhdGVOYXRpdmVSYW5nZShyYW5nZSwgc3RhcnRDb250YWluZXIsIHN0YXJ0T2Zmc2V0LCBlbmRDb250YWluZXIsIGVuZE9mZnNldCkge1xuICAgICAgICB2YXIgc3RhcnRNb3ZlZCA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyICE9PSBzdGFydENvbnRhaW5lciB8fCByYW5nZS5zdGFydE9mZnNldCAhPSBzdGFydE9mZnNldDtcbiAgICAgICAgdmFyIGVuZE1vdmVkID0gcmFuZ2UuZW5kQ29udGFpbmVyICE9PSBlbmRDb250YWluZXIgfHwgcmFuZ2UuZW5kT2Zmc2V0ICE9IGVuZE9mZnNldDtcblxuICAgICAgICAvLyBBbHdheXMgc2V0IGJvdGggYm91bmRhcmllcyBmb3IgdGhlIGJlbmVmaXQgb2YgSUU5IChzZWUgaXNzdWUgMzUpXG4gICAgICAgIGlmIChzdGFydE1vdmVkIHx8IGVuZE1vdmVkKSB7XG4gICAgICAgICAgcmFuZ2Uuc2V0RW5kKGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0KTtcbiAgICAgICAgICByYW5nZS5zZXRTdGFydChzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRldGFjaChyYW5nZSkge1xuICAgICAgICByYW5nZS5uYXRpdmVSYW5nZS5kZXRhY2goKTtcbiAgICAgICAgcmFuZ2UuZGV0YWNoZWQgPSB0cnVlO1xuICAgICAgICB2YXIgaSA9IHJhbmdlUHJvcGVydGllcy5sZW5ndGgsXG4gICAgICAgICAgICBwcm9wO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgcHJvcCA9IHJhbmdlUHJvcGVydGllc1tpXTtcbiAgICAgICAgICByYW5nZVtwcm9wXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNyZWF0ZUJlZm9yZUFmdGVyTm9kZVNldHRlcjtcblxuICAgICAgV3JhcHBlZFJhbmdlID0gZnVuY3Rpb24gV3JhcHBlZFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZSBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlID0gcmFuZ2U7XG4gICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgIH07XG5cbiAgICAgIERvbVJhbmdlLmNyZWF0ZVByb3RvdHlwZVJhbmdlKFdyYXBwZWRSYW5nZSwgdXBkYXRlTmF0aXZlUmFuZ2UsIGRldGFjaCk7XG5cbiAgICAgIHJhbmdlUHJvdG8gPSBXcmFwcGVkUmFuZ2UucHJvdG90eXBlO1xuXG4gICAgICByYW5nZVByb3RvLnNlbGVjdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnNlbGVjdE5vZGUobm9kZSk7XG4gICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgIH07XG5cbiAgICAgIHJhbmdlUHJvdG8uZGVsZXRlQ29udGVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubmF0aXZlUmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgfTtcblxuICAgICAgcmFuZ2VQcm90by5leHRyYWN0Q29udGVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmcmFnID0gdGhpcy5uYXRpdmVSYW5nZS5leHRyYWN0Q29udGVudHMoKTtcbiAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICByZXR1cm4gZnJhZztcbiAgICAgIH07XG5cbiAgICAgIHJhbmdlUHJvdG8uY2xvbmVDb250ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlUmFuZ2UuY2xvbmVDb250ZW50cygpO1xuICAgICAgfTtcblxuICAgICAgLy8gVE9ETzogVW50aWwgSSBjYW4gZmluZCBhIHdheSB0byBwcm9ncmFtbWF0aWNhbGx5IHRyaWdnZXIgdGhlIEZpcmVmb3ggYnVnIChhcHBhcmVudGx5IGxvbmctc3RhbmRpbmcsIHN0aWxsXG4gICAgICAvLyBwcmVzZW50IGluIDMuNi44KSB0aGF0IHRocm93cyBcIkluZGV4IG9yIHNpemUgaXMgbmVnYXRpdmUgb3IgZ3JlYXRlciB0aGFuIHRoZSBhbGxvd2VkIGFtb3VudFwiIGZvclxuICAgICAgLy8gaW5zZXJ0Tm9kZSBpbiBzb21lIGNpcmN1bXN0YW5jZXMsIGFsbCBicm93c2VycyB3aWxsIGhhdmUgdG8gdXNlIHRoZSBSYW5neSdzIG93biBpbXBsZW1lbnRhdGlvbiBvZlxuICAgICAgLy8gaW5zZXJ0Tm9kZSwgd2hpY2ggd29ya3MgYnV0IGlzIGFsbW9zdCBjZXJ0YWlubHkgc2xvd2VyIHRoYW4gdGhlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIC8qXG4gICAgICAgICAgICAgICAgICByYW5nZVByb3RvLmluc2VydE5vZGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAqL1xuXG4gICAgICByYW5nZVByb3RvLnN1cnJvdW5kQ29udGVudHMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnN1cnJvdW5kQ29udGVudHMobm9kZSk7XG4gICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgIH07XG5cbiAgICAgIHJhbmdlUHJvdG8uY29sbGFwc2UgPSBmdW5jdGlvbiAoaXNTdGFydCkge1xuICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLmNvbGxhcHNlKGlzU3RhcnQpO1xuICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICB9O1xuXG4gICAgICByYW5nZVByb3RvLmNsb25lUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgV3JhcHBlZFJhbmdlKHRoaXMubmF0aXZlUmFuZ2UuY2xvbmVSYW5nZSgpKTtcbiAgICAgIH07XG5cbiAgICAgIHJhbmdlUHJvdG8ucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgfTtcblxuICAgICAgcmFuZ2VQcm90by50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmF0aXZlUmFuZ2UudG9TdHJpbmcoKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIENyZWF0ZSB0ZXN0IHJhbmdlIGFuZCBub2RlIGZvciBmZWF0dXJlIGRldGVjdGlvblxuXG4gICAgICB2YXIgdGVzdFRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ0ZXN0XCIpO1xuICAgICAgZG9tLmdldEJvZHkoZG9jdW1lbnQpLmFwcGVuZENoaWxkKHRlc3RUZXh0Tm9kZSk7XG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuXG4gICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgLy8gVGVzdCBmb3IgRmlyZWZveCAyIGJ1ZyB0aGF0IHByZXZlbnRzIG1vdmluZyB0aGUgc3RhcnQgb2YgYSBSYW5nZSB0byBhIHBvaW50IGFmdGVyIGl0cyBjdXJyZW50IGVuZCBhbmRcbiAgICAgIC8vIGNvcnJlY3QgZm9yIGl0XG5cbiAgICAgIHJhbmdlLnNldFN0YXJ0KHRlc3RUZXh0Tm9kZSwgMCk7XG4gICAgICByYW5nZS5zZXRFbmQodGVzdFRleHROb2RlLCAwKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQodGVzdFRleHROb2RlLCAxKTtcbiAgICAgICAgY2FuU2V0UmFuZ2VTdGFydEFmdGVyRW5kID0gdHJ1ZTtcblxuICAgICAgICByYW5nZVByb3RvLnNldFN0YXJ0ID0gZnVuY3Rpb24gKG5vZGUsIG9mZnNldCkge1xuICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmFuZ2VQcm90by5zZXRFbmQgPSBmdW5jdGlvbiAobm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRFbmQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyID0gZnVuY3Rpb24gY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2VbbmFtZV0obm9kZSk7XG4gICAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG5cbiAgICAgICAgY2FuU2V0UmFuZ2VTdGFydEFmdGVyRW5kID0gZmFsc2U7XG5cbiAgICAgICAgcmFuZ2VQcm90by5zZXRTdGFydCA9IGZ1bmN0aW9uIChub2RlLCBvZmZzZXQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnNldEVuZChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZS5zZXRTdGFydChub2RlLCBvZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmFuZ2VQcm90by5zZXRFbmQgPSBmdW5jdGlvbiAobm9kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2V0U3RhcnQobm9kZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMubmF0aXZlUmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVJhbmdlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIgPSBmdW5jdGlvbiBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIobmFtZSwgb3Bwb3NpdGVOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlW25hbWVdKG5vZGUpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgdGhpcy5uYXRpdmVSYW5nZVtvcHBvc2l0ZU5hbWVdKG5vZGUpO1xuICAgICAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlW25hbWVdKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlUmFuZ2VQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJhbmdlUHJvdG8uc2V0U3RhcnRCZWZvcmUgPSBjcmVhdGVCZWZvcmVBZnRlck5vZGVTZXR0ZXIoXCJzZXRTdGFydEJlZm9yZVwiLCBcInNldEVuZEJlZm9yZVwiKTtcbiAgICAgIHJhbmdlUHJvdG8uc2V0U3RhcnRBZnRlciA9IGNyZWF0ZUJlZm9yZUFmdGVyTm9kZVNldHRlcihcInNldFN0YXJ0QWZ0ZXJcIiwgXCJzZXRFbmRBZnRlclwiKTtcbiAgICAgIHJhbmdlUHJvdG8uc2V0RW5kQmVmb3JlID0gY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKFwic2V0RW5kQmVmb3JlXCIsIFwic2V0U3RhcnRCZWZvcmVcIik7XG4gICAgICByYW5nZVByb3RvLnNldEVuZEFmdGVyID0gY3JlYXRlQmVmb3JlQWZ0ZXJOb2RlU2V0dGVyKFwic2V0RW5kQWZ0ZXJcIiwgXCJzZXRTdGFydEFmdGVyXCIpO1xuXG4gICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgLy8gVGVzdCBmb3IgYW5kIGNvcnJlY3QgRmlyZWZveCAyIGJlaGF2aW91ciB3aXRoIHNlbGVjdE5vZGVDb250ZW50cyBvbiB0ZXh0IG5vZGVzOiBpdCBjb2xsYXBzZXMgdGhlIHJhbmdlIHRvXG4gICAgICAvLyB0aGUgMHRoIGNoYXJhY3RlciBvZiB0aGUgdGV4dCBub2RlXG4gICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHModGVzdFRleHROb2RlKTtcbiAgICAgIGlmIChyYW5nZS5zdGFydENvbnRhaW5lciA9PSB0ZXN0VGV4dE5vZGUgJiYgcmFuZ2UuZW5kQ29udGFpbmVyID09IHRlc3RUZXh0Tm9kZSAmJiByYW5nZS5zdGFydE9mZnNldCA9PSAwICYmIHJhbmdlLmVuZE9mZnNldCA9PSB0ZXN0VGV4dE5vZGUubGVuZ3RoKSB7XG4gICAgICAgIHJhbmdlUHJvdG8uc2VsZWN0Tm9kZUNvbnRlbnRzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICB0aGlzLm5hdGl2ZVJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgICAgICAgICB1cGRhdGVSYW5nZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZVByb3RvLnNlbGVjdE5vZGVDb250ZW50cyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgdGhpcy5zZXRTdGFydChub2RlLCAwKTtcbiAgICAgICAgICB0aGlzLnNldEVuZChub2RlLCBEb21SYW5nZS5nZXRFbmRPZmZzZXQobm9kZSkpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgLy8gVGVzdCBmb3IgV2ViS2l0IGJ1ZyB0aGF0IGhhcyB0aGUgYmVhaHZpb3VyIG9mIGNvbXBhcmVCb3VuZGFyeVBvaW50cyByb3VuZCB0aGUgd3Jvbmcgd2F5IGZvciBjb25zdGFudHNcbiAgICAgIC8vIFNUQVJUX1RPX0VORCBhbmQgRU5EX1RPX1NUQVJUOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA3MzhcblxuICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKHRlc3RUZXh0Tm9kZSk7XG4gICAgICByYW5nZS5zZXRFbmQodGVzdFRleHROb2RlLCAzKTtcblxuICAgICAgdmFyIHJhbmdlMiA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICByYW5nZTIuc2VsZWN0Tm9kZUNvbnRlbnRzKHRlc3RUZXh0Tm9kZSk7XG4gICAgICByYW5nZTIuc2V0RW5kKHRlc3RUZXh0Tm9kZSwgNCk7XG4gICAgICByYW5nZTIuc2V0U3RhcnQodGVzdFRleHROb2RlLCAyKTtcblxuICAgICAgaWYgKHJhbmdlLmNvbXBhcmVCb3VuZGFyeVBvaW50cyhyYW5nZS5TVEFSVF9UT19FTkQsIHJhbmdlMikgPT0gLTEgJiByYW5nZS5jb21wYXJlQm91bmRhcnlQb2ludHMocmFuZ2UuRU5EX1RPX1NUQVJULCByYW5nZTIpID09IDEpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgd3Jvbmcgd2F5IHJvdW5kLCBzbyBjb3JyZWN0IGZvciBpdFxuXG5cbiAgICAgICAgcmFuZ2VQcm90by5jb21wYXJlQm91bmRhcnlQb2ludHMgPSBmdW5jdGlvbiAodHlwZSwgcmFuZ2UpIHtcbiAgICAgICAgICByYW5nZSA9IHJhbmdlLm5hdGl2ZVJhbmdlIHx8IHJhbmdlO1xuICAgICAgICAgIGlmICh0eXBlID09IHJhbmdlLlNUQVJUX1RPX0VORCkge1xuICAgICAgICAgICAgdHlwZSA9IHJhbmdlLkVORF9UT19TVEFSVDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT0gcmFuZ2UuRU5EX1RPX1NUQVJUKSB7XG4gICAgICAgICAgICB0eXBlID0gcmFuZ2UuU1RBUlRfVE9fRU5EO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVSYW5nZS5jb21wYXJlQm91bmRhcnlQb2ludHModHlwZSwgcmFuZ2UpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2VQcm90by5jb21wYXJlQm91bmRhcnlQb2ludHMgPSBmdW5jdGlvbiAodHlwZSwgcmFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5uYXRpdmVSYW5nZS5jb21wYXJlQm91bmRhcnlQb2ludHModHlwZSwgcmFuZ2UubmF0aXZlUmFuZ2UgfHwgcmFuZ2UpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgICAgLy8gVGVzdCBmb3IgZXhpc3RlbmNlIG9mIGNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCBhbmQgZGVsZWdhdGUgdG8gaXQgaWYgaXQgZXhpc3RzXG4gICAgICBpZiAoYXBpLnV0aWwuaXNIb3N0TWV0aG9kKHJhbmdlLCBcImNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudFwiKSkge1xuICAgICAgICByYW5nZVByb3RvLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudCA9IGZ1bmN0aW9uIChmcmFnbWVudFN0cikge1xuICAgICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZVJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChmcmFnbWVudFN0cik7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgICAvLyBDbGVhbiB1cFxuICAgICAgZG9tLmdldEJvZHkoZG9jdW1lbnQpLnJlbW92ZUNoaWxkKHRlc3RUZXh0Tm9kZSk7XG4gICAgICByYW5nZS5kZXRhY2goKTtcbiAgICAgIHJhbmdlMi5kZXRhY2goKTtcbiAgICB9KSgpO1xuXG4gICAgYXBpLmNyZWF0ZU5hdGl2ZVJhbmdlID0gZnVuY3Rpb24gKGRvYykge1xuICAgICAgZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuICAgICAgcmV0dXJuIGRvYy5jcmVhdGVSYW5nZSgpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoYXBpLmZlYXR1cmVzLmltcGxlbWVudHNUZXh0UmFuZ2UpIHtcbiAgICAvLyBUaGlzIGlzIGEgd3JhcHBlciBhcm91bmQgYSBUZXh0UmFuZ2UsIHByb3ZpZGluZyBmdWxsIERPTSBSYW5nZSBmdW5jdGlvbmFsaXR5IHVzaW5nIHJhbmd5J3MgRG9tUmFuZ2UgYXMgYVxuICAgIC8vIHByb3RvdHlwZVxuXG4gICAgV3JhcHBlZFJhbmdlID0gZnVuY3Rpb24gV3JhcHBlZFJhbmdlKHRleHRSYW5nZSkge1xuICAgICAgdGhpcy50ZXh0UmFuZ2UgPSB0ZXh0UmFuZ2U7XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9O1xuXG4gICAgV3JhcHBlZFJhbmdlLnByb3RvdHlwZSA9IG5ldyBEb21SYW5nZShkb2N1bWVudCk7XG5cbiAgICBXcmFwcGVkUmFuZ2UucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhcnQsIGVuZDtcblxuICAgICAgLy8gVGV4dFJhbmdlJ3MgcGFyZW50RWxlbWVudCgpIG1ldGhvZCBjYW5ub3QgYmUgdHJ1c3RlZC4gZ2V0VGV4dFJhbmdlQ29udGFpbmVyRWxlbWVudCgpIHdvcmtzIGFyb3VuZCB0aGF0LlxuICAgICAgdmFyIHJhbmdlQ29udGFpbmVyRWxlbWVudCA9IGdldFRleHRSYW5nZUNvbnRhaW5lckVsZW1lbnQodGhpcy50ZXh0UmFuZ2UpO1xuXG4gICAgICBpZiAodGV4dFJhbmdlSXNDb2xsYXBzZWQodGhpcy50ZXh0UmFuZ2UpKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0ID0gZ2V0VGV4dFJhbmdlQm91bmRhcnlQb3NpdGlvbih0aGlzLnRleHRSYW5nZSwgcmFuZ2VDb250YWluZXJFbGVtZW50LCB0cnVlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgc3RhcnQgPSBnZXRUZXh0UmFuZ2VCb3VuZGFyeVBvc2l0aW9uKHRoaXMudGV4dFJhbmdlLCByYW5nZUNvbnRhaW5lckVsZW1lbnQsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgZW5kID0gZ2V0VGV4dFJhbmdlQm91bmRhcnlQb3NpdGlvbih0aGlzLnRleHRSYW5nZSwgcmFuZ2VDb250YWluZXJFbGVtZW50LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFN0YXJ0KHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldCk7XG4gICAgICB0aGlzLnNldEVuZChlbmQubm9kZSwgZW5kLm9mZnNldCk7XG4gICAgfTtcblxuICAgIERvbVJhbmdlLmNvcHlDb21wYXJpc29uQ29uc3RhbnRzKFdyYXBwZWRSYW5nZSk7XG5cbiAgICAvLyBBZGQgV3JhcHBlZFJhbmdlIGFzIHRoZSBSYW5nZSBwcm9wZXJ0eSBvZiB0aGUgZ2xvYmFsIG9iamVjdCB0byBhbGxvdyBleHByZXNzaW9uIGxpa2UgUmFuZ2UuRU5EX1RPX0VORCB0byB3b3JrXG4gICAgdmFyIGdsb2JhbE9iaiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0oKTtcbiAgICBpZiAodHlwZW9mIGdsb2JhbE9iai5SYW5nZSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBnbG9iYWxPYmouUmFuZ2UgPSBXcmFwcGVkUmFuZ2U7XG4gICAgfVxuXG4gICAgYXBpLmNyZWF0ZU5hdGl2ZVJhbmdlID0gZnVuY3Rpb24gKGRvYykge1xuICAgICAgZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuICAgICAgcmV0dXJuIGRvYy5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgIH07XG4gIH1cblxuICBpZiAoYXBpLmZlYXR1cmVzLmltcGxlbWVudHNUZXh0UmFuZ2UpIHtcbiAgICBXcmFwcGVkUmFuZ2UucmFuZ2VUb1RleHRSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgaWYgKHJhbmdlLmNvbGxhcHNlZCkge1xuICAgICAgICB2YXIgdHIgPSBjcmVhdGVCb3VuZGFyeVRleHRSYW5nZShuZXcgRG9tUG9zaXRpb24ocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHRyO1xuXG4gICAgICAgIC8vcmV0dXJuIGNyZWF0ZUJvdW5kYXJ5VGV4dFJhbmdlKG5ldyBEb21Qb3NpdGlvbihyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzdGFydFJhbmdlID0gY3JlYXRlQm91bmRhcnlUZXh0UmFuZ2UobmV3IERvbVBvc2l0aW9uKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCksIHRydWUpO1xuICAgICAgICB2YXIgZW5kUmFuZ2UgPSBjcmVhdGVCb3VuZGFyeVRleHRSYW5nZShuZXcgRG9tUG9zaXRpb24ocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpLCBmYWxzZSk7XG4gICAgICAgIHZhciB0ZXh0UmFuZ2UgPSBkb20uZ2V0RG9jdW1lbnQocmFuZ2Uuc3RhcnRDb250YWluZXIpLmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgIHRleHRSYW5nZS5zZXRFbmRQb2ludChcIlN0YXJ0VG9TdGFydFwiLCBzdGFydFJhbmdlKTtcbiAgICAgICAgdGV4dFJhbmdlLnNldEVuZFBvaW50KFwiRW5kVG9FbmRcIiwgZW5kUmFuZ2UpO1xuICAgICAgICByZXR1cm4gdGV4dFJhbmdlO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBXcmFwcGVkUmFuZ2UucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiV3JhcHBlZFJhbmdlXCI7XG4gIH07XG5cbiAgYXBpLldyYXBwZWRSYW5nZSA9IFdyYXBwZWRSYW5nZTtcblxuICBhcGkuY3JlYXRlUmFuZ2UgPSBmdW5jdGlvbiAoZG9jKSB7XG4gICAgZG9jID0gZG9jIHx8IGRvY3VtZW50O1xuICAgIHJldHVybiBuZXcgV3JhcHBlZFJhbmdlKGFwaS5jcmVhdGVOYXRpdmVSYW5nZShkb2MpKTtcbiAgfTtcblxuICBhcGkuY3JlYXRlUmFuZ3lSYW5nZSA9IGZ1bmN0aW9uIChkb2MpIHtcbiAgICBkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG4gICAgcmV0dXJuIG5ldyBEb21SYW5nZShkb2MpO1xuICB9O1xuXG4gIGFwaS5jcmVhdGVJZnJhbWVSYW5nZSA9IGZ1bmN0aW9uIChpZnJhbWVFbCkge1xuICAgIHJldHVybiBhcGkuY3JlYXRlUmFuZ2UoZG9tLmdldElmcmFtZURvY3VtZW50KGlmcmFtZUVsKSk7XG4gIH07XG5cbiAgYXBpLmNyZWF0ZUlmcmFtZVJhbmd5UmFuZ2UgPSBmdW5jdGlvbiAoaWZyYW1lRWwpIHtcbiAgICByZXR1cm4gYXBpLmNyZWF0ZVJhbmd5UmFuZ2UoZG9tLmdldElmcmFtZURvY3VtZW50KGlmcmFtZUVsKSk7XG4gIH07XG5cbiAgYXBpLmFkZENyZWF0ZU1pc3NpbmdOYXRpdmVBcGlMaXN0ZW5lcihmdW5jdGlvbiAod2luKSB7XG4gICAgdmFyIGRvYyA9IHdpbi5kb2N1bWVudDtcbiAgICBpZiAodHlwZW9mIGRvYy5jcmVhdGVSYW5nZSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBkb2MuY3JlYXRlUmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcGkuY3JlYXRlUmFuZ2UodGhpcyk7XG4gICAgICB9O1xuICAgIH1cbiAgICBkb2MgPSB3aW4gPSBudWxsO1xuICB9KTtcbn0pO3Jhbmd5LmNyZWF0ZU1vZHVsZShcIldyYXBwZWRTZWxlY3Rpb25cIiwgZnVuY3Rpb24gKGFwaSwgbW9kdWxlKSB7XG4gIC8vIFRoaXMgd2lsbCBjcmVhdGUgYSBzZWxlY3Rpb24gb2JqZWN0IHdyYXBwZXIgdGhhdCBmb2xsb3dzIHRoZSBTZWxlY3Rpb24gb2JqZWN0IGZvdW5kIGluIHRoZSBXSEFUV0cgZHJhZnQgRE9NIFJhbmdlXG4gIC8vIHNwZWMgKGh0dHA6Ly9odG1sNS5vcmcvc3BlY3MvZG9tLXJhbmdlLmh0bWwpXG5cbiAgYXBpLnJlcXVpcmVNb2R1bGVzKFtcIkRvbVV0aWxcIiwgXCJEb21SYW5nZVwiLCBcIldyYXBwZWRSYW5nZVwiXSk7XG5cbiAgYXBpLmNvbmZpZy5jaGVja1NlbGVjdGlvblJhbmdlcyA9IHRydWU7XG5cbiAgdmFyIEJPT0xFQU4gPSBcImJvb2xlYW5cIixcbiAgICAgIHdpbmRvd1Byb3BlcnR5TmFtZSA9IFwiX3Jhbmd5U2VsZWN0aW9uXCIsXG4gICAgICBkb20gPSBhcGkuZG9tLFxuICAgICAgdXRpbCA9IGFwaS51dGlsLFxuICAgICAgRG9tUmFuZ2UgPSBhcGkuRG9tUmFuZ2UsXG4gICAgICBXcmFwcGVkUmFuZ2UgPSBhcGkuV3JhcHBlZFJhbmdlLFxuICAgICAgRE9NRXhjZXB0aW9uID0gYXBpLkRPTUV4Y2VwdGlvbixcbiAgICAgIERvbVBvc2l0aW9uID0gZG9tLkRvbVBvc2l0aW9uLFxuICAgICAgZ2V0U2VsZWN0aW9uLFxuICAgICAgc2VsZWN0aW9uSXNDb2xsYXBzZWQsXG4gICAgICBDT05UUk9MID0gXCJDb250cm9sXCI7XG5cbiAgZnVuY3Rpb24gZ2V0V2luU2VsZWN0aW9uKHdpblBhcmFtKSB7XG4gICAgcmV0dXJuICh3aW5QYXJhbSB8fCB3aW5kb3cpLmdldFNlbGVjdGlvbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RG9jU2VsZWN0aW9uKHdpblBhcmFtKSB7XG4gICAgcmV0dXJuICh3aW5QYXJhbSB8fCB3aW5kb3cpLmRvY3VtZW50LnNlbGVjdGlvbjtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIHRoZSBSYW5nZS9UZXh0UmFuZ2UgYW5kIFNlbGVjdGlvbiBmZWF0dXJlcyByZXF1aXJlZFxuICAvLyBUZXN0IGZvciBhYmlsaXR5IHRvIHJldHJpZXZlIHNlbGVjdGlvblxuICB2YXIgaW1wbGVtZW50c1dpbkdldFNlbGVjdGlvbiA9IGFwaS51dGlsLmlzSG9zdE1ldGhvZCh3aW5kb3csIFwiZ2V0U2VsZWN0aW9uXCIpLFxuICAgICAgaW1wbGVtZW50c0RvY1NlbGVjdGlvbiA9IGFwaS51dGlsLmlzSG9zdE9iamVjdChkb2N1bWVudCwgXCJzZWxlY3Rpb25cIik7XG5cbiAgdmFyIHVzZURvY3VtZW50U2VsZWN0aW9uID0gaW1wbGVtZW50c0RvY1NlbGVjdGlvbiAmJiAoIWltcGxlbWVudHNXaW5HZXRTZWxlY3Rpb24gfHwgYXBpLmNvbmZpZy5wcmVmZXJUZXh0UmFuZ2UpO1xuXG4gIGlmICh1c2VEb2N1bWVudFNlbGVjdGlvbikge1xuICAgIGdldFNlbGVjdGlvbiA9IGdldERvY1NlbGVjdGlvbjtcbiAgICBhcGkuaXNTZWxlY3Rpb25WYWxpZCA9IGZ1bmN0aW9uICh3aW5QYXJhbSkge1xuICAgICAgdmFyIGRvYyA9ICh3aW5QYXJhbSB8fCB3aW5kb3cpLmRvY3VtZW50LFxuICAgICAgICAgIG5hdGl2ZVNlbCA9IGRvYy5zZWxlY3Rpb247XG5cbiAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBUZXh0UmFuZ2UgaXMgYWN0dWFsbHkgY29udGFpbmVkIHdpdGhpbiB0aGUgY29ycmVjdCBkb2N1bWVudFxuICAgICAgcmV0dXJuIG5hdGl2ZVNlbC50eXBlICE9IFwiTm9uZVwiIHx8IGRvbS5nZXREb2N1bWVudChuYXRpdmVTZWwuY3JlYXRlUmFuZ2UoKS5wYXJlbnRFbGVtZW50KCkpID09IGRvYztcbiAgICB9O1xuICB9IGVsc2UgaWYgKGltcGxlbWVudHNXaW5HZXRTZWxlY3Rpb24pIHtcbiAgICBnZXRTZWxlY3Rpb24gPSBnZXRXaW5TZWxlY3Rpb247XG4gICAgYXBpLmlzU2VsZWN0aW9uVmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5mYWlsKFwiTmVpdGhlciBkb2N1bWVudC5zZWxlY3Rpb24gb3Igd2luZG93LmdldFNlbGVjdGlvbigpIGRldGVjdGVkLlwiKTtcbiAgfVxuXG4gIGFwaS5nZXROYXRpdmVTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb247XG5cbiAgdmFyIHRlc3RTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oKTtcbiAgdmFyIHRlc3RSYW5nZSA9IGFwaS5jcmVhdGVOYXRpdmVSYW5nZShkb2N1bWVudCk7XG4gIHZhciBib2R5ID0gZG9tLmdldEJvZHkoZG9jdW1lbnQpO1xuXG4gIC8vIE9idGFpbmluZyBhIHJhbmdlIGZyb20gYSBzZWxlY3Rpb25cbiAgdmFyIHNlbGVjdGlvbkhhc0FuY2hvckFuZEZvY3VzID0gdXRpbC5hcmVIb3N0T2JqZWN0cyh0ZXN0U2VsZWN0aW9uLCBbXCJhbmNob3JOb2RlXCIsIFwiZm9jdXNOb2RlXCJdICYmIHV0aWwuYXJlSG9zdFByb3BlcnRpZXModGVzdFNlbGVjdGlvbiwgW1wiYW5jaG9yT2Zmc2V0XCIsIFwiZm9jdXNPZmZzZXRcIl0pKTtcbiAgYXBpLmZlYXR1cmVzLnNlbGVjdGlvbkhhc0FuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uSGFzQW5jaG9yQW5kRm9jdXM7XG5cbiAgLy8gVGVzdCBmb3IgZXhpc3RlbmNlIG9mIG5hdGl2ZSBzZWxlY3Rpb24gZXh0ZW5kKCkgbWV0aG9kXG4gIHZhciBzZWxlY3Rpb25IYXNFeHRlbmQgPSB1dGlsLmlzSG9zdE1ldGhvZCh0ZXN0U2VsZWN0aW9uLCBcImV4dGVuZFwiKTtcbiAgYXBpLmZlYXR1cmVzLnNlbGVjdGlvbkhhc0V4dGVuZCA9IHNlbGVjdGlvbkhhc0V4dGVuZDtcblxuICAvLyBUZXN0IGlmIHJhbmdlQ291bnQgZXhpc3RzXG4gIHZhciBzZWxlY3Rpb25IYXNSYW5nZUNvdW50ID0gdHlwZW9mIHRlc3RTZWxlY3Rpb24ucmFuZ2VDb3VudCA9PSBcIm51bWJlclwiO1xuICBhcGkuZmVhdHVyZXMuc2VsZWN0aW9uSGFzUmFuZ2VDb3VudCA9IHNlbGVjdGlvbkhhc1JhbmdlQ291bnQ7XG5cbiAgdmFyIHNlbGVjdGlvblN1cHBvcnRzTXVsdGlwbGVSYW5nZXMgPSBmYWxzZTtcbiAgdmFyIGNvbGxhcHNlZE5vbkVkaXRhYmxlU2VsZWN0aW9uc1N1cHBvcnRlZCA9IHRydWU7XG5cbiAgaWYgKHV0aWwuYXJlSG9zdE1ldGhvZHModGVzdFNlbGVjdGlvbiwgW1wiYWRkUmFuZ2VcIiwgXCJnZXRSYW5nZUF0XCIsIFwicmVtb3ZlQWxsUmFuZ2VzXCJdKSAmJiB0eXBlb2YgdGVzdFNlbGVjdGlvbi5yYW5nZUNvdW50ID09IFwibnVtYmVyXCIgJiYgYXBpLmZlYXR1cmVzLmltcGxlbWVudHNEb21SYW5nZSkge1xuXG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO1xuICAgICAgYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXG4gICAgICB2YXIgaWZyYW1lRG9jID0gZG9tLmdldElmcmFtZURvY3VtZW50KGlmcmFtZSk7XG4gICAgICBpZnJhbWVEb2Mub3BlbigpO1xuICAgICAgaWZyYW1lRG9jLndyaXRlKFwiPGh0bWw+PGhlYWQ+PC9oZWFkPjxib2R5PjEyPC9ib2R5PjwvaHRtbD5cIik7XG4gICAgICBpZnJhbWVEb2MuY2xvc2UoKTtcblxuICAgICAgdmFyIHNlbCA9IGRvbS5nZXRJZnJhbWVXaW5kb3coaWZyYW1lKS5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIHZhciBkb2NFbCA9IGlmcmFtZURvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB2YXIgaWZyYW1lQm9keSA9IGRvY0VsLmxhc3RDaGlsZCxcbiAgICAgICAgICB0ZXh0Tm9kZSA9IGlmcmFtZUJvZHkuZmlyc3RDaGlsZDtcblxuICAgICAgLy8gVGVzdCB3aGV0aGVyIHRoZSBuYXRpdmUgc2VsZWN0aW9uIHdpbGwgYWxsb3cgYSBjb2xsYXBzZWQgc2VsZWN0aW9uIHdpdGhpbiBhIG5vbi1lZGl0YWJsZSBlbGVtZW50XG4gICAgICB2YXIgcjEgPSBpZnJhbWVEb2MuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHIxLnNldFN0YXJ0KHRleHROb2RlLCAxKTtcbiAgICAgIHIxLmNvbGxhcHNlKHRydWUpO1xuICAgICAgc2VsLmFkZFJhbmdlKHIxKTtcbiAgICAgIGNvbGxhcHNlZE5vbkVkaXRhYmxlU2VsZWN0aW9uc1N1cHBvcnRlZCA9IHNlbC5yYW5nZUNvdW50ID09IDE7XG4gICAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG5cbiAgICAgIC8vIFRlc3Qgd2hldGhlciB0aGUgbmF0aXZlIHNlbGVjdGlvbiBpcyBjYXBhYmxlIG9mIHN1cHBvcnRpbmcgbXVsdGlwbGUgcmFuZ2VzXG4gICAgICB2YXIgcjIgPSByMS5jbG9uZVJhbmdlKCk7XG4gICAgICByMS5zZXRTdGFydCh0ZXh0Tm9kZSwgMCk7XG4gICAgICByMi5zZXRFbmQodGV4dE5vZGUsIDIpO1xuICAgICAgc2VsLmFkZFJhbmdlKHIxKTtcbiAgICAgIHNlbC5hZGRSYW5nZShyMik7XG5cbiAgICAgIHNlbGVjdGlvblN1cHBvcnRzTXVsdGlwbGVSYW5nZXMgPSBzZWwucmFuZ2VDb3VudCA9PSAyO1xuXG4gICAgICAvLyBDbGVhbiB1cFxuICAgICAgcjEuZGV0YWNoKCk7XG4gICAgICByMi5kZXRhY2goKTtcblxuICAgICAgYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgIH0pKCk7XG4gIH1cblxuICBhcGkuZmVhdHVyZXMuc2VsZWN0aW9uU3VwcG9ydHNNdWx0aXBsZVJhbmdlcyA9IHNlbGVjdGlvblN1cHBvcnRzTXVsdGlwbGVSYW5nZXM7XG4gIGFwaS5mZWF0dXJlcy5jb2xsYXBzZWROb25FZGl0YWJsZVNlbGVjdGlvbnNTdXBwb3J0ZWQgPSBjb2xsYXBzZWROb25FZGl0YWJsZVNlbGVjdGlvbnNTdXBwb3J0ZWQ7XG5cbiAgLy8gQ29udHJvbFJhbmdlc1xuICB2YXIgaW1wbGVtZW50c0NvbnRyb2xSYW5nZSA9IGZhbHNlLFxuICAgICAgdGVzdENvbnRyb2xSYW5nZTtcblxuICBpZiAoYm9keSAmJiB1dGlsLmlzSG9zdE1ldGhvZChib2R5LCBcImNyZWF0ZUNvbnRyb2xSYW5nZVwiKSkge1xuICAgIHRlc3RDb250cm9sUmFuZ2UgPSBib2R5LmNyZWF0ZUNvbnRyb2xSYW5nZSgpO1xuICAgIGlmICh1dGlsLmFyZUhvc3RQcm9wZXJ0aWVzKHRlc3RDb250cm9sUmFuZ2UsIFtcIml0ZW1cIiwgXCJhZGRcIl0pKSB7XG4gICAgICBpbXBsZW1lbnRzQ29udHJvbFJhbmdlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgYXBpLmZlYXR1cmVzLmltcGxlbWVudHNDb250cm9sUmFuZ2UgPSBpbXBsZW1lbnRzQ29udHJvbFJhbmdlO1xuXG4gIC8vIFNlbGVjdGlvbiBjb2xsYXBzZWRuZXNzXG4gIGlmIChzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cykge1xuICAgIHNlbGVjdGlvbklzQ29sbGFwc2VkID0gZnVuY3Rpb24gc2VsZWN0aW9uSXNDb2xsYXBzZWQoc2VsKSB7XG4gICAgICByZXR1cm4gc2VsLmFuY2hvck5vZGUgPT09IHNlbC5mb2N1c05vZGUgJiYgc2VsLmFuY2hvck9mZnNldCA9PT0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc2VsZWN0aW9uSXNDb2xsYXBzZWQgPSBmdW5jdGlvbiBzZWxlY3Rpb25Jc0NvbGxhcHNlZChzZWwpIHtcbiAgICAgIHJldHVybiBzZWwucmFuZ2VDb3VudCA/IHNlbC5nZXRSYW5nZUF0KHNlbC5yYW5nZUNvdW50IC0gMSkuY29sbGFwc2VkIDogZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbVJhbmdlKHNlbCwgcmFuZ2UsIGJhY2t3YXJkcykge1xuICAgIHZhciBhbmNob3JQcmVmaXggPSBiYWNrd2FyZHMgPyBcImVuZFwiIDogXCJzdGFydFwiLFxuICAgICAgICBmb2N1c1ByZWZpeCA9IGJhY2t3YXJkcyA/IFwic3RhcnRcIiA6IFwiZW5kXCI7XG4gICAgc2VsLmFuY2hvck5vZGUgPSByYW5nZVthbmNob3JQcmVmaXggKyBcIkNvbnRhaW5lclwiXTtcbiAgICBzZWwuYW5jaG9yT2Zmc2V0ID0gcmFuZ2VbYW5jaG9yUHJlZml4ICsgXCJPZmZzZXRcIl07XG4gICAgc2VsLmZvY3VzTm9kZSA9IHJhbmdlW2ZvY3VzUHJlZml4ICsgXCJDb250YWluZXJcIl07XG4gICAgc2VsLmZvY3VzT2Zmc2V0ID0gcmFuZ2VbZm9jdXNQcmVmaXggKyBcIk9mZnNldFwiXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbU5hdGl2ZVNlbGVjdGlvbihzZWwpIHtcbiAgICB2YXIgbmF0aXZlU2VsID0gc2VsLm5hdGl2ZVNlbGVjdGlvbjtcbiAgICBzZWwuYW5jaG9yTm9kZSA9IG5hdGl2ZVNlbC5hbmNob3JOb2RlO1xuICAgIHNlbC5hbmNob3JPZmZzZXQgPSBuYXRpdmVTZWwuYW5jaG9yT2Zmc2V0O1xuICAgIHNlbC5mb2N1c05vZGUgPSBuYXRpdmVTZWwuZm9jdXNOb2RlO1xuICAgIHNlbC5mb2N1c09mZnNldCA9IG5hdGl2ZVNlbC5mb2N1c09mZnNldDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUVtcHR5U2VsZWN0aW9uKHNlbCkge1xuICAgIHNlbC5hbmNob3JOb2RlID0gc2VsLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgc2VsLmFuY2hvck9mZnNldCA9IHNlbC5mb2N1c09mZnNldCA9IDA7XG4gICAgc2VsLnJhbmdlQ291bnQgPSAwO1xuICAgIHNlbC5pc0NvbGxhcHNlZCA9IHRydWU7XG4gICAgc2VsLl9yYW5nZXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5hdGl2ZVJhbmdlKHJhbmdlKSB7XG4gICAgdmFyIG5hdGl2ZVJhbmdlO1xuICAgIGlmIChyYW5nZSBpbnN0YW5jZW9mIERvbVJhbmdlKSB7XG4gICAgICBuYXRpdmVSYW5nZSA9IHJhbmdlLl9zZWxlY3Rpb25OYXRpdmVSYW5nZTtcbiAgICAgIGlmICghbmF0aXZlUmFuZ2UpIHtcbiAgICAgICAgbmF0aXZlUmFuZ2UgPSBhcGkuY3JlYXRlTmF0aXZlUmFuZ2UoZG9tLmdldERvY3VtZW50KHJhbmdlLnN0YXJ0Q29udGFpbmVyKSk7XG4gICAgICAgIG5hdGl2ZVJhbmdlLnNldEVuZChyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgIG5hdGl2ZVJhbmdlLnNldFN0YXJ0KHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICAgIHJhbmdlLl9zZWxlY3Rpb25OYXRpdmVSYW5nZSA9IG5hdGl2ZVJhbmdlO1xuICAgICAgICByYW5nZS5hdHRhY2hMaXN0ZW5lcihcImRldGFjaFwiLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICB0aGlzLl9zZWxlY3Rpb25OYXRpdmVSYW5nZSA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmFuZ2UgaW5zdGFuY2VvZiBXcmFwcGVkUmFuZ2UpIHtcbiAgICAgIG5hdGl2ZVJhbmdlID0gcmFuZ2UubmF0aXZlUmFuZ2U7XG4gICAgfSBlbHNlIGlmIChhcGkuZmVhdHVyZXMuaW1wbGVtZW50c0RvbVJhbmdlICYmIHJhbmdlIGluc3RhbmNlb2YgZG9tLmdldFdpbmRvdyhyYW5nZS5zdGFydENvbnRhaW5lcikuUmFuZ2UpIHtcbiAgICAgIG5hdGl2ZVJhbmdlID0gcmFuZ2U7XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVSYW5nZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJhbmdlQ29udGFpbnNTaW5nbGVFbGVtZW50KHJhbmdlTm9kZXMpIHtcbiAgICBpZiAoIXJhbmdlTm9kZXMubGVuZ3RoIHx8IHJhbmdlTm9kZXNbMF0ubm9kZVR5cGUgIT0gMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMSwgbGVuID0gcmFuZ2VOb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgaWYgKCFkb20uaXNBbmNlc3Rvck9mKHJhbmdlTm9kZXNbMF0sIHJhbmdlTm9kZXNbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTaW5nbGVFbGVtZW50RnJvbVJhbmdlKHJhbmdlKSB7XG4gICAgdmFyIG5vZGVzID0gcmFuZ2UuZ2V0Tm9kZXMoKTtcbiAgICBpZiAoIXJhbmdlQ29udGFpbnNTaW5nbGVFbGVtZW50KG5vZGVzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0U2luZ2xlRWxlbWVudEZyb21SYW5nZTogcmFuZ2UgXCIgKyByYW5nZS5pbnNwZWN0KCkgKyBcIiBkaWQgbm90IGNvbnNpc3Qgb2YgYSBzaW5nbGUgZWxlbWVudFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzWzBdO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNUZXh0UmFuZ2UocmFuZ2UpIHtcbiAgICByZXR1cm4gISFyYW5nZSAmJiB0eXBlb2YgcmFuZ2UudGV4dCAhPSBcInVuZGVmaW5lZFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbVRleHRSYW5nZShzZWwsIHJhbmdlKSB7XG4gICAgLy8gQ3JlYXRlIGEgUmFuZ2UgZnJvbSB0aGUgc2VsZWN0ZWQgVGV4dFJhbmdlXG4gICAgdmFyIHdyYXBwZWRSYW5nZSA9IG5ldyBXcmFwcGVkUmFuZ2UocmFuZ2UpO1xuICAgIHNlbC5fcmFuZ2VzID0gW3dyYXBwZWRSYW5nZV07XG5cbiAgICB1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21SYW5nZShzZWwsIHdyYXBwZWRSYW5nZSwgZmFsc2UpO1xuICAgIHNlbC5yYW5nZUNvdW50ID0gMTtcbiAgICBzZWwuaXNDb2xsYXBzZWQgPSB3cmFwcGVkUmFuZ2UuY29sbGFwc2VkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ29udHJvbFNlbGVjdGlvbihzZWwpIHtcbiAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZWQgc2VsZWN0aW9uIGJhc2VkIG9uIHdoYXQncyBub3cgaW4gdGhlIG5hdGl2ZSBzZWxlY3Rpb25cbiAgICBzZWwuX3Jhbmdlcy5sZW5ndGggPSAwO1xuICAgIGlmIChzZWwuZG9jU2VsZWN0aW9uLnR5cGUgPT0gXCJOb25lXCIpIHtcbiAgICAgIHVwZGF0ZUVtcHR5U2VsZWN0aW9uKHNlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250cm9sUmFuZ2UgPSBzZWwuZG9jU2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICBpZiAoaXNUZXh0UmFuZ2UoY29udHJvbFJhbmdlKSkge1xuICAgICAgICAvLyBUaGlzIGNhc2UgKHdoZXJlIHRoZSBzZWxlY3Rpb24gdHlwZSBpcyBcIkNvbnRyb2xcIiBhbmQgY2FsbGluZyBjcmVhdGVSYW5nZSgpIG9uIHRoZSBzZWxlY3Rpb24gcmV0dXJuc1xuICAgICAgICAvLyBhIFRleHRSYW5nZSkgY2FuIGhhcHBlbiBpbiBJRSA5LiBJdCBoYXBwZW5zLCBmb3IgZXhhbXBsZSwgd2hlbiBhbGwgZWxlbWVudHMgaW4gdGhlIHNlbGVjdGVkXG4gICAgICAgIC8vIENvbnRyb2xSYW5nZSBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBDb250cm9sUmFuZ2UgYW5kIHJlbW92ZWQgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAgICAgIHVwZGF0ZUZyb21UZXh0UmFuZ2Uoc2VsLCBjb250cm9sUmFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsLnJhbmdlQ291bnQgPSBjb250cm9sUmFuZ2UubGVuZ3RoO1xuICAgICAgICB2YXIgcmFuZ2UsXG4gICAgICAgICAgICBkb2MgPSBkb20uZ2V0RG9jdW1lbnQoY29udHJvbFJhbmdlLml0ZW0oMCkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbC5yYW5nZUNvdW50OyArK2kpIHtcbiAgICAgICAgICByYW5nZSA9IGFwaS5jcmVhdGVSYW5nZShkb2MpO1xuICAgICAgICAgIHJhbmdlLnNlbGVjdE5vZGUoY29udHJvbFJhbmdlLml0ZW0oaSkpO1xuICAgICAgICAgIHNlbC5fcmFuZ2VzLnB1c2gocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHNlbC5pc0NvbGxhcHNlZCA9IHNlbC5yYW5nZUNvdW50ID09IDEgJiYgc2VsLl9yYW5nZXNbMF0uY29sbGFwc2VkO1xuICAgICAgICB1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21SYW5nZShzZWwsIHNlbC5fcmFuZ2VzW3NlbC5yYW5nZUNvdW50IC0gMV0sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhZGRSYW5nZVRvQ29udHJvbFNlbGVjdGlvbihzZWwsIHJhbmdlKSB7XG4gICAgdmFyIGNvbnRyb2xSYW5nZSA9IHNlbC5kb2NTZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICB2YXIgcmFuZ2VFbGVtZW50ID0gZ2V0U2luZ2xlRWxlbWVudEZyb21SYW5nZShyYW5nZSk7XG5cbiAgICAvLyBDcmVhdGUgYSBuZXcgQ29udHJvbFJhbmdlIGNvbnRhaW5pbmcgYWxsIHRoZSBlbGVtZW50cyBpbiB0aGUgc2VsZWN0ZWQgQ29udHJvbFJhbmdlIHBsdXMgdGhlIGVsZW1lbnRcbiAgICAvLyBjb250YWluZWQgYnkgdGhlIHN1cHBsaWVkIHJhbmdlXG4gICAgdmFyIGRvYyA9IGRvbS5nZXREb2N1bWVudChjb250cm9sUmFuZ2UuaXRlbSgwKSk7XG4gICAgdmFyIG5ld0NvbnRyb2xSYW5nZSA9IGRvbS5nZXRCb2R5KGRvYykuY3JlYXRlQ29udHJvbFJhbmdlKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbnRyb2xSYW5nZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgbmV3Q29udHJvbFJhbmdlLmFkZChjb250cm9sUmFuZ2UuaXRlbShpKSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBuZXdDb250cm9sUmFuZ2UuYWRkKHJhbmdlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZFJhbmdlKCk6IEVsZW1lbnQgd2l0aGluIHRoZSBzcGVjaWZpZWQgUmFuZ2UgY291bGQgbm90IGJlIGFkZGVkIHRvIGNvbnRyb2wgc2VsZWN0aW9uIChkb2VzIGl0IGhhdmUgbGF5b3V0PylcIik7XG4gICAgfVxuICAgIG5ld0NvbnRyb2xSYW5nZS5zZWxlY3QoKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlZCBzZWxlY3Rpb24gYmFzZWQgb24gd2hhdCdzIG5vdyBpbiB0aGUgbmF0aXZlIHNlbGVjdGlvblxuICAgIHVwZGF0ZUNvbnRyb2xTZWxlY3Rpb24oc2VsKTtcbiAgfVxuXG4gIHZhciBnZXRTZWxlY3Rpb25SYW5nZUF0O1xuXG4gIGlmICh1dGlsLmlzSG9zdE1ldGhvZCh0ZXN0U2VsZWN0aW9uLCBcImdldFJhbmdlQXRcIikpIHtcbiAgICBnZXRTZWxlY3Rpb25SYW5nZUF0ID0gZnVuY3Rpb24gZ2V0U2VsZWN0aW9uUmFuZ2VBdChzZWwsIGluZGV4KSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gc2VsLmdldFJhbmdlQXQoaW5kZXgpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIGlmIChzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cykge1xuICAgIGdldFNlbGVjdGlvblJhbmdlQXQgPSBmdW5jdGlvbiBnZXRTZWxlY3Rpb25SYW5nZUF0KHNlbCkge1xuICAgICAgdmFyIGRvYyA9IGRvbS5nZXREb2N1bWVudChzZWwuYW5jaG9yTm9kZSk7XG4gICAgICB2YXIgcmFuZ2UgPSBhcGkuY3JlYXRlUmFuZ2UoZG9jKTtcbiAgICAgIHJhbmdlLnNldFN0YXJ0KHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgIHJhbmdlLnNldEVuZChzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuXG4gICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlbiB0aGUgc2VsZWN0aW9uIHdhcyBzZWxlY3RlZCBiYWNrd2FyZHMgKGZyb20gdGhlIGVuZCB0byB0aGUgc3RhcnQgaW4gdGhlXG4gICAgICAvLyBkb2N1bWVudClcbiAgICAgIGlmIChyYW5nZS5jb2xsYXBzZWQgIT09IHRoaXMuaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBXcmFwcGVkU2VsZWN0aW9uKHNlbGVjdGlvbiwgZG9jU2VsZWN0aW9uLCB3aW4pIHtcbiAgICB0aGlzLm5hdGl2ZVNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICB0aGlzLmRvY1NlbGVjdGlvbiA9IGRvY1NlbGVjdGlvbjtcbiAgICB0aGlzLl9yYW5nZXMgPSBbXTtcbiAgICB0aGlzLndpbiA9IHdpbjtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgfVxuXG4gIGFwaS5nZXRTZWxlY3Rpb24gPSBmdW5jdGlvbiAod2luKSB7XG4gICAgd2luID0gd2luIHx8IHdpbmRvdztcbiAgICB2YXIgc2VsID0gd2luW3dpbmRvd1Byb3BlcnR5TmFtZV07XG4gICAgdmFyIG5hdGl2ZVNlbCA9IGdldFNlbGVjdGlvbih3aW4pLFxuICAgICAgICBkb2NTZWwgPSBpbXBsZW1lbnRzRG9jU2VsZWN0aW9uID8gZ2V0RG9jU2VsZWN0aW9uKHdpbikgOiBudWxsO1xuICAgIGlmIChzZWwpIHtcbiAgICAgIHNlbC5uYXRpdmVTZWxlY3Rpb24gPSBuYXRpdmVTZWw7XG4gICAgICBzZWwuZG9jU2VsZWN0aW9uID0gZG9jU2VsO1xuICAgICAgc2VsLnJlZnJlc2god2luKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsID0gbmV3IFdyYXBwZWRTZWxlY3Rpb24obmF0aXZlU2VsLCBkb2NTZWwsIHdpbik7XG4gICAgICB3aW5bd2luZG93UHJvcGVydHlOYW1lXSA9IHNlbDtcbiAgICB9XG4gICAgcmV0dXJuIHNlbDtcbiAgfTtcblxuICBhcGkuZ2V0SWZyYW1lU2VsZWN0aW9uID0gZnVuY3Rpb24gKGlmcmFtZUVsKSB7XG4gICAgcmV0dXJuIGFwaS5nZXRTZWxlY3Rpb24oZG9tLmdldElmcmFtZVdpbmRvdyhpZnJhbWVFbCkpO1xuICB9O1xuXG4gIHZhciBzZWxQcm90byA9IFdyYXBwZWRTZWxlY3Rpb24ucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbnRyb2xTZWxlY3Rpb24oc2VsLCByYW5nZXMpIHtcbiAgICAvLyBFbnN1cmUgdGhhdCB0aGUgc2VsZWN0aW9uIGJlY29tZXMgb2YgdHlwZSBcIkNvbnRyb2xcIlxuICAgIHZhciBkb2MgPSBkb20uZ2V0RG9jdW1lbnQocmFuZ2VzWzBdLnN0YXJ0Q29udGFpbmVyKTtcbiAgICB2YXIgY29udHJvbFJhbmdlID0gZG9tLmdldEJvZHkoZG9jKS5jcmVhdGVDb250cm9sUmFuZ2UoKTtcbiAgICBmb3IgKHZhciBpID0gMCwgZWw7IGkgPCByYW5nZUNvdW50OyArK2kpIHtcbiAgICAgIGVsID0gZ2V0U2luZ2xlRWxlbWVudEZyb21SYW5nZShyYW5nZXNbaV0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29udHJvbFJhbmdlLmFkZChlbCk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXRSYW5nZXMoKTogRWxlbWVudCB3aXRoaW4gdGhlIG9uZSBvZiB0aGUgc3BlY2lmaWVkIFJhbmdlcyBjb3VsZCBub3QgYmUgYWRkZWQgdG8gY29udHJvbCBzZWxlY3Rpb24gKGRvZXMgaXQgaGF2ZSBsYXlvdXQ/KVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29udHJvbFJhbmdlLnNlbGVjdCgpO1xuXG4gICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVkIHNlbGVjdGlvbiBiYXNlZCBvbiB3aGF0J3Mgbm93IGluIHRoZSBuYXRpdmUgc2VsZWN0aW9uXG4gICAgdXBkYXRlQ29udHJvbFNlbGVjdGlvbihzZWwpO1xuICB9XG5cbiAgLy8gU2VsZWN0aW5nIGEgcmFuZ2VcbiAgaWYgKCF1c2VEb2N1bWVudFNlbGVjdGlvbiAmJiBzZWxlY3Rpb25IYXNBbmNob3JBbmRGb2N1cyAmJiB1dGlsLmFyZUhvc3RNZXRob2RzKHRlc3RTZWxlY3Rpb24sIFtcInJlbW92ZUFsbFJhbmdlc1wiLCBcImFkZFJhbmdlXCJdKSkge1xuICAgIHNlbFByb3RvLnJlbW92ZUFsbFJhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMubmF0aXZlU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgdXBkYXRlRW1wdHlTZWxlY3Rpb24odGhpcyk7XG4gICAgfTtcblxuICAgIHZhciBhZGRSYW5nZUJhY2t3YXJkcyA9IGZ1bmN0aW9uIGFkZFJhbmdlQmFja3dhcmRzKHNlbCwgcmFuZ2UpIHtcbiAgICAgIHZhciBkb2MgPSBEb21SYW5nZS5nZXRSYW5nZURvY3VtZW50KHJhbmdlKTtcbiAgICAgIHZhciBlbmRSYW5nZSA9IGFwaS5jcmVhdGVSYW5nZShkb2MpO1xuICAgICAgZW5kUmFuZ2UuY29sbGFwc2VUb1BvaW50KHJhbmdlLmVuZENvbnRhaW5lciwgcmFuZ2UuZW5kT2Zmc2V0KTtcbiAgICAgIHNlbC5uYXRpdmVTZWxlY3Rpb24uYWRkUmFuZ2UoZ2V0TmF0aXZlUmFuZ2UoZW5kUmFuZ2UpKTtcbiAgICAgIHNlbC5uYXRpdmVTZWxlY3Rpb24uZXh0ZW5kKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICBzZWwucmVmcmVzaCgpO1xuICAgIH07XG5cbiAgICBpZiAoc2VsZWN0aW9uSGFzUmFuZ2VDb3VudCkge1xuICAgICAgc2VsUHJvdG8uYWRkUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UsIGJhY2t3YXJkcykge1xuICAgICAgICBpZiAoaW1wbGVtZW50c0NvbnRyb2xSYW5nZSAmJiBpbXBsZW1lbnRzRG9jU2VsZWN0aW9uICYmIHRoaXMuZG9jU2VsZWN0aW9uLnR5cGUgPT0gQ09OVFJPTCkge1xuICAgICAgICAgIGFkZFJhbmdlVG9Db250cm9sU2VsZWN0aW9uKHRoaXMsIHJhbmdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoYmFja3dhcmRzICYmIHNlbGVjdGlvbkhhc0V4dGVuZCkge1xuICAgICAgICAgICAgYWRkUmFuZ2VCYWNrd2FyZHModGhpcywgcmFuZ2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNSYW5nZUNvdW50O1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN1cHBvcnRzTXVsdGlwbGVSYW5nZXMpIHtcbiAgICAgICAgICAgICAgcHJldmlvdXNSYW5nZUNvdW50ID0gdGhpcy5yYW5nZUNvdW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgcHJldmlvdXNSYW5nZUNvdW50ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmF0aXZlU2VsZWN0aW9uLmFkZFJhbmdlKGdldE5hdGl2ZVJhbmdlKHJhbmdlKSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgYWRkaW5nIHRoZSByYW5nZSB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgICAgICAgdGhpcy5yYW5nZUNvdW50ID0gdGhpcy5uYXRpdmVTZWxlY3Rpb24ucmFuZ2VDb3VudDtcblxuICAgICAgICAgICAgaWYgKHRoaXMucmFuZ2VDb3VudCA9PSBwcmV2aW91c1JhbmdlQ291bnQgKyAxKSB7XG4gICAgICAgICAgICAgIC8vIFRoZSByYW5nZSB3YXMgYWRkZWQgc3VjY2Vzc2Z1bGx5XG5cbiAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgcmFuZ2UgdGhhdCB3ZSBhZGRlZCB0byB0aGUgc2VsZWN0aW9uIGlzIHJlZmxlY3RlZCBpbiB0aGUgbGFzdCByYW5nZSBleHRyYWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAvLyB0aGUgc2VsZWN0aW9uXG4gICAgICAgICAgICAgIGlmIChhcGkuY29uZmlnLmNoZWNrU2VsZWN0aW9uUmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hdGl2ZVJhbmdlID0gZ2V0U2VsZWN0aW9uUmFuZ2VBdCh0aGlzLm5hdGl2ZVNlbGVjdGlvbiwgdGhpcy5yYW5nZUNvdW50IC0gMSk7XG4gICAgICAgICAgICAgICAgaWYgKG5hdGl2ZVJhbmdlICYmICFEb21SYW5nZS5yYW5nZXNFcXVhbChuYXRpdmVSYW5nZSwgcmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBIYXBwZW5zIGluIFdlYktpdCB3aXRoLCBmb3IgZXhhbXBsZSwgYSBzZWxlY3Rpb24gcGxhY2VkIGF0IHRoZSBzdGFydCBvZiBhIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBuZXcgV3JhcHBlZFJhbmdlKG5hdGl2ZVJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fcmFuZ2VzW3RoaXMucmFuZ2VDb3VudCAtIDFdID0gcmFuZ2U7XG4gICAgICAgICAgICAgIHVwZGF0ZUFuY2hvckFuZEZvY3VzRnJvbVJhbmdlKHRoaXMsIHJhbmdlLCBzZWxlY3Rpb25Jc0JhY2t3YXJkcyh0aGlzLm5hdGl2ZVNlbGVjdGlvbikpO1xuICAgICAgICAgICAgICB0aGlzLmlzQ29sbGFwc2VkID0gc2VsZWN0aW9uSXNDb2xsYXBzZWQodGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBUaGUgcmFuZ2Ugd2FzIG5vdCBhZGRlZCBzdWNjZXNzZnVsbHkuIFRoZSBzaW1wbGVzdCB0aGluZyBpcyB0byByZWZyZXNoXG4gICAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsUHJvdG8uYWRkUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UsIGJhY2t3YXJkcykge1xuICAgICAgICBpZiAoYmFja3dhcmRzICYmIHNlbGVjdGlvbkhhc0V4dGVuZCkge1xuICAgICAgICAgIGFkZFJhbmdlQmFja3dhcmRzKHRoaXMsIHJhbmdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm5hdGl2ZVNlbGVjdGlvbi5hZGRSYW5nZShnZXROYXRpdmVSYW5nZShyYW5nZSkpO1xuICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHNlbFByb3RvLnNldFJhbmdlcyA9IGZ1bmN0aW9uIChyYW5nZXMpIHtcbiAgICAgIGlmIChpbXBsZW1lbnRzQ29udHJvbFJhbmdlICYmIHJhbmdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNyZWF0ZUNvbnRyb2xTZWxlY3Rpb24odGhpcywgcmFuZ2VzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICB0aGlzLmFkZFJhbmdlKHJhbmdlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHV0aWwuaXNIb3N0TWV0aG9kKHRlc3RTZWxlY3Rpb24sIFwiZW1wdHlcIikgJiYgdXRpbC5pc0hvc3RNZXRob2QodGVzdFJhbmdlLCBcInNlbGVjdFwiKSAmJiBpbXBsZW1lbnRzQ29udHJvbFJhbmdlICYmIHVzZURvY3VtZW50U2VsZWN0aW9uKSB7XG5cbiAgICBzZWxQcm90by5yZW1vdmVBbGxSYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBBZGRlZCB0cnkvY2F0Y2ggYXMgZml4IGZvciBpc3N1ZSAjMjFcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuZG9jU2VsZWN0aW9uLmVtcHR5KCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGVtcHR5KCkgbm90IHdvcmtpbmcgKGlzc3VlICMyNClcbiAgICAgICAgaWYgKHRoaXMuZG9jU2VsZWN0aW9uLnR5cGUgIT0gXCJOb25lXCIpIHtcbiAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBmYWlsdXJlIHRvIGVtcHR5IGEgY29udHJvbCBzZWxlY3Rpb24gYnkgaW5zdGVhZCBzZWxlY3RpbmcgYSBUZXh0UmFuZ2UgYW5kIHRoZW5cbiAgICAgICAgICAvLyBjYWxsaW5nIGVtcHR5KClcbiAgICAgICAgICB2YXIgZG9jO1xuICAgICAgICAgIGlmICh0aGlzLmFuY2hvck5vZGUpIHtcbiAgICAgICAgICAgIGRvYyA9IGRvbS5nZXREb2N1bWVudCh0aGlzLmFuY2hvck5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICAgICAgICB2YXIgY29udHJvbFJhbmdlID0gdGhpcy5kb2NTZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgIGlmIChjb250cm9sUmFuZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGRvYyA9IGRvbS5nZXREb2N1bWVudChjb250cm9sUmFuZ2UuaXRlbSgwKSkuYm9keS5jcmVhdGVUZXh0UmFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRvYykge1xuICAgICAgICAgICAgdmFyIHRleHRSYW5nZSA9IGRvYy5ib2R5LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgICAgICAgdGV4dFJhbmdlLnNlbGVjdCgpO1xuICAgICAgICAgICAgdGhpcy5kb2NTZWxlY3Rpb24uZW1wdHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGV4KSB7fVxuICAgICAgdXBkYXRlRW1wdHlTZWxlY3Rpb24odGhpcyk7XG4gICAgfTtcblxuICAgIHNlbFByb3RvLmFkZFJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICBpZiAodGhpcy5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICAgIGFkZFJhbmdlVG9Db250cm9sU2VsZWN0aW9uKHRoaXMsIHJhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFdyYXBwZWRSYW5nZS5yYW5nZVRvVGV4dFJhbmdlKHJhbmdlKS5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5fcmFuZ2VzWzBdID0gcmFuZ2U7XG4gICAgICAgIHRoaXMucmFuZ2VDb3VudCA9IDE7XG4gICAgICAgIHRoaXMuaXNDb2xsYXBzZWQgPSB0aGlzLl9yYW5nZXNbMF0uY29sbGFwc2VkO1xuICAgICAgICB1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21SYW5nZSh0aGlzLCByYW5nZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxQcm90by5zZXRSYW5nZXMgPSBmdW5jdGlvbiAocmFuZ2VzKSB7XG4gICAgICB0aGlzLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgdmFyIHJhbmdlQ291bnQgPSByYW5nZXMubGVuZ3RoO1xuICAgICAgaWYgKHJhbmdlQ291bnQgPiAxKSB7XG4gICAgICAgIGNyZWF0ZUNvbnRyb2xTZWxlY3Rpb24odGhpcywgcmFuZ2VzKTtcbiAgICAgIH0gZWxzZSBpZiAocmFuZ2VDb3VudCkge1xuICAgICAgICB0aGlzLmFkZFJhbmdlKHJhbmdlc1swXSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZmFpbChcIk5vIG1lYW5zIG9mIHNlbGVjdGluZyBhIFJhbmdlIG9yIFRleHRSYW5nZSB3YXMgZm91bmRcIik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc2VsUHJvdG8uZ2V0UmFuZ2VBdCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5yYW5nZUNvdW50KSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSU5ERVhfU0laRV9FUlJcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9yYW5nZXNbaW5kZXhdO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcmVmcmVzaFNlbGVjdGlvbjtcblxuICBpZiAodXNlRG9jdW1lbnRTZWxlY3Rpb24pIHtcbiAgICByZWZyZXNoU2VsZWN0aW9uID0gZnVuY3Rpb24gcmVmcmVzaFNlbGVjdGlvbihzZWwpIHtcbiAgICAgIHZhciByYW5nZTtcbiAgICAgIGlmIChhcGkuaXNTZWxlY3Rpb25WYWxpZChzZWwud2luKSkge1xuICAgICAgICByYW5nZSA9IHNlbC5kb2NTZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlID0gZG9tLmdldEJvZHkoc2VsLndpbi5kb2N1bWVudCkuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgIHJhbmdlLmNvbGxhcHNlKHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsLmRvY1NlbGVjdGlvbi50eXBlID09IENPTlRST0wpIHtcbiAgICAgICAgdXBkYXRlQ29udHJvbFNlbGVjdGlvbihzZWwpO1xuICAgICAgfSBlbHNlIGlmIChpc1RleHRSYW5nZShyYW5nZSkpIHtcbiAgICAgICAgdXBkYXRlRnJvbVRleHRSYW5nZShzZWwsIHJhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZUVtcHR5U2VsZWN0aW9uKHNlbCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIGlmICh1dGlsLmlzSG9zdE1ldGhvZCh0ZXN0U2VsZWN0aW9uLCBcImdldFJhbmdlQXRcIikgJiYgdHlwZW9mIHRlc3RTZWxlY3Rpb24ucmFuZ2VDb3VudCA9PSBcIm51bWJlclwiKSB7XG4gICAgcmVmcmVzaFNlbGVjdGlvbiA9IGZ1bmN0aW9uIHJlZnJlc2hTZWxlY3Rpb24oc2VsKSB7XG4gICAgICBpZiAoaW1wbGVtZW50c0NvbnRyb2xSYW5nZSAmJiBpbXBsZW1lbnRzRG9jU2VsZWN0aW9uICYmIHNlbC5kb2NTZWxlY3Rpb24udHlwZSA9PSBDT05UUk9MKSB7XG4gICAgICAgIHVwZGF0ZUNvbnRyb2xTZWxlY3Rpb24oc2VsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbC5fcmFuZ2VzLmxlbmd0aCA9IHNlbC5yYW5nZUNvdW50ID0gc2VsLm5hdGl2ZVNlbGVjdGlvbi5yYW5nZUNvdW50O1xuICAgICAgICBpZiAoc2VsLnJhbmdlQ291bnQpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsLnJhbmdlQ291bnQ7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgc2VsLl9yYW5nZXNbaV0gPSBuZXcgYXBpLldyYXBwZWRSYW5nZShzZWwubmF0aXZlU2VsZWN0aW9uLmdldFJhbmdlQXQoaSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21SYW5nZShzZWwsIHNlbC5fcmFuZ2VzW3NlbC5yYW5nZUNvdW50IC0gMV0sIHNlbGVjdGlvbklzQmFja3dhcmRzKHNlbC5uYXRpdmVTZWxlY3Rpb24pKTtcbiAgICAgICAgICBzZWwuaXNDb2xsYXBzZWQgPSBzZWxlY3Rpb25Jc0NvbGxhcHNlZChzZWwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwZGF0ZUVtcHR5U2VsZWN0aW9uKHNlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHNlbGVjdGlvbkhhc0FuY2hvckFuZEZvY3VzICYmIF90eXBlb2YodGVzdFNlbGVjdGlvbi5pc0NvbGxhcHNlZCkgPT0gQk9PTEVBTiAmJiBfdHlwZW9mKHRlc3RSYW5nZS5jb2xsYXBzZWQpID09IEJPT0xFQU4gJiYgYXBpLmZlYXR1cmVzLmltcGxlbWVudHNEb21SYW5nZSkge1xuICAgIHJlZnJlc2hTZWxlY3Rpb24gPSBmdW5jdGlvbiByZWZyZXNoU2VsZWN0aW9uKHNlbCkge1xuICAgICAgdmFyIHJhbmdlLFxuICAgICAgICAgIG5hdGl2ZVNlbCA9IHNlbC5uYXRpdmVTZWxlY3Rpb247XG4gICAgICBpZiAobmF0aXZlU2VsLmFuY2hvck5vZGUpIHtcbiAgICAgICAgcmFuZ2UgPSBnZXRTZWxlY3Rpb25SYW5nZUF0KG5hdGl2ZVNlbCwgMCk7XG4gICAgICAgIHNlbC5fcmFuZ2VzID0gW3JhbmdlXTtcbiAgICAgICAgc2VsLnJhbmdlQ291bnQgPSAxO1xuICAgICAgICB1cGRhdGVBbmNob3JBbmRGb2N1c0Zyb21OYXRpdmVTZWxlY3Rpb24oc2VsKTtcbiAgICAgICAgc2VsLmlzQ29sbGFwc2VkID0gc2VsZWN0aW9uSXNDb2xsYXBzZWQoc2VsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZUVtcHR5U2VsZWN0aW9uKHNlbCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZmFpbChcIk5vIG1lYW5zIG9mIG9idGFpbmluZyBhIFJhbmdlIG9yIFRleHRSYW5nZSBmcm9tIHRoZSB1c2VyJ3Mgc2VsZWN0aW9uIHdhcyBmb3VuZFwiKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzZWxQcm90by5yZWZyZXNoID0gZnVuY3Rpb24gKGNoZWNrRm9yQ2hhbmdlcykge1xuICAgIHZhciBvbGRSYW5nZXMgPSBjaGVja0ZvckNoYW5nZXMgPyB0aGlzLl9yYW5nZXMuc2xpY2UoMCkgOiBudWxsO1xuICAgIHJlZnJlc2hTZWxlY3Rpb24odGhpcyk7XG4gICAgaWYgKGNoZWNrRm9yQ2hhbmdlcykge1xuICAgICAgdmFyIGkgPSBvbGRSYW5nZXMubGVuZ3RoO1xuICAgICAgaWYgKGkgIT0gdGhpcy5fcmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmICghRG9tUmFuZ2UucmFuZ2VzRXF1YWwob2xkUmFuZ2VzW2ldLCB0aGlzLl9yYW5nZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVtb3ZhbCBvZiBhIHNpbmdsZSByYW5nZVxuICB2YXIgcmVtb3ZlUmFuZ2VNYW51YWxseSA9IGZ1bmN0aW9uIHJlbW92ZVJhbmdlTWFudWFsbHkoc2VsLCByYW5nZSkge1xuICAgIHZhciByYW5nZXMgPSBzZWwuZ2V0QWxsUmFuZ2VzKCksXG4gICAgICAgIHJlbW92ZWQgPSBmYWxzZTtcbiAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJhbmdlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgaWYgKHJlbW92ZWQgfHwgcmFuZ2UgIT09IHJhbmdlc1tpXSkge1xuICAgICAgICBzZWwuYWRkUmFuZ2UocmFuZ2VzW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgZHJhZnQgV0hBVFdHIFJhbmdlIHNwZWMsIHRoZSBzYW1lIHJhbmdlIG1heSBiZSBhZGRlZCB0byB0aGUgc2VsZWN0aW9uIG11bHRpcGxlXG4gICAgICAgIC8vIHRpbWVzLiByZW1vdmVSYW5nZSBzaG91bGQgb25seSByZW1vdmUgdGhlIGZpcnN0IGluc3RhbmNlLCBzbyB0aGUgZm9sbG93aW5nIGVuc3VyZXMgb25seSB0aGUgZmlyc3RcbiAgICAgICAgLy8gaW5zdGFuY2UgaXMgcmVtb3ZlZFxuICAgICAgICByZW1vdmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzZWwucmFuZ2VDb3VudCkge1xuICAgICAgdXBkYXRlRW1wdHlTZWxlY3Rpb24oc2VsKTtcbiAgICB9XG4gIH07XG5cbiAgaWYgKGltcGxlbWVudHNDb250cm9sUmFuZ2UpIHtcbiAgICBzZWxQcm90by5yZW1vdmVSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgaWYgKHRoaXMuZG9jU2VsZWN0aW9uLnR5cGUgPT0gQ09OVFJPTCkge1xuICAgICAgICB2YXIgY29udHJvbFJhbmdlID0gdGhpcy5kb2NTZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgdmFyIHJhbmdlRWxlbWVudCA9IGdldFNpbmdsZUVsZW1lbnRGcm9tUmFuZ2UocmFuZ2UpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBDb250cm9sUmFuZ2UgY29udGFpbmluZyBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBzZWxlY3RlZCBDb250cm9sUmFuZ2UgbWludXMgdGhlXG4gICAgICAgIC8vIGVsZW1lbnQgY29udGFpbmVkIGJ5IHRoZSBzdXBwbGllZCByYW5nZVxuICAgICAgICB2YXIgZG9jID0gZG9tLmdldERvY3VtZW50KGNvbnRyb2xSYW5nZS5pdGVtKDApKTtcbiAgICAgICAgdmFyIG5ld0NvbnRyb2xSYW5nZSA9IGRvbS5nZXRCb2R5KGRvYykuY3JlYXRlQ29udHJvbFJhbmdlKCk7XG4gICAgICAgIHZhciBlbCxcbiAgICAgICAgICAgIHJlbW92ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbnRyb2xSYW5nZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIGVsID0gY29udHJvbFJhbmdlLml0ZW0oaSk7XG4gICAgICAgICAgaWYgKGVsICE9PSByYW5nZUVsZW1lbnQgfHwgcmVtb3ZlZCkge1xuICAgICAgICAgICAgbmV3Q29udHJvbFJhbmdlLmFkZChjb250cm9sUmFuZ2UuaXRlbShpKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdDb250cm9sUmFuZ2Uuc2VsZWN0KCk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVkIHNlbGVjdGlvbiBiYXNlZCBvbiB3aGF0J3Mgbm93IGluIHRoZSBuYXRpdmUgc2VsZWN0aW9uXG4gICAgICAgIHVwZGF0ZUNvbnRyb2xTZWxlY3Rpb24odGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1vdmVSYW5nZU1hbnVhbGx5KHRoaXMsIHJhbmdlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHNlbFByb3RvLnJlbW92ZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICByZW1vdmVSYW5nZU1hbnVhbGx5KHRoaXMsIHJhbmdlKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gRGV0ZWN0aW5nIGlmIGEgc2VsZWN0aW9uIGlzIGJhY2t3YXJkc1xuICB2YXIgc2VsZWN0aW9uSXNCYWNrd2FyZHM7XG4gIGlmICghdXNlRG9jdW1lbnRTZWxlY3Rpb24gJiYgc2VsZWN0aW9uSGFzQW5jaG9yQW5kRm9jdXMgJiYgYXBpLmZlYXR1cmVzLmltcGxlbWVudHNEb21SYW5nZSkge1xuICAgIHNlbGVjdGlvbklzQmFja3dhcmRzID0gZnVuY3Rpb24gc2VsZWN0aW9uSXNCYWNrd2FyZHMoc2VsKSB7XG4gICAgICB2YXIgYmFja3dhcmRzID0gZmFsc2U7XG4gICAgICBpZiAoc2VsLmFuY2hvck5vZGUpIHtcbiAgICAgICAgYmFja3dhcmRzID0gZG9tLmNvbXBhcmVQb2ludHMoc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQsIHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCkgPT0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYWNrd2FyZHM7XG4gICAgfTtcblxuICAgIHNlbFByb3RvLmlzQmFja3dhcmRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNlbGVjdGlvbklzQmFja3dhcmRzKHRoaXMpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgc2VsZWN0aW9uSXNCYWNrd2FyZHMgPSBzZWxQcm90by5pc0JhY2t3YXJkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgLy8gU2VsZWN0aW9uIHRleHRcbiAgLy8gVGhpcyBpcyBjb25mb3JtYW50IHRvIHRoZSBuZXcgV0hBVFdHIERPTSBSYW5nZSBkcmFmdCBzcGVjIGJ1dCBkaWZmZXJzIGZyb20gV2ViS2l0IGFuZCBNb3ppbGxhJ3MgaW1wbGVtZW50YXRpb25cbiAgc2VsUHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICB2YXIgcmFuZ2VUZXh0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnJhbmdlQ291bnQ7IGkgPCBsZW47ICsraSkge1xuICAgICAgcmFuZ2VUZXh0c1tpXSA9IFwiXCIgKyB0aGlzLl9yYW5nZXNbaV07XG4gICAgfVxuICAgIHJldHVybiByYW5nZVRleHRzLmpvaW4oXCJcIik7XG4gIH07XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZUluU2FtZURvY3VtZW50KHNlbCwgbm9kZSkge1xuICAgIGlmIChzZWwuYW5jaG9yTm9kZSAmJiBkb20uZ2V0RG9jdW1lbnQoc2VsLmFuY2hvck5vZGUpICE9PSBkb20uZ2V0RG9jdW1lbnQobm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJXUk9OR19ET0NVTUVOVF9FUlJcIik7XG4gICAgfVxuICB9XG5cbiAgLy8gTm8gY3VycmVudCBicm93c2VycyBjb25mb3JtIGZ1bGx5IHRvIHRoZSBIVE1MIDUgZHJhZnQgc3BlYyBmb3IgdGhpcyBtZXRob2QsIHNvIFJhbmd5J3Mgb3duIG1ldGhvZCBpcyBhbHdheXMgdXNlZFxuICBzZWxQcm90by5jb2xsYXBzZSA9IGZ1bmN0aW9uIChub2RlLCBvZmZzZXQpIHtcbiAgICBhc3NlcnROb2RlSW5TYW1lRG9jdW1lbnQodGhpcywgbm9kZSk7XG4gICAgdmFyIHJhbmdlID0gYXBpLmNyZWF0ZVJhbmdlKGRvbS5nZXREb2N1bWVudChub2RlKSk7XG4gICAgcmFuZ2UuY29sbGFwc2VUb1BvaW50KG5vZGUsIG9mZnNldCk7XG4gICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICB0aGlzLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB0aGlzLmlzQ29sbGFwc2VkID0gdHJ1ZTtcbiAgfTtcblxuICBzZWxQcm90by5jb2xsYXBzZVRvU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucmFuZ2VDb3VudCkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5fcmFuZ2VzWzBdO1xuICAgICAgdGhpcy5jb2xsYXBzZShyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKFwiSU5WQUxJRF9TVEFURV9FUlJcIik7XG4gICAgfVxuICB9O1xuXG4gIHNlbFByb3RvLmNvbGxhcHNlVG9FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucmFuZ2VDb3VudCkge1xuICAgICAgdmFyIHJhbmdlID0gdGhpcy5fcmFuZ2VzW3RoaXMucmFuZ2VDb3VudCAtIDFdO1xuICAgICAgdGhpcy5jb2xsYXBzZShyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oXCJJTlZBTElEX1NUQVRFX0VSUlwiKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVGhlIEhUTUwgNSBzcGVjIGlzIHZlcnkgc3BlY2lmaWMgb24gaG93IHNlbGVjdEFsbENoaWxkcmVuIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBzbyB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzXG4gIC8vIG5ldmVyIHVzZWQgYnkgUmFuZ3kuXG4gIHNlbFByb3RvLnNlbGVjdEFsbENoaWxkcmVuID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBhc3NlcnROb2RlSW5TYW1lRG9jdW1lbnQodGhpcywgbm9kZSk7XG4gICAgdmFyIHJhbmdlID0gYXBpLmNyZWF0ZVJhbmdlKGRvbS5nZXREb2N1bWVudChub2RlKSk7XG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgIHRoaXMucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgdGhpcy5hZGRSYW5nZShyYW5nZSk7XG4gIH07XG5cbiAgc2VsUHJvdG8uZGVsZXRlRnJvbURvY3VtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFNlcGNpYWwgYmVoYXZpb3VyIHJlcXVpcmVkIGZvciBDb250cm9sIHNlbGVjdGlvbnNcbiAgICBpZiAoaW1wbGVtZW50c0NvbnRyb2xSYW5nZSAmJiBpbXBsZW1lbnRzRG9jU2VsZWN0aW9uICYmIHRoaXMuZG9jU2VsZWN0aW9uLnR5cGUgPT0gQ09OVFJPTCkge1xuICAgICAgdmFyIGNvbnRyb2xSYW5nZSA9IHRoaXMuZG9jU2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgICB2YXIgZWxlbWVudDtcbiAgICAgIHdoaWxlIChjb250cm9sUmFuZ2UubGVuZ3RoKSB7XG4gICAgICAgIGVsZW1lbnQgPSBjb250cm9sUmFuZ2UuaXRlbSgwKTtcbiAgICAgICAgY29udHJvbFJhbmdlLnJlbW92ZShlbGVtZW50KTtcbiAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnJhbmdlQ291bnQpIHtcbiAgICAgIHZhciByYW5nZXMgPSB0aGlzLmdldEFsbFJhbmdlcygpO1xuICAgICAgdGhpcy5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgcmFuZ2VzW2ldLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICB9XG4gICAgICAvLyBUaGUgSFRNTDUgc3BlYyBzYXlzIG5vdGhpbmcgYWJvdXQgd2hhdCB0aGUgc2VsZWN0aW9uIHNob3VsZCBjb250YWluIGFmdGVyIGNhbGxpbmcgZGVsZXRlQ29udGVudHMgb24gZWFjaFxuICAgICAgLy8gcmFuZ2UuIEZpcmVmb3ggbW92ZXMgdGhlIHNlbGVjdGlvbiB0byB3aGVyZSB0aGUgZmluYWwgc2VsZWN0ZWQgcmFuZ2Ugd2FzLCBzbyB3ZSBlbXVsYXRlIHRoYXRcbiAgICAgIHRoaXMuYWRkUmFuZ2UocmFuZ2VzW2xlbiAtIDFdKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVGhlIGZvbGxvd2luZyBhcmUgbm9uLXN0YW5kYXJkIGV4dGVuc2lvbnNcbiAgc2VsUHJvdG8uZ2V0QWxsUmFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yYW5nZXMuc2xpY2UoMCk7XG4gIH07XG5cbiAgc2VsUHJvdG8uc2V0U2luZ2xlUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICB0aGlzLnNldFJhbmdlcyhbcmFuZ2VdKTtcbiAgfTtcblxuICBzZWxQcm90by5jb250YWluc05vZGUgPSBmdW5jdGlvbiAobm9kZSwgYWxsb3dQYXJ0aWFsKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3Jhbmdlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgaWYgKHRoaXMuX3Jhbmdlc1tpXS5jb250YWluc05vZGUobm9kZSwgYWxsb3dQYXJ0aWFsKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHNlbFByb3RvLnRvSHRtbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaHRtbCA9IFwiXCI7XG4gICAgaWYgKHRoaXMucmFuZ2VDb3VudCkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IERvbVJhbmdlLmdldFJhbmdlRG9jdW1lbnQodGhpcy5fcmFuZ2VzWzBdKS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3Jhbmdlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcmFuZ2VzW2ldLmNsb25lQ29udGVudHMoKSk7XG4gICAgICB9XG4gICAgICBodG1sID0gY29udGFpbmVyLmlubmVySFRNTDtcbiAgICB9XG4gICAgcmV0dXJuIGh0bWw7XG4gIH07XG5cbiAgZnVuY3Rpb24gaW5zcGVjdChzZWwpIHtcbiAgICB2YXIgcmFuZ2VJbnNwZWN0cyA9IFtdO1xuICAgIHZhciBhbmNob3IgPSBuZXcgRG9tUG9zaXRpb24oc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpO1xuICAgIHZhciBmb2N1cyA9IG5ldyBEb21Qb3NpdGlvbihzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgIHZhciBuYW1lID0gdHlwZW9mIHNlbC5nZXROYW1lID09IFwiZnVuY3Rpb25cIiA/IHNlbC5nZXROYW1lKCkgOiBcIlNlbGVjdGlvblwiO1xuXG4gICAgaWYgKHR5cGVvZiBzZWwucmFuZ2VDb3VudCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsLnJhbmdlQ291bnQ7IGkgPCBsZW47ICsraSkge1xuICAgICAgICByYW5nZUluc3BlY3RzW2ldID0gRG9tUmFuZ2UuaW5zcGVjdChzZWwuZ2V0UmFuZ2VBdChpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIltcIiArIG5hbWUgKyBcIihSYW5nZXM6IFwiICsgcmFuZ2VJbnNwZWN0cy5qb2luKFwiLCBcIikgKyBcIikoYW5jaG9yOiBcIiArIGFuY2hvci5pbnNwZWN0KCkgKyBcIiwgZm9jdXM6IFwiICsgZm9jdXMuaW5zcGVjdCgpICsgXCJdXCI7XG4gIH1cblxuICBzZWxQcm90by5nZXROYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIldyYXBwZWRTZWxlY3Rpb25cIjtcbiAgfTtcblxuICBzZWxQcm90by5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpbnNwZWN0KHRoaXMpO1xuICB9O1xuXG4gIHNlbFByb3RvLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLndpblt3aW5kb3dQcm9wZXJ0eU5hbWVdID0gbnVsbDtcbiAgICB0aGlzLndpbiA9IHRoaXMuYW5jaG9yTm9kZSA9IHRoaXMuZm9jdXNOb2RlID0gbnVsbDtcbiAgfTtcblxuICBXcmFwcGVkU2VsZWN0aW9uLmluc3BlY3QgPSBpbnNwZWN0O1xuXG4gIGFwaS5TZWxlY3Rpb24gPSBXcmFwcGVkU2VsZWN0aW9uO1xuXG4gIGFwaS5zZWxlY3Rpb25Qcm90b3R5cGUgPSBzZWxQcm90bztcblxuICBhcGkuYWRkQ3JlYXRlTWlzc2luZ05hdGl2ZUFwaUxpc3RlbmVyKGZ1bmN0aW9uICh3aW4pIHtcbiAgICBpZiAodHlwZW9mIHdpbi5nZXRTZWxlY3Rpb24gPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2luLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFwaS5nZXRTZWxlY3Rpb24odGhpcyk7XG4gICAgICB9O1xuICAgIH1cbiAgICB3aW4gPSBudWxsO1xuICB9KTtcbn0pO1xuLypcblx0QmFzZS5qcywgdmVyc2lvbiAxLjFhXG5cdENvcHlyaWdodCAyMDA2LTIwMTAsIERlYW4gRWR3YXJkc1xuXHRMaWNlbnNlOiBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuKi9cblxudmFyIEJhc2UgPSBmdW5jdGlvbiBCYXNlKCkge1xuICAvLyBkdW1teVxufTtcblxuQmFzZS5leHRlbmQgPSBmdW5jdGlvbiAoX2luc3RhbmNlLCBfc3RhdGljKSB7XG4gIC8vIHN1YmNsYXNzXG4gIHZhciBleHRlbmQgPSBCYXNlLnByb3RvdHlwZS5leHRlbmQ7XG5cbiAgLy8gYnVpbGQgdGhlIHByb3RvdHlwZVxuICBCYXNlLl9wcm90b3R5cGluZyA9IHRydWU7XG4gIHZhciBwcm90byA9IG5ldyB0aGlzKCk7XG4gIGV4dGVuZC5jYWxsKHByb3RvLCBfaW5zdGFuY2UpO1xuICBwcm90by5iYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGNhbGwgdGhpcyBtZXRob2QgZnJvbSBhbnkgb3RoZXIgbWV0aG9kIHRvIGludm9rZSB0aGF0IG1ldGhvZCdzIGFuY2VzdG9yXG4gIH07XG4gIGRlbGV0ZSBCYXNlLl9wcm90b3R5cGluZztcblxuICAvLyBjcmVhdGUgdGhlIHdyYXBwZXIgZm9yIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvblxuICAvL3ZhciBjb25zdHJ1Y3RvciA9IHByb3RvLmNvbnN0cnVjdG9yLnZhbHVlT2YoKTsgLy8tZGVhblxuICB2YXIgY29uc3RydWN0b3IgPSBwcm90by5jb25zdHJ1Y3RvcjtcbiAgdmFyIGtsYXNzID0gcHJvdG8uY29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCYXNlLl9wcm90b3R5cGluZykge1xuICAgICAgaWYgKHRoaXMuX2NvbnN0cnVjdGluZyB8fCB0aGlzLmNvbnN0cnVjdG9yID09IGtsYXNzKSB7XG4gICAgICAgIC8vIGluc3RhbnRpYXRpb25cbiAgICAgICAgdGhpcy5fY29uc3RydWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2NvbnN0cnVjdGluZztcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdICE9IG51bGwpIHtcbiAgICAgICAgLy8gY2FzdGluZ1xuICAgICAgICByZXR1cm4gKGFyZ3VtZW50c1swXS5leHRlbmQgfHwgZXh0ZW5kKS5jYWxsKGFyZ3VtZW50c1swXSwgcHJvdG8pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBidWlsZCB0aGUgY2xhc3MgaW50ZXJmYWNlXG4gIGtsYXNzLmFuY2VzdG9yID0gdGhpcztcbiAga2xhc3MuZXh0ZW5kID0gdGhpcy5leHRlbmQ7XG4gIGtsYXNzLmZvckVhY2ggPSB0aGlzLmZvckVhY2g7XG4gIGtsYXNzLmltcGxlbWVudCA9IHRoaXMuaW1wbGVtZW50O1xuICBrbGFzcy5wcm90b3R5cGUgPSBwcm90bztcbiAga2xhc3MudG9TdHJpbmcgPSB0aGlzLnRvU3RyaW5nO1xuICBrbGFzcy52YWx1ZU9mID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAvL3JldHVybiAodHlwZSA9PSBcIm9iamVjdFwiKSA/IGtsYXNzIDogY29uc3RydWN0b3I7IC8vLWRlYW5cbiAgICByZXR1cm4gdHlwZSA9PSBcIm9iamVjdFwiID8ga2xhc3MgOiBjb25zdHJ1Y3Rvci52YWx1ZU9mKCk7XG4gIH07XG4gIGV4dGVuZC5jYWxsKGtsYXNzLCBfc3RhdGljKTtcbiAgLy8gY2xhc3MgaW5pdGlhbGlzYXRpb25cbiAgaWYgKHR5cGVvZiBrbGFzcy5pbml0ID09IFwiZnVuY3Rpb25cIikga2xhc3MuaW5pdCgpO1xuICByZXR1cm4ga2xhc3M7XG59O1xuXG5CYXNlLnByb3RvdHlwZSA9IHtcbiAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoc291cmNlLCB2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgLy8gZXh0ZW5kaW5nIHdpdGggYSBuYW1lL3ZhbHVlIHBhaXJcbiAgICAgIHZhciBhbmNlc3RvciA9IHRoaXNbc291cmNlXTtcbiAgICAgIGlmIChhbmNlc3RvciAmJiB0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiICYmICggLy8gb3ZlcnJpZGluZyBhIG1ldGhvZD9cbiAgICAgIC8vIHRoZSB2YWx1ZU9mKCkgY29tcGFyaXNvbiBpcyB0byBhdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICAhYW5jZXN0b3IudmFsdWVPZiB8fCBhbmNlc3Rvci52YWx1ZU9mKCkgIT0gdmFsdWUudmFsdWVPZigpKSAmJiAvXFxiYmFzZVxcYi8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgLy8gZ2V0IHRoZSB1bmRlcmx5aW5nIG1ldGhvZFxuICAgICAgICB2YXIgbWV0aG9kID0gdmFsdWUudmFsdWVPZigpO1xuICAgICAgICAvLyBvdmVycmlkZVxuICAgICAgICB2YWx1ZSA9IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMuYmFzZSB8fCBCYXNlLnByb3RvdHlwZS5iYXNlO1xuICAgICAgICAgIHRoaXMuYmFzZSA9IGFuY2VzdG9yO1xuICAgICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIHRoaXMuYmFzZSA9IHByZXZpb3VzO1xuICAgICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gcG9pbnQgdG8gdGhlIHVuZGVybHlpbmcgbWV0aG9kXG4gICAgICAgIHZhbHVlLnZhbHVlT2YgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgIHJldHVybiB0eXBlID09IFwib2JqZWN0XCIgPyB2YWx1ZSA6IG1ldGhvZDtcbiAgICAgICAgfTtcbiAgICAgICAgdmFsdWUudG9TdHJpbmcgPSBCYXNlLnRvU3RyaW5nO1xuICAgICAgfVxuICAgICAgdGhpc1tzb3VyY2VdID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmIChzb3VyY2UpIHtcbiAgICAgIC8vIGV4dGVuZGluZyB3aXRoIGFuIG9iamVjdCBsaXRlcmFsXG4gICAgICB2YXIgZXh0ZW5kID0gQmFzZS5wcm90b3R5cGUuZXh0ZW5kO1xuICAgICAgLy8gaWYgdGhpcyBvYmplY3QgaGFzIGEgY3VzdG9taXNlZCBleHRlbmQgbWV0aG9kIHRoZW4gdXNlIGl0XG4gICAgICBpZiAoIUJhc2UuX3Byb3RvdHlwaW5nICYmIHR5cGVvZiB0aGlzICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBleHRlbmQgPSB0aGlzLmV4dGVuZCB8fCBleHRlbmQ7XG4gICAgICB9XG4gICAgICB2YXIgcHJvdG8gPSB7IHRvU291cmNlOiBudWxsIH07XG4gICAgICAvLyBkbyB0aGUgXCJ0b1N0cmluZ1wiIGFuZCBvdGhlciBtZXRob2RzIG1hbnVhbGx5XG4gICAgICB2YXIgaGlkZGVuID0gW1wiY29uc3RydWN0b3JcIiwgXCJ0b1N0cmluZ1wiLCBcInZhbHVlT2ZcIl07XG4gICAgICAvLyBpZiB3ZSBhcmUgcHJvdG90eXBpbmcgdGhlbiBpbmNsdWRlIHRoZSBjb25zdHJ1Y3RvclxuICAgICAgdmFyIGkgPSBCYXNlLl9wcm90b3R5cGluZyA/IDAgOiAxO1xuICAgICAgd2hpbGUgKGtleSA9IGhpZGRlbltpKytdKSB7XG4gICAgICAgIGlmIChzb3VyY2Vba2V5XSAhPSBwcm90b1trZXldKSB7XG4gICAgICAgICAgZXh0ZW5kLmNhbGwodGhpcywga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGNvcHkgZWFjaCBvZiB0aGUgc291cmNlIG9iamVjdCdzIHByb3BlcnRpZXMgdG8gdGhpcyBvYmplY3RcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKCFwcm90b1trZXldKSBleHRlbmQuY2FsbCh0aGlzLCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn07XG5cbi8vIGluaXRpYWxpc2VcbkJhc2UgPSBCYXNlLmV4dGVuZCh7XG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmV4dGVuZChhcmd1bWVudHNbMF0pO1xuICB9XG59LCB7XG4gIGFuY2VzdG9yOiBPYmplY3QsXG4gIHZlcnNpb246IFwiMS4xXCIsXG5cbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChvYmplY3QsIGJsb2NrLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgaWYgKHRoaXMucHJvdG90eXBlW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBibG9jay5jYWxsKGNvbnRleHQsIG9iamVjdFtrZXldLCBrZXksIG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGltcGxlbWVudDogZnVuY3Rpb24gaW1wbGVtZW50KCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gaWYgaXQncyBhIGZ1bmN0aW9uLCBjYWxsIGl0XG4gICAgICAgIGFyZ3VtZW50c1tpXSh0aGlzLnByb3RvdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhZGQgdGhlIGludGVyZmFjZSB1c2luZyB0aGUgZXh0ZW5kIG1ldGhvZFxuICAgICAgICB0aGlzLnByb3RvdHlwZS5leHRlbmQoYXJndW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy52YWx1ZU9mKCkpO1xuICB9XG59KTsgLyoqXG4gICAgKiBEZXRlY3QgYnJvd3NlciBzdXBwb3J0IGZvciBzcGVjaWZpYyBmZWF0dXJlc1xuICAgICovXG53eXNpaHRtbDUuYnJvd3NlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQsXG4gICAgICB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cbiAgLy8gQnJvd3NlciBzbmlmZmluZyBpcyB1bmZvcnR1bmF0ZWx5IG5lZWRlZCBzaW5jZSBzb21lIGJlaGF2aW9ycyBhcmUgaW1wb3NzaWJsZSB0byBmZWF0dXJlIGRldGVjdFxuICBpc0lFID0gdXNlckFnZW50LmluZGV4T2YoXCJNU0lFXCIpICE9PSAtMSAmJiB1c2VyQWdlbnQuaW5kZXhPZihcIk9wZXJhXCIpID09PSAtMSxcbiAgICAgIGlzR2Vja28gPSB1c2VyQWdlbnQuaW5kZXhPZihcIkdlY2tvXCIpICE9PSAtMSAmJiB1c2VyQWdlbnQuaW5kZXhPZihcIktIVE1MXCIpID09PSAtMSxcbiAgICAgIGlzV2ViS2l0ID0gdXNlckFnZW50LmluZGV4T2YoXCJBcHBsZVdlYktpdC9cIikgIT09IC0xLFxuICAgICAgaXNDaHJvbWUgPSB1c2VyQWdlbnQuaW5kZXhPZihcIkNocm9tZS9cIikgIT09IC0xLFxuICAgICAgaXNPcGVyYSA9IHVzZXJBZ2VudC5pbmRleE9mKFwiT3BlcmEvXCIpICE9PSAtMTtcblxuICBmdW5jdGlvbiBpb3NWZXJzaW9uKHVzZXJBZ2VudCkge1xuICAgIHJldHVybiAoL2lwYWR8aXBob25lfGlwb2QvLnRlc3QodXNlckFnZW50KSAmJiB1c2VyQWdlbnQubWF0Y2goLyBvcyAoXFxkKykuKz8gbGlrZSBtYWMgb3MgeC8pIHx8IFssIDBdKVsxXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gU3RhdGljIHZhcmlhYmxlIG5lZWRlZCwgcHVibGljbHkgYWNjZXNzaWJsZSwgdG8gYmUgYWJsZSBvdmVycmlkZSBpdCBpbiB1bml0IHRlc3RzXG4gICAgVVNFUl9BR0VOVDogdXNlckFnZW50LFxuXG4gICAgLyoqXG4gICAgICogRXhjbHVkZSBicm93c2VycyB0aGF0IGFyZSBub3QgY2FwYWJsZSBvZiBkaXNwbGF5aW5nIGFuZCBoYW5kbGluZ1xuICAgICAqIGNvbnRlbnRFZGl0YWJsZSBhcyBkZXNpcmVkOlxuICAgICAqICAgIC0gaVBob25lLCBpUGFkICh0ZXN0ZWQgaU9TIDQuMi4yKSBhbmQgQW5kcm9pZCAodGVzdGVkIDIuMikgcmVmdXNlIHRvIG1ha2UgY29udGVudEVkaXRhYmxlcyBmb2N1c2FibGVcbiAgICAgKiAgICAtIElFIDwgOCBjcmVhdGUgaW52YWxpZCBtYXJrdXAgYW5kIGNyYXNoIHJhbmRvbWx5IGZyb20gdGltZSB0byB0aW1lXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHN1cHBvcnRlZDogZnVuY3Rpb24gc3VwcG9ydGVkKCkge1xuICAgICAgdmFyIHVzZXJBZ2VudCA9IHRoaXMuVVNFUl9BR0VOVC50b0xvd2VyQ2FzZSgpLFxuXG4gICAgICAvLyBFc3NlbnRpYWwgZm9yIG1ha2luZyBodG1sIGVsZW1lbnRzIGVkaXRhYmxlXG4gICAgICBoYXNDb250ZW50RWRpdGFibGVTdXBwb3J0ID0gXCJjb250ZW50RWRpdGFibGVcIiBpbiB0ZXN0RWxlbWVudCxcblxuICAgICAgLy8gRm9sbG93aW5nIG1ldGhvZHMgYXJlIG5lZWRlZCBpbiBvcmRlciB0byBpbnRlcmFjdCB3aXRoIHRoZSBjb250ZW50RWRpdGFibGUgYXJlYVxuICAgICAgaGFzRWRpdGluZ0FwaVN1cHBvcnQgPSBkb2N1bWVudC5leGVjQ29tbWFuZCAmJiBkb2N1bWVudC5xdWVyeUNvbW1hbmRTdXBwb3J0ZWQgJiYgZG9jdW1lbnQucXVlcnlDb21tYW5kU3RhdGUsXG5cbiAgICAgIC8vIGRvY3VtZW50IHNlbGVjdG9yIGFwaXMgYXJlIG9ubHkgc3VwcG9ydGVkIGJ5IElFIDgrLCBTYWZhcmkgNCssIENocm9tZSBhbmQgRmlyZWZveCAzLjUrXG4gICAgICBoYXNRdWVyeVNlbGVjdG9yU3VwcG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgJiYgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCxcblxuICAgICAgLy8gY29udGVudEVkaXRhYmxlIGlzIHVudXNhYmxlIGluIG1vYmlsZSBicm93c2VycyAodGVzdGVkIGlPUyA0LjIuMiwgQW5kcm9pZCAyLjIsIE9wZXJhIE1vYmlsZSwgV2ViT1MgMy4wNSlcbiAgICAgIGlzSW5jb21wYXRpYmxlTW9iaWxlQnJvd3NlciA9IHRoaXMuaXNJb3MoKSAmJiBpb3NWZXJzaW9uKHVzZXJBZ2VudCkgPCA1IHx8IHVzZXJBZ2VudC5pbmRleE9mKFwib3BlcmEgbW9iaVwiKSAhPT0gLTEgfHwgdXNlckFnZW50LmluZGV4T2YoXCJocHdvcy9cIikgIT09IC0xO1xuXG4gICAgICByZXR1cm4gaGFzQ29udGVudEVkaXRhYmxlU3VwcG9ydCAmJiBoYXNFZGl0aW5nQXBpU3VwcG9ydCAmJiBoYXNRdWVyeVNlbGVjdG9yU3VwcG9ydCAmJiAhaXNJbmNvbXBhdGlibGVNb2JpbGVCcm93c2VyO1xuICAgIH0sXG5cbiAgICBpc1RvdWNoRGV2aWNlOiBmdW5jdGlvbiBpc1RvdWNoRGV2aWNlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3VwcG9ydHNFdmVudChcInRvdWNobW92ZVwiKTtcbiAgICB9LFxuXG4gICAgaXNJb3M6IGZ1bmN0aW9uIGlzSW9zKCkge1xuICAgICAgdmFyIHVzZXJBZ2VudCA9IHRoaXMuVVNFUl9BR0VOVC50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIHVzZXJBZ2VudC5pbmRleE9mKFwid2Via2l0XCIpICE9PSAtMSAmJiB1c2VyQWdlbnQuaW5kZXhPZihcIm1vYmlsZVwiKSAhPT0gLTE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgc2FuZGJveGVkIGlmcmFtZXNcbiAgICAgKiBDdXJyZW50bHkgb25seSBJRSA2KyBvZmZlcnMgc3VjaCBmZWF0dXJlIDxpZnJhbWUgc2VjdXJpdHk9XCJyZXN0cmljdGVkXCI+XG4gICAgICpcbiAgICAgKiBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzQ2MjIodj12cy44NSkuYXNweFxuICAgICAqIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llL2FyY2hpdmUvMjAwOC8wMS8xOC91c2luZy1mcmFtZXMtbW9yZS1zZWN1cmVseS5hc3B4XG4gICAgICpcbiAgICAgKiBIVE1MNSBzYW5kYm94ZWQgaWZyYW1lcyBhcmUgc3RpbGwgYnVnZ3kgYW5kIHRoZWlyIERPTSBpcyBub3QgcmVhY2hhYmxlIGZyb20gdGhlIG91dHNpZGUgKGV4Y2VwdCB3aGVuIHVzaW5nIHBvc3RNZXNzYWdlKVxuICAgICAqL1xuICAgIHN1cHBvcnRzU2FuZGJveGVkSWZyYW1lczogZnVuY3Rpb24gc3VwcG9ydHNTYW5kYm94ZWRJZnJhbWVzKCkge1xuICAgICAgcmV0dXJuIGlzSUU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElFNis3IHRocm93IGEgbWl4ZWQgY29udGVudCB3YXJuaW5nIHdoZW4gdGhlIHNyYyBvZiBhbiBpZnJhbWVcbiAgICAgKiBpcyBlbXB0eS91bnNldCBvciBhYm91dDpibGFua1xuICAgICAqIHdpbmRvdy5xdWVyeVNlbGVjdG9yIGlzIGltcGxlbWVudGVkIGFzIG9mIElFOFxuICAgICAqL1xuICAgIHRocm93c01peGVkQ29udGVudFdhcm5pbmdXaGVuSWZyYW1lU3JjSXNFbXB0eTogZnVuY3Rpb24gdGhyb3dzTWl4ZWRDb250ZW50V2FybmluZ1doZW5JZnJhbWVTcmNJc0VtcHR5KCkge1xuICAgICAgcmV0dXJuICEoXCJxdWVyeVNlbGVjdG9yXCIgaW4gZG9jdW1lbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjYXJldCBpcyBjb3JyZWN0bHkgZGlzcGxheWVkIGluIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50c1xuICAgICAqIEZpcmVmb3ggc29tZXRpbWVzIHNob3dzIGEgaHVnZSBjYXJldCBpbiB0aGUgYmVnaW5uaW5nIGFmdGVyIGZvY3VzaW5nXG4gICAgICovXG4gICAgZGlzcGxheXNDYXJldEluRW1wdHlDb250ZW50RWRpdGFibGVDb3JyZWN0bHk6IGZ1bmN0aW9uIGRpc3BsYXlzQ2FyZXRJbkVtcHR5Q29udGVudEVkaXRhYmxlQ29ycmVjdGx5KCkge1xuICAgICAgcmV0dXJuICFpc0dlY2tvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPcGVyYSBhbmQgSUUgYXJlIHRoZSBvbmx5IGJyb3dzZXJzIHdobyBvZmZlciB0aGUgY3NzIHZhbHVlXG4gICAgICogaW4gdGhlIG9yaWdpbmFsIHVuaXQsIHRoeCB0byB0aGUgY3VycmVudFN0eWxlIG9iamVjdFxuICAgICAqIEFsbCBvdGhlciBicm93c2VycyBwcm92aWRlIHRoZSBjb21wdXRlZCBzdHlsZSBpbiBweCB2aWEgd2luZG93LmdldENvbXB1dGVkU3R5bGVcbiAgICAgKi9cbiAgICBoYXNDdXJyZW50U3R5bGVQcm9wZXJ0eTogZnVuY3Rpb24gaGFzQ3VycmVudFN0eWxlUHJvcGVydHkoKSB7XG4gICAgICByZXR1cm4gXCJjdXJyZW50U3R5bGVcIiBpbiB0ZXN0RWxlbWVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYnJvd3NlciBpbnNlcnRzIGEgPGJyPiB3aGVuIHByZXNzaW5nIGVudGVyIGluIGEgY29udGVudEVkaXRhYmxlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBpbnNlcnRzTGluZUJyZWFrc09uUmV0dXJuOiBmdW5jdGlvbiBpbnNlcnRzTGluZUJyZWFrc09uUmV0dXJuKCkge1xuICAgICAgcmV0dXJuIGlzR2Vja287XG4gICAgfSxcblxuICAgIHN1cHBvcnRzUGxhY2Vob2xkZXJBdHRyaWJ1dGVPbjogZnVuY3Rpb24gc3VwcG9ydHNQbGFjZWhvbGRlckF0dHJpYnV0ZU9uKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBcInBsYWNlaG9sZGVyXCIgaW4gZWxlbWVudDtcbiAgICB9LFxuXG4gICAgc3VwcG9ydHNFdmVudDogZnVuY3Rpb24gc3VwcG9ydHNFdmVudChldmVudE5hbWUpIHtcbiAgICAgIHJldHVybiBcIm9uXCIgKyBldmVudE5hbWUgaW4gdGVzdEVsZW1lbnQgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0ZXN0RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJvblwiICsgZXZlbnROYW1lLCBcInJldHVybjtcIik7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGVzdEVsZW1lbnRbXCJvblwiICsgZXZlbnROYW1lXSA9PT0gXCJmdW5jdGlvblwiO1xuICAgICAgfSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBPcGVyYSBkb2Vzbid0IGNvcnJlY3RseSBmaXJlIGZvY3VzL2JsdXIgZXZlbnRzIHdoZW4gY2xpY2tpbmcgaW4tIGFuZCBvdXRzaWRlIG9mIGlmcmFtZVxuICAgICAqL1xuICAgIHN1cHBvcnRzRXZlbnRzSW5JZnJhbWVDb3JyZWN0bHk6IGZ1bmN0aW9uIHN1cHBvcnRzRXZlbnRzSW5JZnJhbWVDb3JyZWN0bHkoKSB7XG4gICAgICByZXR1cm4gIWlzT3BlcmE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENocm9tZSAmIFNhZmFyaSBvbmx5IGZpcmUgdGhlIG9uZHJvcC9vbmRyYWdlbmQvLi4uIGV2ZW50cyB3aGVuIHRoZSBvbmRyYWdvdmVyIGV2ZW50IGlzIGNhbmNlbGxlZFxuICAgICAqIHdpdGggZXZlbnQucHJldmVudERlZmF1bHRcbiAgICAgKiBGaXJlZm94IDMuNiBmaXJlcyB0aG9zZSBldmVudHMgYW55d2F5LCBidXQgdGhlIG1vemlsbGEgZG9jIHNheXMgdGhhdCB0aGUgZHJhZ292ZXIvZHJhZ2VudGVyIGV2ZW50IG5lZWRzXG4gICAgICogdG8gYmUgY2FuY2VsbGVkXG4gICAgICovXG4gICAgZmlyZXNPbkRyb3BPbmx5V2hlbk9uRHJhZ092ZXJJc0NhbmNlbGxlZDogZnVuY3Rpb24gZmlyZXNPbkRyb3BPbmx5V2hlbk9uRHJhZ092ZXJJc0NhbmNlbGxlZCgpIHtcbiAgICAgIHJldHVybiBpc1dlYktpdCB8fCBpc0dlY2tvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBldmVudC5kYXRhVHJhbnNmZXIgcHJvcGVydHkgaW4gYSBwcm9wZXIgd2F5XG4gICAgICovXG4gICAgc3VwcG9ydHNEYXRhVHJhbnNmZXI6IGZ1bmN0aW9uIHN1cHBvcnRzRGF0YVRyYW5zZmVyKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgZGF0YVRyYW5zZmVyIGluIGEgc2FmZSB3YXksIGl0IGRvZXNuJ3Qgc3RyaXAgc2NyaXB0IGNvZGUgaW4gdGhlIGh0bWwgcGF5bG9hZCAobGlrZSBDaHJvbWUgZG9lcylcbiAgICAgICAgcmV0dXJuIGlzV2ViS2l0ICYmICh3aW5kb3cuQ2xpcGJvYXJkIHx8IHdpbmRvdy5EYXRhVHJhbnNmZXIpLnByb3RvdHlwZS5nZXREYXRhO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEV2ZXJ5dGhpbmcgYmVsb3cgSUU5IGRvZXNuJ3Qga25vdyBob3cgdG8gdHJlYXQgSFRNTDUgdGFnc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHQgVGhlIGRvY3VtZW50IG9iamVjdCBvbiB3aGljaCB0byBjaGVjayBIVE1MNSBzdXBwb3J0XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzSFRNTDVUYWdzKGRvY3VtZW50KTtcbiAgICAgKi9cbiAgICBzdXBwb3J0c0hUTUw1VGFnczogZnVuY3Rpb24gc3VwcG9ydHNIVE1MNVRhZ3MoY29udGV4dCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgaHRtbDUgPSBcIjxhcnRpY2xlPmZvbzwvYXJ0aWNsZT5cIjtcbiAgICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDU7XG4gICAgICByZXR1cm4gZWxlbWVudC5pbm5lckhUTUwudG9Mb3dlckNhc2UoKSA9PT0gaHRtbDU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGEgZG9jdW1lbnQgc3VwcG9ydHMgYSBjZXJ0YWluIHF1ZXJ5Q29tbWFuZFxuICAgICAqIEluIHBhcnRpY3VsYXIsIE9wZXJhIG5lZWRzIGEgcmVmZXJlbmNlIHRvIGEgZG9jdW1lbnQgdGhhdCBoYXMgYSBjb250ZW50RWRpdGFibGUgaW4gaXQncyBkb20gdHJlZVxuICAgICAqIGluIG9kZXIgdG8gcmVwb3J0IGNvcnJlY3QgcmVzdWx0c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRvYyBEb2N1bWVudCBvYmplY3Qgb24gd2hpY2ggdG8gY2hlY2sgZm9yIGEgcXVlcnkgY29tbWFuZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21tYW5kIFRoZSBxdWVyeSBjb21tYW5kIHRvIGNoZWNrIGZvclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzQ29tbWFuZChkb2N1bWVudCwgXCJib2xkXCIpO1xuICAgICAqL1xuICAgIHN1cHBvcnRzQ29tbWFuZDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8gRm9sbG93aW5nIGNvbW1hbmRzIGFyZSBzdXBwb3J0ZWQgYnV0IGNvbnRhaW4gYnVncyBpbiBzb21lIGJyb3dzZXJzXG4gICAgICB2YXIgYnVnZ3lDb21tYW5kcyA9IHtcbiAgICAgICAgLy8gZm9ybWF0QmxvY2sgZmFpbHMgd2l0aCBzb21lIHRhZ3MgKGVnLiA8YmxvY2txdW90ZT4pXG4gICAgICAgIFwiZm9ybWF0QmxvY2tcIjogaXNJRSxcbiAgICAgICAgLy8gV2hlbiBpbnNlcnRpbmcgdW5vcmRlcmVkIG9yIG9yZGVyZWQgbGlzdHMgaW4gRmlyZWZveCwgQ2hyb21lIG9yIFNhZmFyaSwgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIG9yIGxpbmUgZ2V0c1xuICAgICAgICAvLyBjb252ZXJ0ZWQgaW50byBhIGxpc3QgKDx1bD48bGk+Li4uPC9saT48L3VsPiwgPG9sPjxsaT4uLi48L2xpPjwvb2w+KVxuICAgICAgICAvLyBJRSBhbmQgT3BlcmEgYWN0IGEgYml0IGRpZmZlcmVudCBoZXJlIGFzIHRoZXkgY29udmVydCB0aGUgZW50aXJlIGNvbnRlbnQgb2YgdGhlIGN1cnJlbnQgYmxvY2sgZWxlbWVudCBpbnRvIGEgbGlzdFxuICAgICAgICBcImluc2VydFVub3JkZXJlZExpc3RcIjogaXNJRSB8fCBpc09wZXJhIHx8IGlzV2ViS2l0LFxuICAgICAgICBcImluc2VydE9yZGVyZWRMaXN0XCI6IGlzSUUgfHwgaXNPcGVyYSB8fCBpc1dlYktpdFxuICAgICAgfTtcblxuICAgICAgLy8gRmlyZWZveCB0aHJvd3MgZXJyb3JzIGZvciBxdWVyeUNvbW1hbmRTdXBwb3J0ZWQsIHNvIHdlIGhhdmUgdG8gYnVpbGQgdXAgb3VyIG93biBvYmplY3Qgb2Ygc3VwcG9ydGVkIGNvbW1hbmRzXG4gICAgICB2YXIgc3VwcG9ydGVkID0ge1xuICAgICAgICBcImluc2VydEhUTUxcIjogaXNHZWNrb1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkb2MsIGNvbW1hbmQpIHtcbiAgICAgICAgdmFyIGlzQnVnZ3kgPSBidWdneUNvbW1hbmRzW2NvbW1hbmRdO1xuICAgICAgICBpZiAoIWlzQnVnZ3kpIHtcbiAgICAgICAgICAvLyBGaXJlZm94IHRocm93cyBlcnJvcnMgd2hlbiBpbnZva2luZyBxdWVyeUNvbW1hbmRTdXBwb3J0ZWQgb3IgcXVlcnlDb21tYW5kRW5hYmxlZFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jLnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZChjb21tYW5kKTtcbiAgICAgICAgICB9IGNhdGNoIChlMSkge31cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jLnF1ZXJ5Q29tbWFuZEVuYWJsZWQoY29tbWFuZCk7XG4gICAgICAgICAgfSBjYXRjaCAoZTIpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXN1cHBvcnRlZFtjb21tYW5kXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICB9KCksXG5cbiAgICAvKipcbiAgICAgKiBJRTogVVJMcyBzdGFydGluZyB3aXRoOlxuICAgICAqICAgIHd3dy4sIGh0dHA6Ly8sIGh0dHBzOi8vLCBmdHA6Ly8sIGdvcGhlcjovLywgbWFpbHRvOiwgbmV3Oiwgc25ld3M6LCB0ZWxuZXQ6LCB3YXNpczosIGZpbGU6Ly8sXG4gICAgICogICAgbm50cDovLywgbmV3c3JjOiwgbGRhcDovLywgbGRhcHM6Ly8sIG91dGxvb2s6LCBtaWM6Ly8gYW5kIHVybDpcbiAgICAgKiB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgYXV0by1saW5rZWQgd2hlbiBlaXRoZXIgdGhlIHVzZXIgaW5zZXJ0cyB0aGVtIHZpYSBjb3B5JnBhc3RlIG9yIHByZXNzZXMgdGhlXG4gICAgICogc3BhY2UgYmFyIHdoZW4gdGhlIGNhcmV0IGlzIGRpcmVjdGx5IGFmdGVyIHN1Y2ggYW4gdXJsLlxuICAgICAqIFRoaXMgYmVoYXZpb3IgY2Fubm90IGVhc2lseSBiZSBhdm9pZGVkIGluIElFIDwgOSBzaW5jZSB0aGUgbG9naWMgaXMgaGFyZGNvZGVkIGluIHRoZSBtc2h0bWwuZGxsXG4gICAgICogKHJlbGF0ZWQgYmxvZyBwb3N0IG9uIG1zZG5cbiAgICAgKiBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMDkvMDkvMTcvcHJldmVudC1hdXRvbWF0aWMtaHlwZXJsaW5raW5nLWluLWNvbnRlbnRlZGl0YWJsZS1odG1sLmFzcHgpLlxuICAgICAqL1xuICAgIGRvZXNBdXRvTGlua2luZ0luQ29udGVudEVkaXRhYmxlOiBmdW5jdGlvbiBkb2VzQXV0b0xpbmtpbmdJbkNvbnRlbnRFZGl0YWJsZSgpIHtcbiAgICAgIHJldHVybiBpc0lFO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBcyBzdGF0ZWQgYWJvdmUsIElFIGF1dG8gbGlua3MgdXJscyB0eXBlZCBpbnRvIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50c1xuICAgICAqIFNpbmNlIElFOSBpdCdzIHBvc3NpYmxlIHRvIHByZXZlbnQgdGhpcyBiZWhhdmlvclxuICAgICAqL1xuICAgIGNhbkRpc2FibGVBdXRvTGlua2luZzogZnVuY3Rpb24gY2FuRGlzYWJsZUF1dG9MaW5raW5nKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3VwcG9ydHNDb21tYW5kKGRvY3VtZW50LCBcIkF1dG9VcmxEZXRlY3RcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElFIGxlYXZlcyBhbiBlbXB0eSBwYXJhZ3JhcGggaW4gdGhlIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50IGFmdGVyIGNsZWFyaW5nIGl0XG4gICAgICogQ2hyb21lL1NhZmFyaSBzb21ldGltZXMgYW4gZW1wdHkgPGRpdj5cbiAgICAgKi9cbiAgICBjbGVhcnNDb250ZW50RWRpdGFibGVDb3JyZWN0bHk6IGZ1bmN0aW9uIGNsZWFyc0NvbnRlbnRFZGl0YWJsZUNvcnJlY3RseSgpIHtcbiAgICAgIHJldHVybiBpc0dlY2tvIHx8IGlzT3BlcmEgfHwgaXNXZWJLaXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElFIGdpdmVzIHdyb25nIHJlc3VsdHMgZm9yIGdldEF0dHJpYnV0ZVxuICAgICAqL1xuICAgIHN1cHBvcnRzR2V0QXR0cmlidXRlQ29ycmVjdGx5OiBmdW5jdGlvbiBzdXBwb3J0c0dldEF0dHJpYnV0ZUNvcnJlY3RseSgpIHtcbiAgICAgIHZhciB0ZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiKTtcbiAgICAgIHJldHVybiB0ZC5nZXRBdHRyaWJ1dGUoXCJyb3dzcGFuXCIpICE9IFwiMVwiO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGNsaWNraW5nIG9uIGltYWdlcyBpbiBJRSwgT3BlcmEgYW5kIEZpcmVmb3gsIHRoZXkgYXJlIHNlbGVjdGVkLCB3aGljaCBtYWtlcyBpdCBlYXN5IHRvIGludGVyYWN0IHdpdGggdGhlbS5cbiAgICAgKiBDaHJvbWUgYW5kIFNhZmFyaSBib3RoIGRvbid0IHN1cHBvcnQgdGhpc1xuICAgICAqL1xuICAgIGNhblNlbGVjdEltYWdlc0luQ29udGVudEVkaXRhYmxlOiBmdW5jdGlvbiBjYW5TZWxlY3RJbWFnZXNJbkNvbnRlbnRFZGl0YWJsZSgpIHtcbiAgICAgIHJldHVybiBpc0dlY2tvIHx8IGlzSUUgfHwgaXNPcGVyYTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hlbiB0aGUgY2FyZXQgaXMgaW4gYW4gZW1wdHkgbGlzdCAoPHVsPjxsaT58PC9saT48L3VsPikgd2hpY2ggaXMgdGhlIGZpcnN0IGNoaWxkIGluIGFuIGNvbnRlbnRFZGl0YWJsZSBjb250YWluZXJcbiAgICAgKiBwcmVzc2luZyBiYWNrc3BhY2UgZG9lc24ndCByZW1vdmUgdGhlIGVudGlyZSBsaXN0IGFzIGRvbmUgaW4gb3RoZXIgYnJvd3NlcnNcbiAgICAgKi9cbiAgICBjbGVhcnNMaXN0c0luQ29udGVudEVkaXRhYmxlQ29ycmVjdGx5OiBmdW5jdGlvbiBjbGVhcnNMaXN0c0luQ29udGVudEVkaXRhYmxlQ29ycmVjdGx5KCkge1xuICAgICAgcmV0dXJuIGlzR2Vja28gfHwgaXNJRSB8fCBpc1dlYktpdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWxsIGJyb3dzZXJzIGV4Y2VwdCBTYWZhcmkgYW5kIENocm9tZSBhdXRvbWF0aWNhbGx5IHNjcm9sbCB0aGUgcmFuZ2UvY2FyZXQgcG9zaXRpb24gaW50byB2aWV3XG4gICAgICovXG4gICAgYXV0b1Njcm9sbHNUb0NhcmV0OiBmdW5jdGlvbiBhdXRvU2Nyb2xsc1RvQ2FyZXQoKSB7XG4gICAgICByZXR1cm4gIWlzV2ViS2l0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHRoZSBicm93c2VyIGF1dG9tYXRpY2FsbHkgY2xvc2VzIHRhZ3MgdGhhdCBkb24ndCBuZWVkIHRvIGJlIG9wZW5lZFxuICAgICAqL1xuICAgIGF1dG9DbG9zZXNVbmNsb3NlZFRhZ3M6IGZ1bmN0aW9uIGF1dG9DbG9zZXNVbmNsb3NlZFRhZ3MoKSB7XG4gICAgICB2YXIgY2xvbmVkVGVzdEVsZW1lbnQgPSB0ZXN0RWxlbWVudC5jbG9uZU5vZGUoZmFsc2UpLFxuICAgICAgICAgIHJldHVyblZhbHVlLFxuICAgICAgICAgIGlubmVySFRNTDtcblxuICAgICAgY2xvbmVkVGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gXCI8cD48ZGl2PjwvZGl2PlwiO1xuICAgICAgaW5uZXJIVE1MID0gY2xvbmVkVGVzdEVsZW1lbnQuaW5uZXJIVE1MLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm5WYWx1ZSA9IGlubmVySFRNTCA9PT0gXCI8cD48L3A+PGRpdj48L2Rpdj5cIiB8fCBpbm5lckhUTUwgPT09IFwiPHA+PGRpdj48L2Rpdj48L3A+XCI7XG5cbiAgICAgIC8vIENhY2hlIHJlc3VsdCBieSBvdmVyd3JpdGluZyBjdXJyZW50IGZ1bmN0aW9uXG4gICAgICB0aGlzLmF1dG9DbG9zZXNVbmNsb3NlZFRhZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgbmF0aXZlIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgd2hpY2ggcmV0dXJucyBsaXZlIE5vZGVMaXN0c1xuICAgICAqL1xuICAgIHN1cHBvcnRzTmF0aXZlR2V0RWxlbWVudHNCeUNsYXNzTmFtZTogZnVuY3Rpb24gc3VwcG9ydHNOYXRpdmVHZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCkge1xuICAgICAgcmV0dXJuIFN0cmluZyhkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKSAhPT0gLTE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFzIG9mIG5vdyAoMTkuMDQuMjAxMSkgb25seSBzdXBwb3J0ZWQgYnkgRmlyZWZveCA0IGFuZCBDaHJvbWVcbiAgICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL1NlbGVjdGlvbi9tb2RpZnlcbiAgICAgKi9cbiAgICBzdXBwb3J0c1NlbGVjdGlvbk1vZGlmeTogZnVuY3Rpb24gc3VwcG9ydHNTZWxlY3Rpb25Nb2RpZnkoKSB7XG4gICAgICByZXR1cm4gXCJnZXRTZWxlY3Rpb25cIiBpbiB3aW5kb3cgJiYgXCJtb2RpZnlcIiBpbiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIGNsYXNzTGlzdCBvYmplY3QgZm9yIGZhc3QgY2xhc3NOYW1lIG1hbmlwdWxhdGlvblxuICAgICAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vZWxlbWVudC5jbGFzc0xpc3RcbiAgICAgKi9cbiAgICBzdXBwb3J0c0NsYXNzTGlzdDogZnVuY3Rpb24gc3VwcG9ydHNDbGFzc0xpc3QoKSB7XG4gICAgICByZXR1cm4gXCJjbGFzc0xpc3RcIiBpbiB0ZXN0RWxlbWVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogT3BlcmEgbmVlZHMgYSB3aGl0ZSBzcGFjZSBhZnRlciBhIDxicj4gaW4gb3JkZXIgdG8gcG9zaXRpb24gdGhlIGNhcmV0IGNvcnJlY3RseVxuICAgICAqL1xuICAgIG5lZWRzU3BhY2VBZnRlckxpbmVCcmVhazogZnVuY3Rpb24gbmVlZHNTcGFjZUFmdGVyTGluZUJyZWFrKCkge1xuICAgICAgcmV0dXJuIGlzT3BlcmE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIHNwZWVjaCBhcGkgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAgICAgKiBTZWUgaHR0cDovL21pa2VwdWx0ei5jb20vMjAxMS8wMy9hY2Nlc3NpbmctZ29vZ2xlLXNwZWVjaC1hcGktY2hyb21lLTExL1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICogICAgaWYgKHd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzU3BlZWNoQXBpT24oaW5wdXQpKSB7XG4gICAgICogICAgICAvLyAuLi5cbiAgICAgKiAgICB9XG4gICAgICovXG4gICAgc3VwcG9ydHNTcGVlY2hBcGlPbjogZnVuY3Rpb24gc3VwcG9ydHNTcGVlY2hBcGlPbihpbnB1dCkge1xuICAgICAgdmFyIGNocm9tZVZlcnNpb24gPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pIHx8IFssIDBdO1xuICAgICAgcmV0dXJuIGNocm9tZVZlcnNpb25bMV0gPj0gMTEgJiYgKFwib253ZWJraXRzcGVlY2hjaGFuZ2VcIiBpbiBpbnB1dCB8fCBcInNwZWVjaFwiIGluIGlucHV0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSUU5IGNyYXNoZXMgd2hlbiBzZXR0aW5nIGEgZ2V0dGVyIHZpYSBPYmplY3QuZGVmaW5lUHJvcGVydHkgb24gWE1MSHR0cFJlcXVlc3Qgb3IgWERvbWFpblJlcXVlc3RcbiAgICAgKiBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vaWUvZmVlZGJhY2svZGV0YWlscy82NTAxMTJcbiAgICAgKiBvciB0cnkgdGhlIFBPQyBodHRwOi8vdGlmZnRpZmYuZGUvaWU5X2NyYXNoL1xuICAgICAqL1xuICAgIGNyYXNoZXNXaGVuRGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGNyYXNoZXNXaGVuRGVmaW5lUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBpc0lFICYmIChwcm9wZXJ0eSA9PT0gXCJYTUxIdHRwUmVxdWVzdFwiIHx8IHByb3BlcnR5ID09PSBcIlhEb21haW5SZXF1ZXN0XCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJRSBpcyB0aGUgb25seSBicm93c2VyIHdobyBmaXJlcyB0aGUgXCJmb2N1c1wiIGV2ZW50IG5vdCBpbW1lZGlhdGVseSB3aGVuIC5mb2N1cygpIGlzIGNhbGxlZCBvbiBhbiBlbGVtZW50XG4gICAgICovXG4gICAgZG9lc0FzeW5jRm9jdXM6IGZ1bmN0aW9uIGRvZXNBc3luY0ZvY3VzKCkge1xuICAgICAgcmV0dXJuIGlzSUU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluIElFIGl0J3MgaW1wc3NpYmxlIGZvciB0aGUgdXNlciBhbmQgZm9yIHRoZSBzZWxlY3Rpb24gbGlicmFyeSB0byBzZXQgdGhlIGNhcmV0IGFmdGVyIGFuIDxpbWc+IHdoZW4gaXQncyB0aGUgbGFzdENoaWxkIGluIHRoZSBkb2N1bWVudFxuICAgICAqL1xuICAgIGhhc1Byb2JsZW1zU2V0dGluZ0NhcmV0QWZ0ZXJJbWc6IGZ1bmN0aW9uIGhhc1Byb2JsZW1zU2V0dGluZ0NhcmV0QWZ0ZXJJbWcoKSB7XG4gICAgICByZXR1cm4gaXNJRTtcbiAgICB9LFxuXG4gICAgaGFzVW5kb0luQ29udGV4dE1lbnU6IGZ1bmN0aW9uIGhhc1VuZG9JbkNvbnRleHRNZW51KCkge1xuICAgICAgcmV0dXJuIGlzR2Vja28gfHwgaXNDaHJvbWUgfHwgaXNPcGVyYTtcbiAgICB9XG4gIH07XG59KCk7d3lzaWh0bWw1LmxhbmcuYXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciBhIGdpdmVuIG9iamVjdCBleGlzdHMgaW4gYW4gYXJyYXlcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1LmxhbmcuYXJyYXkoWzEsIDJdKS5jb250YWlucygxKTtcbiAgICAgKiAgICAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uIGNvbnRhaW5zKG5lZWRsZSkge1xuICAgICAgaWYgKGFyci5pbmRleE9mKSB7XG4gICAgICAgIHJldHVybiBhcnIuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnIubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoYXJyW2ldID09PSBuZWVkbGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN1YnN0cmFjdCBvbmUgYXJyYXkgZnJvbSBhbm90aGVyXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHd5c2lodG1sNS5sYW5nLmFycmF5KFsxLCAyLCAzLCA0XSkud2l0aG91dChbMywgNF0pO1xuICAgICAqICAgIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIHdpdGhvdXQ6IGZ1bmN0aW9uIHdpdGhvdXQoYXJyYXlUb1N1YnN0cmFjdCkge1xuICAgICAgYXJyYXlUb1N1YnN0cmFjdCA9IHd5c2lodG1sNS5sYW5nLmFycmF5KGFycmF5VG9TdWJzdHJhY3QpO1xuICAgICAgdmFyIG5ld0FyciA9IFtdLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghYXJyYXlUb1N1YnN0cmFjdC5jb250YWlucyhhcnJbaV0pKSB7XG4gICAgICAgICAgbmV3QXJyLnB1c2goYXJyW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0FycjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgY2xlYW4gbmF0aXZlIGFycmF5XG4gICAgICogXG4gICAgICogRm9sbG93aW5nIHdpbGwgY29udmVydCBhIExpdmUgTm9kZUxpc3QgdG8gYSBwcm9wZXIgQXJyYXlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHZhciBjaGlsZE5vZGVzID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZE5vZGVzKS5nZXQoKTtcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBpID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBhcnIubGVuZ3RoLFxuICAgICAgICAgIG5ld0FycmF5ID0gW107XG4gICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0FycmF5LnB1c2goYXJyW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdBcnJheTtcbiAgICB9XG4gIH07XG59O3d5c2lodG1sNS5sYW5nLkRpc3BhdGNoZXIgPSBCYXNlLmV4dGVuZChcbi8qKiBAc2NvcGUgd3lzaWh0bWw1LmxhbmcuRGlhbG9nLnByb3RvdHlwZSAqL3tcbiAgb2JzZXJ2ZTogZnVuY3Rpb24gb2JzZXJ2ZShldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICB0aGlzLmV2ZW50cyA9IHRoaXMuZXZlbnRzIHx8IHt9O1xuICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPSB0aGlzLmV2ZW50c1tldmVudE5hbWVdIHx8IFtdO1xuICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0ucHVzaChoYW5kbGVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBvbjogZnVuY3Rpb24gb24oKSB7XG4gICAgcmV0dXJuIHRoaXMub2JzZXJ2ZS5hcHBseSh0aGlzLCB3eXNpaHRtbDUubGFuZy5hcnJheShhcmd1bWVudHMpLmdldCgpKTtcbiAgfSxcblxuICBmaXJlOiBmdW5jdGlvbiBmaXJlKGV2ZW50TmFtZSwgcGF5bG9hZCkge1xuICAgIHRoaXMuZXZlbnRzID0gdGhpcy5ldmVudHMgfHwge307XG4gICAgdmFyIGhhbmRsZXJzID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXSB8fCBbXSxcbiAgICAgICAgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaGFuZGxlcnNbaV0uY2FsbCh0aGlzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgc3RvcE9ic2VydmluZzogZnVuY3Rpb24gc3RvcE9ic2VydmluZyhldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICB0aGlzLmV2ZW50cyA9IHRoaXMuZXZlbnRzIHx8IHt9O1xuICAgIHZhciBpID0gMCxcbiAgICAgICAgaGFuZGxlcnMsXG4gICAgICAgIG5ld0hhbmRsZXJzO1xuICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgIGhhbmRsZXJzID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXSB8fCBbXSwgbmV3SGFuZGxlcnMgPSBbXTtcbiAgICAgIGZvciAoOyBpIDwgaGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGhhbmRsZXJzW2ldICE9PSBoYW5kbGVyICYmIGhhbmRsZXIpIHtcbiAgICAgICAgICBuZXdIYW5kbGVycy5wdXNoKGhhbmRsZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IG5ld0hhbmRsZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDbGVhbiB1cCBhbGwgZXZlbnRzXG4gICAgICB0aGlzLmV2ZW50cyA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufSk7d3lzaWh0bWw1Lmxhbmcub2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1Lmxhbmcub2JqZWN0KHsgZm9vOiAxLCBiYXI6IDEgfSkubWVyZ2UoeyBiYXI6IDIsIGJhejogMyB9KS5nZXQoKTtcbiAgICAgKiAgICAvLyA9PiB7IGZvbzogMSwgYmFyOiAyLCBiYXo6IDMgfVxuICAgICAqL1xuICAgIG1lcmdlOiBmdW5jdGlvbiBtZXJnZShvdGhlck9iaikge1xuICAgICAgZm9yICh2YXIgaSBpbiBvdGhlck9iaikge1xuICAgICAgICBvYmpbaV0gPSBvdGhlck9ialtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1Lmxhbmcub2JqZWN0KHsgZm9vOiAxIH0pLmNsb25lKCk7XG4gICAgICogICAgLy8gPT4geyBmb286IDEgfVxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgIHZhciBuZXdPYmogPSB7fSxcbiAgICAgICAgICBpO1xuICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICBuZXdPYmpbaV0gPSBvYmpbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHd5c2lodG1sNS5sYW5nLm9iamVjdChbXSkuaXNBcnJheSgpO1xuICAgICAqICAgIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBpc0FycmF5OiBmdW5jdGlvbiBpc0FycmF5KCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgfVxuICB9O1xufTsoZnVuY3Rpb24gKCkge1xuICB2YXIgV0hJVEVfU1BBQ0VfU1RBUlQgPSAvXlxccysvLFxuICAgICAgV0hJVEVfU1BBQ0VfRU5EID0gL1xccyskLztcbiAgd3lzaWh0bWw1Lmxhbmcuc3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiAgICB3eXNpaHRtbDUubGFuZy5zdHJpbmcoXCIgICBmb28gICBcIikudHJpbSgpO1xuICAgICAgICogICAgLy8gPT4gXCJmb29cIlxuICAgICAgICovXG4gICAgICB0cmltOiBmdW5jdGlvbiB0cmltKCkge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoV0hJVEVfU1BBQ0VfU1RBUlQsIFwiXCIpLnJlcGxhY2UoV0hJVEVfU1BBQ0VfRU5ELCBcIlwiKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqICAgIHd5c2lodG1sNS5sYW5nLnN0cmluZyhcIkhlbGxvICN7bmFtZX1cIikuaW50ZXJwb2xhdGUoeyBuYW1lOiBcIkNocmlzdG9waGVyXCIgfSk7XG4gICAgICAgKiAgICAvLyA9PiBcIkhlbGxvIENocmlzdG9waGVyXCJcbiAgICAgICAqL1xuICAgICAgaW50ZXJwb2xhdGU6IGZ1bmN0aW9uIGludGVycG9sYXRlKHZhcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB2YXJzKSB7XG4gICAgICAgICAgc3RyID0gdGhpcy5yZXBsYWNlKFwiI3tcIiArIGkgKyBcIn1cIikuYnkodmFyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqICAgIHd5c2lodG1sNS5sYW5nLnN0cmluZyhcIkhlbGxvIFRvbVwiKS5yZXBsYWNlKFwiVG9tXCIpLndpdGgoXCJIYW5zXCIpO1xuICAgICAgICogICAgLy8gPT4gXCJIZWxsbyBIYW5zXCJcbiAgICAgICAqL1xuICAgICAgcmVwbGFjZTogZnVuY3Rpb24gcmVwbGFjZShzZWFyY2gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBieTogZnVuY3Rpb24gYnkocmVwbGFjZSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5zcGxpdChzZWFyY2gpLmpvaW4ocmVwbGFjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH07XG59KSgpOyAvKipcbiAgICAgICogRmluZCB1cmxzIGluIGRlc2NlbmRhbnQgdGV4dCBub2RlcyBvZiBhbiBlbGVtZW50IGFuZCBhdXRvLWxpbmtzIHRoZW1cbiAgICAgICogSW5zcGlyZWQgYnkgaHR0cDovL2phbWVzLnBhZG9sc2V5LmNvbS9qYXZhc2NyaXB0L2ZpbmQtYW5kLXJlcGxhY2UtdGV4dC13aXRoLWphdmFzY3JpcHQvXG4gICAgICAqXG4gICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBDb250YWluZXIgZWxlbWVudCBpbiB3aGljaCB0byBzZWFyY2ggZm9yIHVybHNcbiAgICAgICpcbiAgICAgICogQGV4YW1wbGVcbiAgICAgICogICAgPGRpdiBpZD1cInRleHQtY29udGFpbmVyXCI+UGxlYXNlIGNsaWNrIGhlcmU6IHd3dy5nb29nbGUuY29tPC9kaXY+XG4gICAgICAqICAgIDxzY3JpcHQ+d3lzaWh0bWw1LmRvbS5hdXRvTGluayhkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRleHQtY29udGFpbmVyXCIpKTs8L3NjcmlwdD5cbiAgICAgICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgLyoqXG4gICAgICAgKiBEb24ndCBhdXRvLWxpbmsgdXJscyB0aGF0IGFyZSBjb250YWluZWQgaW4gdGhlIGZvbGxvd2luZyBlbGVtZW50czpcbiAgICAgICAqL1xuICBJR05PUkVfVVJMU19JTiA9IHd5c2lodG1sNS5sYW5nLmFycmF5KFtcIkNPREVcIiwgXCJQUkVcIiwgXCJBXCIsIFwiU0NSSVBUXCIsIFwiSEVBRFwiLCBcIlRJVExFXCIsIFwiU1RZTEVcIl0pLFxuXG4gIC8qKlxuICAgKiByZXZpc2lvbiAxOlxuICAgKiAgICAvKFxcUytcXC57MX1bXlxcc1xcLFxcLlxcIV0rKS9nXG4gICAqXG4gICAqIHJldmlzaW9uIDI6XG4gICAqICAgIC8oXFxiKCgoaHR0cHM/fGZ0cCk6XFwvXFwvKXwod3d3XFwuKSlbLUEtWjAtOSsmQCNcXC8lPz1+X3whOiwuO1xcW1xcXV0qWy1BLVowLTkrJkAjXFwvJT1+X3xdKS9naW1cbiAgICpcbiAgICogcHV0IHRoaXMgaW4gdGhlIGJlZ2lubmluZyBpZiB5b3UgZG9uJ3Qgd2FuJ3QgdG8gbWF0Y2ggd2l0aGluIGEgd29yZFxuICAgKiAgICAoXnxbXFw+XFwoXFx7XFxbXFxzXFw+XSlcbiAgICovXG4gIFVSTF9SRUdfRVhQID0gLygoaHR0cHM/OlxcL1xcL3x3d3dcXC4pW15cXHM8XXszLH0pL2dpLFxuICAgICAgVFJBSUxJTkdfQ0hBUl9SRUdfRVhQID0gLyhbXlxcd1xcL1xcLV0oLD8pKSQvaSxcbiAgICAgIE1BWF9ESVNQTEFZX0xFTkdUSCA9IDEwMCxcbiAgICAgIEJSQUNLRVRTID0geyBcIilcIjogXCIoXCIsIFwiXVwiOiBcIltcIiwgXCJ9XCI6IFwie1wiIH07XG5cbiAgZnVuY3Rpb24gYXV0b0xpbmsoZWxlbWVudCkge1xuICAgIGlmIChfaGFzUGFyZW50VGhhdFNob3VsZEJlSWdub3JlZChlbGVtZW50KSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQgPT09IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICB9XG5cbiAgICByZXR1cm4gX3BhcnNlTm9kZShlbGVtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGJhc2ljYWxseSBhIHJlYnVpbGQgb2ZcbiAgICogdGhlIHJhaWxzIGF1dG9fbGlua191cmxzIHRleHQgaGVscGVyXG4gICAqL1xuICBmdW5jdGlvbiBfY29udmVydFVybHNUb0xpbmtzKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShVUkxfUkVHX0VYUCwgZnVuY3Rpb24gKG1hdGNoLCB1cmwpIHtcbiAgICAgIHZhciBwdW5jdHVhdGlvbiA9ICh1cmwubWF0Y2goVFJBSUxJTkdfQ0hBUl9SRUdfRVhQKSB8fCBbXSlbMV0gfHwgXCJcIixcbiAgICAgICAgICBvcGVuaW5nID0gQlJBQ0tFVFNbcHVuY3R1YXRpb25dO1xuICAgICAgdXJsID0gdXJsLnJlcGxhY2UoVFJBSUxJTkdfQ0hBUl9SRUdfRVhQLCBcIlwiKTtcblxuICAgICAgaWYgKHVybC5zcGxpdChvcGVuaW5nKS5sZW5ndGggPiB1cmwuc3BsaXQocHVuY3R1YXRpb24pLmxlbmd0aCkge1xuICAgICAgICB1cmwgPSB1cmwgKyBwdW5jdHVhdGlvbjtcbiAgICAgICAgcHVuY3R1YXRpb24gPSBcIlwiO1xuICAgICAgfVxuICAgICAgdmFyIHJlYWxVcmwgPSB1cmwsXG4gICAgICAgICAgZGlzcGxheVVybCA9IHVybDtcbiAgICAgIGlmICh1cmwubGVuZ3RoID4gTUFYX0RJU1BMQVlfTEVOR1RIKSB7XG4gICAgICAgIGRpc3BsYXlVcmwgPSBkaXNwbGF5VXJsLnN1YnN0cigwLCBNQVhfRElTUExBWV9MRU5HVEgpICsgXCIuLi5cIjtcbiAgICAgIH1cbiAgICAgIC8vIEFkZCBodHRwIHByZWZpeCBpZiBuZWNlc3NhcnlcbiAgICAgIGlmIChyZWFsVXJsLnN1YnN0cigwLCA0KSA9PT0gXCJ3d3cuXCIpIHtcbiAgICAgICAgcmVhbFVybCA9IFwiaHR0cDovL1wiICsgcmVhbFVybDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8YSBocmVmPVwiJyArIHJlYWxVcmwgKyAnXCI+JyArIHJlYWxVcmwgKyAnPC9hPicgKyBwdW5jdHVhdGlvbjtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG9yIChpZiBhbHJlYWR5IGNhY2hlZCkgcmV0dXJucyBhIHRlbXAgZWxlbWVudFxuICAgKiBmb3IgdGhlIGdpdmVuIGRvY3VtZW50IG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gX2dldFRlbXBFbGVtZW50KGNvbnRleHQpIHtcbiAgICB2YXIgdGVtcEVsZW1lbnQgPSBjb250ZXh0Ll93eXNpaHRtbDVfdGVtcEVsZW1lbnQ7XG4gICAgaWYgKCF0ZW1wRWxlbWVudCkge1xuICAgICAgdGVtcEVsZW1lbnQgPSBjb250ZXh0Ll93eXNpaHRtbDVfdGVtcEVsZW1lbnQgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgfVxuICAgIHJldHVybiB0ZW1wRWxlbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgb3JpZ2luYWwgdGV4dCBub2RlcyB3aXRoIHRoZSBuZXdseSBhdXRvLWxpbmtlZCBkb20gdHJlZVxuICAgKi9cbiAgZnVuY3Rpb24gX3dyYXBNYXRjaGVzSW5Ob2RlKHRleHROb2RlKSB7XG4gICAgdmFyIHBhcmVudE5vZGUgPSB0ZXh0Tm9kZS5wYXJlbnROb2RlLFxuICAgICAgICB0ZW1wRWxlbWVudCA9IF9nZXRUZW1wRWxlbWVudChwYXJlbnROb2RlLm93bmVyRG9jdW1lbnQpO1xuXG4gICAgLy8gV2UgbmVlZCB0byBpbnNlcnQgYW4gZW1wdHkvdGVtcG9yYXJ5IDxzcGFuIC8+IHRvIGZpeCBJRSBxdWlya3NcbiAgICAvLyBFbHNld2lzZSBJRSB3b3VsZCBzdHJpcCB3aGl0ZSBzcGFjZSBpbiB0aGUgYmVnaW5uaW5nXG4gICAgdGVtcEVsZW1lbnQuaW5uZXJIVE1MID0gXCI8c3Bhbj48L3NwYW4+XCIgKyBfY29udmVydFVybHNUb0xpbmtzKHRleHROb2RlLmRhdGEpO1xuICAgIHRlbXBFbGVtZW50LnJlbW92ZUNoaWxkKHRlbXBFbGVtZW50LmZpcnN0Q2hpbGQpO1xuXG4gICAgd2hpbGUgKHRlbXBFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIC8vIGluc2VydHMgdGVtcEVsZW1lbnQuZmlyc3RDaGlsZCBiZWZvcmUgdGV4dE5vZGVcbiAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRlbXBFbGVtZW50LmZpcnN0Q2hpbGQsIHRleHROb2RlKTtcbiAgICB9XG4gICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0ZXh0Tm9kZSk7XG4gIH1cblxuICBmdW5jdGlvbiBfaGFzUGFyZW50VGhhdFNob3VsZEJlSWdub3JlZChub2RlKSB7XG4gICAgdmFyIG5vZGVOYW1lO1xuICAgIHdoaWxlIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWU7XG4gICAgICBpZiAoSUdOT1JFX1VSTFNfSU4uY29udGFpbnMobm9kZU5hbWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChub2RlTmFtZSA9PT0gXCJib2R5XCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBfcGFyc2VOb2RlKGVsZW1lbnQpIHtcbiAgICBpZiAoSUdOT1JFX1VSTFNfSU4uY29udGFpbnMoZWxlbWVudC5ub2RlTmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gd3lzaWh0bWw1LlRFWFRfTk9ERSAmJiBlbGVtZW50LmRhdGEubWF0Y2goVVJMX1JFR19FWFApKSB7XG4gICAgICBfd3JhcE1hdGNoZXNJbk5vZGUoZWxlbWVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkTm9kZXMgPSB3eXNpaHRtbDUubGFuZy5hcnJheShlbGVtZW50LmNoaWxkTm9kZXMpLmdldCgpLFxuICAgICAgICBjaGlsZE5vZGVzTGVuZ3RoID0gY2hpbGROb2Rlcy5sZW5ndGgsXG4gICAgICAgIGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBjaGlsZE5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICAgIF9wYXJzZU5vZGUoY2hpbGROb2Rlc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICB3eXNpaHRtbDUuZG9tLmF1dG9MaW5rID0gYXV0b0xpbms7XG5cbiAgLy8gUmV2ZWFsIHVybCByZWcgZXhwIHRvIHRoZSBvdXRzaWRlXG4gIHd5c2lodG1sNS5kb20uYXV0b0xpbmsuVVJMX1JFR19FWFAgPSBVUkxfUkVHX0VYUDtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIHN1cHBvcnRzQ2xhc3NMaXN0ID0gd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNDbGFzc0xpc3QoKSxcbiAgICAgIGFwaSA9IHd5c2lodG1sNS5kb207XG5cbiAgYXBpLmFkZENsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIGlmIChzdXBwb3J0c0NsYXNzTGlzdCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICAgIH1cbiAgICBpZiAoYXBpLmhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxlbWVudC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gIH07XG5cbiAgYXBpLnJlbW92ZUNsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIGlmIChzdXBwb3J0c0NsYXNzTGlzdCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgIH1cblxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gZWxlbWVudC5jbGFzc05hbWUucmVwbGFjZShuZXcgUmVnRXhwKFwiKF58XFxcXHMrKVwiICsgY2xhc3NOYW1lICsgXCIoXFxcXHMrfCQpXCIpLCBcIiBcIik7XG4gIH07XG5cbiAgYXBpLmhhc0NsYXNzID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICAgIGlmIChzdXBwb3J0c0NsYXNzTGlzdCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRDbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZTtcbiAgICByZXR1cm4gZWxlbWVudENsYXNzTmFtZS5sZW5ndGggPiAwICYmIChlbGVtZW50Q2xhc3NOYW1lID09IGNsYXNzTmFtZSB8fCBuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBjbGFzc05hbWUgKyBcIihcXFxcc3wkKVwiKS50ZXN0KGVsZW1lbnRDbGFzc05hbWUpKTtcbiAgfTtcbn0pKHd5c2lodG1sNSk7XG53eXNpaHRtbDUuZG9tLmNvbnRhaW5zID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBpZiAoZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb250YWluZXIsIGVsZW1lbnQpIHtcbiAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSB3eXNpaHRtbDUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGFpbmVyICE9PSBlbGVtZW50ICYmIGNvbnRhaW5lci5jb250YWlucyhlbGVtZW50KTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY29udGFpbmVyLCBlbGVtZW50KSB7XG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuICAgICAgcmV0dXJuICEhKGNvbnRhaW5lci5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50KSAmIDE2KTtcbiAgICB9O1xuICB9XG59KCk7IC8qKlxuICAgICAqIENvbnZlcnRzIGFuIEhUTUwgZnJhZ21lbnQvZWxlbWVudCBpbnRvIGEgdW5vcmRlcmVkL29yZGVyZWQgbGlzdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHdoaWNoIHNob3VsZCBiZSB0dXJuZWQgaW50byBhIGxpc3RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbGlzdFR5cGUgVGhlIGxpc3QgdHlwZSBpbiB3aGljaCB0byBjb252ZXJ0IHRoZSB0cmVlIChlaXRoZXIgXCJ1bFwiIG9yIFwib2xcIilcbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBUaGUgY3JlYXRlZCBsaXN0XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIDwhLS0gQXNzdW1lIHRoZSBmb2xsb3dpbmcgZG9tOiAtLT5cbiAgICAgKiAgICA8c3BhbiBpZD1cInBzZXVkby1saXN0XCI+XG4gICAgICogICAgICBlbWluZW08YnI+XG4gICAgICogICAgICBkci4gZHJlXG4gICAgICogICAgICA8ZGl2PjUwIENlbnQ8L2Rpdj5cbiAgICAgKiAgICA8L3NwYW4+XG4gICAgICpcbiAgICAgKiAgICA8c2NyaXB0PlxuICAgICAqICAgICAgd3lzaWh0bWw1LmRvbS5jb252ZXJ0VG9MaXN0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHNldWRvLWxpc3RcIiksIFwidWxcIik7XG4gICAgICogICAgPC9zY3JpcHQ+XG4gICAgICpcbiAgICAgKiAgICA8IS0tIFdpbGwgcmVzdWx0IGluOiAtLT5cbiAgICAgKiAgICA8dWw+XG4gICAgICogICAgICA8bGk+ZW1pbmVtPC9saT5cbiAgICAgKiAgICAgIDxsaT5kci4gZHJlPC9saT5cbiAgICAgKiAgICAgIDxsaT41MCBDZW50PC9saT5cbiAgICAgKiAgICA8L3VsPlxuICAgICAqL1xud3lzaWh0bWw1LmRvbS5jb252ZXJ0VG9MaXN0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBfY3JlYXRlTGlzdEl0ZW0oZG9jLCBsaXN0KSB7XG4gICAgdmFyIGxpc3RJdGVtID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcbiAgICBsaXN0LmFwcGVuZENoaWxkKGxpc3RJdGVtKTtcbiAgICByZXR1cm4gbGlzdEl0ZW07XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlTGlzdChkb2MsIHR5cGUpIHtcbiAgICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjb252ZXJ0VG9MaXN0KGVsZW1lbnQsIGxpc3RUeXBlKSB7XG4gICAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09IFwiVUxcIiB8fCBlbGVtZW50Lm5vZGVOYW1lID09PSBcIk9MXCIgfHwgZWxlbWVudC5ub2RlTmFtZSA9PT0gXCJNRU5VXCIpIHtcbiAgICAgIC8vIEFscmVhZHkgYSBsaXN0XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50LFxuICAgICAgICBsaXN0ID0gX2NyZWF0ZUxpc3QoZG9jLCBsaXN0VHlwZSksXG4gICAgICAgIGxpbmVCcmVha3MgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJiclwiKSxcbiAgICAgICAgbGluZUJyZWFrc0xlbmd0aCA9IGxpbmVCcmVha3MubGVuZ3RoLFxuICAgICAgICBjaGlsZE5vZGVzLFxuICAgICAgICBjaGlsZE5vZGVzTGVuZ3RoLFxuICAgICAgICBjaGlsZE5vZGUsXG4gICAgICAgIGxpbmVCcmVhayxcbiAgICAgICAgcGFyZW50Tm9kZSxcbiAgICAgICAgaXNCbG9ja0VsZW1lbnQsXG4gICAgICAgIGlzTGluZUJyZWFrLFxuICAgICAgICBjdXJyZW50TGlzdEl0ZW0sXG4gICAgICAgIGk7XG5cbiAgICAvLyBGaXJzdCBmaW5kIDxicj4gYXQgdGhlIGVuZCBvZiBpbmxpbmUgZWxlbWVudHMgYW5kIG1vdmUgdGhlbSBiZWhpbmQgdGhlbVxuICAgIGZvciAoaSA9IDA7IGkgPCBsaW5lQnJlYWtzTGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpbmVCcmVhayA9IGxpbmVCcmVha3NbaV07XG4gICAgICB3aGlsZSAoKHBhcmVudE5vZGUgPSBsaW5lQnJlYWsucGFyZW50Tm9kZSkgJiYgcGFyZW50Tm9kZSAhPT0gZWxlbWVudCAmJiBwYXJlbnROb2RlLmxhc3RDaGlsZCA9PT0gbGluZUJyZWFrKSB7XG4gICAgICAgIGlmICh3eXNpaHRtbDUuZG9tLmdldFN0eWxlKFwiZGlzcGxheVwiKS5mcm9tKHBhcmVudE5vZGUpID09PSBcImJsb2NrXCIpIHtcbiAgICAgICAgICBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpbmVCcmVhayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgd3lzaWh0bWw1LmRvbS5pbnNlcnQobGluZUJyZWFrKS5hZnRlcihsaW5lQnJlYWsucGFyZW50Tm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGROb2RlcyA9IHd5c2lodG1sNS5sYW5nLmFycmF5KGVsZW1lbnQuY2hpbGROb2RlcykuZ2V0KCk7XG4gICAgY2hpbGROb2Rlc0xlbmd0aCA9IGNoaWxkTm9kZXMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkTm9kZXNMZW5ndGg7IGkrKykge1xuICAgICAgY3VycmVudExpc3RJdGVtID0gY3VycmVudExpc3RJdGVtIHx8IF9jcmVhdGVMaXN0SXRlbShkb2MsIGxpc3QpO1xuICAgICAgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tpXTtcbiAgICAgIGlzQmxvY2tFbGVtZW50ID0gd3lzaWh0bWw1LmRvbS5nZXRTdHlsZShcImRpc3BsYXlcIikuZnJvbShjaGlsZE5vZGUpID09PSBcImJsb2NrXCI7XG4gICAgICBpc0xpbmVCcmVhayA9IGNoaWxkTm9kZS5ub2RlTmFtZSA9PT0gXCJCUlwiO1xuXG4gICAgICBpZiAoaXNCbG9ja0VsZW1lbnQpIHtcbiAgICAgICAgLy8gQXBwZW5kIGJsb2NrRWxlbWVudCB0byBjdXJyZW50IDxsaT4gaWYgZW1wdHksIG90aGVyd2lzZSBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgIGN1cnJlbnRMaXN0SXRlbSA9IGN1cnJlbnRMaXN0SXRlbS5maXJzdENoaWxkID8gX2NyZWF0ZUxpc3RJdGVtKGRvYywgbGlzdCkgOiBjdXJyZW50TGlzdEl0ZW07XG4gICAgICAgIGN1cnJlbnRMaXN0SXRlbS5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuICAgICAgICBjdXJyZW50TGlzdEl0ZW0gPSBudWxsO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzTGluZUJyZWFrKSB7XG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIGEgbmV3IGxpc3QgaXRlbSBpbiB0aGUgbmV4dCBpdGVyYXRpb24gd2hlbiB0aGUgY3VycmVudCBvbmUgaGFzIGFscmVhZHkgY29udGVudFxuICAgICAgICBjdXJyZW50TGlzdEl0ZW0gPSBjdXJyZW50TGlzdEl0ZW0uZmlyc3RDaGlsZCA/IG51bGwgOiBjdXJyZW50TGlzdEl0ZW07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50TGlzdEl0ZW0uYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcbiAgICB9XG5cbiAgICBlbGVtZW50LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGxpc3QsIGVsZW1lbnQpO1xuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgcmV0dXJuIGNvbnZlcnRUb0xpc3Q7XG59KCk7IC8qKlxuICAgICAqIENvcHkgYSBzZXQgb2YgYXR0cmlidXRlcyBmcm9tIG9uZSBlbGVtZW50IHRvIGFub3RoZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGF0dHJpYnV0ZXNUb0NvcHkgTGlzdCBvZiBhdHRyaWJ1dGVzIHdoaWNoIHNob3VsZCBiZSBjb3BpZWRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdoaWNoIG9mZmVycyB0aGUgXCJmcm9tXCIgbWV0aG9kIHdoaWNoIGNhbiBiZSBpbnZva2VkIHdpdGggdGhlIGVsZW1lbnQgd2hlcmUgdG9cbiAgICAgKiAgICBjb3B5IHRoZSBhdHRyaWJ1dGVzIGZyb20uLCB0aGlzIGFnYWluIHJldHVybnMgYW4gb2JqZWN0IHdoaWNoIHByb3ZpZGVzIGEgbWV0aG9kIG5hbWVkIFwidG9cIiB3aGljaCBjYW4gYmUgaW52b2tlZCBcbiAgICAgKiAgICB3aXRoIHRoZSBlbGVtZW50IHdoZXJlIHRvIGNvcHkgdGhlIGF0dHJpYnV0ZXMgdG8gKHNlZSBleGFtcGxlKVxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB2YXIgdGV4dGFyZWEgICAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwidGV4dGFyZWFcIiksXG4gICAgICogICAgICAgIGRpdiAgICAgICAgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImRpdltjb250ZW50ZWRpdGFibGU9dHJ1ZV1cIiksXG4gICAgICogICAgICAgIGFub3RoZXJEaXYgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImRpdi5wcmV2aWV3XCIpO1xuICAgICAqICAgIHd5c2lodG1sNS5kb20uY29weUF0dHJpYnV0ZXMoW1wic3BlbGxjaGVja1wiLCBcInZhbHVlXCIsIFwicGxhY2Vob2xkZXJcIl0pLmZyb20odGV4dGFyZWEpLnRvKGRpdikuYW5kVG8oYW5vdGhlckRpdik7XG4gICAgICpcbiAgICAgKi9cbnd5c2lodG1sNS5kb20uY29weUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoYXR0cmlidXRlc1RvQ29weSkge1xuICByZXR1cm4ge1xuICAgIGZyb206IGZ1bmN0aW9uIGZyb20oZWxlbWVudFRvQ29weUZyb20pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvOiBmdW5jdGlvbiB0byhlbGVtZW50VG9Db3B5VG8pIHtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlLFxuICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgbGVuZ3RoID0gYXR0cmlidXRlc1RvQ29weS5sZW5ndGg7XG4gICAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXR0cmlidXRlID0gYXR0cmlidXRlc1RvQ29weVtpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZWxlbWVudFRvQ29weUZyb21bYXR0cmlidXRlXSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtZW50VG9Db3B5RnJvbVthdHRyaWJ1dGVdICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnRUb0NvcHlUb1thdHRyaWJ1dGVdID0gZWxlbWVudFRvQ29weUZyb21bYXR0cmlidXRlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgYW5kVG86IGFyZ3VtZW50cy5jYWxsZWUgfTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59OyAvKipcbiAgICogQ29weSBhIHNldCBvZiBzdHlsZXMgZnJvbSBvbmUgZWxlbWVudCB0byBhbm90aGVyXG4gICAqIFBsZWFzZSBub3RlIHRoYXQgdGhpcyBvbmx5IHdvcmtzIHByb3Blcmx5IGFjcm9zcyBicm93c2VycyB3aGVuIHRoZSBlbGVtZW50IGZyb20gd2hpY2ggdG8gY29weSB0aGUgc3R5bGVzXG4gICAqIGlzIGluIHRoZSBkb21cbiAgICpcbiAgICogSW50ZXJlc3RpbmcgYXJ0aWNsZSBvbiBob3cgdG8gY29weSBzdHlsZXNcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gc3R5bGVzVG9Db3B5IExpc3Qgb2Ygc3R5bGVzIHdoaWNoIHNob3VsZCBiZSBjb3BpZWRcbiAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGFuIG9iamVjdCB3aGljaCBvZmZlcnMgdGhlIFwiZnJvbVwiIG1ldGhvZCB3aGljaCBjYW4gYmUgaW52b2tlZCB3aXRoIHRoZSBlbGVtZW50IHdoZXJlIHRvXG4gICAqICAgIGNvcHkgdGhlIHN0eWxlcyBmcm9tLiwgdGhpcyBhZ2FpbiByZXR1cm5zIGFuIG9iamVjdCB3aGljaCBwcm92aWRlcyBhIG1ldGhvZCBuYW1lZCBcInRvXCIgd2hpY2ggY2FuIGJlIGludm9rZWQgXG4gICAqICAgIHdpdGggdGhlIGVsZW1lbnQgd2hlcmUgdG8gY29weSB0aGUgc3R5bGVzIHRvIChzZWUgZXhhbXBsZSlcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogICAgdmFyIHRleHRhcmVhICAgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInRleHRhcmVhXCIpLFxuICAgKiAgICAgICAgZGl2ICAgICAgICAgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiZGl2W2NvbnRlbnRlZGl0YWJsZT10cnVlXVwiKSxcbiAgICogICAgICAgIGFub3RoZXJEaXYgID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImRpdi5wcmV2aWV3XCIpO1xuICAgKiAgICB3eXNpaHRtbDUuZG9tLmNvcHlTdHlsZXMoW1wib3ZlcmZsb3cteVwiLCBcIndpZHRoXCIsIFwiaGVpZ2h0XCJdKS5mcm9tKHRleHRhcmVhKS50byhkaXYpLmFuZFRvKGFub3RoZXJEaXYpO1xuICAgKlxuICAgKi9cbihmdW5jdGlvbiAoZG9tKSB7XG5cbiAgLyoqXG4gICAqIE1vemlsbGEsIFdlYktpdCBhbmQgT3BlcmEgcmVjYWxjdWxhdGUgdGhlIGNvbXB1dGVkIHdpZHRoIHdoZW4gYm94LXNpemluZzogYm9kZXItYm94OyBpcyBzZXRcbiAgICogU28gaWYgYW4gZWxlbWVudCBoYXMgXCJ3aWR0aDogMjAwcHg7IC1tb3otYm94LXNpemluZzogYm9yZGVyLWJveDsgYm9yZGVyOiAxcHg7XCIgdGhlbiBcbiAgICogaXRzIGNvbXB1dGVkIGNzcyB3aWR0aCB3aWxsIGJlIDE5OHB4XG4gICAqL1xuICB2YXIgQk9YX1NJWklOR19QUk9QRVJUSUVTID0gW1wiLXdlYmtpdC1ib3gtc2l6aW5nXCIsIFwiLW1vei1ib3gtc2l6aW5nXCIsIFwiLW1zLWJveC1zaXppbmdcIiwgXCJib3gtc2l6aW5nXCJdO1xuXG4gIHZhciBzaG91bGRJZ25vcmVCb3hTaXppbmdCb3JkZXJCb3ggPSBmdW5jdGlvbiBzaG91bGRJZ25vcmVCb3hTaXppbmdCb3JkZXJCb3goZWxlbWVudCkge1xuICAgIGlmIChoYXNCb3hTaXppbmdCb3JkZXJCb3goZWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChkb20uZ2V0U3R5bGUoXCJ3aWR0aFwiKS5mcm9tKGVsZW1lbnQpLCAxMCkgPCBlbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgdmFyIGhhc0JveFNpemluZ0JvcmRlckJveCA9IGZ1bmN0aW9uIGhhc0JveFNpemluZ0JvcmRlckJveChlbGVtZW50KSB7XG4gICAgdmFyIGkgPSAwLFxuICAgICAgICBsZW5ndGggPSBCT1hfU0laSU5HX1BST1BFUlRJRVMubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChkb20uZ2V0U3R5bGUoQk9YX1NJWklOR19QUk9QRVJUSUVTW2ldKS5mcm9tKGVsZW1lbnQpID09PSBcImJvcmRlci1ib3hcIikge1xuICAgICAgICByZXR1cm4gQk9YX1NJWklOR19QUk9QRVJUSUVTW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBkb20uY29weVN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZXNUb0NvcHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbTogZnVuY3Rpb24gZnJvbShlbGVtZW50KSB7XG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVCb3hTaXppbmdCb3JkZXJCb3goZWxlbWVudCkpIHtcbiAgICAgICAgICBzdHlsZXNUb0NvcHkgPSB3eXNpaHRtbDUubGFuZy5hcnJheShzdHlsZXNUb0NvcHkpLndpdGhvdXQoQk9YX1NJWklOR19QUk9QRVJUSUVTKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjc3NUZXh0ID0gXCJcIixcbiAgICAgICAgICAgIGxlbmd0aCA9IHN0eWxlc1RvQ29weS5sZW5ndGgsXG4gICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgIHByb3BlcnR5O1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcHJvcGVydHkgPSBzdHlsZXNUb0NvcHlbaV07XG4gICAgICAgICAgY3NzVGV4dCArPSBwcm9wZXJ0eSArIFwiOlwiICsgZG9tLmdldFN0eWxlKHByb3BlcnR5KS5mcm9tKGVsZW1lbnQpICsgXCI7XCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvOiBmdW5jdGlvbiB0byhlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0X3IgPSAvXFw7aGVpZ2h0XFw6LztcbiAgICAgICAgICAgIGlmIChjc3NUZXh0Lm1hdGNoKGhlaWdodF9yKSAmJiBlbGVtZW50KSB7XG4gICAgICAgICAgICAgIGxpc3QgPSBjc3NUZXh0LnNwbGl0KGhlaWdodF9yKTtcbiAgICAgICAgICAgICAgaGVpZ2h0ID0gcGFyc2VJbnQobGlzdFsxXSwgMTApO1xuICAgICAgICAgICAgICBpZiAoZWxlbWVudC5vZmZzZXRIZWlnaHQgPiBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBjc3NUZXh0ID0gbGlzdFswXSArICdoZWlnaHQ6JyArIGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgJ3B4Oyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbS5zZXRTdHlsZXMoY3NzVGV4dCkub24oZWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4geyBhbmRUbzogYXJndW1lbnRzLmNhbGxlZSB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufSkod3lzaWh0bWw1LmRvbSk7IC8qKlxuICAgICAgICAgICAgICAgICAgICogRXZlbnQgRGVsZWdhdGlvblxuICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgKiAgICB3eXNpaHRtbDUuZG9tLmRlbGVnYXRlKGRvY3VtZW50LmJvZHksIFwiYVwiLCBcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICogICAgICAvLyBmb29cbiAgICAgICAgICAgICAgICAgICAqICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuXG4gIHd5c2lodG1sNS5kb20uZGVsZWdhdGUgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBzZWxlY3RvciwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHd5c2lodG1sNS5kb20ub2JzZXJ2ZShjb250YWluZXIsIGV2ZW50TmFtZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0LFxuICAgICAgICAgIG1hdGNoID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcblxuICAgICAgd2hpbGUgKHRhcmdldCAmJiB0YXJnZXQgIT09IGNvbnRhaW5lcikge1xuICAgICAgICBpZiAobWF0Y2guY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICAgIGhhbmRsZXIuY2FsbCh0YXJnZXQsIGV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0pKHd5c2lodG1sNSk7IC8qKlxuICAgICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBnaXZlbiBodG1sIHdyYXBwZWQgaW4gYSBkaXYgZWxlbWVudFxuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiBGaXhpbmcgSUUncyBpbmFiaWxpdHkgdG8gdHJlYXQgdW5rbm93biBlbGVtZW50cyAoSFRNTDUgc2VjdGlvbiwgYXJ0aWNsZSwgLi4uKSBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICogd2hlbiBpbnNlcnRlZCB2aWEgaW5uZXJIVE1MXG4gICAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaHRtbCBUaGUgaHRtbCB3aGljaCBzaG91bGQgYmUgd3JhcHBlZCBpbiBhIGRvbSBlbGVtZW50XG4gICAgICAgICAgICAgICAqIEBwYXJhbSB7T2JlamN0fSBbY29udGV4dF0gRG9jdW1lbnQgb2JqZWN0IG9mIHRoZSBjb250ZXh0IHRoZSBodG1sIGJlbG9uZ3MgdG9cbiAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICogICAgd3lzaWh0bWw1LmRvbS5nZXRBc0RvbShcIjxhcnRpY2xlPmZvbzwvYXJ0aWNsZT5cIik7XG4gICAgICAgICAgICAgICAqL1xud3lzaWh0bWw1LmRvbS5nZXRBc0RvbSA9IGZ1bmN0aW9uICgpIHtcblxuICB2YXIgX2lubmVySFRNTFNoaXYgPSBmdW5jdGlvbiBfaW5uZXJIVE1MU2hpdihodG1sLCBjb250ZXh0KSB7XG4gICAgdmFyIHRlbXBFbGVtZW50ID0gY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRlbXBFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBjb250ZXh0LmJvZHkuYXBwZW5kQ2hpbGQodGVtcEVsZW1lbnQpO1xuICAgIC8vIElFIHRocm93cyBhbiBleGNlcHRpb24gd2hlbiB0cnlpbmcgdG8gaW5zZXJ0IDxmcmFtZXNldD48L2ZyYW1lc2V0PiB2aWEgaW5uZXJIVE1MXG4gICAgdHJ5IHtcbiAgICAgIHRlbXBFbGVtZW50LmlubmVySFRNTCA9IGh0bWw7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICBjb250ZXh0LmJvZHkucmVtb3ZlQ2hpbGQodGVtcEVsZW1lbnQpO1xuICAgIHJldHVybiB0ZW1wRWxlbWVudDtcbiAgfTtcblxuICAvKipcbiAgICogTWFrZSBzdXJlIElFIHN1cHBvcnRzIEhUTUw1IHRhZ3MsIHdoaWNoIGlzIGFjY29tcGxpc2hlZCBieSBzaW1wbHkgY3JlYXRpbmcgb25lIGluc3RhbmNlIG9mIGVhY2ggZWxlbWVudFxuICAgKi9cbiAgdmFyIF9lbnN1cmVIVE1MNUNvbXBhdGliaWxpdHkgPSBmdW5jdGlvbiBfZW5zdXJlSFRNTDVDb21wYXRpYmlsaXR5KGNvbnRleHQpIHtcbiAgICBpZiAoY29udGV4dC5fd3lzaWh0bWw1X3N1cHBvcnRzSFRNTDVUYWdzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBIVE1MNV9FTEVNRU5UUy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29udGV4dC5jcmVhdGVFbGVtZW50KEhUTUw1X0VMRU1FTlRTW2ldKTtcbiAgICB9XG4gICAgY29udGV4dC5fd3lzaWh0bWw1X3N1cHBvcnRzSFRNTDVUYWdzID0gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogTGlzdCBvZiBodG1sNSB0YWdzXG4gICAqIHRha2VuIGZyb20gaHR0cDovL3NpbW9uLmh0bWw1Lm9yZy9odG1sNS1lbGVtZW50c1xuICAgKi9cbiAgdmFyIEhUTUw1X0VMRU1FTlRTID0gW1wiYWJiclwiLCBcImFydGljbGVcIiwgXCJhc2lkZVwiLCBcImF1ZGlvXCIsIFwiYmRpXCIsIFwiY2FudmFzXCIsIFwiY29tbWFuZFwiLCBcImRhdGFsaXN0XCIsIFwiZGV0YWlsc1wiLCBcImZpZ2NhcHRpb25cIiwgXCJmaWd1cmVcIiwgXCJmb290ZXJcIiwgXCJoZWFkZXJcIiwgXCJoZ3JvdXBcIiwgXCJrZXlnZW5cIiwgXCJtYXJrXCIsIFwibWV0ZXJcIiwgXCJuYXZcIiwgXCJvdXRwdXRcIiwgXCJwcm9ncmVzc1wiLCBcInJwXCIsIFwicnRcIiwgXCJydWJ5XCIsIFwic3ZnXCIsIFwic2VjdGlvblwiLCBcInNvdXJjZVwiLCBcInN1bW1hcnlcIiwgXCJ0aW1lXCIsIFwidHJhY2tcIiwgXCJ2aWRlb1wiLCBcIndiclwiXTtcblxuICByZXR1cm4gZnVuY3Rpb24gKGh0bWwsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcbiAgICB2YXIgdGVtcEVsZW1lbnQ7XG4gICAgaWYgKCh0eXBlb2YgaHRtbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGh0bWwpKSA9PT0gXCJvYmplY3RcIiAmJiBodG1sLm5vZGVUeXBlKSB7XG4gICAgICB0ZW1wRWxlbWVudCA9IGNvbnRleHQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHRlbXBFbGVtZW50LmFwcGVuZENoaWxkKGh0bWwpO1xuICAgIH0gZWxzZSBpZiAod3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNIVE1MNVRhZ3MoY29udGV4dCkpIHtcbiAgICAgIHRlbXBFbGVtZW50ID0gY29udGV4dC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGVtcEVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9IGVsc2Uge1xuICAgICAgX2Vuc3VyZUhUTUw1Q29tcGF0aWJpbGl0eShjb250ZXh0KTtcbiAgICAgIHRlbXBFbGVtZW50ID0gX2lubmVySFRNTFNoaXYoaHRtbCwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0ZW1wRWxlbWVudDtcbiAgfTtcbn0oKTsgLyoqXG4gICAgICogV2Fsa3MgdGhlIGRvbSB0cmVlIGZyb20gdGhlIGdpdmVuIG5vZGUgdXAgdW50aWwgaXQgZmluZHMgYSBtYXRjaFxuICAgICAqIERlc2lnbmVkIGZvciBvcHRpbWFsIHBlcmZvcm1hbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIFRoZSBmcm9tIHdoaWNoIHRvIGNoZWNrIHRoZSBwYXJlbnQgbm9kZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWF0Y2hpbmdTZXQgT2JqZWN0IHRvIG1hdGNoIGFnYWluc3QgKHBvc3NpYmxlIHByb3BlcnRpZXM6IG5vZGVOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbGV2ZWxzXSBIb3cgbWFueSBwYXJlbnRzIHNob3VsZCB0aGUgZnVuY3Rpb24gY2hlY2sgdXAgZnJvbSB0aGUgY3VycmVudCBub2RlIChkZWZhdWx0cyB0byA1MClcbiAgICAgKiBAcmV0dXJuIHtudWxsfEVsZW1lbnR9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBtYXRjaGVkIHRoZSBkZXNpcmVkTm9kZU5hbWUocylcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHZhciBsaXN0RWxlbWVudCA9IHd5c2lodG1sNS5kb20uZ2V0UGFyZW50RWxlbWVudChkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibGlcIiksIHsgbm9kZU5hbWU6IFtcIk1FTlVcIiwgXCJVTFwiLCBcIk9MXCJdIH0pO1xuICAgICAqICAgIC8vIC4uLiBvciAuLi5cbiAgICAgKiAgICB2YXIgdW5vcmRlcmVkTGlzdEVsZW1lbnQgPSB3eXNpaHRtbDUuZG9tLmdldFBhcmVudEVsZW1lbnQoZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImxpXCIpLCB7IG5vZGVOYW1lOiBcIlVMXCIgfSk7XG4gICAgICogICAgLy8gLi4uIG9yIC4uLlxuICAgICAqICAgIHZhciBjb2xvcmVkRWxlbWVudCA9IHd5c2lodG1sNS5kb20uZ2V0UGFyZW50RWxlbWVudChteVRleHROb2RlLCB7IG5vZGVOYW1lOiBcIlNQQU5cIiwgY2xhc3NOYW1lOiBcInd5c2l3eWctY29sb3ItcmVkXCIsIGNsYXNzUmVnRXhwOiAvd3lzaXd5Zy1jb2xvci1bYS16XS9nIH0pO1xuICAgICAqL1xud3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuXG4gIGZ1bmN0aW9uIF9pc1NhbWVOb2RlTmFtZShub2RlTmFtZSwgZGVzaXJlZE5vZGVOYW1lcykge1xuICAgIGlmICghZGVzaXJlZE5vZGVOYW1lcyB8fCAhZGVzaXJlZE5vZGVOYW1lcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGVzaXJlZE5vZGVOYW1lcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIG5vZGVOYW1lID09PSBkZXNpcmVkTm9kZU5hbWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmxhbmcuYXJyYXkoZGVzaXJlZE5vZGVOYW1lcykuY29udGFpbnMobm9kZU5hbWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9pc0VsZW1lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSB3eXNpaHRtbDUuRUxFTUVOVF9OT0RFO1xuICB9XG5cbiAgZnVuY3Rpb24gX2hhc0NsYXNzTmFtZShlbGVtZW50LCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKSB7XG4gICAgdmFyIGNsYXNzTmFtZXMgPSAoZWxlbWVudC5jbGFzc05hbWUgfHwgXCJcIikubWF0Y2goY2xhc3NSZWdFeHApIHx8IFtdO1xuICAgIGlmICghY2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gISFjbGFzc05hbWVzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXNbY2xhc3NOYW1lcy5sZW5ndGggLSAxXSA9PT0gY2xhc3NOYW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldFBhcmVudEVsZW1lbnRXaXRoTm9kZU5hbWUobm9kZSwgbm9kZU5hbWUsIGxldmVscykge1xuICAgIHdoaWxlIChsZXZlbHMtLSAmJiBub2RlICYmIG5vZGUubm9kZU5hbWUgIT09IFwiQk9EWVwiKSB7XG4gICAgICBpZiAoX2lzU2FtZU5vZGVOYW1lKG5vZGUubm9kZU5hbWUsIG5vZGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gX2dldFBhcmVudEVsZW1lbnRXaXRoTm9kZU5hbWVBbmRDbGFzc05hbWUobm9kZSwgbm9kZU5hbWUsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHAsIGxldmVscykge1xuICAgIHdoaWxlIChsZXZlbHMtLSAmJiBub2RlICYmIG5vZGUubm9kZU5hbWUgIT09IFwiQk9EWVwiKSB7XG4gICAgICBpZiAoX2lzRWxlbWVudChub2RlKSAmJiBfaXNTYW1lTm9kZU5hbWUobm9kZS5ub2RlTmFtZSwgbm9kZU5hbWUpICYmIF9oYXNDbGFzc05hbWUobm9kZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAobm9kZSwgbWF0Y2hpbmdTZXQsIGxldmVscykge1xuICAgIGxldmVscyA9IGxldmVscyB8fCA1MDsgLy8gR28gbWF4IDUwIG5vZGVzIHVwd2FyZHMgZnJvbSBjdXJyZW50IG5vZGVcbiAgICBpZiAobWF0Y2hpbmdTZXQuY2xhc3NOYW1lIHx8IG1hdGNoaW5nU2V0LmNsYXNzUmVnRXhwKSB7XG4gICAgICByZXR1cm4gX2dldFBhcmVudEVsZW1lbnRXaXRoTm9kZU5hbWVBbmRDbGFzc05hbWUobm9kZSwgbWF0Y2hpbmdTZXQubm9kZU5hbWUsIG1hdGNoaW5nU2V0LmNsYXNzTmFtZSwgbWF0Y2hpbmdTZXQuY2xhc3NSZWdFeHAsIGxldmVscyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBfZ2V0UGFyZW50RWxlbWVudFdpdGhOb2RlTmFtZShub2RlLCBtYXRjaGluZ1NldC5ub2RlTmFtZSwgbGV2ZWxzKTtcbiAgICB9XG4gIH07XG59KCk7XG4vKipcbiAqIEdldCBlbGVtZW50J3Mgc3R5bGUgZm9yIGEgc3BlY2lmaWMgY3NzIHByb3BlcnR5XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IG9uIHdoaWNoIHRvIHJldHJpZXZlIHRoZSBzdHlsZVxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFRoZSBDU1MgcHJvcGVydHkgdG8gcmV0cmlldmUgKFwiZmxvYXRcIiwgXCJkaXNwbGF5XCIsIFwidGV4dC1hbGlnblwiLCAuLi4pXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIHd5c2lodG1sNS5kb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20oZG9jdW1lbnQuYm9keSk7XG4gKiAgICAvLyA9PiBcImJsb2NrXCJcbiAqL1xud3lzaWh0bWw1LmRvbS5nZXRTdHlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0eWxlUHJvcGVydHlNYXBwaW5nID0ge1xuICAgIFwiZmxvYXRcIjogXCJzdHlsZUZsb2F0XCIgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZSA/IFwic3R5bGVGbG9hdFwiIDogXCJjc3NGbG9hdFwiXG4gIH0sXG4gICAgICBSRUdfRVhQX0NBTUVMSVpFID0gL1xcLVthLXpdL2c7XG5cbiAgZnVuY3Rpb24gY2FtZWxpemUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKFJFR19FWFBfQ0FNRUxJWkUsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hdGNoLmNoYXJBdCgxKS50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tOiBmdW5jdGlvbiBmcm9tKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IHd5c2lodG1sNS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50LFxuICAgICAgICAgICAgY2FtZWxpemVkUHJvcGVydHkgPSBzdHlsZVByb3BlcnR5TWFwcGluZ1twcm9wZXJ0eV0gfHwgY2FtZWxpemUocHJvcGVydHkpLFxuICAgICAgICAgICAgc3R5bGUgPSBlbGVtZW50LnN0eWxlLFxuICAgICAgICAgICAgY3VycmVudFN0eWxlID0gZWxlbWVudC5jdXJyZW50U3R5bGUsXG4gICAgICAgICAgICBzdHlsZVZhbHVlID0gc3R5bGVbY2FtZWxpemVkUHJvcGVydHldO1xuICAgICAgICBpZiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzdHlsZVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3VycmVudFN0eWxlIGlzIG5vIHN0YW5kYXJkIGFuZCBvbmx5IHN1cHBvcnRlZCBieSBPcGVyYSBhbmQgSUUgYnV0IGl0IGhhcyBvbmUgaW1wb3J0YW50IGFkdmFudGFnZSBvdmVyIHRoZSBzdGFuZGFyZC1jb21wbGlhbnRcbiAgICAgICAgLy8gd2luZG93LmdldENvbXB1dGVkU3R5bGUsIHNpbmNlIGl0IHJldHVybnMgY3NzIHByb3BlcnR5IHZhbHVlcyBpbiB0aGVpciBvcmlnaW5hbCB1bml0OlxuICAgICAgICAvLyBJZiB5b3Ugc2V0IGFuIGVsZW1lbnRzIHdpZHRoIHRvIFwiNTAlXCIsIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIHdpbGwgZ2l2ZSB5b3UgaXQncyBjdXJyZW50IHdpZHRoIGluIHB4IHdoaWxlIGN1cnJlbnRTdHlsZVxuICAgICAgICAvLyBnaXZlcyB5b3UgdGhlIG9yaWdpbmFsIFwiNTAlXCIuXG4gICAgICAgIC8vIE9wZXJhIHN1cHBvcnRzIGJvdGgsIGN1cnJlbnRTdHlsZSBhbmQgd2luZG93LmdldENvbXB1dGVkU3R5bGUsIHRoYXQncyB3aHkgY2hlY2tpbmcgZm9yIGN1cnJlbnRTdHlsZSBzaG91bGQgaGF2ZSBoaWdoZXIgcHJpb1xuICAgICAgICBpZiAoY3VycmVudFN0eWxlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50U3R5bGVbY2FtZWxpemVkUHJvcGVydHldO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vaWUgd2lsbCBvY2Nhc2lvbmFsbHkgZmFpbCBmb3IgdW5rbm93biByZWFzb25zLiBzd2FsbG93aW5nIGV4Y2VwdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyxcbiAgICAgICAgICAgIG5lZWRzT3ZlcmZsb3dSZXNldCA9IChwcm9wZXJ0eSA9PT0gXCJoZWlnaHRcIiB8fCBwcm9wZXJ0eSA9PT0gXCJ3aWR0aFwiKSAmJiBlbGVtZW50Lm5vZGVOYW1lID09PSBcIlRFWFRBUkVBXCIsXG4gICAgICAgICAgICBvcmlnaW5hbE92ZXJmbG93LFxuICAgICAgICAgICAgcmV0dXJuVmFsdWU7XG5cbiAgICAgICAgaWYgKHdpbi5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICAgICAgLy8gQ2hyb21lIGFuZCBTYWZhcmkgYm90aCBjYWxjdWxhdGUgYSB3cm9uZyB3aWR0aCBhbmQgaGVpZ2h0IGZvciB0ZXh0YXJlYXMgd2hlbiB0aGV5IGhhdmUgc2Nyb2xsIGJhcnNcbiAgICAgICAgICAvLyB0aGVyZm9yZSB3ZSByZW1vdmUgYW5kIHJlc3RvcmUgdGhlIHNjcm9sbGJhciBhbmQgY2FsY3VsYXRlIHRoZSB2YWx1ZSBpbiBiZXR3ZWVuXG4gICAgICAgICAgaWYgKG5lZWRzT3ZlcmZsb3dSZXNldCkge1xuICAgICAgICAgICAgb3JpZ2luYWxPdmVyZmxvdyA9IHN0eWxlLm92ZXJmbG93O1xuICAgICAgICAgICAgc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IHdpbi5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuICAgICAgICAgIGlmIChuZWVkc092ZXJmbG93UmVzZXQpIHtcbiAgICAgICAgICAgIHN0eWxlLm92ZXJmbG93ID0gb3JpZ2luYWxPdmVyZmxvdyB8fCBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0dXJuVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9O1xufSgpOyAvKipcbiAgICAgKiBIaWdoIHBlcmZvcm1hbnQgd2F5IHRvIGNoZWNrIHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIGEgc3BlY2lmaWMgdGFnIG5hbWUgaXMgaW4gdGhlIGdpdmVuIGRvY3VtZW50XG4gICAgICogT3B0aW1pemVkIGZvciBiZWluZyBoZWF2aWx5IGV4ZWN1dGVkXG4gICAgICogVW5sZWFzaGVzIHRoZSBwb3dlciBvZiBsaXZlIG5vZGUgbGlzdHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkb2MgVGhlIGRvY3VtZW50IG9iamVjdCBvZiB0aGUgY29udGV4dCB3aGVyZSB0byBjaGVja1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0YWdOYW1lIFVwcGVyIGNhc2VkIHRhZyBuYW1lXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB3eXNpaHRtbDUuZG9tLmhhc0VsZW1lbnRXaXRoVGFnTmFtZShkb2N1bWVudCwgXCJJTUdcIik7XG4gICAgICovXG53eXNpaHRtbDUuZG9tLmhhc0VsZW1lbnRXaXRoVGFnTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIExJVkVfQ0FDSEUgPSB7fSxcbiAgICAgIERPQ1VNRU5UX0lERU5USUZJRVIgPSAxO1xuXG4gIGZ1bmN0aW9uIF9nZXREb2N1bWVudElkZW50aWZpZXIoZG9jKSB7XG4gICAgcmV0dXJuIGRvYy5fd3lzaWh0bWw1X2lkZW50aWZpZXIgfHwgKGRvYy5fd3lzaWh0bWw1X2lkZW50aWZpZXIgPSBET0NVTUVOVF9JREVOVElGSUVSKyspO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChkb2MsIHRhZ05hbWUpIHtcbiAgICB2YXIga2V5ID0gX2dldERvY3VtZW50SWRlbnRpZmllcihkb2MpICsgXCI6XCIgKyB0YWdOYW1lLFxuICAgICAgICBjYWNoZUVudHJ5ID0gTElWRV9DQUNIRVtrZXldO1xuICAgIGlmICghY2FjaGVFbnRyeSkge1xuICAgICAgY2FjaGVFbnRyeSA9IExJVkVfQ0FDSEVba2V5XSA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FjaGVFbnRyeS5sZW5ndGggPiAwO1xuICB9O1xufSgpOyAvKipcbiAgICAgKiBIaWdoIHBlcmZvcm1hbnQgd2F5IHRvIGNoZWNrIHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIGEgc3BlY2lmaWMgY2xhc3MgbmFtZSBpcyBpbiB0aGUgZ2l2ZW4gZG9jdW1lbnRcbiAgICAgKiBPcHRpbWl6ZWQgZm9yIGJlaW5nIGhlYXZpbHkgZXhlY3V0ZWRcbiAgICAgKiBVbmxlYXNoZXMgdGhlIHBvd2VyIG9mIGxpdmUgbm9kZSBsaXN0c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRvYyBUaGUgZG9jdW1lbnQgb2JqZWN0IG9mIHRoZSBjb250ZXh0IHdoZXJlIHRvIGNoZWNrXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRhZ05hbWUgVXBwZXIgY2FzZWQgdGFnIG5hbWVcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHd5c2lodG1sNS5kb20uaGFzRWxlbWVudFdpdGhDbGFzc05hbWUoZG9jdW1lbnQsIFwiZm9vYmFyXCIpO1xuICAgICAqL1xuKGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIExJVkVfQ0FDSEUgPSB7fSxcbiAgICAgIERPQ1VNRU5UX0lERU5USUZJRVIgPSAxO1xuXG4gIGZ1bmN0aW9uIF9nZXREb2N1bWVudElkZW50aWZpZXIoZG9jKSB7XG4gICAgcmV0dXJuIGRvYy5fd3lzaWh0bWw1X2lkZW50aWZpZXIgfHwgKGRvYy5fd3lzaWh0bWw1X2lkZW50aWZpZXIgPSBET0NVTUVOVF9JREVOVElGSUVSKyspO1xuICB9XG5cbiAgd3lzaWh0bWw1LmRvbS5oYXNFbGVtZW50V2l0aENsYXNzTmFtZSA9IGZ1bmN0aW9uIChkb2MsIGNsYXNzTmFtZSkge1xuICAgIC8vIGdldEVsZW1lbnRzQnlDbGFzc05hbWUgaXMgbm90IHN1cHBvcnRlZCBieSBJRTw5XG4gICAgLy8gYnV0IGlzIHNvbWV0aW1lcyBtb2NrZWQgdmlhIGxpYnJhcnkgY29kZSAod2hpY2ggdGhlbiBkb2Vzbid0IHJldHVybiBsaXZlIG5vZGUgbGlzdHMpXG4gICAgaWYgKCF3eXNpaHRtbDUuYnJvd3Nlci5zdXBwb3J0c05hdGl2ZUdldEVsZW1lbnRzQnlDbGFzc05hbWUoKSkge1xuICAgICAgcmV0dXJuICEhZG9jLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBjbGFzc05hbWUpO1xuICAgIH1cblxuICAgIHZhciBrZXkgPSBfZ2V0RG9jdW1lbnRJZGVudGlmaWVyKGRvYykgKyBcIjpcIiArIGNsYXNzTmFtZSxcbiAgICAgICAgY2FjaGVFbnRyeSA9IExJVkVfQ0FDSEVba2V5XTtcbiAgICBpZiAoIWNhY2hlRW50cnkpIHtcbiAgICAgIGNhY2hlRW50cnkgPSBMSVZFX0NBQ0hFW2tleV0gPSBkb2MuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoZUVudHJ5Lmxlbmd0aCA+IDA7XG4gIH07XG59KSh3eXNpaHRtbDUpO1xud3lzaWh0bWw1LmRvbS5pbnNlcnQgPSBmdW5jdGlvbiAoZWxlbWVudFRvSW5zZXJ0KSB7XG4gIHJldHVybiB7XG4gICAgYWZ0ZXI6IGZ1bmN0aW9uIGFmdGVyKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudFRvSW5zZXJ0LCBlbGVtZW50Lm5leHRTaWJsaW5nKTtcbiAgICB9LFxuXG4gICAgYmVmb3JlOiBmdW5jdGlvbiBiZWZvcmUoZWxlbWVudCkge1xuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbGVtZW50VG9JbnNlcnQsIGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBpbnRvOiBmdW5jdGlvbiBpbnRvKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbWVudFRvSW5zZXJ0KTtcbiAgICB9XG4gIH07XG59O3d5c2lodG1sNS5kb20uaW5zZXJ0Q1NTID0gZnVuY3Rpb24gKHJ1bGVzKSB7XG4gIHJ1bGVzID0gcnVsZXMuam9pbihcIlxcblwiKTtcblxuICByZXR1cm4ge1xuICAgIGludG86IGZ1bmN0aW9uIGludG8oZG9jKSB7XG4gICAgICB2YXIgaGVhZCA9IGRvYy5oZWFkIHx8IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0sXG4gICAgICAgICAgc3R5bGVFbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuICAgICAgc3R5bGVFbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XG5cbiAgICAgIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcnVsZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jLmNyZWF0ZVRleHROb2RlKHJ1bGVzKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoZWFkKSB7XG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59OyAvKipcbiAgICogTWV0aG9kIHRvIHNldCBkb20gZXZlbnRzXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAgIHd5c2lodG1sNS5kb20ub2JzZXJ2ZShpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudC5ib2R5LCBbXCJmb2N1c1wiLCBcImJsdXJcIl0sIGZ1bmN0aW9uKCkgeyAuLi4gfSk7XG4gICAqL1xud3lzaWh0bWw1LmRvbS5vYnNlcnZlID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50TmFtZXMsIGhhbmRsZXIpIHtcbiAgZXZlbnROYW1lcyA9IHR5cGVvZiBldmVudE5hbWVzID09PSBcInN0cmluZ1wiID8gW2V2ZW50TmFtZXNdIDogZXZlbnROYW1lcztcblxuICB2YXIgaGFuZGxlcldyYXBwZXIsXG4gICAgICBldmVudE5hbWUsXG4gICAgICBpID0gMCxcbiAgICAgIGxlbmd0aCA9IGV2ZW50TmFtZXMubGVuZ3RoO1xuXG4gIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBldmVudE5hbWUgPSBldmVudE5hbWVzW2ldO1xuICAgIGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlcldyYXBwZXIgPSBmdW5jdGlvbiBoYW5kbGVyV3JhcHBlcihldmVudCkge1xuICAgICAgICBpZiAoIShcInRhcmdldFwiIGluIGV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnRhcmdldCA9IGV2ZW50LnNyY0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQgPSBldmVudC5wcmV2ZW50RGVmYXVsdCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24gPSBldmVudC5zdG9wUHJvcGFnYXRpb24gfHwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgaGFuZGxlci5jYWxsKGVsZW1lbnQsIGV2ZW50KTtcbiAgICAgIH07XG4gICAgICBlbGVtZW50LmF0dGFjaEV2ZW50KFwib25cIiArIGV2ZW50TmFtZSwgaGFuZGxlcldyYXBwZXIpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHZhciBldmVudE5hbWUsXG4gICAgICAgICAgaSA9IDAsXG4gICAgICAgICAgbGVuZ3RoID0gZXZlbnROYW1lcy5sZW5ndGg7XG4gICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZXNbaV07XG4gICAgICAgIGlmIChlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudC5kZXRhY2hFdmVudChcIm9uXCIgKyBldmVudE5hbWUsIGhhbmRsZXJXcmFwcGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn07XG4vKipcbiAqIEhUTUwgU2FuaXRpemVyXG4gKiBSZXdyaXRlcyB0aGUgSFRNTCBiYXNlZCBvbiBnaXZlbiBydWxlc1xuICpcbiAqIEBwYXJhbSB7RWxlbWVudHxTdHJpbmd9IGVsZW1lbnRPckh0bWwgSFRNTCBTdHJpbmcgdG8gYmUgc2FuaXRpemVkIE9SIGVsZW1lbnQgd2hvc2UgY29udGVudCBzaG91bGQgYmUgc2FuaXRpemVkXG4gKiBAcGFyYW0ge09iamVjdH0gW3J1bGVzXSBMaXN0IG9mIHJ1bGVzIGZvciByZXdyaXRpbmcgdGhlIEhUTUwsIGlmIHRoZXJlJ3Mgbm8gcnVsZSBmb3IgYW4gZWxlbWVudCBpdCB3aWxsXG4gKiAgICBiZSBjb252ZXJ0ZWQgdG8gYSBcInNwYW5cIi4gRWFjaCBydWxlIGlzIGEga2V5L3ZhbHVlIHBhaXIgd2hlcmUga2V5IGlzIHRoZSB0YWcgdG8gY29udmVydCwgYW5kIHZhbHVlIHRoZVxuICogICAgZGVzaXJlZCBzdWJzdGl0dXRpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCBEb2N1bWVudCBvYmplY3QgaW4gd2hpY2ggdG8gcGFyc2UgdGhlIGh0bWwsIG5lZWRlZCB0byBzYW5kYm94IHRoZSBwYXJzaW5nXG4gKlxuICogQHJldHVybiB7RWxlbWVudHxTdHJpbmd9IERlcGVuZHMgb24gdGhlIGVsZW1lbnRPckh0bWwgcGFyYW1ldGVyLiBXaGVuIGh0bWwgdGhlbiB0aGUgc2FuaXRpemVkIGh0bWwgYXMgc3RyaW5nIGVsc2V3aXNlIHRoZSBlbGVtZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICB2YXIgdXNlckhUTUwgPSAnPGRpdiBpZD1cImZvb1wiIG9uY2xpY2s9XCJhbGVydCgxKTtcIj48cD48Zm9udCBjb2xvcj1cInJlZFwiPmZvbzwvZm9udD48c2NyaXB0PmFsZXJ0KDEpOzwvc2NyaXB0PjwvcD48L2Rpdj4nO1xuICogICAgd3lzaWh0bWw1LmRvbS5wYXJzZSh1c2VySFRNTCwge1xuICogICAgICB0YWdzIHtcbiAqICAgICAgICBwOiAgICAgIFwiZGl2XCIsICAgICAgLy8gUmVuYW1lIHAgdGFncyB0byBkaXYgdGFnc1xuICogICAgICAgIGZvbnQ6ICAgXCJzcGFuXCIgICAgICAvLyBSZW5hbWUgZm9udCB0YWdzIHRvIHNwYW4gdGFnc1xuICogICAgICAgIGRpdjogICAgdHJ1ZSwgICAgICAgLy8gS2VlcCB0aGVtLCBhbHNvIHBvc3NpYmxlIChzYW1lIHJlc3VsdCB3aGVuIHBhc3Npbmc6IFwiZGl2XCIgb3IgdHJ1ZSlcbiAqICAgICAgICBzY3JpcHQ6IHVuZGVmaW5lZCAgIC8vIFJlbW92ZSBzY3JpcHQgZWxlbWVudHNcbiAqICAgICAgfVxuICogICAgfSk7XG4gKiAgICAvLyA9PiA8ZGl2PjxkaXY+PHNwYW4+Zm9vIGJhcjwvc3Bhbj48L2Rpdj48L2Rpdj5cbiAqXG4gKiAgICB2YXIgdXNlckhUTUwgPSAnPHRhYmxlPjx0Ym9keT48dHI+PHRkPkknbSBhIHRhYmxlITwvdGQ+PC90cj48L3Rib2R5PjwvdGFibGU+JztcbiAqICAgIHd5c2lodG1sNS5kb20ucGFyc2UodXNlckhUTUwpO1xuICogICAgLy8gPT4gJzxzcGFuPjxzcGFuPjxzcGFuPjxzcGFuPkknbSBhIHRhYmxlITwvc3Bhbj48L3NwYW4+PC9zcGFuPjwvc3Bhbj4nXG4gKlxuICogICAgdmFyIHVzZXJIVE1MID0gJzxkaXY+Zm9vYmFyPGJyPmZvb2JhcjwvZGl2Pic7XG4gKiAgICB3eXNpaHRtbDUuZG9tLnBhcnNlKHVzZXJIVE1MLCB7XG4gKiAgICAgIHRhZ3M6IHtcbiAqICAgICAgICBkaXY6IHVuZGVmaW5lZCxcbiAqICAgICAgICBicjogIHRydWVcbiAqICAgICAgfVxuICogICAgfSk7XG4gKiAgICAvLyA9PiAnJ1xuICpcbiAqICAgIHZhciB1c2VySFRNTCA9ICc8ZGl2IGNsYXNzPVwicmVkXCI+Zm9vPC9kaXY+PGRpdiBjbGFzcz1cInBpbmtcIj5iYXI8L2Rpdj4nO1xuICogICAgd3lzaWh0bWw1LmRvbS5wYXJzZSh1c2VySFRNTCwge1xuICogICAgICBjbGFzc2VzOiB7XG4gKiAgICAgICAgcmVkOiAgICAxLFxuICogICAgICAgIGdyZWVuOiAgMVxuICogICAgICB9LFxuICogICAgICB0YWdzOiB7XG4gKiAgICAgICAgZGl2OiB7XG4gKiAgICAgICAgICByZW5hbWVfdGFnOiAgICAgXCJwXCJcbiAqICAgICAgICB9XG4gKiAgICAgIH1cbiAqICAgIH0pO1xuICogICAgLy8gPT4gJzxwIGNsYXNzPVwicmVkXCI+Zm9vPC9wPjxwPmJhcjwvcD4nXG4gKi9cbnd5c2lodG1sNS5kb20ucGFyc2UgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBhIFhNTFBhcnNlci9ET01QYXJzZXIgYXMgSFRNTDUgaXMgbm90IGFsd2F5cyB3ZWxsLWZvcm1lZCBYTUxcbiAgICogbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZygnPGltZyBzcmM9XCJmb28uZ2lmXCI+Jykgd2lsbCBjYXVzZSBhIHBhcnNlRXJyb3Igc2luY2UgdGhlXG4gICAqIG5vZGUgaXNuJ3QgY2xvc2VkXG4gICAqXG4gICAqIFRoZXJlZm9yZSB3ZSd2ZSB0byB1c2UgdGhlIGJyb3dzZXIncyBvcmRpbmFyeSBIVE1MIHBhcnNlciBpbnZva2VkIGJ5IHNldHRpbmcgaW5uZXJIVE1MLlxuICAgKi9cbiAgdmFyIE5PREVfVFlQRV9NQVBQSU5HID0ge1xuICAgIFwiMVwiOiBfaGFuZGxlRWxlbWVudCxcbiAgICBcIjNcIjogX2hhbmRsZVRleHRcbiAgfSxcblxuICAvLyBSZW5hbWUgdW5rbm93biB0YWdzIHRvIHRoaXNcbiAgREVGQVVMVF9OT0RFX05BTUUgPSBcInNwYW5cIixcbiAgICAgIFdISVRFX1NQQUNFX1JFR19FWFAgPSAvXFxzKy8sXG4gICAgICBkZWZhdWx0UnVsZXMgPSB7IHRhZ3M6IHt9LCBjbGFzc2VzOiB7fSB9LFxuICAgICAgY3VycmVudFJ1bGVzID0ge307XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgYWxsIGNoaWxkcyBvZiB0aGUgZWxlbWVudCwgcmVjcmVhdGVzIHRoZW0sIGFwcGVuZHMgdGhlbSBpbnRvIGEgZG9jdW1lbnQgZnJhZ21lbnRcbiAgICogd2hpY2ggbGF0ZXIgcmVwbGFjZXMgdGhlIGVudGlyZSBib2R5IGNvbnRlbnRcbiAgICovXG4gIGZ1bmN0aW9uIHBhcnNlKGVsZW1lbnRPckh0bWwsIHJ1bGVzLCBjb250ZXh0LCBjbGVhblVwKSB7XG4gICAgd3lzaWh0bWw1Lmxhbmcub2JqZWN0KGN1cnJlbnRSdWxlcykubWVyZ2UoZGVmYXVsdFJ1bGVzKS5tZXJnZShydWxlcykuZ2V0KCk7XG5cbiAgICBjb250ZXh0ID0gY29udGV4dCB8fCBlbGVtZW50T3JIdG1sLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG4gICAgdmFyIGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgIGlzU3RyaW5nID0gdHlwZW9mIGVsZW1lbnRPckh0bWwgPT09IFwic3RyaW5nXCIsXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIG5ld05vZGUsXG4gICAgICAgIGZpcnN0Q2hpbGQ7XG5cbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIGVsZW1lbnQgPSB3eXNpaHRtbDUuZG9tLmdldEFzRG9tKGVsZW1lbnRPckh0bWwsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudE9ySHRtbDtcbiAgICB9XG5cbiAgICB3aGlsZSAoZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICBmaXJzdENoaWxkID0gZWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgZWxlbWVudC5yZW1vdmVDaGlsZChmaXJzdENoaWxkKTtcbiAgICAgIG5ld05vZGUgPSBfY29udmVydChmaXJzdENoaWxkLCBjbGVhblVwKTtcbiAgICAgIGlmIChuZXdOb2RlKSB7XG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKG5ld05vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENsZWFyIGVsZW1lbnQgY29udGVudHNcbiAgICBlbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG5cbiAgICAvLyBJbnNlcnQgbmV3IERPTSB0cmVlXG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG5cbiAgICByZXR1cm4gaXNTdHJpbmcgPyB3eXNpaHRtbDUucXVpcmtzLmdldENvcnJlY3RJbm5lckhUTUwoZWxlbWVudCkgOiBlbGVtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gX2NvbnZlcnQob2xkTm9kZSwgY2xlYW5VcCkge1xuICAgIHZhciBvbGROb2RlVHlwZSA9IG9sZE5vZGUubm9kZVR5cGUsXG4gICAgICAgIG9sZENoaWxkcyA9IG9sZE5vZGUuY2hpbGROb2RlcyxcbiAgICAgICAgb2xkQ2hpbGRzTGVuZ3RoID0gb2xkQ2hpbGRzLmxlbmd0aCxcbiAgICAgICAgbmV3Tm9kZSxcbiAgICAgICAgbWV0aG9kID0gTk9ERV9UWVBFX01BUFBJTkdbb2xkTm9kZVR5cGVdLFxuICAgICAgICBpID0gMDtcblxuICAgIG5ld05vZGUgPSBtZXRob2QgJiYgbWV0aG9kKG9sZE5vZGUpO1xuXG4gICAgaWYgKCFuZXdOb2RlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgb2xkQ2hpbGRzTGVuZ3RoOyBpKyspIHtcbiAgICAgIG5ld0NoaWxkID0gX2NvbnZlcnQob2xkQ2hpbGRzW2ldLCBjbGVhblVwKTtcbiAgICAgIGlmIChuZXdDaGlsZCkge1xuICAgICAgICBuZXdOb2RlLmFwcGVuZENoaWxkKG5ld0NoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDbGVhbnVwIHNlbnNlbGVzcyA8c3Bhbj4gZWxlbWVudHNcbiAgICBpZiAoY2xlYW5VcCAmJiBuZXdOb2RlLmNoaWxkTm9kZXMubGVuZ3RoIDw9IDEgJiYgbmV3Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBERUZBVUxUX05PREVfTkFNRSAmJiAhbmV3Tm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIG5ld05vZGUuZmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3Tm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9oYW5kbGVFbGVtZW50KG9sZE5vZGUpIHtcbiAgICB2YXIgcnVsZSxcbiAgICAgICAgbmV3Tm9kZSxcbiAgICAgICAgZW5kVGFnLFxuICAgICAgICB0YWdSdWxlcyA9IGN1cnJlbnRSdWxlcy50YWdzLFxuICAgICAgICBub2RlTmFtZSA9IG9sZE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgc2NvcGVOYW1lID0gb2xkTm9kZS5zY29wZU5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBXZSBhbHJlYWR5IHBhcnNlZCB0aGF0IGVsZW1lbnRcbiAgICAgKiBpZ25vcmUgaXQhICh5ZXMsIHRoaXMgc29tZXRpbWVzIGhhcHBlbnMgaW4gSUU4IHdoZW4gdGhlIGh0bWwgaXMgaW52YWxpZClcbiAgICAgKi9cbiAgICBpZiAob2xkTm9kZS5fd3lzaWh0bWw1KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgb2xkTm9kZS5fd3lzaWh0bWw1ID0gMTtcblxuICAgIGlmIChvbGROb2RlLmNsYXNzTmFtZSA9PT0gXCJ3eXNpaHRtbDUtdGVtcFwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJRSBpcyB0aGUgb25seSBicm93c2VyIHdobyBkb2Vzbid0IGluY2x1ZGUgdGhlIG5hbWVzcGFjZSBpbiB0aGVcbiAgICAgKiBub2RlTmFtZSwgdGhhdCdzIHdoeSB3ZSBoYXZlIHRvIHByZXBlbmQgaXQgYnkgb3Vyc2VsdmVzXG4gICAgICogc2NvcGVOYW1lIGlzIGEgcHJvcHJpZXRhcnkgSUUgZmVhdHVyZVxuICAgICAqIHJlYWQgbW9yZSBoZXJlIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNDM4OCh2PXZzLjg1KS5hc3B4XG4gICAgICovXG4gICAgaWYgKHNjb3BlTmFtZSAmJiBzY29wZU5hbWUgIT0gXCJIVE1MXCIpIHtcbiAgICAgIG5vZGVOYW1lID0gc2NvcGVOYW1lICsgXCI6XCIgKyBub2RlTmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBhaXIgbm9kZVxuICAgICAqIElFIGlzIGEgYml0IGJpdGNoeSB3aGVuIGl0IGNvbWVzIHRvIGludmFsaWQgbmVzdGVkIG1hcmt1cCB3aGljaCBpbmNsdWRlcyB1bmNsb3NlZCB0YWdzXG4gICAgICogQSA8cD4gZG9lc24ndCBuZWVkIHRvIGJlIGNsb3NlZCBhY2NvcmRpbmcgSFRNTDQtNSBzcGVjLCB3ZSBzaW1wbHkgcmVwbGFjZSBpdCB3aXRoIGEgPGRpdj4gdG8gcHJlc2VydmUgaXRzIGNvbnRlbnQgYW5kIGxheW91dFxuICAgICAqL1xuICAgIGlmIChcIm91dGVySFRNTFwiIGluIG9sZE5vZGUpIHtcbiAgICAgIGlmICghd3lzaWh0bWw1LmJyb3dzZXIuYXV0b0Nsb3Nlc1VuY2xvc2VkVGFncygpICYmIG9sZE5vZGUubm9kZU5hbWUgPT09IFwiUFwiICYmIG9sZE5vZGUub3V0ZXJIVE1MLnNsaWNlKC00KS50b0xvd2VyQ2FzZSgpICE9PSBcIjwvcD5cIikge1xuICAgICAgICBub2RlTmFtZSA9IFwiZGl2XCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGVOYW1lIGluIHRhZ1J1bGVzKSB7XG4gICAgICBydWxlID0gdGFnUnVsZXNbbm9kZU5hbWVdO1xuICAgICAgaWYgKCFydWxlIHx8IHJ1bGUucmVtb3ZlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBydWxlID0gdHlwZW9mIHJ1bGUgPT09IFwic3RyaW5nXCIgPyB7IHJlbmFtZV90YWc6IHJ1bGUgfSA6IHJ1bGU7XG4gICAgfSBlbHNlIGlmIChvbGROb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIHJ1bGUgPSB7IHJlbmFtZV90YWc6IERFRkFVTFRfTk9ERV9OQU1FIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZSBlbXB0eSB1bmtub3duIGVsZW1lbnRzXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBuZXdOb2RlID0gb2xkTm9kZS5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocnVsZS5yZW5hbWVfdGFnIHx8IG5vZGVOYW1lKTtcbiAgICBfaGFuZGxlQXR0cmlidXRlcyhvbGROb2RlLCBuZXdOb2RlLCBydWxlKTtcblxuICAgIG9sZE5vZGUgPSBudWxsO1xuICAgIHJldHVybiBuZXdOb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gX2hhbmRsZUF0dHJpYnV0ZXMob2xkTm9kZSwgbmV3Tm9kZSwgcnVsZSkge1xuICAgIHZhciBhdHRyaWJ1dGVzID0ge30sXG4gICAgICAgIC8vIGZyZXNoIG5ldyBzZXQgb2YgYXR0cmlidXRlcyB0byBzZXQgb24gbmV3Tm9kZVxuICAgIHNldENsYXNzID0gcnVsZS5zZXRfY2xhc3MsXG4gICAgICAgIC8vIGNsYXNzZXMgdG8gc2V0XG4gICAgYWRkQ2xhc3MgPSBydWxlLmFkZF9jbGFzcyxcbiAgICAgICAgLy8gYWRkIGNsYXNzZXMgYmFzZWQgb24gZXhpc3RpbmcgYXR0cmlidXRlc1xuICAgIHNldEF0dHJpYnV0ZXMgPSBydWxlLnNldF9hdHRyaWJ1dGVzLFxuICAgICAgICAvLyBhdHRyaWJ1dGVzIHRvIHNldCBvbiB0aGUgY3VycmVudCBub2RlXG4gICAgY2hlY2tBdHRyaWJ1dGVzID0gcnVsZS5jaGVja19hdHRyaWJ1dGVzLFxuICAgICAgICAvLyBjaGVjay9jb252ZXJ0IHZhbHVlcyBvZiBhdHRyaWJ1dGVzXG4gICAgYWxsb3dlZENsYXNzZXMgPSBjdXJyZW50UnVsZXMuY2xhc3NlcyxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGNsYXNzZXMgPSBbXSxcbiAgICAgICAgbmV3Q2xhc3NlcyA9IFtdLFxuICAgICAgICBuZXdVbmlxdWVDbGFzc2VzID0gW10sXG4gICAgICAgIG9sZENsYXNzZXMgPSBbXSxcbiAgICAgICAgY2xhc3Nlc0xlbmd0aCxcbiAgICAgICAgbmV3Q2xhc3Nlc0xlbmd0aCxcbiAgICAgICAgY3VycmVudENsYXNzLFxuICAgICAgICBuZXdDbGFzcyxcbiAgICAgICAgYXR0cmlidXRlTmFtZSxcbiAgICAgICAgbmV3QXR0cmlidXRlVmFsdWUsXG4gICAgICAgIG1ldGhvZDtcblxuICAgIGlmIChzZXRBdHRyaWJ1dGVzKSB7XG4gICAgICBhdHRyaWJ1dGVzID0gd3lzaWh0bWw1Lmxhbmcub2JqZWN0KHNldEF0dHJpYnV0ZXMpLmNsb25lKCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQXR0cmlidXRlcykge1xuICAgICAgZm9yIChhdHRyaWJ1dGVOYW1lIGluIGNoZWNrQXR0cmlidXRlcykge1xuICAgICAgICBtZXRob2QgPSBhdHRyaWJ1dGVDaGVja01ldGhvZHNbY2hlY2tBdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdXTtcbiAgICAgICAgaWYgKCFtZXRob2QpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBuZXdBdHRyaWJ1dGVWYWx1ZSA9IG1ldGhvZChfZ2V0QXR0cmlidXRlKG9sZE5vZGUsIGF0dHJpYnV0ZU5hbWUpKTtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdBdHRyaWJ1dGVWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV0gPSBuZXdBdHRyaWJ1dGVWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZXRDbGFzcykge1xuICAgICAgY2xhc3Nlcy5wdXNoKHNldENsYXNzKTtcbiAgICB9XG5cbiAgICBpZiAoYWRkQ2xhc3MpIHtcbiAgICAgIGZvciAoYXR0cmlidXRlTmFtZSBpbiBhZGRDbGFzcykge1xuICAgICAgICBtZXRob2QgPSBhZGRDbGFzc01ldGhvZHNbYWRkQ2xhc3NbYXR0cmlidXRlTmFtZV1dO1xuICAgICAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG5ld0NsYXNzID0gbWV0aG9kKF9nZXRBdHRyaWJ1dGUob2xkTm9kZSwgYXR0cmlidXRlTmFtZSkpO1xuICAgICAgICBpZiAodHlwZW9mIG5ld0NsYXNzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgY2xhc3Nlcy5wdXNoKG5ld0NsYXNzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHd5c2lodG1sNSB0ZW1wIGNsYXNzIGRvZXNuJ3QgZ2V0IHN0cmlwcGVkIG91dFxuICAgIGFsbG93ZWRDbGFzc2VzW1wiX3d5c2lodG1sNS10ZW1wLXBsYWNlaG9sZGVyXCJdID0gMTtcblxuICAgIC8vIGFkZCBvbGQgY2xhc3NlcyBsYXN0XG4gICAgb2xkQ2xhc3NlcyA9IG9sZE5vZGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7XG4gICAgaWYgKG9sZENsYXNzZXMpIHtcbiAgICAgIGNsYXNzZXMgPSBjbGFzc2VzLmNvbmNhdChvbGRDbGFzc2VzLnNwbGl0KFdISVRFX1NQQUNFX1JFR19FWFApKTtcbiAgICB9XG4gICAgY2xhc3Nlc0xlbmd0aCA9IGNsYXNzZXMubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgY2xhc3Nlc0xlbmd0aDsgaSsrKSB7XG4gICAgICBjdXJyZW50Q2xhc3MgPSBjbGFzc2VzW2ldO1xuICAgICAgaWYgKGFsbG93ZWRDbGFzc2VzW2N1cnJlbnRDbGFzc10pIHtcbiAgICAgICAgbmV3Q2xhc3Nlcy5wdXNoKGN1cnJlbnRDbGFzcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGR1cGxpY2F0ZSBlbnRyaWVzIGFuZCBwcmVzZXJ2ZSBjbGFzcyBzcGVjaWZpY2l0eVxuICAgIG5ld0NsYXNzZXNMZW5ndGggPSBuZXdDbGFzc2VzLmxlbmd0aDtcbiAgICB3aGlsZSAobmV3Q2xhc3Nlc0xlbmd0aC0tKSB7XG4gICAgICBjdXJyZW50Q2xhc3MgPSBuZXdDbGFzc2VzW25ld0NsYXNzZXNMZW5ndGhdO1xuICAgICAgaWYgKCF3eXNpaHRtbDUubGFuZy5hcnJheShuZXdVbmlxdWVDbGFzc2VzKS5jb250YWlucyhjdXJyZW50Q2xhc3MpKSB7XG4gICAgICAgIG5ld1VuaXF1ZUNsYXNzZXMudW5zaGlmdChjdXJyZW50Q2xhc3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZXdVbmlxdWVDbGFzc2VzLmxlbmd0aCkge1xuICAgICAgYXR0cmlidXRlc1tcImNsYXNzXCJdID0gbmV3VW5pcXVlQ2xhc3Nlcy5qb2luKFwiIFwiKTtcbiAgICB9XG5cbiAgICAvLyBzZXQgYXR0cmlidXRlcyBvbiBuZXdOb2RlXG4gICAgZm9yIChhdHRyaWJ1dGVOYW1lIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIC8vIFNldHRpbmcgYXR0cmlidXRlcyBjYW4gY2F1c2UgYSBqcyBlcnJvciBpbiBJRSB1bmRlciBjZXJ0YWluIGNpcmN1bXN0YW5jZXNcbiAgICAgIC8vIGVnLiBvbiBhIDxpbWc+IHVuZGVyIGh0dHBzIHdoZW4gaXQncyBuZXcgYXR0cmlidXRlIHZhbHVlIGlzIG5vbi1odHRwc1xuICAgICAgLy8gVE9ETzogSW52ZXN0aWdhdGUgdGhpcyBmdXJ0aGVyIGFuZCBjaGVjayBmb3Igc21hcnRlciBoYW5kbGluZ1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3Tm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIC8vIElFOCBzb21ldGltZXMgbG9zZXMgdGhlIHdpZHRoL2hlaWdodCBhdHRyaWJ1dGVzIHdoZW4gdGhvc2UgYXJlIHNldCBiZWZvcmUgdGhlIFwic3JjXCJcbiAgICAvLyBzbyB3ZSBtYWtlIHN1cmUgdG8gc2V0IHRoZW0gYWdhaW5cbiAgICBpZiAoYXR0cmlidXRlcy5zcmMpIHtcbiAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy53aWR0aCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBuZXdOb2RlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIGF0dHJpYnV0ZXMud2lkdGgpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLmhlaWdodCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBuZXdOb2RlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBhdHRyaWJ1dGVzLmhlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElFIGdpdmVzIHdyb25nIHJlc3VsdHMgZm9yIGhhc0F0dHJpYnV0ZS9nZXRBdHRyaWJ1dGUsIGZvciBleGFtcGxlOlxuICAgKiAgICB2YXIgdGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG4gICAqICAgIHRkLmdldEF0dHJpYnV0ZShcInJvd3NwYW5cIik7IC8vID0+IFwiMVwiIGluIElFXG4gICAqXG4gICAqIFRoZXJlZm9yZSB3ZSBoYXZlIHRvIGNoZWNrIHRoZSBlbGVtZW50J3Mgb3V0ZXJIVE1MIGZvciB0aGUgYXR0cmlidXRlXG4gICAqL1xuICB2YXIgSEFTX0dFVF9BVFRSSUJVVEVfQlVHID0gIXd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzR2V0QXR0cmlidXRlQ29ycmVjdGx5KCk7XG4gIGZ1bmN0aW9uIF9nZXRBdHRyaWJ1dGUobm9kZSwgYXR0cmlidXRlTmFtZSkge1xuICAgIGF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZTtcbiAgICBpZiAobm9kZU5hbWUgPT0gXCJJTUdcIiAmJiBhdHRyaWJ1dGVOYW1lID09IFwic3JjXCIgJiYgX2lzTG9hZGVkSW1hZ2Uobm9kZSkgPT09IHRydWUpIHtcbiAgICAgIC8vIEdldCAnc3JjJyBhdHRyaWJ1dGUgdmFsdWUgdmlhIG9iamVjdCBwcm9wZXJ0eSBzaW5jZSB0aGlzIHdpbGwgYWx3YXlzIGNvbnRhaW4gdGhlXG4gICAgICAvLyBmdWxsIGFic29sdXRlIHVybCAoaHR0cDovLy4uLilcbiAgICAgIC8vIHRoaXMgZml4ZXMgYSB2ZXJ5IGFubm95aW5nIGJ1ZyBpbiBmaXJlZm94ICh2ZXIgMy42ICYgNCkgYW5kIElFIDggd2hlcmUgaW1hZ2VzIGNvcGllZCBmcm9tIHRoZSBzYW1lIGhvc3RcbiAgICAgIC8vIHdpbGwgaGF2ZSByZWxhdGl2ZSBwYXRocywgd2hpY2ggdGhlIHNhbml0aXplciBzdHJpcHMgb3V0IChzZWUgYXR0cmlidXRlQ2hlY2tNZXRob2RzLnVybClcbiAgICAgIHJldHVybiBub2RlLnNyYztcbiAgICB9IGVsc2UgaWYgKEhBU19HRVRfQVRUUklCVVRFX0JVRyAmJiBcIm91dGVySFRNTFwiIGluIG5vZGUpIHtcbiAgICAgIC8vIERvbid0IHRydXN0IGdldEF0dHJpYnV0ZS9oYXNBdHRyaWJ1dGUgaW4gSUUgNi04LCBpbnN0ZWFkIGNoZWNrIHRoZSBlbGVtZW50J3Mgb3V0ZXJIVE1MXG4gICAgICB2YXIgb3V0ZXJIVE1MID0gbm9kZS5vdXRlckhUTUwudG9Mb3dlckNhc2UoKSxcblxuICAgICAgLy8gVE9ETzogVGhpcyBtaWdodCBub3Qgd29yayBmb3IgYXR0cmlidXRlcyB3aXRob3V0IHZhbHVlOiA8aW5wdXQgZGlzYWJsZWQ+XG4gICAgICBoYXNBdHRyaWJ1dGUgPSBvdXRlckhUTUwuaW5kZXhPZihcIiBcIiArIGF0dHJpYnV0ZU5hbWUgKyBcIj1cIikgIT0gLTE7XG5cbiAgICAgIHJldHVybiBoYXNBdHRyaWJ1dGUgPyBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gbm9kZSBpcyBhIHByb3BlciBsb2FkZWQgaW1hZ2VcbiAgICogRklYTUU6IFJldHVybnMgdW5kZWZpbmVkIHdoZW4gdW5rbm93biAoQ2hyb21lLCBTYWZhcmkpXG4gICAqL1xuICBmdW5jdGlvbiBfaXNMb2FkZWRJbWFnZShub2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBub2RlLmNvbXBsZXRlICYmICFub2RlLm1vek1hdGNoZXNTZWxlY3RvcihcIjotbW96LWJyb2tlblwiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAobm9kZS5jb21wbGV0ZSAmJiBub2RlLnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfaGFuZGxlVGV4dChvbGROb2RlKSB7XG4gICAgcmV0dXJuIG9sZE5vZGUub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShvbGROb2RlLmRhdGEpO1xuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tIGF0dHJpYnV0ZSBjaGVja3MgLS0tLS0tLS0tLS0tIFxcXFxcbiAgdmFyIGF0dHJpYnV0ZUNoZWNrTWV0aG9kcyA9IHtcbiAgICB1cmw6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBSRUdfRVhQID0gL15odHRwcz86XFwvXFwvL2k7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgIGlmICghYXR0cmlidXRlVmFsdWUgfHwgIWF0dHJpYnV0ZVZhbHVlLm1hdGNoKFJFR19FWFApKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlLnJlcGxhY2UoUkVHX0VYUCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KCksXG5cbiAgICBhbHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBSRUdfRVhQID0gL1teIGEtejAtOV9cXC1dL2dpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICBpZiAoIWF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlLnJlcGxhY2UoUkVHX0VYUCwgXCJcIik7XG4gICAgICB9O1xuICAgIH0oKSxcblxuICAgIG51bWJlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBSRUdfRVhQID0gL1xcRC9nO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICBhdHRyaWJ1dGVWYWx1ZSA9IChhdHRyaWJ1dGVWYWx1ZSB8fCBcIlwiKS5yZXBsYWNlKFJFR19FWFAsIFwiXCIpO1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWUgfHwgbnVsbDtcbiAgICAgIH07XG4gICAgfSgpXG4gIH07XG5cbiAgLy8gLS0tLS0tLS0tLS0tIGNsYXNzIGNvbnZlcnRlciAoY29udmVydHMgYW4gaHRtbCBhdHRyaWJ1dGUgdG8gYSBjbGFzcyBuYW1lKSAtLS0tLS0tLS0tLS0gXFxcXFxuICB2YXIgYWRkQ2xhc3NNZXRob2RzID0ge1xuICAgIGFsaWduX2ltZzogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgIGxlZnQ6IFwid3lzaXd5Zy1mbG9hdC1sZWZ0XCIsXG4gICAgICAgIHJpZ2h0OiBcInd5c2l3eWctZmxvYXQtcmlnaHRcIlxuICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1hcHBpbmdbU3RyaW5nKGF0dHJpYnV0ZVZhbHVlKS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIH07XG4gICAgfSgpLFxuXG4gICAgYWxpZ25fdGV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgIGxlZnQ6IFwid3lzaXd5Zy10ZXh0LWFsaWduLWxlZnRcIixcbiAgICAgICAgcmlnaHQ6IFwid3lzaXd5Zy10ZXh0LWFsaWduLXJpZ2h0XCIsXG4gICAgICAgIGNlbnRlcjogXCJ3eXNpd3lnLXRleHQtYWxpZ24tY2VudGVyXCIsXG4gICAgICAgIGp1c3RpZnk6IFwid3lzaXd5Zy10ZXh0LWFsaWduLWp1c3RpZnlcIlxuICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1hcHBpbmdbU3RyaW5nKGF0dHJpYnV0ZVZhbHVlKS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIH07XG4gICAgfSgpLFxuXG4gICAgY2xlYXJfYnI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBtYXBwaW5nID0ge1xuICAgICAgICBsZWZ0OiBcInd5c2l3eWctY2xlYXItbGVmdFwiLFxuICAgICAgICByaWdodDogXCJ3eXNpd3lnLWNsZWFyLXJpZ2h0XCIsXG4gICAgICAgIGJvdGg6IFwid3lzaXd5Zy1jbGVhci1ib3RoXCIsXG4gICAgICAgIGFsbDogXCJ3eXNpd3lnLWNsZWFyLWJvdGhcIlxuICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1hcHBpbmdbU3RyaW5nKGF0dHJpYnV0ZVZhbHVlKS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIH07XG4gICAgfSgpLFxuXG4gICAgc2l6ZV9mb250OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICAgXCIxXCI6IFwid3lzaXd5Zy1mb250LXNpemUteHgtc21hbGxcIixcbiAgICAgICAgXCIyXCI6IFwid3lzaXd5Zy1mb250LXNpemUtc21hbGxcIixcbiAgICAgICAgXCIzXCI6IFwid3lzaXd5Zy1mb250LXNpemUtbWVkaXVtXCIsXG4gICAgICAgIFwiNFwiOiBcInd5c2l3eWctZm9udC1zaXplLWxhcmdlXCIsXG4gICAgICAgIFwiNVwiOiBcInd5c2l3eWctZm9udC1zaXplLXgtbGFyZ2VcIixcbiAgICAgICAgXCI2XCI6IFwid3lzaXd5Zy1mb250LXNpemUteHgtbGFyZ2VcIixcbiAgICAgICAgXCI3XCI6IFwid3lzaXd5Zy1mb250LXNpemUteHgtbGFyZ2VcIixcbiAgICAgICAgXCItXCI6IFwid3lzaXd5Zy1mb250LXNpemUtc21hbGxlclwiLFxuICAgICAgICBcIitcIjogXCJ3eXNpd3lnLWZvbnQtc2l6ZS1sYXJnZXJcIlxuICAgICAgfTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYXR0cmlidXRlVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG1hcHBpbmdbU3RyaW5nKGF0dHJpYnV0ZVZhbHVlKS5jaGFyQXQoMCldO1xuICAgICAgfTtcbiAgICB9KClcbiAgfTtcblxuICByZXR1cm4gcGFyc2U7XG59KCk7IC8qKlxuICAgICAqIENoZWNrcyBmb3IgZW1wdHkgdGV4dCBub2RlIGNoaWxkcyBhbmQgcmVtb3ZlcyB0aGVtXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgVGhlIGVsZW1lbnQgaW4gd2hpY2ggdG8gY2xlYW51cFxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgd3lzaWh0bWw1LmRvbS5yZW1vdmVFbXB0eVRleHROb2RlcyhlbGVtZW50KTtcbiAgICAgKi9cbnd5c2lodG1sNS5kb20ucmVtb3ZlRW1wdHlUZXh0Tm9kZXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICB2YXIgY2hpbGROb2RlLFxuICAgICAgY2hpbGROb2RlcyA9IHd5c2lodG1sNS5sYW5nLmFycmF5KG5vZGUuY2hpbGROb2RlcykuZ2V0KCksXG4gICAgICBjaGlsZE5vZGVzTGVuZ3RoID0gY2hpbGROb2Rlcy5sZW5ndGgsXG4gICAgICBpID0gMDtcbiAgZm9yICg7IGkgPCBjaGlsZE5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGVzW2ldO1xuICAgIGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IHd5c2lodG1sNS5URVhUX05PREUgJiYgY2hpbGROb2RlLmRhdGEgPT09IFwiXCIpIHtcbiAgICAgIGNoaWxkTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZSk7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBSZW5hbWVzIGFuIGVsZW1lbnQgKGVnLiBhIDxkaXY+IHRvIGEgPHA+KSBhbmQga2VlcHMgaXRzIGNoaWxkc1xuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBUaGUgbGlzdCBlbGVtZW50IHdoaWNoIHNob3VsZCBiZSByZW5hbWVkXG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5ld05vZGVOYW1lIFRoZSBkZXNpcmVkIHRhZyBuYW1lXG4gKlxuICogQGV4YW1wbGVcbiAqICAgIDwhLS0gQXNzdW1lIHRoZSBmb2xsb3dpbmcgZG9tOiAtLT5cbiAqICAgIDx1bCBpZD1cImxpc3RcIj5cbiAqICAgICAgPGxpPmVtaW5lbTwvbGk+XG4gKiAgICAgIDxsaT5kci4gZHJlPC9saT5cbiAqICAgICAgPGxpPjUwIENlbnQ8L2xpPlxuICogICAgPC91bD5cbiAqXG4gKiAgICA8c2NyaXB0PlxuICogICAgICB3eXNpaHRtbDUuZG9tLnJlbmFtZUVsZW1lbnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJsaXN0XCIpLCBcIm9sXCIpO1xuICogICAgPC9zY3JpcHQ+XG4gKlxuICogICAgPCEtLSBXaWxsIHJlc3VsdCBpbjogLS0+XG4gKiAgICA8b2w+XG4gKiAgICAgIDxsaT5lbWluZW08L2xpPlxuICogICAgICA8bGk+ZHIuIGRyZTwvbGk+XG4gKiAgICAgIDxsaT41MCBDZW50PC9saT5cbiAqICAgIDwvb2w+XG4gKi9cbnd5c2lodG1sNS5kb20ucmVuYW1lRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCBuZXdOb2RlTmFtZSkge1xuICB2YXIgbmV3RWxlbWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KG5ld05vZGVOYW1lKSxcbiAgICAgIGZpcnN0Q2hpbGQ7XG4gIHdoaWxlIChmaXJzdENoaWxkID0gZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgbmV3RWxlbWVudC5hcHBlbmRDaGlsZChmaXJzdENoaWxkKTtcbiAgfVxuICB3eXNpaHRtbDUuZG9tLmNvcHlBdHRyaWJ1dGVzKFtcImFsaWduXCIsIFwiY2xhc3NOYW1lXCJdKS5mcm9tKGVsZW1lbnQpLnRvKG5ld0VsZW1lbnQpO1xuICBlbGVtZW50LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5ld0VsZW1lbnQsIGVsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn07IC8qKlxuICAgKiBUYWtlcyBhbiBlbGVtZW50LCByZW1vdmVzIGl0IGFuZCByZXBsYWNlcyBpdCB3aXRoIGl0J3MgY2hpbGRzXG4gICAqIFxuICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBUaGUgbm9kZSB3aGljaCB0byByZXBsYWNlIHdpdGggaXQncyBjaGlsZCBub2Rlc1xuICAgKiBAZXhhbXBsZVxuICAgKiAgICA8ZGl2IGlkPVwiZm9vXCI+XG4gICAqICAgICAgPHNwYW4+aGVsbG88L3NwYW4+XG4gICAqICAgIDwvZGl2PlxuICAgKiAgICA8c2NyaXB0PlxuICAgKiAgICAgIC8vIFJlbW92ZSAjZm9vIGFuZCByZXBsYWNlIHdpdGggaXQncyBjaGlsZHJlblxuICAgKiAgICAgIHd5c2lodG1sNS5kb20ucmVwbGFjZVdpdGhDaGlsZE5vZGVzKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZm9vXCIpKTtcbiAgICogICAgPC9zY3JpcHQ+XG4gICAqL1xud3lzaWh0bWw1LmRvbS5yZXBsYWNlV2l0aENoaWxkTm9kZXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAoIW5vZGUucGFyZW50Tm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghbm9kZS5maXJzdENoaWxkKSB7XG4gICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBmcmFnbWVudCA9IG5vZGUub3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICB9XG4gIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZnJhZ21lbnQsIG5vZGUpO1xuICBub2RlID0gZnJhZ21lbnQgPSBudWxsO1xufTtcbi8qKlxuICogVW53cmFwcyBhbiB1bm9yZGVyZWQvb3JkZXJlZCBsaXN0XG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBsaXN0IGVsZW1lbnQgd2hpY2ggc2hvdWxkIGJlIHVud3JhcHBlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAgICA8IS0tIEFzc3VtZSB0aGUgZm9sbG93aW5nIGRvbTogLS0+XG4gKiAgICA8dWwgaWQ9XCJsaXN0XCI+XG4gKiAgICAgIDxsaT5lbWluZW08L2xpPlxuICogICAgICA8bGk+ZHIuIGRyZTwvbGk+XG4gKiAgICAgIDxsaT41MCBDZW50PC9saT5cbiAqICAgIDwvdWw+XG4gKlxuICogICAgPHNjcmlwdD5cbiAqICAgICAgd3lzaWh0bWw1LmRvbS5yZXNvbHZlTGlzdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImxpc3RcIikpO1xuICogICAgPC9zY3JpcHQ+XG4gKlxuICogICAgPCEtLSBXaWxsIHJlc3VsdCBpbjogLS0+XG4gKiAgICBlbWluZW08YnI+XG4gKiAgICBkci4gZHJlPGJyPlxuICogICAgNTAgQ2VudDxicj5cbiAqL1xuKGZ1bmN0aW9uIChkb20pIHtcbiAgZnVuY3Rpb24gX2lzQmxvY2tFbGVtZW50KG5vZGUpIHtcbiAgICByZXR1cm4gZG9tLmdldFN0eWxlKFwiZGlzcGxheVwiKS5mcm9tKG5vZGUpID09PSBcImJsb2NrXCI7XG4gIH1cblxuICBmdW5jdGlvbiBfaXNMaW5lQnJlYWsobm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVOYW1lID09PSBcIkJSXCI7XG4gIH1cblxuICBmdW5jdGlvbiBfYXBwZW5kTGluZUJyZWFrKGVsZW1lbnQpIHtcbiAgICB2YXIgbGluZUJyZWFrID0gZWxlbWVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKGxpbmVCcmVhayk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlTGlzdChsaXN0KSB7XG4gICAgaWYgKGxpc3Qubm9kZU5hbWUgIT09IFwiTUVOVVwiICYmIGxpc3Qubm9kZU5hbWUgIT09IFwiVUxcIiAmJiBsaXN0Lm5vZGVOYW1lICE9PSBcIk9MXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZG9jID0gbGlzdC5vd25lckRvY3VtZW50LFxuICAgICAgICBmcmFnbWVudCA9IGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG4gICAgICAgIHByZXZpb3VzU2libGluZyA9IGxpc3QucHJldmlvdXNFbGVtZW50U2libGluZyB8fCBsaXN0LnByZXZpb3VzU2libGluZyxcbiAgICAgICAgZmlyc3RDaGlsZCxcbiAgICAgICAgbGFzdENoaWxkLFxuICAgICAgICBpc0xhc3RDaGlsZCxcbiAgICAgICAgc2hvdWxkQXBwZW5kTGluZUJyZWFrLFxuICAgICAgICBsaXN0SXRlbTtcblxuICAgIGlmIChwcmV2aW91c1NpYmxpbmcgJiYgIV9pc0Jsb2NrRWxlbWVudChwcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICBfYXBwZW5kTGluZUJyZWFrKGZyYWdtZW50KTtcbiAgICB9XG5cbiAgICB3aGlsZSAobGlzdEl0ZW0gPSBsaXN0LmZpcnN0Q2hpbGQpIHtcbiAgICAgIGxhc3RDaGlsZCA9IGxpc3RJdGVtLmxhc3RDaGlsZDtcbiAgICAgIHdoaWxlIChmaXJzdENoaWxkID0gbGlzdEl0ZW0uZmlyc3RDaGlsZCkge1xuICAgICAgICBpc0xhc3RDaGlsZCA9IGZpcnN0Q2hpbGQgPT09IGxhc3RDaGlsZDtcbiAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkb25lIGJlZm9yZSBhcHBlbmRpbmcgaXQgdG8gdGhlIGZyYWdtZW50LCBhcyBpdCBvdGhlcndpc2Ugd2lsbCBsb29zZSBzdHlsZSBpbmZvcm1hdGlvblxuICAgICAgICBzaG91bGRBcHBlbmRMaW5lQnJlYWsgPSBpc0xhc3RDaGlsZCAmJiAhX2lzQmxvY2tFbGVtZW50KGZpcnN0Q2hpbGQpICYmICFfaXNMaW5lQnJlYWsoZmlyc3RDaGlsZCk7XG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGZpcnN0Q2hpbGQpO1xuICAgICAgICBpZiAoc2hvdWxkQXBwZW5kTGluZUJyZWFrKSB7XG4gICAgICAgICAgX2FwcGVuZExpbmVCcmVhayhmcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGlzdEl0ZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaXN0SXRlbSk7XG4gICAgfVxuICAgIGxpc3QucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZnJhZ21lbnQsIGxpc3QpO1xuICB9XG5cbiAgZG9tLnJlc29sdmVMaXN0ID0gcmVzb2x2ZUxpc3Q7XG59KSh3eXNpaHRtbDUuZG9tKTsgLyoqXG4gICAgICAgICAgICAgICAgICAgKiBTYW5kYm94IGZvciBleGVjdXRpbmcgamF2YXNjcmlwdCwgcGFyc2luZyBjc3Mgc3R5bGVzIGFuZCBkb2luZyBkb20gb3BlcmF0aW9ucyBpbiBhIHNlY3VyZSB3YXlcbiAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgKiBCcm93c2VyIENvbXBhdGliaWxpdHk6XG4gICAgICAgICAgICAgICAgICAgKiAgLSBTZWN1cmUgaW4gTVNJRSA2KywgYnV0IG9ubHkgd2hlbiB0aGUgdXNlciBoYXNuJ3QgbWFkZSBjaGFuZ2VzIHRvIGhpcyBzZWN1cml0eSBsZXZlbCBcInJlc3RyaWN0ZWRcIlxuICAgICAgICAgICAgICAgICAgICogIC0gUGFydGlhbGx5IHNlY3VyZSBpbiBvdGhlciBicm93c2VycyAoRmlyZWZveCwgT3BlcmEsIFNhZmFyaSwgQ2hyb21lLCAuLi4pXG4gICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICogUGxlYXNlIG5vdGUgdGhhdCB0aGlzIGNsYXNzIGNhbid0IGJlbmVmaXQgZnJvbSB0aGUgSFRNTDUgc2FuZGJveCBhdHRyaWJ1dGUgZm9yIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcbiAgICAgICAgICAgICAgICAgICAqICAgIC0gc2FuZGJveGluZyBkb2Vzbid0IHdvcmsgY29ycmVjdGx5IHdpdGggaW5saW5lZCBjb250ZW50IChzcmM9XCJqYXZhc2NyaXB0Oic8aHRtbD4uLi48L2h0bWw+J1wiKVxuICAgICAgICAgICAgICAgICAgICogICAgLSBzYW5kYm94aW5nIG9mIHBoeXNpY2FsIGRvY3VtZW50cyBjYXVzZXMgdGhhdCB0aGUgZG9tIGlzbid0IGFjY2Vzc2libGUgYW55bW9yZSBmcm9tIHRoZSBvdXRzaWRlIChpZnJhbWUuY29udGVudFdpbmRvdywgLi4uKVxuICAgICAgICAgICAgICAgICAgICogICAgLSBzZXR0aW5nIHRoZSBcImFsbG93LXNhbWUtb3JpZ2luXCIgZmxhZyB3b3VsZCBmaXggdGhhdCwgYnV0IHRoZW4gc3RpbGwgamF2YXNjcmlwdCBhbmQgZG9tIGV2ZW50cyByZWZ1c2UgdG8gZmlyZVxuICAgICAgICAgICAgICAgICAgICogICAgLSB0aGVyZWZvcmUgdGhlIFwiYWxsb3ctc2NyaXB0c1wiIGZsYWcgaXMgbmVlZGVkLCB3aGljaCB0aGVuIHdvdWxkIGRlYWN0aXZhdGUgYW55IHNlY3VyaXR5LCBhcyB0aGUganMgZXhlY3V0ZWQgaW5zaWRlIHRoZSBpZnJhbWVcbiAgICAgICAgICAgICAgICAgICAqICAgICAgY2FuIGRvIGFueXRoaW5nIGFzIGlmIHRoZSBzYW5kYm94IGF0dHJpYnV0ZSB3YXNuJ3Qgc2V0XG4gICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3JlYWR5Q2FsbGJhY2tdIE1ldGhvZCB0aGF0IGdldHMgaW52b2tlZCB3aGVuIHRoZSBzYW5kYm94IGlzIHJlYWR5XG4gICAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgKiAgICBuZXcgd3lzaWh0bWw1LmRvbS5TYW5kYm94KGZ1bmN0aW9uKHNhbmRib3gpIHtcbiAgICAgICAgICAgICAgICAgICAqICAgICAgc2FuZGJveC5nZXRXaW5kb3coKS5kb2N1bWVudC5ib2R5LmlubmVySFRNTCA9ICc8aW1nIHNyYz1mb28uZ2lmIG9uZXJyb3I9XCJhbGVydChkb2N1bWVudC5jb29raWUpXCI+JztcbiAgICAgICAgICAgICAgICAgICAqICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgLyoqXG4gICAgICAgKiBEZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAgICAgICAqL1xuICBkb2MgPSBkb2N1bWVudCxcblxuICAvKipcbiAgICogUHJvcGVydGllcyB0byB1bnNldC9wcm90ZWN0IG9uIHRoZSB3aW5kb3cgb2JqZWN0XG4gICAqL1xuICB3aW5kb3dQcm9wZXJ0aWVzID0gW1wicGFyZW50XCIsIFwidG9wXCIsIFwib3BlbmVyXCIsIFwiZnJhbWVFbGVtZW50XCIsIFwiZnJhbWVzXCIsIFwibG9jYWxTdG9yYWdlXCIsIFwiZ2xvYmFsU3RvcmFnZVwiLCBcInNlc3Npb25TdG9yYWdlXCIsIFwiaW5kZXhlZERCXCJdLFxuXG4gIC8qKlxuICAgKiBQcm9wZXJ0aWVzIG9uIHRoZSB3aW5kb3cgb2JqZWN0IHdoaWNoIGFyZSBzZXQgdG8gYW4gZW1wdHkgZnVuY3Rpb25cbiAgICovXG4gIHdpbmRvd1Byb3BlcnRpZXMyID0gW1wib3BlblwiLCBcImNsb3NlXCIsIFwib3BlbkRpYWxvZ1wiLCBcInNob3dNb2RhbERpYWxvZ1wiLCBcImFsZXJ0XCIsIFwiY29uZmlybVwiLCBcInByb21wdFwiLCBcIm9wZW5EYXRhYmFzZVwiLCBcInBvc3RNZXNzYWdlXCIsIFwiWE1MSHR0cFJlcXVlc3RcIiwgXCJYRG9tYWluUmVxdWVzdFwiXSxcblxuICAvKipcbiAgICogUHJvcGVydGllcyB0byB1bnNldC9wcm90ZWN0IG9uIHRoZSBkb2N1bWVudCBvYmplY3RcbiAgICovXG4gIGRvY3VtZW50UHJvcGVydGllcyA9IFtcInJlZmVycmVyXCIsIFwid3JpdGVcIiwgXCJvcGVuXCIsIFwiY2xvc2VcIl07XG5cbiAgd3lzaWh0bWw1LmRvbS5TYW5kYm94ID0gQmFzZS5leHRlbmQoXG4gIC8qKiBAc2NvcGUgd3lzaWh0bWw1LmRvbS5TYW5kYm94LnByb3RvdHlwZSAqL3tcblxuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBjb25zdHJ1Y3RvcihyZWFkeUNhbGxiYWNrLCBjb25maWcpIHtcbiAgICAgIHRoaXMuY2FsbGJhY2sgPSByZWFkeUNhbGxiYWNrIHx8IHd5c2lodG1sNS5FTVBUWV9GVU5DVElPTjtcbiAgICAgIHRoaXMuY29uZmlnID0gd3lzaWh0bWw1Lmxhbmcub2JqZWN0KHt9KS5tZXJnZShjb25maWcpLmdldCgpO1xuICAgICAgdGhpcy5pZnJhbWUgPSB0aGlzLl9jcmVhdGVJZnJhbWUoKTtcbiAgICB9LFxuXG4gICAgaW5zZXJ0SW50bzogZnVuY3Rpb24gaW5zZXJ0SW50byhlbGVtZW50KSB7XG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZWxlbWVudCA9IGRvYy5nZXRFbGVtZW50QnlJZChlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmlmcmFtZSk7XG4gICAgfSxcblxuICAgIGdldElmcmFtZTogZnVuY3Rpb24gZ2V0SWZyYW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaWZyYW1lO1xuICAgIH0sXG5cbiAgICBnZXRXaW5kb3c6IGZ1bmN0aW9uIGdldFdpbmRvdygpIHtcbiAgICAgIHRoaXMuX3JlYWR5RXJyb3IoKTtcbiAgICB9LFxuXG4gICAgZ2V0RG9jdW1lbnQ6IGZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xuICAgICAgdGhpcy5fcmVhZHlFcnJvcigpO1xuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdmFyIGlmcmFtZSA9IHRoaXMuZ2V0SWZyYW1lKCk7XG4gICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgIH0sXG5cbiAgICBfcmVhZHlFcnJvcjogZnVuY3Rpb24gX3JlYWR5RXJyb3IoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3eXNpaHRtbDUuU2FuZGJveDogU2FuZGJveCBpZnJhbWUgaXNuJ3QgbG9hZGVkIHlldFwiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgc2FuZGJveCBpZnJhbWVcbiAgICAgKlxuICAgICAqIFNvbWUgaW1wb3J0YW50IG5vdGVzOlxuICAgICAqICAtIFdlIGNhbid0IHVzZSBIVE1MNSBzYW5kYm94IGZvciBub3c6XG4gICAgICogICAgc2V0dGluZyBpdCBjYXVzZXMgdGhhdCB0aGUgaWZyYW1lJ3MgZG9tIGNhbid0IGJlIGFjY2Vzc2VkIGZyb20gdGhlIG91dHNpZGVcbiAgICAgKiAgICBUaGVyZWZvcmUgd2UgbmVlZCB0byBzZXQgdGhlIFwiYWxsb3ctc2FtZS1vcmlnaW5cIiBmbGFnIHdoaWNoIGVuYWJsZXMgYWNjZXNzaW5nIHRoZSBpZnJhbWUncyBkb21cbiAgICAgKiAgICBCdXQgdGhlbiB0aGVyZSdzIGFub3RoZXIgcHJvYmxlbSwgRE9NIGV2ZW50cyAoZm9jdXMsIGJsdXIsIGNoYW5nZSwga2V5cHJlc3MsIC4uLikgYXJlbid0IGZpcmVkLlxuICAgICAqICAgIEluIG9yZGVyIHRvIG1ha2UgdGhpcyBoYXBwZW4gd2UgbmVlZCB0byBzZXQgdGhlIFwiYWxsb3ctc2NyaXB0c1wiIGZsYWcuXG4gICAgICogICAgQSBjb21iaW5hdGlvbiBvZiBhbGxvdy1zY3JpcHRzIGFuZCBhbGxvdy1zYW1lLW9yaWdpbiBpcyBhbG1vc3QgdGhlIHNhbWUgYXMgc2V0dGluZyBubyBzYW5kYm94IGF0dHJpYnV0ZSBhdCBhbGwuXG4gICAgICogIC0gQ2hyb21lICYgU2FmYXJpLCBkb2Vzbid0IHNlZW0gdG8gc3VwcG9ydCBzYW5kYm94aW5nIGNvcnJlY3RseSB3aGVuIHRoZSBpZnJhbWUncyBodG1sIGlzIGlubGluZWQgKG5vIHBoeXNpY2FsIGRvY3VtZW50KVxuICAgICAqICAtIElFIG5lZWRzIHRvIGhhdmUgdGhlIHNlY3VyaXR5PVwicmVzdHJpY3RlZFwiIGF0dHJpYnV0ZSBzZXQgYmVmb3JlIHRoZSBpZnJhbWUgaXMgXG4gICAgICogICAgaW5zZXJ0ZWQgaW50byB0aGUgZG9tIHRyZWVcbiAgICAgKiAgLSBCZWxpZXZlIGl0IG9yIG5vdCBidXQgaW4gSUUgXCJzZWN1cml0eVwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIikgaXMgZmFsc2UsIGV2ZW5cbiAgICAgKiAgICB0aG91Z2ggaXQgc3VwcG9ydHMgaXRcbiAgICAgKiAgLSBXaGVuIGFuIGlmcmFtZSBoYXMgc2VjdXJpdHk9XCJyZXN0cmljdGVkXCIsIGluIElFIGV2YWwoKSAmIGV4ZWNTY3JpcHQoKSBkb24ndCB3b3JrIGFueW1vcmVcbiAgICAgKiAgLSBJRSBkb2Vzbid0IGZpcmUgdGhlIG9ubG9hZCBldmVudCB3aGVuIHRoZSBjb250ZW50IGlzIGlubGluZWQgaW4gdGhlIHNyYyBhdHRyaWJ1dGUsIHRoZXJlZm9yZSB3ZSByZWx5XG4gICAgICogICAgb24gdGhlIG9ucmVhZHlzdGF0ZWNoYW5nZSBldmVudFxuICAgICAqL1xuICAgIF9jcmVhdGVJZnJhbWU6IGZ1bmN0aW9uIF9jcmVhdGVJZnJhbWUoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgaWZyYW1lID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICBpZnJhbWUuY2xhc3NOYW1lID0gXCJ3eXNpaHRtbDUtc2FuZGJveFwiO1xuICAgICAgd3lzaWh0bWw1LmRvbS5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgXCJzZWN1cml0eVwiOiBcInJlc3RyaWN0ZWRcIixcbiAgICAgICAgXCJhbGxvd3RyYW5zcGFyZW5jeVwiOiBcInRydWVcIixcbiAgICAgICAgXCJmcmFtZWJvcmRlclwiOiAwLFxuICAgICAgICBcIndpZHRoXCI6IDAsXG4gICAgICAgIFwiaGVpZ2h0XCI6IDAsXG4gICAgICAgIFwibWFyZ2lud2lkdGhcIjogMCxcbiAgICAgICAgXCJtYXJnaW5oZWlnaHRcIjogMFxuICAgICAgfSkub24oaWZyYW1lKTtcblxuICAgICAgLy8gU2V0dGluZyB0aGUgc3JjIGxpa2UgdGhpcyBwcmV2ZW50cyBzc2wgd2FybmluZ3MgaW4gSUU2XG4gICAgICBpZiAod3lzaWh0bWw1LmJyb3dzZXIudGhyb3dzTWl4ZWRDb250ZW50V2FybmluZ1doZW5JZnJhbWVTcmNJc0VtcHR5KCkpIHtcbiAgICAgICAgaWZyYW1lLnNyYyA9IFwiamF2YXNjcmlwdDonPGh0bWw+PC9odG1sPidcIjtcbiAgICAgIH1cblxuICAgICAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICB0aGF0Ll9vbkxvYWRJZnJhbWUoaWZyYW1lKTtcbiAgICAgIH07XG5cbiAgICAgIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgvbG9hZGVkfGNvbXBsZXRlLy50ZXN0KGlmcmFtZS5yZWFkeVN0YXRlKSkge1xuICAgICAgICAgIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAgICAgICB0aGF0Ll9vbkxvYWRJZnJhbWUoaWZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGlmcmFtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgZm9yIHdoZW4gdGhlIGlmcmFtZSBoYXMgZmluaXNoZWQgbG9hZGluZ1xuICAgICAqL1xuICAgIF9vbkxvYWRJZnJhbWU6IGZ1bmN0aW9uIF9vbkxvYWRJZnJhbWUoaWZyYW1lKSB7XG4gICAgICAvLyBkb24ndCByZXN1bWUgd2hlbiB0aGUgaWZyYW1lIGdvdCB1bmxvYWRlZCAoZWcuIGJ5IHJlbW92aW5nIGl0IGZyb20gdGhlIGRvbSlcbiAgICAgIGlmICghd3lzaWh0bWw1LmRvbS5jb250YWlucyhkb2MuZG9jdW1lbnRFbGVtZW50LCBpZnJhbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgIGlmcmFtZVdpbmRvdyA9IGlmcmFtZS5jb250ZW50V2luZG93LFxuICAgICAgICAgIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQsXG4gICAgICAgICAgY2hhcnNldCA9IGRvYy5jaGFyYWN0ZXJTZXQgfHwgZG9jLmNoYXJzZXQgfHwgXCJ1dGYtOFwiLFxuICAgICAgICAgIHNhbmRib3hIdG1sID0gdGhpcy5fZ2V0SHRtbCh7XG4gICAgICAgIGNoYXJzZXQ6IGNoYXJzZXQsXG4gICAgICAgIHN0eWxlc2hlZXRzOiB0aGlzLmNvbmZpZy5zdHlsZXNoZWV0c1xuICAgICAgfSk7XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgYmFzaWMgZG9tIHRyZWUgaW5jbHVkaW5nIHByb3BlciBET0NUWVBFIGFuZCBjaGFyc2V0XG4gICAgICBpZnJhbWVEb2N1bWVudC5vcGVuKFwidGV4dC9odG1sXCIsIFwicmVwbGFjZVwiKTtcbiAgICAgIGlmcmFtZURvY3VtZW50LndyaXRlKHNhbmRib3hIdG1sKTtcbiAgICAgIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG5cbiAgICAgIHRoaXMuZ2V0V2luZG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gICAgICB9O1xuICAgICAgdGhpcy5nZXREb2N1bWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICAgICAgfTtcblxuICAgICAgLy8gQ2F0Y2gganMgZXJyb3JzIGFuZCBwYXNzIHRoZW0gdG8gdGhlIHBhcmVudCdzIG9uZXJyb3IgZXZlbnRcbiAgICAgIC8vIGFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiKSBkb2Vzbid0IHdvcmsgcHJvcGVybHkgaW4gc29tZSBicm93c2Vyc1xuICAgICAgLy8gVE9ETzogYXBwYXJlbnRseSB0aGlzIGRvZXNuJ3Qgd29yayBpbiBJRTkhXG4gICAgICBpZnJhbWVXaW5kb3cub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvck1lc3NhZ2UsIGZpbGVOYW1lLCBsaW5lTnVtYmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInd5c2lodG1sNS5TYW5kYm94OiBcIiArIGVycm9yTWVzc2FnZSwgZmlsZU5hbWUsIGxpbmVOdW1iZXIpO1xuICAgICAgfTtcblxuICAgICAgaWYgKCF3eXNpaHRtbDUuYnJvd3Nlci5zdXBwb3J0c1NhbmRib3hlZElmcmFtZXMoKSkge1xuICAgICAgICAvLyBVbnNldCBhIGJ1bmNoIG9mIHNlbnNpdGl2ZSB2YXJpYWJsZXNcbiAgICAgICAgLy8gUGxlYXNlIG5vdGU6IFRoaXMgaXNuJ3QgaGFjayBzYWZlISAgXG4gICAgICAgIC8vIEl0IG1vcmUgb3IgbGVzcyBqdXN0IHRha2VzIGNhcmUgb2YgYmFzaWMgYXR0YWNrcyBhbmQgcHJldmVudHMgYWNjaWRlbnRhbCB0aGVmdCBvZiBzZW5zaXRpdmUgaW5mb3JtYXRpb25cbiAgICAgICAgLy8gSUUgaXMgc2VjdXJlIHRob3VnaCwgd2hpY2ggaXMgdGhlIG1vc3QgaW1wb3J0YW50IHRoaW5nLCBzaW5jZSBJRSBpcyB0aGUgb25seSBicm93c2VyLCB3aG9cbiAgICAgICAgLy8gdGFrZXMgb3ZlciBzY3JpcHRzICYgc3R5bGVzIGludG8gY29udGVudEVkaXRhYmxlIGVsZW1lbnRzIHdoZW4gY29waWVkIGZyb20gZXh0ZXJuYWwgd2Vic2l0ZXNcbiAgICAgICAgLy8gb3IgYXBwbGljYXRpb25zIChNaWNyb3NvZnQgV29yZCwgLi4uKVxuICAgICAgICB2YXIgaSwgbGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSB3aW5kb3dQcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5fdW5zZXQoaWZyYW1lV2luZG93LCB3aW5kb3dQcm9wZXJ0aWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSB3aW5kb3dQcm9wZXJ0aWVzMi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHRoaXMuX3Vuc2V0KGlmcmFtZVdpbmRvdywgd2luZG93UHJvcGVydGllczJbaV0sIHd5c2lodG1sNS5FTVBUWV9GVU5DVElPTik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gZG9jdW1lbnRQcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5fdW5zZXQoaWZyYW1lRG9jdW1lbnQsIGRvY3VtZW50UHJvcGVydGllc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyBkb2Vzbid0IHdvcmsgaW4gU2FmYXJpIDUgXG4gICAgICAgIC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk5MjQ2MS9pcy1pdC1wb3NzaWJsZS10by1vdmVycmlkZS1kb2N1bWVudC1jb29raWUtaW4td2Via2l0XG4gICAgICAgIHRoaXMuX3Vuc2V0KGlmcmFtZURvY3VtZW50LCBcImNvb2tpZVwiLCBcIlwiLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuXG4gICAgICAvLyBUcmlnZ2VyIHRoZSBjYWxsYmFja1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoYXQuY2FsbGJhY2sodGhhdCk7XG4gICAgICB9LCAwKTtcbiAgICB9LFxuXG4gICAgX2dldEh0bWw6IGZ1bmN0aW9uIF9nZXRIdG1sKHRlbXBsYXRlVmFycykge1xuICAgICAgdmFyIHN0eWxlc2hlZXRzID0gdGVtcGxhdGVWYXJzLnN0eWxlc2hlZXRzLFxuICAgICAgICAgIGh0bWwgPSBcIlwiLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIGxlbmd0aDtcbiAgICAgIHN0eWxlc2hlZXRzID0gdHlwZW9mIHN0eWxlc2hlZXRzID09PSBcInN0cmluZ1wiID8gW3N0eWxlc2hlZXRzXSA6IHN0eWxlc2hlZXRzO1xuICAgICAgaWYgKHN0eWxlc2hlZXRzKSB7XG4gICAgICAgIGxlbmd0aCA9IHN0eWxlc2hlZXRzLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGh0bWwgKz0gJzxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiBocmVmPVwiJyArIHN0eWxlc2hlZXRzW2ldICsgJ1wiPic7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlVmFycy5zdHlsZXNoZWV0cyA9IGh0bWw7XG5cbiAgICAgIHJldHVybiB3eXNpaHRtbDUubGFuZy5zdHJpbmcoJzwhRE9DVFlQRSBodG1sPjxodG1sPjxoZWFkPicgKyAnPG1ldGEgY2hhcnNldD1cIiN7Y2hhcnNldH1cIj4je3N0eWxlc2hlZXRzfTwvaGVhZD4nICsgJzxib2R5PjwvYm9keT48L2h0bWw+JykuaW50ZXJwb2xhdGUodGVtcGxhdGVWYXJzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIHVuc2V0L292ZXJyaWRlIGV4aXN0aW5nIHZhcmlhYmxlc1xuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgLy8gTWFrZSBjb29raWUgdW5yZWFkYWJsZSBhbmQgdW53cml0YWJsZVxuICAgICAqICAgIHRoaXMuX3Vuc2V0KGRvY3VtZW50LCBcImNvb2tpZVwiLCBcIlwiLCB0cnVlKTtcbiAgICAgKi9cbiAgICBfdW5zZXQ6IGZ1bmN0aW9uIF91bnNldChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgc2V0dGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBvYmplY3RbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICB0cnkge1xuICAgICAgICBvYmplY3QuX19kZWZpbmVHZXR0ZXJfXyhwcm9wZXJ0eSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9iamVjdC5fX2RlZmluZVNldHRlcl9fKHByb3BlcnR5LCBmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG5cbiAgICAgIGlmICghd3lzaWh0bWw1LmJyb3dzZXIuY3Jhc2hlc1doZW5EZWZpbmVQcm9wZXJ0eShwcm9wZXJ0eSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChzZXR0ZXIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5zZXQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIGNvbmZpZyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pKHd5c2lodG1sNSk7XG4oZnVuY3Rpb24gKCkge1xuICB2YXIgbWFwcGluZyA9IHtcbiAgICBcImNsYXNzTmFtZVwiOiBcImNsYXNzXCJcbiAgfTtcbiAgd3lzaWh0bWw1LmRvbS5zZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb246IGZ1bmN0aW9uIG9uKGVsZW1lbnQpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobWFwcGluZ1tpXSB8fCBpLCBhdHRyaWJ1dGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH07XG59KSgpO3d5c2lodG1sNS5kb20uc2V0U3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICByZXR1cm4ge1xuICAgIG9uOiBmdW5jdGlvbiBvbihlbGVtZW50KSB7XG4gICAgICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgICAgaWYgKHR5cGVvZiBzdHlsZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3R5bGUuY3NzVGV4dCArPSBcIjtcIiArIHN0eWxlcztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSBpbiBzdHlsZXMpIHtcbiAgICAgICAgaWYgKGkgPT09IFwiZmxvYXRcIikge1xuICAgICAgICAgIHN0eWxlLmNzc0Zsb2F0ID0gc3R5bGVzW2ldO1xuICAgICAgICAgIHN0eWxlLnN0eWxlRmxvYXQgPSBzdHlsZXNbaV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3R5bGVbaV0gPSBzdHlsZXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59OyAvKipcbiAgICogU2ltdWxhdGUgSFRNTDUgcGxhY2Vob2xkZXIgYXR0cmlidXRlXG4gICAqXG4gICAqIE5lZWRlZCBzaW5jZVxuICAgKiAgICAtIGRpdltjb250ZW50RWRpdGFibGVdIGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgaXRcbiAgICogICAgLSBvbGRlciBicm93c2VycyAoc3VjaCBhcyBJRTggYW5kIEZpcmVmb3ggMy42KSBkb24ndCBzdXBwb3J0IGl0IGF0IGFsbFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50IEluc3RhbmNlIG9mIG1haW4gd3lzaWh0bWw1LkVkaXRvciBjbGFzc1xuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHZpZXcgSW5zdGFuY2Ugb2Ygd3lzaWh0bWw1LnZpZXdzLiogY2xhc3NcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBsYWNlaG9sZGVyVGV4dFxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgICB3eXNpaHRtbC5kb20uc2ltdWxhdGVQbGFjZWhvbGRlcih0aGlzLCBjb21wb3NlciwgXCJGb29iYXJcIik7XG4gICAqL1xuKGZ1bmN0aW9uIChkb20pIHtcbiAgZG9tLnNpbXVsYXRlUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoZWRpdG9yLCB2aWV3LCBwbGFjZWhvbGRlclRleHQpIHtcbiAgICB2YXIgQ0xBU1NfTkFNRSA9IFwicGxhY2Vob2xkZXJcIixcbiAgICAgICAgdW5zZXQgPSBmdW5jdGlvbiB1bnNldCgpIHtcbiAgICAgIGlmICh2aWV3Lmhhc1BsYWNlaG9sZGVyU2V0KCkpIHtcbiAgICAgICAgdmlldy5jbGVhcigpO1xuICAgICAgfVxuICAgICAgZG9tLnJlbW92ZUNsYXNzKHZpZXcuZWxlbWVudCwgQ0xBU1NfTkFNRSk7XG4gICAgfSxcbiAgICAgICAgc2V0ID0gZnVuY3Rpb24gc2V0KCkge1xuICAgICAgaWYgKHZpZXcuaXNFbXB0eSgpKSB7XG4gICAgICAgIHZpZXcuc2V0VmFsdWUocGxhY2Vob2xkZXJUZXh0KTtcbiAgICAgICAgZG9tLmFkZENsYXNzKHZpZXcuZWxlbWVudCwgQ0xBU1NfTkFNRSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGVkaXRvci5vYnNlcnZlKFwic2V0X3BsYWNlaG9sZGVyXCIsIHNldCkub2JzZXJ2ZShcInVuc2V0X3BsYWNlaG9sZGVyXCIsIHVuc2V0KS5vYnNlcnZlKFwiZm9jdXM6Y29tcG9zZXJcIiwgdW5zZXQpLm9ic2VydmUoXCJwYXN0ZTpjb21wb3NlclwiLCB1bnNldCkub2JzZXJ2ZShcImJsdXI6Y29tcG9zZXJcIiwgc2V0KTtcblxuICAgIHNldCgpO1xuICB9O1xufSkod3lzaWh0bWw1LmRvbSk7XG4oZnVuY3Rpb24gKGRvbSkge1xuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICBpZiAoXCJ0ZXh0Q29udGVudFwiIGluIGRvY3VtZW50RWxlbWVudCkge1xuICAgIGRvbS5zZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChlbGVtZW50LCB0ZXh0KSB7XG4gICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICB9O1xuXG4gICAgZG9tLmdldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LnRleHRDb250ZW50O1xuICAgIH07XG4gIH0gZWxzZSBpZiAoXCJpbm5lclRleHRcIiBpbiBkb2N1bWVudEVsZW1lbnQpIHtcbiAgICBkb20uc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCwgdGV4dCkge1xuICAgICAgZWxlbWVudC5pbm5lclRleHQgPSB0ZXh0O1xuICAgIH07XG5cbiAgICBkb20uZ2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuaW5uZXJUZXh0O1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZG9tLnNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIHRleHQpIHtcbiAgICAgIGVsZW1lbnQubm9kZVZhbHVlID0gdGV4dDtcbiAgICB9O1xuXG4gICAgZG9tLmdldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBlbGVtZW50Lm5vZGVWYWx1ZTtcbiAgICB9O1xuICB9XG59KSh3eXNpaHRtbDUuZG9tKTtcblxuLyoqXG4gKiBGaXggbW9zdCBjb21tb24gaHRtbCBmb3JtYXR0aW5nIG1pc2JlaGF2aW9ycyBvZiBicm93c2VycyBpbXBsZW1lbnRhdGlvbiB3aGVuIGluc2VydGluZ1xuICogY29udGVudCB2aWEgY29weSAmIHBhc3RlIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIEBhdXRob3IgQ2hyaXN0b3BoZXIgQmx1bVxuICovXG53eXNpaHRtbDUucXVpcmtzLmNsZWFuUGFzdGVkSFRNTCA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gVE9ETzogV2UgcHJvYmFibHkgbmVlZCBtb3JlIHJ1bGVzIGhlcmVcbiAgdmFyIGRlZmF1bHRSdWxlcyA9IHtcbiAgICAvLyBXaGVuIHBhc3RpbmcgdW5kZXJsaW5lZCBsaW5rcyA8YT4gaW50byBhIGNvbnRlbnRFZGl0YWJsZSwgSUUgdGhpbmtzLCBpdCBoYXMgdG8gaW5zZXJ0IDx1PiB0byBrZWVwIHRoZSBzdHlsaW5nXG4gICAgXCJhIHVcIjogd3lzaWh0bWw1LmRvbS5yZXBsYWNlV2l0aENoaWxkTm9kZXNcbiAgfTtcblxuICBmdW5jdGlvbiBjbGVhblBhc3RlZEhUTUwoZWxlbWVudE9ySHRtbCwgcnVsZXMsIGNvbnRleHQpIHtcbiAgICBydWxlcyA9IHJ1bGVzIHx8IGRlZmF1bHRSdWxlcztcbiAgICBjb250ZXh0ID0gY29udGV4dCB8fCBlbGVtZW50T3JIdG1sLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cbiAgICB2YXIgZWxlbWVudCxcbiAgICAgICAgaXNTdHJpbmcgPSB0eXBlb2YgZWxlbWVudE9ySHRtbCA9PT0gXCJzdHJpbmdcIixcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBtYXRjaGVzTGVuZ3RoLFxuICAgICAgICBpLFxuICAgICAgICBqID0gMDtcbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIGVsZW1lbnQgPSB3eXNpaHRtbDUuZG9tLmdldEFzRG9tKGVsZW1lbnRPckh0bWwsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50ID0gZWxlbWVudE9ySHRtbDtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCkge1xuICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBlbGVtZW50LmlubmVySFRNTC5yZXBsYWNlKC9cXG4vZywgJzwvYnI+JylcbiAgICAgIHZhciBlbHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlJylcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbCA9IGVsc1tpXTtcbiAgICAgICAgZWwucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChlbCk7XG4gICAgICB9XG4gICAgICB2YXIgZGl2cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnZGl2Jyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpdnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRpdiA9IGRpdnNbaV07XG4gICAgICAgIHZhciBuZXdfZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xuICAgICAgICBuZXdfZGl2LmlubmVyVGV4dCA9IGRpdi5pbm5lclRleHQ7XG4gICAgICAgIGRpdi5yZXBsYWNlV2l0aChuZXdfZGl2KTtcbiAgICAgIH1cbiAgICAgIHZhciBwX2VscyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgncCcpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwX2Vscy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZWwgPSBwX2Vsc1tpXTtcbiAgICAgICAgaWYgKCEkLnRyaW0oZWwuaW5uZXJUZXh0KS5sZW5ndGgpIHtcbiAgICAgICAgICBlbC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGJyX2VscyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnYnInKTtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlKGkgPCBicl9lbHMubGVuZ3RoIC0gMSkge1xuICAgICAgICB2YXIgYnIgPSBicl9lbHNbaV07XG4gICAgICAgIHdoaWxlIChici5uZXh0U2libGluZyA9PSBicl9lbHNbaSArIDFdKSB7XG4gICAgICAgICAgdmFyIGVsID0gYnJfZWxzW2kgKyAxXTtcbiAgICAgICAgICBlbC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGVsKTtcbiAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBicl9lbHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGJyX2Vsc1tpXVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSBpbiBydWxlcykge1xuICAgICAgbWF0Y2hlcyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChpKTtcbiAgICAgIG1ldGhvZCA9IHJ1bGVzW2ldO1xuICAgICAgbWF0Y2hlc0xlbmd0aCA9IG1hdGNoZXMubGVuZ3RoO1xuICAgICAgZm9yICg7IGogPCBtYXRjaGVzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbWV0aG9kKG1hdGNoZXNbal0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1hdGNoZXMgPSBlbGVtZW50T3JIdG1sID0gcnVsZXMgPSBudWxsO1xuXG4gICAgcmV0dXJuIGlzU3RyaW5nID8gZWxlbWVudC5pbm5lckhUTUwgOiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIGNsZWFuUGFzdGVkSFRNTDtcbn0oKTsgLyoqXG4gICAgICogSUUgYW5kIE9wZXJhIGxlYXZlIGFuIGVtcHR5IHBhcmFncmFwaCBpbiB0aGUgY29udGVudEVkaXRhYmxlIGVsZW1lbnQgYWZ0ZXIgY2xlYXJpbmcgaXRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZW50RWRpdGFibGVFbGVtZW50IFRoZSBjb250ZW50RWRpdGFibGUgZWxlbWVudCB0byBvYnNlcnZlIGZvciBjbGVhcmluZyBldmVudHNcbiAgICAgKiBAZXhhcGxlXG4gICAgICogICAgd3lzaWh0bWw1LnF1aXJrcy5lbnN1cmVQcm9wZXJDbGVhcmluZyhteUNvbnRlbnRFZGl0YWJsZUVsZW1lbnQpO1xuICAgICAqL1xuKGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIGRvbSA9IHd5c2lodG1sNS5kb207XG5cbiAgd3lzaWh0bWw1LnF1aXJrcy5lbnN1cmVQcm9wZXJDbGVhcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2xlYXJJZk5lY2Vzc2FyeSA9IGZ1bmN0aW9uIGNsZWFySWZOZWNlc3NhcnkoZXZlbnQpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcztcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5uZXJIVE1MID0gZWxlbWVudC5pbm5lckhUTUwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGlubmVySFRNTCA9PSBcIjxwPiZuYnNwOzwvcD5cIiB8fCBpbm5lckhUTUwgPT0gXCI8cD4mbmJzcDs8L3A+PHA+Jm5ic3A7PC9wPlwiKSB7XG4gICAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICB9LCAwKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb21wb3Nlcikge1xuICAgICAgZG9tLm9ic2VydmUoY29tcG9zZXIuZWxlbWVudCwgW1wiY3V0XCIsIFwia2V5ZG93blwiXSwgY2xlYXJJZk5lY2Vzc2FyeSk7XG4gICAgfTtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBJbiBPcGVyYSB3aGVuIHRoZSBjYXJldCBpcyBpbiB0aGUgZmlyc3QgYW5kIG9ubHkgaXRlbSBvZiBhIGxpc3QgKDx1bD48bGk+fDwvbGk+PC91bD4pIGFuZCB0aGUgbGlzdCBpcyB0aGUgZmlyc3QgY2hpbGQgb2YgdGhlIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50LCBpdCdzIGltcG9zc2libGUgdG8gZGVsZXRlIHRoZSBsaXN0IGJ5IGhpdHRpbmcgYmFja3NwYWNlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZW50RWRpdGFibGVFbGVtZW50IFRoZSBjb250ZW50RWRpdGFibGUgZWxlbWVudCB0byBvYnNlcnZlIGZvciBjbGVhcmluZyBldmVudHNcbiAgICogQGV4YXBsZVxuICAgKiAgICB3eXNpaHRtbDUucXVpcmtzLmVuc3VyZVByb3BlckNsZWFyaW5nKG15Q29udGVudEVkaXRhYmxlRWxlbWVudCk7XG4gICAqL1xuICB3eXNpaHRtbDUucXVpcmtzLmVuc3VyZVByb3BlckNsZWFyaW5nT2ZMaXN0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgRUxFTUVOVFNfVEhBVF9DT05UQUlOX0xJID0gW1wiT0xcIiwgXCJVTFwiLCBcIk1FTlVcIl07XG5cbiAgICB2YXIgY2xlYXJJZk5lY2Vzc2FyeSA9IGZ1bmN0aW9uIGNsZWFySWZOZWNlc3NhcnkoZWxlbWVudCwgY29udGVudEVkaXRhYmxlRWxlbWVudCkge1xuICAgICAgaWYgKCFjb250ZW50RWRpdGFibGVFbGVtZW50LmZpcnN0Q2hpbGQgfHwgIXd5c2lodG1sNS5sYW5nLmFycmF5KEVMRU1FTlRTX1RIQVRfQ09OVEFJTl9MSSkuY29udGFpbnMoY29udGVudEVkaXRhYmxlRWxlbWVudC5maXJzdENoaWxkLm5vZGVOYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBsaXN0ID0gZG9tLmdldFBhcmVudEVsZW1lbnQoZWxlbWVudCwgeyBub2RlTmFtZTogRUxFTUVOVFNfVEhBVF9DT05UQUlOX0xJIH0pO1xuICAgICAgaWYgKCFsaXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpc3RJc0ZpcnN0Q2hpbGRPZkNvbnRlbnRFZGl0YWJsZSA9IGxpc3QgPT0gY29udGVudEVkaXRhYmxlRWxlbWVudC5maXJzdENoaWxkO1xuICAgICAgaWYgKCFsaXN0SXNGaXJzdENoaWxkT2ZDb250ZW50RWRpdGFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGFzT25seU9uZUxpc3RJdGVtID0gbGlzdC5jaGlsZE5vZGVzLmxlbmd0aCA8PSAxO1xuICAgICAgaWYgKCFoYXNPbmx5T25lTGlzdEl0ZW0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgb25seUxpc3RJdGVtSXNFbXB0eSA9IGxpc3QuZmlyc3RDaGlsZCA/IGxpc3QuZmlyc3RDaGlsZC5pbm5lckhUTUwgPT09IFwiXCIgOiB0cnVlO1xuICAgICAgaWYgKCFvbmx5TGlzdEl0ZW1Jc0VtcHR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGlzdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGxpc3QpO1xuICAgIH07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbXBvc2VyKSB7XG4gICAgICBkb20ub2JzZXJ2ZShjb21wb3Nlci5lbGVtZW50LCBcImtleWRvd25cIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC5rZXlDb2RlICE9PSB3eXNpaHRtbDUuQkFDS1NQQUNFX0tFWSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbGVtZW50ID0gY29tcG9zZXIuc2VsZWN0aW9uLmdldFNlbGVjdGVkTm9kZSgpO1xuICAgICAgICBjbGVhcklmTmVjZXNzYXJ5KGVsZW1lbnQsIGNvbXBvc2VyLmVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSgpO1xufSkod3lzaWh0bWw1KTtcbi8vIFNlZSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02NjQzOThcbi8vXG4vLyBJbiBGaXJlZm94IHRoaXM6XG4vLyAgICAgIHZhciBkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbi8vICAgICAgZC5pbm5lckhUTUwgPSc8YSBocmVmPVwiflwiPjwvYT4nO1xuLy8gICAgICBkLmlubmVySFRNTDtcbi8vIHdpbGwgcmVzdWx0IGluOlxuLy8gICAgICA8YSBocmVmPVwiJTdFXCI+PC9hPlxuLy8gd2hpY2ggaXMgd3JvbmdcbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciBUSUxERV9FU0NBUEVEID0gXCIlN0VcIjtcbiAgd3lzaWh0bWw1LnF1aXJrcy5nZXRDb3JyZWN0SW5uZXJIVE1MID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB2YXIgaW5uZXJIVE1MID0gZWxlbWVudC5pbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTC5pbmRleE9mKFRJTERFX0VTQ0FQRUQpID09PSAtMSkge1xuICAgICAgcmV0dXJuIGlubmVySFRNTDtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudHNXaXRoVGlsZGUgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbaHJlZio9J34nXSwgW3NyYyo9J34nXVwiKSxcbiAgICAgICAgdXJsLFxuICAgICAgICB1cmxUb1NlYXJjaCxcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBpO1xuICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGVsZW1lbnRzV2l0aFRpbGRlLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB1cmwgPSBlbGVtZW50c1dpdGhUaWxkZVtpXS5ocmVmIHx8IGVsZW1lbnRzV2l0aFRpbGRlW2ldLnNyYztcbiAgICAgIHVybFRvU2VhcmNoID0gd3lzaWh0bWw1Lmxhbmcuc3RyaW5nKHVybCkucmVwbGFjZShcIn5cIikuYnkoVElMREVfRVNDQVBFRCk7XG4gICAgICBpbm5lckhUTUwgPSB3eXNpaHRtbDUubGFuZy5zdHJpbmcoaW5uZXJIVE1MKS5yZXBsYWNlKHVybFRvU2VhcmNoKS5ieSh1cmwpO1xuICAgIH1cbiAgICByZXR1cm4gaW5uZXJIVE1MO1xuICB9O1xufSkod3lzaWh0bWw1KTsgLyoqXG4gICAgICAgICAgICAgICAqIFNvbWUgYnJvd3NlcnMgZG9uJ3QgaW5zZXJ0IGxpbmUgYnJlYWtzIHdoZW4gaGl0dGluZyByZXR1cm4gaW4gYSBjb250ZW50RWRpdGFibGUgZWxlbWVudFxuICAgICAgICAgICAgICAgKiAgICAtIE9wZXJhICYgSUUgaW5zZXJ0IG5ldyA8cD4gb24gcmV0dXJuXG4gICAgICAgICAgICAgICAqICAgIC0gQ2hyb21lICYgU2FmYXJpIGluc2VydCBuZXcgPGRpdj4gb24gcmV0dXJuXG4gICAgICAgICAgICAgICAqICAgIC0gRmlyZWZveCBpbnNlcnRzIDxicj4gb24gcmV0dXJuICh5aXBwaWUhKVxuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICogICAgd3lzaWh0bWw1LnF1aXJrcy5pbnNlcnRMaW5lQnJlYWtPblJldHVybihlbGVtZW50KTtcbiAgICAgICAgICAgICAgICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgZG9tID0gd3lzaWh0bWw1LmRvbSxcbiAgICAgIFVTRV9OQVRJVkVfTElORV9CUkVBS19XSEVOX0NBUkVUX0lOU0lERV9UQUdTID0gW1wiTElcIiwgXCJQXCIsIFwiSDFcIiwgXCJIMlwiLCBcIkgzXCIsIFwiSDRcIiwgXCJINVwiLCBcIkg2XCJdLFxuICAgICAgTElTVF9UQUdTID0gW1wiVUxcIiwgXCJPTFwiLCBcIk1FTlVcIl07XG5cbiAgd3lzaWh0bWw1LnF1aXJrcy5pbnNlcnRMaW5lQnJlYWtPblJldHVybiA9IGZ1bmN0aW9uIChjb21wb3Nlcikge1xuICAgIGZ1bmN0aW9uIHVud3JhcChzZWxlY3RlZE5vZGUpIHtcbiAgICAgIHZhciBwYXJlbnRFbGVtZW50ID0gZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7IG5vZGVOYW1lOiBbXCJQXCIsIFwiRElWXCJdIH0sIDIpO1xuICAgICAgaWYgKCFwYXJlbnRFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGludmlzaWJsZVNwYWNlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUod3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRSk7XG4gICAgICBkb20uaW5zZXJ0KGludmlzaWJsZVNwYWNlKS5iZWZvcmUocGFyZW50RWxlbWVudCk7XG4gICAgICBkb20ucmVwbGFjZVdpdGhDaGlsZE5vZGVzKHBhcmVudEVsZW1lbnQpO1xuICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNlbGVjdE5vZGUoaW52aXNpYmxlU3BhY2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtleURvd24oZXZlbnQpIHtcbiAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgIGlmIChldmVudC5zaGlmdEtleSB8fCBrZXlDb2RlICE9PSB3eXNpaHRtbDUuRU5URVJfS0VZICYmIGtleUNvZGUgIT09IHd5c2lodG1sNS5CQUNLU1BBQ0VfS0VZKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZW1lbnQgPSBldmVudC50YXJnZXQsXG4gICAgICAgICAgc2VsZWN0ZWROb2RlID0gY29tcG9zZXIuc2VsZWN0aW9uLmdldFNlbGVjdGVkTm9kZSgpLFxuICAgICAgICAgIGJsb2NrRWxlbWVudCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwgeyBub2RlTmFtZTogVVNFX05BVElWRV9MSU5FX0JSRUFLX1dIRU5fQ0FSRVRfSU5TSURFX1RBR1MgfSwgNCk7XG4gICAgICBpZiAoYmxvY2tFbGVtZW50KSB7XG4gICAgICAgIC8vIFNvbWUgYnJvd3NlcnMgY3JlYXRlIDxwPiBlbGVtZW50cyBhZnRlciBsZWF2aW5nIGEgbGlzdFxuICAgICAgICAvLyBjaGVjayBhZnRlciBrZXlkb3duIG9mIGJhY2tzcGFjZSBhbmQgcmV0dXJuIHdoZXRoZXIgYSA8cD4gZ290IGluc2VydGVkIGFuZCB1bndyYXAgaXRcbiAgICAgICAgaWYgKGJsb2NrRWxlbWVudC5ub2RlTmFtZSA9PT0gXCJMSVwiICYmIChrZXlDb2RlID09PSB3eXNpaHRtbDUuRU5URVJfS0VZIHx8IGtleUNvZGUgPT09IHd5c2lodG1sNS5CQUNLU1BBQ0VfS0VZKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZSA9IGNvbXBvc2VyLnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUoKSxcbiAgICAgICAgICAgICAgICBsaXN0LFxuICAgICAgICAgICAgICAgIGRpdjtcbiAgICAgICAgICAgIGlmICghc2VsZWN0ZWROb2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGlzdCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwge1xuICAgICAgICAgICAgICBub2RlTmFtZTogTElTVF9UQUdTXG4gICAgICAgICAgICB9LCAyKTtcblxuICAgICAgICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1bndyYXAoc2VsZWN0ZWROb2RlKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChibG9ja0VsZW1lbnQubm9kZU5hbWUubWF0Y2goL0hbMS02XS8pICYmIGtleUNvZGUgPT09IHd5c2lodG1sNS5FTlRFUl9LRVkpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHVud3JhcChjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCkpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleUNvZGUgPT09IHd5c2lodG1sNS5FTlRFUl9LRVkgJiYgIXd5c2lodG1sNS5icm93c2VyLmluc2VydHNMaW5lQnJlYWtzT25SZXR1cm4oKSkge1xuICAgICAgICBjb21wb3Nlci5jb21tYW5kcy5leGVjKFwiaW5zZXJ0TGluZUJyZWFrXCIpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGtleXByZXNzIGRvZXNuJ3QgZmlyZSB3aGVuIHlvdSBoaXQgYmFja3NwYWNlXG4gICAgZG9tLm9ic2VydmUoY29tcG9zZXIuZWxlbWVudC5vd25lckRvY3VtZW50LCBcImtleWRvd25cIiwga2V5RG93bik7XG4gIH07XG59KSh3eXNpaHRtbDUpOyAvKipcbiAgICAgICAgICAgICAgICogRm9yY2UgcmVyZW5kZXJpbmcgb2YgYSBnaXZlbiBlbGVtZW50XG4gICAgICAgICAgICAgICAqIE5lZWRlZCB0byBmaXggZGlzcGxheSBtaXNiZWhhdmlvcnMgb2YgSUVcbiAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IG9iamVjdCB3aGljaCBuZWVkcyB0byBiZSByZXJlbmRlcmVkXG4gICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAqICAgIHd5c2lodG1sNS5xdWlya3MucmVkcmF3KGRvY3VtZW50LmJvZHkpO1xuICAgICAgICAgICAgICAgKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciBDTEFTU19OQU1FID0gXCJ3eXNpaHRtbDUtcXVpcmtzLXJlZHJhd1wiO1xuXG4gIHd5c2lodG1sNS5xdWlya3MucmVkcmF3ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICB3eXNpaHRtbDUuZG9tLmFkZENsYXNzKGVsZW1lbnQsIENMQVNTX05BTUUpO1xuICAgIHd5c2lodG1sNS5kb20ucmVtb3ZlQ2xhc3MoZWxlbWVudCwgQ0xBU1NfTkFNRSk7XG5cbiAgICAvLyBGb2xsb3dpbmcgaGFjayBpcyBuZWVkZWQgZm9yIGZpcmVmb3ggdG8gbWFrZSBzdXJlIHRoYXQgaW1hZ2UgcmVzaXplIGhhbmRsZXMgYXJlIHByb3Blcmx5IHJlbW92ZWRcbiAgICB0cnkge1xuICAgICAgdmFyIGRvYyA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICAgIGRvYy5leGVjQ29tbWFuZChcIml0YWxpY1wiLCBmYWxzZSwgbnVsbCk7XG4gICAgICBkb2MuZXhlY0NvbW1hbmQoXCJpdGFsaWNcIiwgZmFsc2UsIG51bGwpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH07XG59KSh3eXNpaHRtbDUpOyAvKipcbiAgICAgICAgICAgICAgICogU2VsZWN0aW9uIEFQSVxuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICAgKiAgICB2YXIgc2VsZWN0aW9uID0gbmV3IHd5c2lodG1sNS5TZWxlY3Rpb24oZWRpdG9yKTtcbiAgICAgICAgICAgICAgICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgZG9tID0gd3lzaWh0bWw1LmRvbTtcblxuICBmdW5jdGlvbiBfZ2V0Q3VtdWxhdGl2ZU9mZnNldFRvcChlbGVtZW50KSB7XG4gICAgdmFyIHRvcCA9IDA7XG4gICAgaWYgKGVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgZG8ge1xuICAgICAgICB0b3AgKz0gZWxlbWVudC5vZmZzZXRUb3AgfHwgMDtcbiAgICAgICAgZWxlbWVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuICAgICAgfSB3aGlsZSAoZWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB0b3A7XG4gIH1cblxuICB3eXNpaHRtbDUuU2VsZWN0aW9uID0gQmFzZS5leHRlbmQoXG4gIC8qKiBAc2NvcGUgd3lzaWh0bWw1LlNlbGVjdGlvbi5wcm90b3R5cGUgKi97XG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKGVkaXRvcikge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgb3VyIGV4dGVybmFsIHJhbmdlIGxpYnJhcnkgaXMgaW5pdGlhbGl6ZWRcbiAgICAgIHdpbmRvdy5yYW5neS5pbml0KCk7XG5cbiAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgdGhpcy5jb21wb3NlciA9IGVkaXRvci5jb21wb3NlcjtcbiAgICAgIHRoaXMuZG9jID0gdGhpcy5jb21wb3Nlci5kb2M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBzZWxlY3Rpb24gYXMgYSBib29rbWFyayB0byBiZSBhYmxlIHRvIGxhdGVyIHJlc3RvcmUgaXRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgY3VycmVudCBzZWxlY3Rpb25cbiAgICAgKi9cbiAgICBnZXRCb29rbWFyazogZnVuY3Rpb24gZ2V0Qm9va21hcmsoKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFJhbmdlKCk7XG4gICAgICByZXR1cm4gcmFuZ2UgJiYgcmFuZ2UuY2xvbmVSYW5nZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlIGEgc2VsZWN0aW9uIHJldHJpZXZlZCB2aWEgd3lzaWh0bWw1LlNlbGVjdGlvbi5wcm90b3R5cGUuZ2V0Qm9va21hcmtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBib29rbWFyayBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAqL1xuICAgIHNldEJvb2ttYXJrOiBmdW5jdGlvbiBzZXRCb29rbWFyayhib29rbWFyaykge1xuICAgICAgaWYgKCFib29rbWFyaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKGJvb2ttYXJrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjYXJldCBpbiBmcm9udCBvZiB0aGUgZ2l2ZW4gbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgVGhlIGVsZW1lbnQgb3IgdGV4dCBub2RlIHdoZXJlIHRvIHBvc2l0aW9uIHRoZSBjYXJldCBpbiBmcm9udCBvZlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgc2VsZWN0aW9uLnNldEJlZm9yZShteUVsZW1lbnQpO1xuICAgICAqL1xuICAgIHNldEJlZm9yZTogZnVuY3Rpb24gc2V0QmVmb3JlKG5vZGUpIHtcbiAgICAgIHZhciByYW5nZSA9IHJhbmd5LmNyZWF0ZVJhbmdlKHRoaXMuZG9jKTtcbiAgICAgIHJhbmdlLnNldFN0YXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgcmFuZ2Uuc2V0RW5kQmVmb3JlKG5vZGUpO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0U2VsZWN0aW9uKHJhbmdlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBjYXJldCBhZnRlciB0aGUgZ2l2ZW4gbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5vZGUgVGhlIGVsZW1lbnQgb3IgdGV4dCBub2RlIHdoZXJlIHRvIHBvc2l0aW9uIHRoZSBjYXJldCBpbiBmcm9udCBvZlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgc2VsZWN0aW9uLnNldEJlZm9yZShteUVsZW1lbnQpO1xuICAgICAqL1xuICAgIHNldEFmdGVyOiBmdW5jdGlvbiBzZXRBZnRlcihub2RlKSB7XG4gICAgICB2YXIgcmFuZ2UgPSByYW5neS5jcmVhdGVSYW5nZSh0aGlzLmRvYyk7XG4gICAgICByYW5nZS5zZXRTdGFydEFmdGVyKG5vZGUpO1xuICAgICAgcmFuZ2Uuc2V0RW5kQWZ0ZXIobm9kZSk7XG4gICAgICByZXR1cm4gdGhpcy5zZXRTZWxlY3Rpb24ocmFuZ2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBYmlsaXR5IHRvIHNlbGVjdC9tYXJrIG5vZGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgVGhlIG5vZGUvZWxlbWVudCB0byBzZWxlY3RcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHNlbGVjdGlvbi5zZWxlY3ROb2RlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibXktaW1hZ2VcIikpO1xuICAgICAqL1xuICAgIHNlbGVjdE5vZGU6IGZ1bmN0aW9uIHNlbGVjdE5vZGUobm9kZSkge1xuICAgICAgdmFyIHJhbmdlID0gcmFuZ3kuY3JlYXRlUmFuZ2UodGhpcy5kb2MpLFxuICAgICAgICAgIGlzRWxlbWVudCA9IG5vZGUubm9kZVR5cGUgPT09IHd5c2lodG1sNS5FTEVNRU5UX05PREUsXG4gICAgICAgICAgY2FuSGF2ZUhUTUwgPSBcImNhbkhhdmVIVE1MXCIgaW4gbm9kZSA/IG5vZGUuY2FuSGF2ZUhUTUwgOiBub2RlLm5vZGVOYW1lICE9PSBcIklNR1wiLFxuICAgICAgICAgIGNvbnRlbnQgPSBpc0VsZW1lbnQgPyBub2RlLmlubmVySFRNTCA6IG5vZGUuZGF0YSxcbiAgICAgICAgICBpc0VtcHR5ID0gY29udGVudCA9PT0gXCJcIiB8fCBjb250ZW50ID09PSB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFLFxuICAgICAgICAgIGRpc3BsYXlTdHlsZSA9IGRvbS5nZXRTdHlsZShcImRpc3BsYXlcIikuZnJvbShub2RlKSxcbiAgICAgICAgICBpc0Jsb2NrRWxlbWVudCA9IGRpc3BsYXlTdHlsZSA9PT0gXCJibG9ja1wiIHx8IGRpc3BsYXlTdHlsZSA9PT0gXCJsaXN0LWl0ZW1cIjtcblxuICAgICAgaWYgKGlzRW1wdHkgJiYgaXNFbGVtZW50ICYmIGNhbkhhdmVIVE1MKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGNhcmV0IGlzIHZpc2libGUgaW4gbm9kZSBieSBpbnNlcnRpbmcgYSB6ZXJvIHdpZHRoIG5vIGJyZWFraW5nIHNwYWNlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbm9kZS5pbm5lckhUTUwgPSB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FuSGF2ZUhUTUwpIHtcbiAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZShub2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbkhhdmVIVE1MICYmIGlzRW1wdHkgJiYgaXNFbGVtZW50KSB7XG4gICAgICAgIHJhbmdlLmNvbGxhcHNlKGlzQmxvY2tFbGVtZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuSGF2ZUhUTUwgJiYgaXNFbXB0eSkge1xuICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKG5vZGUpO1xuICAgICAgICByYW5nZS5zZXRFbmRBZnRlcihub2RlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTZWxlY3Rpb24ocmFuZ2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5vZGUgd2hpY2ggY29udGFpbnMgdGhlIHNlbGVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbY29udHJvbFJhbmdlXSAob25seSBJRSkgV2hldGhlciBpdCBzaG91bGQgcmV0dXJuIHRoZSBzZWxlY3RlZCBDb250cm9sUmFuZ2UgZWxlbWVudCB3aGVuIHRoZSBzZWxlY3Rpb24gdHlwZSBpcyBhIFwiQ29udHJvbFJhbmdlXCJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBub2RlIHRoYXQgY29udGFpbnMgdGhlIGNhcmV0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICB2YXIgbm9kZVRoYXRDb250YWluc0NhcmV0ID0gc2VsZWN0aW9uLmdldFNlbGVjdGVkTm9kZSgpO1xuICAgICAqL1xuICAgIGdldFNlbGVjdGVkTm9kZTogZnVuY3Rpb24gZ2V0U2VsZWN0ZWROb2RlKGNvbnRyb2xSYW5nZSkge1xuICAgICAgdmFyIHNlbGVjdGlvbiwgcmFuZ2U7XG5cbiAgICAgIGlmIChjb250cm9sUmFuZ2UgJiYgdGhpcy5kb2Muc2VsZWN0aW9uICYmIHRoaXMuZG9jLnNlbGVjdGlvbi50eXBlID09PSBcIkNvbnRyb2xcIikge1xuICAgICAgICByYW5nZSA9IHRoaXMuZG9jLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICBpZiAocmFuZ2UgJiYgcmFuZ2UubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIHJhbmdlLml0ZW0oMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb24odGhpcy5kb2MpO1xuICAgICAgaWYgKHNlbGVjdGlvbi5mb2N1c05vZGUgPT09IHNlbGVjdGlvbi5hbmNob3JOb2RlKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb24uZm9jdXNOb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UgPSB0aGlzLmdldFJhbmdlKHRoaXMuZG9jKTtcbiAgICAgICAgcmV0dXJuIHJhbmdlID8gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIgOiB0aGlzLmRvYy5ib2R5O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBleGVjdXRlQW5kUmVzdG9yZTogZnVuY3Rpb24gZXhlY3V0ZUFuZFJlc3RvcmUobWV0aG9kLCByZXN0b3JlU2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgIHZhciBib2R5ID0gdGhpcy5kb2MuYm9keSxcbiAgICAgICAgICBvbGRTY3JvbGxUb3AgPSByZXN0b3JlU2Nyb2xsUG9zaXRpb24gJiYgYm9keS5zY3JvbGxUb3AsXG4gICAgICAgICAgb2xkU2Nyb2xsTGVmdCA9IHJlc3RvcmVTY3JvbGxQb3NpdGlvbiAmJiBib2R5LnNjcm9sbExlZnQsXG4gICAgICAgICAgY2xhc3NOYW1lID0gXCJfd3lzaWh0bWw1LXRlbXAtcGxhY2Vob2xkZXJcIixcbiAgICAgICAgICBwbGFjZWhvbGRlckhUTUwgPSAnPHNwYW4gY2xhc3M9XCInICsgY2xhc3NOYW1lICsgJ1wiPicgKyB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFICsgJzwvc3Bhbj4nLFxuICAgICAgICAgIHJhbmdlID0gdGhpcy5nZXRSYW5nZSh0aGlzLmRvYyksXG4gICAgICAgICAgbmV3UmFuZ2U7XG5cbiAgICAgIC8vIE5vdGhpbmcgc2VsZWN0ZWQsIGV4ZWN1dGUgYW5kIHNheSBnb29kYnllXG4gICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIG1ldGhvZChib2R5LCBib2R5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IHJhbmdlLmNyZWF0ZUNvbnRleHR1YWxGcmFnbWVudChwbGFjZWhvbGRlckhUTUwpO1xuICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShub2RlKTtcblxuICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgYSBwb3RlbnRpYWwgZXJyb3IgZG9lc24ndCBjYXVzZSBvdXIgcGxhY2Vob2xkZXIgZWxlbWVudCB0byBiZSBsZWZ0IGFzIGEgcGxhY2Vob2xkZXJcbiAgICAgIHRyeSB7XG4gICAgICAgIG1ldGhvZChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2UuZW5kQ29udGFpbmVyKTtcbiAgICAgIH0gY2F0Y2ggKGUzKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRocm93IGUzO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cblxuICAgICAgY2FyZXRQbGFjZWhvbGRlciA9IHRoaXMuZG9jLnF1ZXJ5U2VsZWN0b3IoXCIuXCIgKyBjbGFzc05hbWUpO1xuICAgICAgaWYgKGNhcmV0UGxhY2Vob2xkZXIpIHtcbiAgICAgICAgbmV3UmFuZ2UgPSByYW5neS5jcmVhdGVSYW5nZSh0aGlzLmRvYyk7XG4gICAgICAgIG5ld1JhbmdlLnNlbGVjdE5vZGUoY2FyZXRQbGFjZWhvbGRlcik7XG4gICAgICAgIG5ld1JhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7XG4gICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKG5ld1JhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZhbGxiYWNrIGZvciB3aGVuIGFsbCBoZWxsIGJyZWFrcyBsb29zZVxuICAgICAgICBib2R5LmZvY3VzKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN0b3JlU2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgICAgYm9keS5zY3JvbGxUb3AgPSBvbGRTY3JvbGxUb3A7XG4gICAgICAgIGJvZHkuc2Nyb2xsTGVmdCA9IG9sZFNjcm9sbExlZnQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBpdCBhZ2FpbiwganVzdCB0byBtYWtlIHN1cmUgdGhhdCB0aGUgcGxhY2Vob2xkZXIgaXMgZGVmaW5pdGVseSBvdXQgb2YgdGhlIGRvbSB0cmVlXG4gICAgICB0cnkge1xuICAgICAgICBjYXJldFBsYWNlaG9sZGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2FyZXRQbGFjZWhvbGRlcik7XG4gICAgICB9IGNhdGNoIChlNCkge31cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGlmZmVyZW50IGFwcHJvYWNoIG9mIHByZXNlcnZpbmcgdGhlIHNlbGVjdGlvbiAoZG9lc24ndCBtb2RpZnkgdGhlIGRvbSlcbiAgICAgKiBUYWtlcyBhbGwgdGV4dCBub2RlcyBpbiB0aGUgc2VsZWN0aW9uIGFuZCBzYXZlcyB0aGUgc2VsZWN0aW9uIHBvc2l0aW9uIGluIHRoZSBmaXJzdCBhbmQgbGFzdCBvbmVcbiAgICAgKi9cbiAgICBleGVjdXRlQW5kUmVzdG9yZVNpbXBsZTogZnVuY3Rpb24gZXhlY3V0ZUFuZFJlc3RvcmVTaW1wbGUobWV0aG9kKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFJhbmdlKCksXG4gICAgICAgICAgYm9keSA9IHRoaXMuZG9jLmJvZHksXG4gICAgICAgICAgbmV3UmFuZ2UsXG4gICAgICAgICAgZmlyc3ROb2RlLFxuICAgICAgICAgIGxhc3ROb2RlLFxuICAgICAgICAgIHRleHROb2RlcyxcbiAgICAgICAgICByYW5nZUJhY2t1cDtcblxuICAgICAgLy8gTm90aGluZyBzZWxlY3RlZCwgZXhlY3V0ZSBhbmQgc2F5IGdvb2RieWVcbiAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgbWV0aG9kKGJvZHksIGJvZHkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRleHROb2RlcyA9IHJhbmdlLmdldE5vZGVzKFszXSk7XG4gICAgICBmaXJzdE5vZGUgPSB0ZXh0Tm9kZXNbMF0gfHwgcmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICBsYXN0Tm9kZSA9IHRleHROb2Rlc1t0ZXh0Tm9kZXMubGVuZ3RoIC0gMV0gfHwgcmFuZ2UuZW5kQ29udGFpbmVyO1xuXG4gICAgICByYW5nZUJhY2t1cCA9IHtcbiAgICAgICAgY29sbGFwc2VkOiByYW5nZS5jb2xsYXBzZWQsXG4gICAgICAgIHN0YXJ0Q29udGFpbmVyOiBmaXJzdE5vZGUsXG4gICAgICAgIHN0YXJ0T2Zmc2V0OiBmaXJzdE5vZGUgPT09IHJhbmdlLnN0YXJ0Q29udGFpbmVyID8gcmFuZ2Uuc3RhcnRPZmZzZXQgOiAwLFxuICAgICAgICBlbmRDb250YWluZXI6IGxhc3ROb2RlLFxuICAgICAgICBlbmRPZmZzZXQ6IGxhc3ROb2RlID09PSByYW5nZS5lbmRDb250YWluZXIgPyByYW5nZS5lbmRPZmZzZXQgOiBsYXN0Tm9kZS5sZW5ndGhcbiAgICAgIH07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG1ldGhvZChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2UuZW5kQ29udGFpbmVyKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG5cbiAgICAgIG5ld1JhbmdlID0gcmFuZ3kuY3JlYXRlUmFuZ2UodGhpcy5kb2MpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3UmFuZ2Uuc2V0U3RhcnQocmFuZ2VCYWNrdXAuc3RhcnRDb250YWluZXIsIHJhbmdlQmFja3VwLnN0YXJ0T2Zmc2V0KTtcbiAgICAgIH0gY2F0Y2ggKGUxKSB7fVxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3UmFuZ2Uuc2V0RW5kKHJhbmdlQmFja3VwLmVuZENvbnRhaW5lciwgcmFuZ2VCYWNrdXAuZW5kT2Zmc2V0KTtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7fVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24obmV3UmFuZ2UpO1xuICAgICAgfSBjYXRjaCAoZTMpIHt9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydCBodG1sIGF0IHRoZSBjYXJldCBwb3NpdGlvbiBhbmQgbW92ZSB0aGUgY3Vyc29yIGFmdGVyIHRoZSBpbnNlcnRlZCBodG1sXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaHRtbCBIVE1MIHN0cmluZyB0byBpbnNlcnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHNlbGVjdGlvbi5pbnNlcnRIVE1MKFwiPHA+Zm9vYmFyPC9wPlwiKTtcbiAgICAgKi9cbiAgICBpbnNlcnRIVE1MOiBmdW5jdGlvbiBpbnNlcnRIVE1MKGh0bWwpIHtcbiAgICAgIHZhciByYW5nZSA9IHJhbmd5LmNyZWF0ZVJhbmdlKHRoaXMuZG9jKSxcbiAgICAgICAgICBub2RlID0gcmFuZ2UuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KGh0bWwpLFxuICAgICAgICAgIGxhc3RDaGlsZCA9IG5vZGUubGFzdENoaWxkO1xuICAgICAgdGhpcy5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgaWYgKGxhc3RDaGlsZCkge1xuICAgICAgICB0aGlzLnNldEFmdGVyKGxhc3RDaGlsZCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIG5vZGUgYXQgdGhlIGNhcmV0IHBvc2l0aW9uIGFuZCBtb3ZlIHRoZSBjdXJzb3IgYmVoaW5kIGl0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBIVE1MIHN0cmluZyB0byBpbnNlcnRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHNlbGVjdGlvbi5pbnNlcnROb2RlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiZm9vYmFyXCIpKTtcbiAgICAgKi9cbiAgICBpbnNlcnROb2RlOiBmdW5jdGlvbiBpbnNlcnROb2RlKG5vZGUpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKTtcbiAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICByYW5nZS5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXcmFwcyBjdXJyZW50IHNlbGVjdGlvbiB3aXRoIHRoZSBnaXZlbiBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZSBUaGUgbm9kZSB0byBzdXJyb3VuZCB0aGUgc2VsZWN0ZWQgZWxlbWVudHMgd2l0aFxuICAgICAqL1xuICAgIHN1cnJvdW5kOiBmdW5jdGlvbiBzdXJyb3VuZChub2RlKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLmdldFJhbmdlKCk7XG4gICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBvbmx5IHdvcmtzIHdoZW4gdGhlIHJhbmdlIGJvdW5kYXJpZXMgYXJlIG5vdCBvdmVybGFwcGluZyBvdGhlciBlbGVtZW50c1xuICAgICAgICByYW5nZS5zdXJyb3VuZENvbnRlbnRzKG5vZGUpO1xuICAgICAgICB0aGlzLnNlbGVjdE5vZGUobm9kZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGZhbGxiYWNrXG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQocmFuZ2UuZXh0cmFjdENvbnRlbnRzKCkpO1xuICAgICAgICByYW5nZS5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGwgdGhlIGN1cnJlbnQgY2FyZXQgcG9zaXRpb24gaW50byB0aGUgdmlld1xuICAgICAqIEZJWE1FOiBUaGlzIGlzIGEgYml0IGhhY2t5LCB0aGVyZSBtaWdodCBiZSBhIHNtYXJ0ZXIgd2F5IG9mIGRvaW5nIHRoaXNcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgc2VsZWN0aW9uLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICovXG4gICAgc2Nyb2xsSW50b1ZpZXc6IGZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KCkge1xuICAgICAgdmFyIGRvYyA9IHRoaXMuZG9jLFxuICAgICAgICAgIGhhc1Njcm9sbEJhcnMgPSBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvYy5kb2N1bWVudEVsZW1lbnQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgIHRlbXBFbGVtZW50ID0gZG9jLl93eXNpaHRtbDVTY3JvbGxJbnRvVmlld0VsZW1lbnQgPSBkb2MuX3d5c2lodG1sNVNjcm9sbEludG9WaWV3RWxlbWVudCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAvLyBUaGUgZWxlbWVudCBuZWVkcyBjb250ZW50IGluIG9yZGVyIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIGl0J3MgcG9zaXRpb24gcHJvcGVybHlcbiAgICAgICAgZWxlbWVudC5pbm5lckhUTUwgPSB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgIH0oKSxcbiAgICAgICAgICBvZmZzZXRUb3A7XG5cbiAgICAgIGlmIChoYXNTY3JvbGxCYXJzKSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0Tm9kZSh0ZW1wRWxlbWVudCk7XG4gICAgICAgIG9mZnNldFRvcCA9IF9nZXRDdW11bGF0aXZlT2Zmc2V0VG9wKHRlbXBFbGVtZW50KTtcbiAgICAgICAgdGVtcEVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0ZW1wRWxlbWVudCk7XG4gICAgICAgIGlmIChvZmZzZXRUb3AgPiBkb2MuYm9keS5zY3JvbGxUb3ApIHtcbiAgICAgICAgICBkb2MuYm9keS5zY3JvbGxUb3AgPSBvZmZzZXRUb3A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IGxpbmUgd2hlcmUgdGhlIGNhcmV0IGlzIGluXG4gICAgICovXG4gICAgc2VsZWN0TGluZTogZnVuY3Rpb24gc2VsZWN0TGluZSgpIHtcbiAgICAgIGlmICh3eXNpaHRtbDUuYnJvd3Nlci5zdXBwb3J0c1NlbGVjdGlvbk1vZGlmeSgpKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdExpbmVfVzNDKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZG9jLnNlbGVjdGlvbikge1xuICAgICAgICB0aGlzLl9zZWxlY3RMaW5lX01TSUUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS9TZWxlY3Rpb24vbW9kaWZ5XG4gICAgICovXG4gICAgX3NlbGVjdExpbmVfVzNDOiBmdW5jdGlvbiBfc2VsZWN0TGluZV9XM0MoKSB7XG4gICAgICB2YXIgd2luID0gdGhpcy5kb2MuZGVmYXVsdFZpZXcsXG4gICAgICAgICAgc2VsZWN0aW9uID0gd2luLmdldFNlbGVjdGlvbigpO1xuICAgICAgc2VsZWN0aW9uLm1vZGlmeShcImV4dGVuZFwiLCBcImxlZnRcIiwgXCJsaW5lYm91bmRhcnlcIik7XG4gICAgICBzZWxlY3Rpb24ubW9kaWZ5KFwiZXh0ZW5kXCIsIFwicmlnaHRcIiwgXCJsaW5lYm91bmRhcnlcIik7XG4gICAgfSxcblxuICAgIF9zZWxlY3RMaW5lX01TSUU6IGZ1bmN0aW9uIF9zZWxlY3RMaW5lX01TSUUoKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLmRvYy5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKSxcbiAgICAgICAgICByYW5nZVRvcCA9IHJhbmdlLmJvdW5kaW5nVG9wLFxuICAgICAgICAgIHJhbmdlSGVpZ2h0ID0gcmFuZ2UuYm91bmRpbmdIZWlnaHQsXG4gICAgICAgICAgc2Nyb2xsV2lkdGggPSB0aGlzLmRvYy5ib2R5LnNjcm9sbFdpZHRoLFxuICAgICAgICAgIHJhbmdlQm90dG9tLFxuICAgICAgICAgIHJhbmdlRW5kLFxuICAgICAgICAgIG1lYXN1cmVOb2RlLFxuICAgICAgICAgIGksXG4gICAgICAgICAgajtcblxuICAgICAgaWYgKCFyYW5nZS5tb3ZlVG9Qb2ludCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChyYW5nZVRvcCA9PT0gMCkge1xuICAgICAgICAvLyBEb24ndCBrbm93IHdoeSwgYnV0IHdoZW4gdGhlIHNlbGVjdGlvbiBlbmRzIGF0IHRoZSBlbmQgb2YgYSBsaW5lXG4gICAgICAgIC8vIHJhbmdlLmJvdW5kaW5nVG9wIGlzIDBcbiAgICAgICAgbWVhc3VyZU5vZGUgPSB0aGlzLmRvYy5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgdGhpcy5pbnNlcnROb2RlKG1lYXN1cmVOb2RlKTtcbiAgICAgICAgcmFuZ2VUb3AgPSBtZWFzdXJlTm9kZS5vZmZzZXRUb3A7XG4gICAgICAgIG1lYXN1cmVOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobWVhc3VyZU5vZGUpO1xuICAgICAgfVxuXG4gICAgICByYW5nZVRvcCArPSAxO1xuXG4gICAgICBmb3IgKGkgPSAtMTA7IGkgPCBzY3JvbGxXaWR0aDsgaSArPSAyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmFuZ2UubW92ZVRvUG9pbnQoaSwgcmFuZ2VUb3ApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGNhdGNoIChlMSkge31cbiAgICAgIH1cblxuICAgICAgLy8gSW52ZXN0aWdhdGUgdGhlIGZvbGxvd2luZyBpbiBvcmRlciB0byBoYW5kbGUgbXVsdGkgbGluZSBzZWxlY3Rpb25zXG4gICAgICAvLyByYW5nZUJvdHRvbSA9IHJhbmdlVG9wICsgKHJhbmdlSGVpZ2h0ID8gKHJhbmdlSGVpZ2h0IC0gMSkgOiAwKTtcbiAgICAgIHJhbmdlQm90dG9tID0gcmFuZ2VUb3A7XG4gICAgICByYW5nZUVuZCA9IHRoaXMuZG9jLnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgZm9yIChqID0gc2Nyb2xsV2lkdGg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmFuZ2VFbmQubW92ZVRvUG9pbnQoaiwgcmFuZ2VCb3R0b20pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGNhdGNoIChlMikge31cbiAgICAgIH1cblxuICAgICAgcmFuZ2Uuc2V0RW5kUG9pbnQoXCJFbmRUb0VuZFwiLCByYW5nZUVuZCk7XG4gICAgICByYW5nZS5zZWxlY3QoKTtcbiAgICB9LFxuXG4gICAgZ2V0VGV4dDogZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgICAgcmV0dXJuIHNlbGVjdGlvbiA/IHNlbGVjdGlvbi50b1N0cmluZygpIDogXCJcIjtcbiAgICB9LFxuXG4gICAgZ2V0Tm9kZXM6IGZ1bmN0aW9uIGdldE5vZGVzKG5vZGVUeXBlLCBmaWx0ZXIpIHtcbiAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0UmFuZ2UoKTtcbiAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICByZXR1cm4gcmFuZ2UuZ2V0Tm9kZXMoW25vZGVUeXBlXSwgZmlsdGVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0UmFuZ2U6IGZ1bmN0aW9uIGdldFJhbmdlKCkge1xuICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICByZXR1cm4gc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5yYW5nZUNvdW50ICYmIHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uIGdldFNlbGVjdGlvbigpIHtcbiAgICAgIHJldHVybiByYW5neS5nZXRTZWxlY3Rpb24odGhpcy5kb2MuZGVmYXVsdFZpZXcgfHwgdGhpcy5kb2MucGFyZW50V2luZG93KTtcbiAgICB9LFxuXG4gICAgc2V0U2VsZWN0aW9uOiBmdW5jdGlvbiBzZXRTZWxlY3Rpb24ocmFuZ2UpIHtcbiAgICAgIHZhciB3aW4gPSB0aGlzLmRvYy5kZWZhdWx0VmlldyB8fCB0aGlzLmRvYy5wYXJlbnRXaW5kb3csXG4gICAgICAgICAgc2VsZWN0aW9uID0gcmFuZ3kuZ2V0U2VsZWN0aW9uKHdpbik7XG4gICAgICByZXR1cm4gc2VsZWN0aW9uLnNldFNpbmdsZVJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH0pO1xufSkod3lzaWh0bWw1KTtcbi8qKlxuICogSW5zcGlyZWQgYnkgdGhlIHJhbmd5IENTUyBBcHBsaWVyIG1vZHVsZSB3cml0dGVuIGJ5IFRpbSBEb3duIGFuZCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvcmFuZ3kvXG4gKlxuICogY2hhbmdlZCBpbiBvcmRlciB0byBiZSBhYmxlIC4uLlxuICogICAgLSB0byB1c2UgY3VzdG9tIHRhZ3NcbiAqICAgIC0gdG8gZGV0ZWN0IGFuZCByZXBsYWNlIHNpbWlsYXIgY3NzIGNsYXNzZXMgdmlhIHJlZyBleHBcbiAqL1xuKGZ1bmN0aW9uICh3eXNpaHRtbDUsIHJhbmd5KSB7XG4gIHZhciBkZWZhdWx0VGFnTmFtZSA9IFwic3BhblwiO1xuXG4gIHZhciBSRUdfRVhQX1dISVRFX1NQQUNFID0gL1xccysvZztcblxuICBmdW5jdGlvbiBoYXNDbGFzcyhlbCwgY3NzQ2xhc3MsIHJlZ0V4cCkge1xuICAgIGlmICghZWwuY2xhc3NOYW1lKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG1hdGNoaW5nQ2xhc3NOYW1lcyA9IGVsLmNsYXNzTmFtZS5tYXRjaChyZWdFeHApIHx8IFtdO1xuICAgIHJldHVybiBtYXRjaGluZ0NsYXNzTmFtZXNbbWF0Y2hpbmdDbGFzc05hbWVzLmxlbmd0aCAtIDFdID09PSBjc3NDbGFzcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjc3NDbGFzcywgcmVnRXhwKSB7XG4gICAgaWYgKGVsLmNsYXNzTmFtZSkge1xuICAgICAgcmVtb3ZlQ2xhc3MoZWwsIHJlZ0V4cCk7XG4gICAgICBlbC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjc3NDbGFzcztcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NOYW1lID0gY3NzQ2xhc3M7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIHJlZ0V4cCkge1xuICAgIGlmIChlbC5jbGFzc05hbWUpIHtcbiAgICAgIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKHJlZ0V4cCwgXCJcIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzU2FtZUNsYXNzZXMoZWwxLCBlbDIpIHtcbiAgICByZXR1cm4gZWwxLmNsYXNzTmFtZS5yZXBsYWNlKFJFR19FWFBfV0hJVEVfU1BBQ0UsIFwiIFwiKSA9PSBlbDIuY2xhc3NOYW1lLnJlcGxhY2UoUkVHX0VYUF9XSElURV9TUEFDRSwgXCIgXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVwbGFjZVdpdGhPd25DaGlsZHJlbihlbCkge1xuICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgIHdoaWxlIChlbC5maXJzdENoaWxkKSB7XG4gICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGVsLmZpcnN0Q2hpbGQsIGVsKTtcbiAgICB9XG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKGVsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVsZW1lbnRzSGF2ZVNhbWVOb25DbGFzc0F0dHJpYnV0ZXMoZWwxLCBlbDIpIHtcbiAgICBpZiAoZWwxLmF0dHJpYnV0ZXMubGVuZ3RoICE9IGVsMi5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZWwxLmF0dHJpYnV0ZXMubGVuZ3RoLCBhdHRyMSwgYXR0cjIsIG5hbWU7IGkgPCBsZW47ICsraSkge1xuICAgICAgYXR0cjEgPSBlbDEuYXR0cmlidXRlc1tpXTtcbiAgICAgIG5hbWUgPSBhdHRyMS5uYW1lO1xuICAgICAgaWYgKG5hbWUgIT0gXCJjbGFzc1wiKSB7XG4gICAgICAgIGF0dHIyID0gZWwyLmF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKG5hbWUpO1xuICAgICAgICBpZiAoYXR0cjEuc3BlY2lmaWVkICE9IGF0dHIyLnNwZWNpZmllZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cjEuc3BlY2lmaWVkICYmIGF0dHIxLm5vZGVWYWx1ZSAhPT0gYXR0cjIubm9kZVZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTcGxpdFBvaW50KG5vZGUsIG9mZnNldCkge1xuICAgIGlmIChyYW5neS5kb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShub2RlKSkge1xuICAgICAgaWYgKG9mZnNldCA9PSAwKSB7XG4gICAgICAgIHJldHVybiAhIW5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPT0gbm9kZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuICEhbm9kZS5uZXh0U2libGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQgPiAwICYmIG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBzcGxpdE5vZGVBdChub2RlLCBkZXNjZW5kYW50Tm9kZSwgZGVzY2VuZGFudE9mZnNldCkge1xuICAgIHZhciBuZXdOb2RlO1xuICAgIGlmIChyYW5neS5kb20uaXNDaGFyYWN0ZXJEYXRhTm9kZShkZXNjZW5kYW50Tm9kZSkpIHtcbiAgICAgIGlmIChkZXNjZW5kYW50T2Zmc2V0ID09IDApIHtcbiAgICAgICAgZGVzY2VuZGFudE9mZnNldCA9IHJhbmd5LmRvbS5nZXROb2RlSW5kZXgoZGVzY2VuZGFudE5vZGUpO1xuICAgICAgICBkZXNjZW5kYW50Tm9kZSA9IGRlc2NlbmRhbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICB9IGVsc2UgaWYgKGRlc2NlbmRhbnRPZmZzZXQgPT0gZGVzY2VuZGFudE5vZGUubGVuZ3RoKSB7XG4gICAgICAgIGRlc2NlbmRhbnRPZmZzZXQgPSByYW5neS5kb20uZ2V0Tm9kZUluZGV4KGRlc2NlbmRhbnROb2RlKSArIDE7XG4gICAgICAgIGRlc2NlbmRhbnROb2RlID0gZGVzY2VuZGFudE5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5ld05vZGUgPSByYW5neS5kb20uc3BsaXREYXRhTm9kZShkZXNjZW5kYW50Tm9kZSwgZGVzY2VuZGFudE9mZnNldCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbmV3Tm9kZSkge1xuICAgICAgbmV3Tm9kZSA9IGRlc2NlbmRhbnROb2RlLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICBpZiAobmV3Tm9kZS5pZCkge1xuICAgICAgICBuZXdOb2RlLnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkID0gZGVzY2VuZGFudE5vZGUuY2hpbGROb2Rlc1tkZXNjZW5kYW50T2Zmc2V0XSkge1xuICAgICAgICBuZXdOb2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIHJhbmd5LmRvbS5pbnNlcnRBZnRlcihuZXdOb2RlLCBkZXNjZW5kYW50Tm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBkZXNjZW5kYW50Tm9kZSA9PSBub2RlID8gbmV3Tm9kZSA6IHNwbGl0Tm9kZUF0KG5vZGUsIG5ld05vZGUucGFyZW50Tm9kZSwgcmFuZ3kuZG9tLmdldE5vZGVJbmRleChuZXdOb2RlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBNZXJnZShmaXJzdE5vZGUpIHtcbiAgICB0aGlzLmlzRWxlbWVudE1lcmdlID0gZmlyc3ROb2RlLm5vZGVUeXBlID09IHd5c2lodG1sNS5FTEVNRU5UX05PREU7XG4gICAgdGhpcy5maXJzdFRleHROb2RlID0gdGhpcy5pc0VsZW1lbnRNZXJnZSA/IGZpcnN0Tm9kZS5sYXN0Q2hpbGQgOiBmaXJzdE5vZGU7XG4gICAgdGhpcy50ZXh0Tm9kZXMgPSBbdGhpcy5maXJzdFRleHROb2RlXTtcbiAgfVxuXG4gIE1lcmdlLnByb3RvdHlwZSA9IHtcbiAgICBkb01lcmdlOiBmdW5jdGlvbiBkb01lcmdlKCkge1xuICAgICAgdmFyIHRleHRCaXRzID0gW10sXG4gICAgICAgICAgdGV4dE5vZGUsXG4gICAgICAgICAgcGFyZW50LFxuICAgICAgICAgIHRleHQ7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy50ZXh0Tm9kZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdGV4dE5vZGUgPSB0aGlzLnRleHROb2Rlc1tpXTtcbiAgICAgICAgcGFyZW50ID0gdGV4dE5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgdGV4dEJpdHNbaV0gPSB0ZXh0Tm9kZS5kYXRhO1xuICAgICAgICBpZiAoaSkge1xuICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICAgICAgaWYgKCFwYXJlbnQuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwYXJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5maXJzdFRleHROb2RlLmRhdGEgPSB0ZXh0ID0gdGV4dEJpdHMuam9pbihcIlwiKTtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH0sXG5cbiAgICBnZXRMZW5ndGg6IGZ1bmN0aW9uIGdldExlbmd0aCgpIHtcbiAgICAgIHZhciBpID0gdGhpcy50ZXh0Tm9kZXMubGVuZ3RoLFxuICAgICAgICAgIGxlbiA9IDA7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGxlbiArPSB0aGlzLnRleHROb2Rlc1tpXS5sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVuO1xuICAgIH0sXG5cbiAgICB0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgdGV4dEJpdHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLnRleHROb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICB0ZXh0Qml0c1tpXSA9IFwiJ1wiICsgdGhpcy50ZXh0Tm9kZXNbaV0uZGF0YSArIFwiJ1wiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiW01lcmdlKFwiICsgdGV4dEJpdHMuam9pbihcIixcIikgKyBcIildXCI7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIEhUTUxBcHBsaWVyKHRhZ05hbWVzLCBjc3NDbGFzcywgc2ltaWxhckNsYXNzUmVnRXhwLCBub3JtYWxpemUpIHtcbiAgICB0aGlzLnRhZ05hbWVzID0gdGFnTmFtZXMgfHwgW2RlZmF1bHRUYWdOYW1lXTtcbiAgICB0aGlzLmNzc0NsYXNzID0gY3NzQ2xhc3MgfHwgXCJcIjtcbiAgICB0aGlzLnNpbWlsYXJDbGFzc1JlZ0V4cCA9IHNpbWlsYXJDbGFzc1JlZ0V4cDtcbiAgICB0aGlzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbiAgICB0aGlzLmFwcGx5VG9BbnlUYWdOYW1lID0gZmFsc2U7XG4gIH1cblxuICBIVE1MQXBwbGllci5wcm90b3R5cGUgPSB7XG4gICAgZ2V0QW5jZXN0b3JXaXRoQ2xhc3M6IGZ1bmN0aW9uIGdldEFuY2VzdG9yV2l0aENsYXNzKG5vZGUpIHtcbiAgICAgIHZhciBjc3NDbGFzc01hdGNoO1xuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgY3NzQ2xhc3NNYXRjaCA9IHRoaXMuY3NzQ2xhc3MgPyBoYXNDbGFzcyhub2RlLCB0aGlzLmNzc0NsYXNzLCB0aGlzLnNpbWlsYXJDbGFzc1JlZ0V4cCkgOiB0cnVlO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSB3eXNpaHRtbDUuRUxFTUVOVF9OT0RFICYmIHJhbmd5LmRvbS5hcnJheUNvbnRhaW5zKHRoaXMudGFnTmFtZXMsIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSAmJiBjc3NDbGFzc01hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gTm9ybWFsaXplcyBub2RlcyBhZnRlciBhcHBseWluZyBhIENTUyBjbGFzcyB0byBhIFJhbmdlLlxuICAgIHBvc3RBcHBseTogZnVuY3Rpb24gcG9zdEFwcGx5KHRleHROb2RlcywgcmFuZ2UpIHtcbiAgICAgIHZhciBmaXJzdE5vZGUgPSB0ZXh0Tm9kZXNbMF0sXG4gICAgICAgICAgbGFzdE5vZGUgPSB0ZXh0Tm9kZXNbdGV4dE5vZGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICB2YXIgbWVyZ2VzID0gW10sXG4gICAgICAgICAgY3VycmVudE1lcmdlO1xuXG4gICAgICB2YXIgcmFuZ2VTdGFydE5vZGUgPSBmaXJzdE5vZGUsXG4gICAgICAgICAgcmFuZ2VFbmROb2RlID0gbGFzdE5vZGU7XG4gICAgICB2YXIgcmFuZ2VTdGFydE9mZnNldCA9IDAsXG4gICAgICAgICAgcmFuZ2VFbmRPZmZzZXQgPSBsYXN0Tm9kZS5sZW5ndGg7XG5cbiAgICAgIHZhciB0ZXh0Tm9kZSwgcHJlY2VkaW5nVGV4dE5vZGU7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0Tm9kZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdGV4dE5vZGUgPSB0ZXh0Tm9kZXNbaV07XG4gICAgICAgIHByZWNlZGluZ1RleHROb2RlID0gdGhpcy5nZXRBZGphY2VudE1lcmdlYWJsZVRleHROb2RlKHRleHROb2RlLnBhcmVudE5vZGUsIGZhbHNlKTtcbiAgICAgICAgaWYgKHByZWNlZGluZ1RleHROb2RlKSB7XG4gICAgICAgICAgaWYgKCFjdXJyZW50TWVyZ2UpIHtcbiAgICAgICAgICAgIGN1cnJlbnRNZXJnZSA9IG5ldyBNZXJnZShwcmVjZWRpbmdUZXh0Tm9kZSk7XG4gICAgICAgICAgICBtZXJnZXMucHVzaChjdXJyZW50TWVyZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50TWVyZ2UudGV4dE5vZGVzLnB1c2godGV4dE5vZGUpO1xuICAgICAgICAgIGlmICh0ZXh0Tm9kZSA9PT0gZmlyc3ROb2RlKSB7XG4gICAgICAgICAgICByYW5nZVN0YXJ0Tm9kZSA9IGN1cnJlbnRNZXJnZS5maXJzdFRleHROb2RlO1xuICAgICAgICAgICAgcmFuZ2VTdGFydE9mZnNldCA9IHJhbmdlU3RhcnROb2RlLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRleHROb2RlID09PSBsYXN0Tm9kZSkge1xuICAgICAgICAgICAgcmFuZ2VFbmROb2RlID0gY3VycmVudE1lcmdlLmZpcnN0VGV4dE5vZGU7XG4gICAgICAgICAgICByYW5nZUVuZE9mZnNldCA9IGN1cnJlbnRNZXJnZS5nZXRMZW5ndGgoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudE1lcmdlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUZXN0IHdoZXRoZXIgdGhlIGZpcnN0IG5vZGUgYWZ0ZXIgdGhlIHJhbmdlIG5lZWRzIG1lcmdpbmdcbiAgICAgIHZhciBuZXh0VGV4dE5vZGUgPSB0aGlzLmdldEFkamFjZW50TWVyZ2VhYmxlVGV4dE5vZGUobGFzdE5vZGUucGFyZW50Tm9kZSwgdHJ1ZSk7XG4gICAgICBpZiAobmV4dFRleHROb2RlKSB7XG4gICAgICAgIGlmICghY3VycmVudE1lcmdlKSB7XG4gICAgICAgICAgY3VycmVudE1lcmdlID0gbmV3IE1lcmdlKGxhc3ROb2RlKTtcbiAgICAgICAgICBtZXJnZXMucHVzaChjdXJyZW50TWVyZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRNZXJnZS50ZXh0Tm9kZXMucHVzaChuZXh0VGV4dE5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBEbyB0aGUgbWVyZ2VzXG4gICAgICBpZiAobWVyZ2VzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBtZXJnZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICBtZXJnZXNbaV0uZG9NZXJnZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB0aGUgcmFuZ2UgYm91bmRhcmllc1xuICAgICAgICByYW5nZS5zZXRTdGFydChyYW5nZVN0YXJ0Tm9kZSwgcmFuZ2VTdGFydE9mZnNldCk7XG4gICAgICAgIHJhbmdlLnNldEVuZChyYW5nZUVuZE5vZGUsIHJhbmdlRW5kT2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0QWRqYWNlbnRNZXJnZWFibGVUZXh0Tm9kZTogZnVuY3Rpb24gZ2V0QWRqYWNlbnRNZXJnZWFibGVUZXh0Tm9kZShub2RlLCBmb3J3YXJkKSB7XG4gICAgICB2YXIgaXNUZXh0Tm9kZSA9IG5vZGUubm9kZVR5cGUgPT0gd3lzaWh0bWw1LlRFWFRfTk9ERTtcbiAgICAgIHZhciBlbCA9IGlzVGV4dE5vZGUgPyBub2RlLnBhcmVudE5vZGUgOiBub2RlO1xuICAgICAgdmFyIGFkamFjZW50Tm9kZTtcbiAgICAgIHZhciBwcm9wTmFtZSA9IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiO1xuICAgICAgaWYgKGlzVGV4dE5vZGUpIHtcbiAgICAgICAgLy8gQ2FuIG1lcmdlIGlmIHRoZSBub2RlJ3MgcHJldmlvdXMvbmV4dCBzaWJsaW5nIGlzIGEgdGV4dCBub2RlXG4gICAgICAgIGFkamFjZW50Tm9kZSA9IG5vZGVbcHJvcE5hbWVdO1xuICAgICAgICBpZiAoYWRqYWNlbnROb2RlICYmIGFkamFjZW50Tm9kZS5ub2RlVHlwZSA9PSB3eXNpaHRtbDUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgcmV0dXJuIGFkamFjZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ29tcGFyZSBlbGVtZW50IHdpdGggaXRzIHNpYmxpbmdcbiAgICAgICAgYWRqYWNlbnROb2RlID0gZWxbcHJvcE5hbWVdO1xuICAgICAgICBpZiAoYWRqYWNlbnROb2RlICYmIHRoaXMuYXJlRWxlbWVudHNNZXJnZWFibGUobm9kZSwgYWRqYWNlbnROb2RlKSkge1xuICAgICAgICAgIHJldHVybiBhZGphY2VudE5vZGVbZm9yd2FyZCA/IFwiZmlyc3RDaGlsZFwiIDogXCJsYXN0Q2hpbGRcIl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBhcmVFbGVtZW50c01lcmdlYWJsZTogZnVuY3Rpb24gYXJlRWxlbWVudHNNZXJnZWFibGUoZWwxLCBlbDIpIHtcbiAgICAgIHJldHVybiByYW5neS5kb20uYXJyYXlDb250YWlucyh0aGlzLnRhZ05hbWVzLCAoZWwxLnRhZ05hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSkgJiYgcmFuZ3kuZG9tLmFycmF5Q29udGFpbnModGhpcy50YWdOYW1lcywgKGVsMi50YWdOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkpICYmIGhhc1NhbWVDbGFzc2VzKGVsMSwgZWwyKSAmJiBlbGVtZW50c0hhdmVTYW1lTm9uQ2xhc3NBdHRyaWJ1dGVzKGVsMSwgZWwyKTtcbiAgICB9LFxuXG4gICAgY3JlYXRlQ29udGFpbmVyOiBmdW5jdGlvbiBjcmVhdGVDb250YWluZXIoZG9jKSB7XG4gICAgICB2YXIgZWwgPSBkb2MuY3JlYXRlRWxlbWVudCh0aGlzLnRhZ05hbWVzWzBdKTtcbiAgICAgIGlmICh0aGlzLmNzc0NsYXNzKSB7XG4gICAgICAgIGVsLmNsYXNzTmFtZSA9IHRoaXMuY3NzQ2xhc3M7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuICAgIGFwcGx5VG9UZXh0Tm9kZTogZnVuY3Rpb24gYXBwbHlUb1RleHROb2RlKHRleHROb2RlKSB7XG4gICAgICB2YXIgcGFyZW50ID0gdGV4dE5vZGUucGFyZW50Tm9kZTtcbiAgICAgIGlmIChwYXJlbnQuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJiByYW5neS5kb20uYXJyYXlDb250YWlucyh0aGlzLnRhZ05hbWVzLCBwYXJlbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICBpZiAodGhpcy5jc3NDbGFzcykge1xuICAgICAgICAgIGFkZENsYXNzKHBhcmVudCwgdGhpcy5jc3NDbGFzcywgdGhpcy5zaW1pbGFyQ2xhc3NSZWdFeHApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmNyZWF0ZUNvbnRhaW5lcihyYW5neS5kb20uZ2V0RG9jdW1lbnQodGV4dE5vZGUpKTtcbiAgICAgICAgdGV4dE5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIHRleHROb2RlKTtcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpc1JlbW92YWJsZTogZnVuY3Rpb24gaXNSZW1vdmFibGUoZWwpIHtcbiAgICAgIHJldHVybiByYW5neS5kb20uYXJyYXlDb250YWlucyh0aGlzLnRhZ05hbWVzLCBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpICYmIHd5c2lodG1sNS5sYW5nLnN0cmluZyhlbC5jbGFzc05hbWUpLnRyaW0oKSA9PSB0aGlzLmNzc0NsYXNzO1xuICAgIH0sXG5cbiAgICB1bmRvVG9UZXh0Tm9kZTogZnVuY3Rpb24gdW5kb1RvVGV4dE5vZGUodGV4dE5vZGUsIHJhbmdlLCBhbmNlc3RvcldpdGhDbGFzcykge1xuICAgICAgaWYgKCFyYW5nZS5jb250YWluc05vZGUoYW5jZXN0b3JXaXRoQ2xhc3MpKSB7XG4gICAgICAgIC8vIFNwbGl0IG91dCB0aGUgcG9ydGlvbiBvZiB0aGUgYW5jZXN0b3IgZnJvbSB3aGljaCB3ZSBjYW4gcmVtb3ZlIHRoZSBDU1MgY2xhc3NcbiAgICAgICAgdmFyIGFuY2VzdG9yUmFuZ2UgPSByYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgICAgIGFuY2VzdG9yUmFuZ2Uuc2VsZWN0Tm9kZShhbmNlc3RvcldpdGhDbGFzcyk7XG5cbiAgICAgICAgaWYgKGFuY2VzdG9yUmFuZ2UuaXNQb2ludEluUmFuZ2UocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpICYmIGlzU3BsaXRQb2ludChyYW5nZS5lbmRDb250YWluZXIsIHJhbmdlLmVuZE9mZnNldCkpIHtcbiAgICAgICAgICBzcGxpdE5vZGVBdChhbmNlc3RvcldpdGhDbGFzcywgcmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQpO1xuICAgICAgICAgIHJhbmdlLnNldEVuZEFmdGVyKGFuY2VzdG9yV2l0aENsYXNzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5jZXN0b3JSYW5nZS5pc1BvaW50SW5SYW5nZShyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpICYmIGlzU3BsaXRQb2ludChyYW5nZS5zdGFydENvbnRhaW5lciwgcmFuZ2Uuc3RhcnRPZmZzZXQpKSB7XG4gICAgICAgICAgYW5jZXN0b3JXaXRoQ2xhc3MgPSBzcGxpdE5vZGVBdChhbmNlc3RvcldpdGhDbGFzcywgcmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zaW1pbGFyQ2xhc3NSZWdFeHApIHtcbiAgICAgICAgcmVtb3ZlQ2xhc3MoYW5jZXN0b3JXaXRoQ2xhc3MsIHRoaXMuc2ltaWxhckNsYXNzUmVnRXhwKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzUmVtb3ZhYmxlKGFuY2VzdG9yV2l0aENsYXNzKSkge1xuICAgICAgICByZXBsYWNlV2l0aE93bkNoaWxkcmVuKGFuY2VzdG9yV2l0aENsYXNzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYXBwbHlUb1JhbmdlOiBmdW5jdGlvbiBhcHBseVRvUmFuZ2UocmFuZ2UpIHtcbiAgICAgIHZhciB0ZXh0Tm9kZXMgPSByYW5nZS5nZXROb2Rlcyhbd3lzaWh0bWw1LlRFWFRfTk9ERV0pO1xuICAgICAgaWYgKCF0ZXh0Tm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmNyZWF0ZUNvbnRhaW5lcihyYW5nZS5lbmRDb250YWluZXIub3duZXJEb2N1bWVudCk7XG4gICAgICAgICAgcmFuZ2Uuc3Vycm91bmRDb250ZW50cyhub2RlKTtcbiAgICAgICAgICB0aGlzLnNlbGVjdE5vZGUocmFuZ2UsIG5vZGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cblxuICAgICAgcmFuZ2Uuc3BsaXRCb3VuZGFyaWVzKCk7XG4gICAgICB0ZXh0Tm9kZXMgPSByYW5nZS5nZXROb2Rlcyhbd3lzaWh0bWw1LlRFWFRfTk9ERV0pO1xuXG4gICAgICBpZiAodGV4dE5vZGVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgdGV4dE5vZGU7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHROb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgIHRleHROb2RlID0gdGV4dE5vZGVzW2ldO1xuICAgICAgICAgIGlmICghdGhpcy5nZXRBbmNlc3RvcldpdGhDbGFzcyh0ZXh0Tm9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwbHlUb1RleHROb2RlKHRleHROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByYW5nZS5zZXRTdGFydCh0ZXh0Tm9kZXNbMF0sIDApO1xuICAgICAgICB0ZXh0Tm9kZSA9IHRleHROb2Rlc1t0ZXh0Tm9kZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHJhbmdlLnNldEVuZCh0ZXh0Tm9kZSwgdGV4dE5vZGUubGVuZ3RoKTtcblxuICAgICAgICBpZiAodGhpcy5ub3JtYWxpemUpIHtcbiAgICAgICAgICB0aGlzLnBvc3RBcHBseSh0ZXh0Tm9kZXMsIHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB1bmRvVG9SYW5nZTogZnVuY3Rpb24gdW5kb1RvUmFuZ2UocmFuZ2UpIHtcbiAgICAgIHZhciB0ZXh0Tm9kZXMgPSByYW5nZS5nZXROb2Rlcyhbd3lzaWh0bWw1LlRFWFRfTk9ERV0pLFxuICAgICAgICAgIHRleHROb2RlLFxuICAgICAgICAgIGFuY2VzdG9yV2l0aENsYXNzO1xuICAgICAgaWYgKHRleHROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgcmFuZ2Uuc3BsaXRCb3VuZGFyaWVzKCk7XG4gICAgICAgIHRleHROb2RlcyA9IHJhbmdlLmdldE5vZGVzKFt3eXNpaHRtbDUuVEVYVF9OT0RFXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZG9jID0gcmFuZ2UuZW5kQ29udGFpbmVyLm93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICBub2RlID0gZG9jLmNyZWF0ZVRleHROb2RlKHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0UpO1xuICAgICAgICByYW5nZS5pbnNlcnROb2RlKG5vZGUpO1xuICAgICAgICByYW5nZS5zZWxlY3ROb2RlKG5vZGUpO1xuICAgICAgICB0ZXh0Tm9kZXMgPSBbbm9kZV07XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0Tm9kZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgdGV4dE5vZGUgPSB0ZXh0Tm9kZXNbaV07XG4gICAgICAgIGFuY2VzdG9yV2l0aENsYXNzID0gdGhpcy5nZXRBbmNlc3RvcldpdGhDbGFzcyh0ZXh0Tm9kZSk7XG4gICAgICAgIGlmIChhbmNlc3RvcldpdGhDbGFzcykge1xuICAgICAgICAgIHRoaXMudW5kb1RvVGV4dE5vZGUodGV4dE5vZGUsIHJhbmdlLCBhbmNlc3RvcldpdGhDbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGxlbiA9PSAxKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0Tm9kZShyYW5nZSwgdGV4dE5vZGVzWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KHRleHROb2Rlc1swXSwgMCk7XG4gICAgICAgIHRleHROb2RlID0gdGV4dE5vZGVzW3RleHROb2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKHRleHROb2RlLCB0ZXh0Tm9kZS5sZW5ndGgpO1xuXG4gICAgICAgIGlmICh0aGlzLm5vcm1hbGl6ZSkge1xuICAgICAgICAgIHRoaXMucG9zdEFwcGx5KHRleHROb2RlcywgcmFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHNlbGVjdE5vZGU6IGZ1bmN0aW9uIHNlbGVjdE5vZGUocmFuZ2UsIG5vZGUpIHtcbiAgICAgIHZhciBpc0VsZW1lbnQgPSBub2RlLm5vZGVUeXBlID09PSB3eXNpaHRtbDUuRUxFTUVOVF9OT0RFLFxuICAgICAgICAgIGNhbkhhdmVIVE1MID0gXCJjYW5IYXZlSFRNTFwiIGluIG5vZGUgPyBub2RlLmNhbkhhdmVIVE1MIDogdHJ1ZSxcbiAgICAgICAgICBjb250ZW50ID0gaXNFbGVtZW50ID8gbm9kZS5pbm5lckhUTUwgOiBub2RlLmRhdGEsXG4gICAgICAgICAgaXNFbXB0eSA9IGNvbnRlbnQgPT09IFwiXCIgfHwgY29udGVudCA9PT0gd3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRTtcblxuICAgICAgaWYgKGlzRW1wdHkgJiYgaXNFbGVtZW50ICYmIGNhbkhhdmVIVE1MKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGNhcmV0IGlzIHZpc2libGUgaW4gbm9kZSBieSBpbnNlcnRpbmcgYSB6ZXJvIHdpZHRoIG5vIGJyZWFraW5nIHNwYWNlXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbm9kZS5pbm5lckhUTUwgPSB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgfVxuICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgICAgaWYgKGlzRW1wdHkgJiYgaXNFbGVtZW50KSB7XG4gICAgICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNFbXB0eSkge1xuICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKG5vZGUpO1xuICAgICAgICByYW5nZS5zZXRFbmRBZnRlcihub2RlKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VGV4dFNlbGVjdGVkQnlSYW5nZTogZnVuY3Rpb24gZ2V0VGV4dFNlbGVjdGVkQnlSYW5nZSh0ZXh0Tm9kZSwgcmFuZ2UpIHtcbiAgICAgIHZhciB0ZXh0UmFuZ2UgPSByYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgICB0ZXh0UmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKHRleHROb2RlKTtcblxuICAgICAgdmFyIGludGVyc2VjdGlvblJhbmdlID0gdGV4dFJhbmdlLmludGVyc2VjdGlvbihyYW5nZSk7XG4gICAgICB2YXIgdGV4dCA9IGludGVyc2VjdGlvblJhbmdlID8gaW50ZXJzZWN0aW9uUmFuZ2UudG9TdHJpbmcoKSA6IFwiXCI7XG4gICAgICB0ZXh0UmFuZ2UuZGV0YWNoKCk7XG5cbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH0sXG5cbiAgICBpc0FwcGxpZWRUb1JhbmdlOiBmdW5jdGlvbiBpc0FwcGxpZWRUb1JhbmdlKHJhbmdlKSB7XG4gICAgICB2YXIgYW5jZXN0b3JzID0gW10sXG4gICAgICAgICAgYW5jZXN0b3IsXG4gICAgICAgICAgdGV4dE5vZGVzID0gcmFuZ2UuZ2V0Tm9kZXMoW3d5c2lodG1sNS5URVhUX05PREVdKTtcbiAgICAgIGlmICghdGV4dE5vZGVzLmxlbmd0aCkge1xuICAgICAgICBhbmNlc3RvciA9IHRoaXMuZ2V0QW5jZXN0b3JXaXRoQ2xhc3MocmFuZ2Uuc3RhcnRDb250YWluZXIpO1xuICAgICAgICByZXR1cm4gYW5jZXN0b3IgPyBbYW5jZXN0b3JdIDogZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0ZXh0Tm9kZXMubGVuZ3RoLCBzZWxlY3RlZFRleHQ7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBzZWxlY3RlZFRleHQgPSB0aGlzLmdldFRleHRTZWxlY3RlZEJ5UmFuZ2UodGV4dE5vZGVzW2ldLCByYW5nZSk7XG4gICAgICAgIGFuY2VzdG9yID0gdGhpcy5nZXRBbmNlc3RvcldpdGhDbGFzcyh0ZXh0Tm9kZXNbaV0pO1xuICAgICAgICBpZiAoc2VsZWN0ZWRUZXh0ICE9IFwiXCIgJiYgIWFuY2VzdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFuY2VzdG9ycztcbiAgICB9LFxuXG4gICAgdG9nZ2xlUmFuZ2U6IGZ1bmN0aW9uIHRvZ2dsZVJhbmdlKHJhbmdlKSB7XG4gICAgICBpZiAodGhpcy5pc0FwcGxpZWRUb1JhbmdlKHJhbmdlKSkge1xuICAgICAgICB0aGlzLnVuZG9Ub1JhbmdlKHJhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXBwbHlUb1JhbmdlKHJhbmdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgd3lzaWh0bWw1LnNlbGVjdGlvbi5IVE1MQXBwbGllciA9IEhUTUxBcHBsaWVyO1xufSkod3lzaWh0bWw1LCByYW5neSk7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICogUmljaCBUZXh0IFF1ZXJ5L0Zvcm1hdHRpbmcgQ29tbWFuZHNcbiAgICAgICAgICAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAgICAqICAgIHZhciBjb21tYW5kcyA9IG5ldyB3eXNpaHRtbDUuQ29tbWFuZHMoZWRpdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAqL1xud3lzaWh0bWw1LkNvbW1hbmRzID0gQmFzZS5leHRlbmQoXG4vKiogQHNjb3BlIHd5c2lodG1sNS5Db21tYW5kcy5wcm90b3R5cGUgKi97XG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBjb25zdHJ1Y3RvcihlZGl0b3IpIHtcbiAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICB0aGlzLmNvbXBvc2VyID0gZWRpdG9yLmNvbXBvc2VyO1xuICAgIHRoaXMuZG9jID0gdGhpcy5jb21wb3Nlci5kb2M7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIGdpdmVuIGNvbW1hbmRcbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbW1hbmQgVGhlIGNvbW1hbmQgc3RyaW5nIHdoaWNoIHRvIGNoZWNrIChlZy4gXCJib2xkXCIsIFwiaXRhbGljXCIsIFwiaW5zZXJ0VW5vcmRlcmVkTGlzdFwiKVxuICAgKiBAZXhhbXBsZVxuICAgKiAgICBjb21tYW5kcy5zdXBwb3J0cyhcImNyZWF0ZUxpbmtcIik7XG4gICAqL1xuICBzdXBwb3J0OiBmdW5jdGlvbiBzdXBwb3J0KGNvbW1hbmQpIHtcbiAgICByZXR1cm4gd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNDb21tYW5kKHRoaXMuZG9jLCBjb21tYW5kKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgYnJvd3NlciBzdXBwb3J0cyB0aGUgZ2l2ZW4gY29tbWFuZFxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29tbWFuZCBUaGUgY29tbWFuZCBzdHJpbmcgd2hpY2ggdG8gZXhlY3V0ZSAoZWcuIFwiYm9sZFwiLCBcIml0YWxpY1wiLCBcImluc2VydFVub3JkZXJlZExpc3RcIilcbiAgICogQHBhcmFtIHtTdHJpbmd9IFt2YWx1ZV0gVGhlIGNvbW1hbmQgdmFsdWUgcGFyYW1ldGVyLCBuZWVkZWQgZm9yIHNvbWUgY29tbWFuZHMgKFwiY3JlYXRlTGlua1wiLCBcImluc2VydEltYWdlXCIsIC4uLiksIG9wdGlvbmFsIGZvciBjb21tYW5kcyB0aGF0IGRvbid0IHJlcXVpcmUgb25lIChcImJvbGRcIiwgXCJ1bmRlcmxpbmVcIiwgLi4uKVxuICAgKiBAZXhhbXBsZVxuICAgKiAgICBjb21tYW5kcy5leGVjKFwiaW5zZXJ0SW1hZ2VcIiwgXCJodHRwOi8vYTEudHdpbWcuY29tL3Byb2ZpbGVfaW1hZ2VzLzExMzg2ODY1NS9zY2hyZWlfdHdpdHRlcl9yZWFzb25hYmx5X3NtYWxsLmpwZ1wiKTtcbiAgICovXG4gIGV4ZWM6IGZ1bmN0aW9uIGV4ZWMoY29tbWFuZCwgdmFsdWUpIHtcbiAgICB2YXIgb2JqID0gd3lzaWh0bWw1LmNvbW1hbmRzW2NvbW1hbmRdLFxuICAgICAgICBhcmdzID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkoYXJndW1lbnRzKS5nZXQoKSxcbiAgICAgICAgbWV0aG9kID0gb2JqICYmIG9iai5leGVjLFxuICAgICAgICByZXN1bHQgPSBudWxsO1xuXG4gICAgdGhpcy5lZGl0b3IuZmlyZShcImJlZm9yZWNvbW1hbmQ6Y29tcG9zZXJcIik7XG5cbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICBhcmdzLnVuc2hpZnQodGhpcy5jb21wb3Nlcik7XG4gICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkob2JqLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gdHJ5L2NhdGNoIGZvciBidWdneSBmaXJlZm94XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuZG9jLmV4ZWNDb21tYW5kKGNvbW1hbmQsIGZhbHNlLCB2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIHRoaXMuZWRpdG9yLmZpcmUoXCJhZnRlcmNvbW1hbmQ6Y29tcG9zZXJcIik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciB0aGUgY3VycmVudCBjb21tYW5kIGlzIGFjdGl2ZVxuICAgKiBJZiB0aGUgY2FyZXQgaXMgd2l0aGluIGEgYm9sZCB0ZXh0LCB0aGVuIGNhbGxpbmcgdGhpcyB3aXRoIGNvbW1hbmQgXCJib2xkXCIgc2hvdWxkIHJldHVybiB0cnVlXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb21tYW5kIFRoZSBjb21tYW5kIHN0cmluZyB3aGljaCB0byBjaGVjayAoZWcuIFwiYm9sZFwiLCBcIml0YWxpY1wiLCBcImluc2VydFVub3JkZXJlZExpc3RcIilcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb21tYW5kVmFsdWVdIFRoZSBjb21tYW5kIHZhbHVlIHBhcmFtZXRlciAoZWcuIGZvciBcImluc2VydEltYWdlXCIgdGhlIGltYWdlIHNyYylcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gV2hldGhlciB0aGUgY29tbWFuZCBpcyBhY3RpdmVcbiAgICogQGV4YW1wbGVcbiAgICogICAgdmFyIGlzQ3VycmVudFNlbGVjdGlvbkJvbGQgPSBjb21tYW5kcy5zdGF0ZShcImJvbGRcIik7XG4gICAqL1xuICBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoY29tbWFuZCwgY29tbWFuZFZhbHVlKSB7XG4gICAgdmFyIG9iaiA9IHd5c2lodG1sNS5jb21tYW5kc1tjb21tYW5kXSxcbiAgICAgICAgYXJncyA9IHd5c2lodG1sNS5sYW5nLmFycmF5KGFyZ3VtZW50cykuZ2V0KCksXG4gICAgICAgIG1ldGhvZCA9IG9iaiAmJiBvYmouc3RhdGU7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgYXJncy51bnNoaWZ0KHRoaXMuY29tcG9zZXIpO1xuICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseShvYmosIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyB0cnkvY2F0Y2ggZm9yIGJ1Z2d5IGZpcmVmb3hcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jLnF1ZXJ5Q29tbWFuZFN0YXRlKGNvbW1hbmQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgY29tbWFuZCdzIHZhbHVlXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBjb21tYW5kIFRoZSBjb21tYW5kIHN0cmluZyB3aGljaCB0byBjaGVjayAoZWcuIFwiZm9ybWF0QmxvY2tcIilcbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgY29tbWFuZCB2YWx1ZVxuICAgKiBAZXhhbXBsZVxuICAgKiAgICB2YXIgY3VycmVudEJsb2NrRWxlbWVudCA9IGNvbW1hbmRzLnZhbHVlKFwiZm9ybWF0QmxvY2tcIik7XG4gICAqL1xuICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoY29tbWFuZCkge1xuICAgIHZhciBvYmogPSB3eXNpaHRtbDUuY29tbWFuZHNbY29tbWFuZF0sXG4gICAgICAgIG1ldGhvZCA9IG9iaiAmJiBvYmoudmFsdWU7XG4gICAgaWYgKG1ldGhvZCkge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jYWxsKG9iaiwgdGhpcy5jb21wb3NlciwgY29tbWFuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIHRyeS9jYXRjaCBmb3IgYnVnZ3kgZmlyZWZveFxuICAgICAgICByZXR1cm4gdGhpcy5kb2MucXVlcnlDb21tYW5kVmFsdWUoY29tbWFuZCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWY7XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmJvbGQgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gZXhlYyhjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuZXhlYyhjb21wb3NlciwgY29tbWFuZCwgXCJiXCIpO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIGNvbG9yKSB7XG4gICAgICAvLyBlbGVtZW50Lm93bmVyRG9jdW1lbnQucXVlcnlDb21tYW5kU3RhdGUoXCJib2xkXCIpIHJlc3VsdHM6XG4gICAgICAvLyBmaXJlZm94OiBvbmx5IDxiPlxuICAgICAgLy8gY2hyb21lOiAgPGI+LCA8c3Ryb25nPiwgPGgxPiwgPGgyPiwgLi4uXG4gICAgICAvLyBpZTogICAgICA8Yj4sIDxzdHJvbmc+XG4gICAgICAvLyBvcGVyYTogICA8Yj4sIDxzdHJvbmc+XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5zdGF0ZShjb21wb3NlciwgY29tbWFuZCwgXCJiXCIpO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTtcblxuKGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmLFxuICAgICAgTk9ERV9OQU1FID0gXCJBXCIsXG4gICAgICBkb20gPSB3eXNpaHRtbDUuZG9tO1xuXG4gIGZ1bmN0aW9uIF9yZW1vdmVGb3JtYXQoY29tcG9zZXIsIGFuY2hvcnMpIHtcbiAgICB2YXIgbGVuZ3RoID0gYW5jaG9ycy5sZW5ndGgsXG4gICAgICAgIGkgPSAwLFxuICAgICAgICBhbmNob3IsXG4gICAgICAgIGNvZGVFbGVtZW50LFxuICAgICAgICB0ZXh0Q29udGVudDtcbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBhbmNob3IgPSBhbmNob3JzW2ldO1xuICAgICAgY29kZUVsZW1lbnQgPSBkb20uZ2V0UGFyZW50RWxlbWVudChhbmNob3IsIHsgbm9kZU5hbWU6IFwiY29kZVwiIH0pO1xuICAgICAgdGV4dENvbnRlbnQgPSBkb20uZ2V0VGV4dENvbnRlbnQoYW5jaG9yKTtcblxuICAgICAgLy8gaWYgPGE+IGNvbnRhaW5zIHVybC1saWtlIHRleHQgY29udGVudCwgcmVuYW1lIGl0IHRvIDxjb2RlPiB0byBwcmV2ZW50IHJlLWF1dG9saW5raW5nXG4gICAgICAvLyBlbHNlIHJlcGxhY2UgPGE+IHdpdGggaXRzIGNoaWxkTm9kZXNcbiAgICAgIGlmICh0ZXh0Q29udGVudC5tYXRjaChkb20uYXV0b0xpbmsuVVJMX1JFR19FWFApICYmICFjb2RlRWxlbWVudCkge1xuICAgICAgICAvLyA8Y29kZT4gZWxlbWVudCBpcyB1c2VkIHRvIHByZXZlbnQgbGF0ZXIgYXV0by1saW5raW5nIG9mIHRoZSBjb250ZW50XG4gICAgICAgIGNvZGVFbGVtZW50ID0gZG9tLnJlbmFtZUVsZW1lbnQoYW5jaG9yLCBcImNvZGVcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkb20ucmVwbGFjZVdpdGhDaGlsZE5vZGVzKGFuY2hvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2Zvcm1hdChjb21wb3NlciwgYXR0cmlidXRlcykge1xuICAgIHZhciBkb2MgPSBjb21wb3Nlci5kb2MsXG4gICAgICAgIHRlbXBDbGFzcyA9IFwiX3d5c2lodG1sNS10ZW1wLVwiICsgK25ldyBEYXRlKCksXG4gICAgICAgIHRlbXBDbGFzc1JlZ0V4cCA9IC9ub24tbWF0Y2hpbmctY2xhc3MvZyxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgYW5jaG9ycyxcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBoYXNFbGVtZW50Q2hpbGQsXG4gICAgICAgIGlzRW1wdHksXG4gICAgICAgIGVsZW1lbnRUb1NldENhcmV0QWZ0ZXIsXG4gICAgICAgIHRleHRDb250ZW50LFxuICAgICAgICB3aGl0ZVNwYWNlLFxuICAgICAgICBqO1xuICAgIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuZXhlYyhjb21wb3NlciwgdW5kZWYsIE5PREVfTkFNRSwgdGVtcENsYXNzLCB0ZW1wQ2xhc3NSZWdFeHApO1xuICAgIGFuY2hvcnMgPSBkb2MucXVlcnlTZWxlY3RvckFsbChOT0RFX05BTUUgKyBcIi5cIiArIHRlbXBDbGFzcyk7XG4gICAgbGVuZ3RoID0gYW5jaG9ycy5sZW5ndGg7XG4gICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYW5jaG9yID0gYW5jaG9yc1tpXTtcbiAgICAgIGFuY2hvci5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICAgIGZvciAoaiBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGFuY2hvci5zZXRBdHRyaWJ1dGUoaiwgYXR0cmlidXRlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZWxlbWVudFRvU2V0Q2FyZXRBZnRlciA9IGFuY2hvcjtcbiAgICBpZiAobGVuZ3RoID09PSAxKSB7XG4gICAgICB0ZXh0Q29udGVudCA9IGRvbS5nZXRUZXh0Q29udGVudChhbmNob3IpO1xuICAgICAgaGFzRWxlbWVudENoaWxkID0gISFhbmNob3IucXVlcnlTZWxlY3RvcihcIipcIik7XG4gICAgICBpc0VtcHR5ID0gdGV4dENvbnRlbnQgPT09IFwiXCIgfHwgdGV4dENvbnRlbnQgPT09IHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0U7XG4gICAgICBpZiAoIWhhc0VsZW1lbnRDaGlsZCAmJiBpc0VtcHR5KSB7XG4gICAgICAgIGRvbS5zZXRUZXh0Q29udGVudChhbmNob3IsIGF0dHJpYnV0ZXMudGV4dCB8fCBhbmNob3IuaHJlZik7XG4gICAgICAgIHdoaXRlU3BhY2UgPSBkb2MuY3JlYXRlVGV4dE5vZGUoXCIgXCIpO1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2V0QWZ0ZXIoYW5jaG9yKTtcbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLmluc2VydE5vZGUod2hpdGVTcGFjZSk7XG4gICAgICAgIGVsZW1lbnRUb1NldENhcmV0QWZ0ZXIgPSB3aGl0ZVNwYWNlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2V0QWZ0ZXIoZWxlbWVudFRvU2V0Q2FyZXRBZnRlcik7XG4gIH1cblxuICB3eXNpaHRtbDUuY29tbWFuZHMuY3JlYXRlTGluayA9IHtcbiAgICAvKipcbiAgICAgKiBUT0RPOiBVc2UgSFRNTEFwcGxpZXIgb3IgZm9ybWF0SW5saW5lIGhlcmVcbiAgICAgKlxuICAgICAqIFR1cm5zIHNlbGVjdGlvbiBpbnRvIGEgbGlua1xuICAgICAqIElmIHNlbGVjdGlvbiBpcyBhbHJlYWR5IGEgbGluaywgaXQgcmVtb3ZlcyB0aGUgbGluayBhbmQgd3JhcHMgaXQgd2l0aCBhIDxjb2RlPiBlbGVtZW50XG4gICAgICogVGhlIDxjb2RlPiBlbGVtZW50IGlzIG5lZWRlZCB0byBhdm9pZCBhdXRvIGxpbmtpbmdcbiAgICAgKiBcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIC8vIGVpdGhlciAuLi5cbiAgICAgKiAgICB3eXNpaHRtbDUuY29tbWFuZHMuY3JlYXRlTGluay5leGVjKGNvbXBvc2VyLCBcImNyZWF0ZUxpbmtcIiwgXCJodHRwOi8vd3d3Lmdvb2dsZS5kZVwiKTtcbiAgICAgKiAgICAvLyAuLi4gb3IgLi4uXG4gICAgICogICAgd3lzaWh0bWw1LmNvbW1hbmRzLmNyZWF0ZUxpbmsuZXhlYyhjb21wb3NlciwgXCJjcmVhdGVMaW5rXCIsIHsgaHJlZjogXCJodHRwOi8vd3d3Lmdvb2dsZS5kZVwiLCB0YXJnZXQ6IFwiX2JsYW5rXCIgfSk7XG4gICAgICovXG4gICAgZXhlYzogZnVuY3Rpb24gZXhlYyhjb21wb3NlciwgY29tbWFuZCwgdmFsdWUpIHtcbiAgICAgIHZhciBhbmNob3JzID0gdGhpcy5zdGF0ZShjb21wb3NlciwgY29tbWFuZCk7XG4gICAgICBpZiAoYW5jaG9ycykge1xuICAgICAgICAvLyBTZWxlY3Rpb24gY29udGFpbnMgbGlua3NcbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfcmVtb3ZlRm9ybWF0KGNvbXBvc2VyLCBhbmNob3JzKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDcmVhdGUgbGlua3NcbiAgICAgICAgdmFsdWUgPSAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YodmFsdWUpKSA9PT0gXCJvYmplY3RcIiA/IHZhbHVlIDogeyBocmVmOiB2YWx1ZSB9O1xuICAgICAgICBfZm9ybWF0KGNvbXBvc2VyLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZShjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIFwiQVwiKTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7IC8qKlxuICAgICAgICAgICAgICAgKiBkb2N1bWVudC5leGVjQ29tbWFuZChcImZvbnRTaXplXCIpIHdpbGwgY3JlYXRlIGVpdGhlciBpbmxpbmUgc3R5bGVzIChmaXJlZm94LCBjaHJvbWUpIG9yIHVzZSBmb250IHRhZ3NcbiAgICAgICAgICAgICAgICogd2hpY2ggd2UgZG9uJ3Qgd2FudFxuICAgICAgICAgICAgICAgKiBJbnN0ZWFkIHdlIHNldCBhIGNzcyBjbGFzc1xuICAgICAgICAgICAgICAgKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZixcbiAgICAgIFJFR19FWFAgPSAvd3lzaXd5Zy1mb250LXNpemUtW2EtelxcLV0rL2c7XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmZvbnRTaXplID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uIGV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIHNpemUpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLmV4ZWMoY29tcG9zZXIsIGNvbW1hbmQsIFwic3BhblwiLCBcInd5c2l3eWctZm9udC1zaXplLVwiICsgc2l6ZSwgUkVHX0VYUCk7XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZShjb21wb3NlciwgY29tbWFuZCwgc2l6ZSkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIFwic3BhblwiLCBcInd5c2l3eWctZm9udC1zaXplLVwiICsgc2l6ZSwgUkVHX0VYUCk7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpO1xuLyoqXG4gKiBkb2N1bWVudC5leGVjQ29tbWFuZChcImZvcmVDb2xvclwiKSB3aWxsIGNyZWF0ZSBlaXRoZXIgaW5saW5lIHN0eWxlcyAoZmlyZWZveCwgY2hyb21lKSBvciB1c2UgZm9udCB0YWdzXG4gKiB3aGljaCB3ZSBkb24ndCB3YW50XG4gKiBJbnN0ZWFkIHdlIHNldCBhIGNzcyBjbGFzc1xuICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWYsXG4gICAgICBSRUdfRVhQID0gL3d5c2l3eWctY29sb3ItW2Etel0rL2c7XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmZvcmVDb2xvciA9IHtcbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kLCBjb2xvcikge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuZXhlYyhjb21wb3NlciwgY29tbWFuZCwgXCJzcGFuXCIsIFwid3lzaXd5Zy1jb2xvci1cIiArIGNvbG9yLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBjb2xvcikge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIFwic3BhblwiLCBcInd5c2l3eWctY29sb3ItXCIgKyBjb2xvciwgUkVHX0VYUCk7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpOyhmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZixcbiAgICAgIGRvbSA9IHd5c2lodG1sNS5kb20sXG4gICAgICBERUZBVUxUX05PREVfTkFNRSA9IFwiRElWXCIsXG5cbiAgLy8gRm9sbG93aW5nIGVsZW1lbnRzIGFyZSBncm91cGVkXG4gIC8vIHdoZW4gdGhlIGNhcmV0IGlzIHdpdGhpbiBhIEgxIGFuZCB0aGUgSDQgaXMgaW52b2tlZCwgdGhlIEgxIHNob3VsZCB0dXJuIGludG8gSDRcbiAgLy8gaW5zdGVhZCBvZiBjcmVhdGluZyBhIEg0IHdpdGhpbiBhIEgxIHdoaWNoIHdvdWxkIHJlc3VsdCBpbiBzZW1hbnRpY2FsbHkgaW52YWxpZCBodG1sXG4gIEJMT0NLX0VMRU1FTlRTX0dST1VQID0gW1wiSDFcIiwgXCJIMlwiLCBcIkgzXCIsIFwiSDRcIiwgXCJINVwiLCBcIkg2XCIsIFwiUFwiLCBcIkJMT0NLUVVPVEVcIiwgREVGQVVMVF9OT0RFX05BTUVdO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgc2ltaWxpYXIgY2xhc3NlcyAoYmFzZWQgb24gY2xhc3NSZWdFeHApXG4gICAqIGFuZCBhZGQgdGhlIGRlc2lyZWQgY2xhc3MgbmFtZVxuICAgKi9cbiAgZnVuY3Rpb24gX2FkZENsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHApIHtcbiAgICBpZiAoZWxlbWVudC5jbGFzc05hbWUpIHtcbiAgICAgIF9yZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc1JlZ0V4cCk7XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX3JlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzUmVnRXhwKSB7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKGNsYXNzUmVnRXhwLCBcIlwiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayB3aGV0aGVyIGdpdmVuIG5vZGUgaXMgYSB0ZXh0IG5vZGUgYW5kIHdoZXRoZXIgaXQncyBlbXB0eVxuICAgKi9cbiAgZnVuY3Rpb24gX2lzQmxhbmtUZXh0Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZVR5cGUgPT09IHd5c2lodG1sNS5URVhUX05PREUgJiYgIXd5c2lodG1sNS5sYW5nLnN0cmluZyhub2RlLmRhdGEpLnRyaW0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHByZXZpb3VzIHNpYmxpbmcgbm9kZSB0aGF0IGlzIG5vdCBhIGJsYW5rIHRleHQgbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gX2dldFByZXZpb3VzU2libGluZ1RoYXRJc05vdEJsYW5rKG5vZGUpIHtcbiAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgd2hpbGUgKHByZXZpb3VzU2libGluZyAmJiBfaXNCbGFua1RleHROb2RlKHByZXZpb3VzU2libGluZykpIHtcbiAgICAgIHByZXZpb3VzU2libGluZyA9IHByZXZpb3VzU2libGluZy5wcmV2aW91c1NpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBwcmV2aW91c1NpYmxpbmc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBuZXh0IHNpYmxpbmcgbm9kZSB0aGF0IGlzIG5vdCBhIGJsYW5rIHRleHQgbm9kZVxuICAgKi9cbiAgZnVuY3Rpb24gX2dldE5leHRTaWJsaW5nVGhhdElzTm90Qmxhbmsobm9kZSkge1xuICAgIHZhciBuZXh0U2libGluZyA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgd2hpbGUgKG5leHRTaWJsaW5nICYmIF9pc0JsYW5rVGV4dE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICBuZXh0U2libGluZyA9IG5leHRTaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dFNpYmxpbmc7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBsaW5lIGJyZWFrcyBiZWZvcmUgYW5kIGFmdGVyIHRoZSBnaXZlbiBub2RlIGlmIHRoZSBwcmV2aW91cyBhbmQgbmV4dCBzaWJsaW5nc1xuICAgKiBhcmVuJ3QgYWxyZWFkeSBjYXVzaW5nIGEgdmlzdWFsIGxpbmUgYnJlYWsgKGJsb2NrIGVsZW1lbnQgb3IgPGJyPilcbiAgICovXG4gIGZ1bmN0aW9uIF9hZGRMaW5lQnJlYWtCZWZvcmVBbmRBZnRlcihub2RlKSB7XG4gICAgdmFyIGRvYyA9IG5vZGUub3duZXJEb2N1bWVudCxcbiAgICAgICAgbmV4dFNpYmxpbmcgPSBfZ2V0TmV4dFNpYmxpbmdUaGF0SXNOb3RCbGFuayhub2RlKSxcbiAgICAgICAgcHJldmlvdXNTaWJsaW5nID0gX2dldFByZXZpb3VzU2libGluZ1RoYXRJc05vdEJsYW5rKG5vZGUpO1xuXG4gICAgaWYgKG5leHRTaWJsaW5nICYmICFfaXNMaW5lQnJlYWtPckJsb2NrRWxlbWVudChuZXh0U2libGluZykpIHtcbiAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZG9jLmNyZWF0ZUVsZW1lbnQoXCJiclwiKSwgbmV4dFNpYmxpbmcpO1xuICAgIH1cbiAgICBpZiAocHJldmlvdXNTaWJsaW5nICYmICFfaXNMaW5lQnJlYWtPckJsb2NrRWxlbWVudChwcmV2aW91c1NpYmxpbmcpKSB7XG4gICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRvYy5jcmVhdGVFbGVtZW50KFwiYnJcIiksIG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGxpbmUgYnJlYWtzIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlIGdpdmVuIG5vZGVcbiAgICovXG4gIGZ1bmN0aW9uIF9yZW1vdmVMaW5lQnJlYWtCZWZvcmVBbmRBZnRlcihub2RlKSB7XG4gICAgdmFyIG5leHRTaWJsaW5nID0gX2dldE5leHRTaWJsaW5nVGhhdElzTm90Qmxhbmsobm9kZSksXG4gICAgICAgIHByZXZpb3VzU2libGluZyA9IF9nZXRQcmV2aW91c1NpYmxpbmdUaGF0SXNOb3RCbGFuayhub2RlKTtcblxuICAgIGlmIChuZXh0U2libGluZyAmJiBfaXNMaW5lQnJlYWsobmV4dFNpYmxpbmcpKSB7XG4gICAgICBuZXh0U2libGluZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5leHRTaWJsaW5nKTtcbiAgICB9XG4gICAgaWYgKHByZXZpb3VzU2libGluZyAmJiBfaXNMaW5lQnJlYWsocHJldmlvdXNTaWJsaW5nKSkge1xuICAgICAgcHJldmlvdXNTaWJsaW5nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocHJldmlvdXNTaWJsaW5nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfcmVtb3ZlTGFzdENoaWxkSWZMaW5lQnJlYWsobm9kZSkge1xuICAgIHZhciBsYXN0Q2hpbGQgPSBub2RlLmxhc3RDaGlsZDtcbiAgICBpZiAobGFzdENoaWxkICYmIF9pc0xpbmVCcmVhayhsYXN0Q2hpbGQpKSB7XG4gICAgICBsYXN0Q2hpbGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsYXN0Q2hpbGQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9pc0xpbmVCcmVhayhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubm9kZU5hbWUgPT09IFwiQlJcIjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZWxtZW50IGNhdXNlcyBhIHZpc3VhbCBsaW5lIGJyZWFrXG4gICAqICg8YnI+IG9yIGJsb2NrIGVsZW1lbnRzKVxuICAgKi9cbiAgZnVuY3Rpb24gX2lzTGluZUJyZWFrT3JCbG9ja0VsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmIChfaXNMaW5lQnJlYWsoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChkb20uZ2V0U3R5bGUoXCJkaXNwbGF5XCIpLmZyb20oZWxlbWVudCkgPT09IFwiYmxvY2tcIikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgbmF0aXZlIHF1ZXJ5IGNvbW1hbmRcbiAgICogYW5kIGlmIG5lY2Vzc2FyeSBtb2RpZnkgdGhlIGluc2VydGVkIG5vZGUncyBjbGFzc05hbWVcbiAgICovXG4gIGZ1bmN0aW9uIF9leGVjQ29tbWFuZChkb2MsIGNvbW1hbmQsIG5vZGVOYW1lLCBjbGFzc05hbWUpIHtcbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IGRvbS5vYnNlcnZlKGRvYywgXCJET01Ob2RlSW5zZXJ0ZWRcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQsXG4gICAgICAgICAgICBkaXNwbGF5U3R5bGU7XG4gICAgICAgIGlmICh0YXJnZXQubm9kZVR5cGUgIT09IHd5c2lodG1sNS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGxheVN0eWxlID0gZG9tLmdldFN0eWxlKFwiZGlzcGxheVwiKS5mcm9tKHRhcmdldCk7XG4gICAgICAgIGlmIChkaXNwbGF5U3R5bGUuc3Vic3RyKDAsIDYpICE9PSBcImlubGluZVwiKSB7XG4gICAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgb25seSBibG9jayBlbGVtZW50cyByZWNlaXZlIHRoZSBnaXZlbiBjbGFzc1xuICAgICAgICAgIHRhcmdldC5jbGFzc05hbWUgKz0gXCIgXCIgKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBkb2MuZXhlY0NvbW1hbmQoY29tbWFuZCwgZmFsc2UsIG5vZGVOYW1lKTtcbiAgICBpZiAoZXZlbnRMaXN0ZW5lcikge1xuICAgICAgZXZlbnRMaXN0ZW5lci5zdG9wKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX3NlbGVjdExpbmVBbmRXcmFwKGNvbXBvc2VyLCBlbGVtZW50KSB7XG4gICAgY29tcG9zZXIuc2VsZWN0aW9uLnNlbGVjdExpbmUoKTtcbiAgICBjb21wb3Nlci5zZWxlY3Rpb24uc3Vycm91bmQoZWxlbWVudCk7XG4gICAgX3JlbW92ZUxpbmVCcmVha0JlZm9yZUFuZEFmdGVyKGVsZW1lbnQpO1xuICAgIF9yZW1vdmVMYXN0Q2hpbGRJZkxpbmVCcmVhayhlbGVtZW50KTtcbiAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2VsZWN0Tm9kZShlbGVtZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9oYXNDbGFzc2VzKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gISF3eXNpaHRtbDUubGFuZy5zdHJpbmcoZWxlbWVudC5jbGFzc05hbWUpLnRyaW0oKTtcbiAgfVxuXG4gIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRCbG9jayA9IHtcbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kLCBub2RlTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCkge1xuICAgICAgdmFyIGRvYyA9IGNvbXBvc2VyLmRvYyxcbiAgICAgICAgICBibG9ja0VsZW1lbnQgPSB0aGlzLnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBub2RlTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCksXG4gICAgICAgICAgc2VsZWN0ZWROb2RlO1xuXG4gICAgICBub2RlTmFtZSA9IHR5cGVvZiBub2RlTmFtZSA9PT0gXCJzdHJpbmdcIiA/IG5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgOiBub2RlTmFtZTtcblxuICAgICAgaWYgKGJsb2NrRWxlbWVudCkge1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmVTaW1wbGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChjbGFzc1JlZ0V4cCkge1xuICAgICAgICAgICAgX3JlbW92ZUNsYXNzKGJsb2NrRWxlbWVudCwgY2xhc3NSZWdFeHApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaGFzQ2xhc3NlcyA9IF9oYXNDbGFzc2VzKGJsb2NrRWxlbWVudCk7XG4gICAgICAgICAgaWYgKCFoYXNDbGFzc2VzICYmIGJsb2NrRWxlbWVudC5ub2RlTmFtZSA9PT0gKG5vZGVOYW1lIHx8IERFRkFVTFRfTk9ERV9OQU1FKSkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IGEgbGluZSBicmVhayBhZnRlcndhcmRzIGFuZCBiZWZvcmV3YXJkcyB3aGVuIHRoZXJlIGFyZSBzaWJsaW5nc1xuICAgICAgICAgICAgLy8gdGhhdCBhcmUgbm90IG9mIHR5cGUgbGluZSBicmVhayBvciBibG9jayBlbGVtZW50XG4gICAgICAgICAgICBfYWRkTGluZUJyZWFrQmVmb3JlQW5kQWZ0ZXIoYmxvY2tFbGVtZW50KTtcbiAgICAgICAgICAgIGRvbS5yZXBsYWNlV2l0aENoaWxkTm9kZXMoYmxvY2tFbGVtZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NsYXNzZXMpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHN0eWxpbmcgaXMga2VwdCBieSByZW5hbWluZyB0aGUgZWxlbWVudCB0byA8ZGl2PiBhbmQgY29weWluZyBvdmVyIHRoZSBjbGFzcyBuYW1lXG4gICAgICAgICAgICBkb20ucmVuYW1lRWxlbWVudChibG9ja0VsZW1lbnQsIERFRkFVTFRfTk9ERV9OQU1FKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmQgc2ltaWxpYXIgYmxvY2sgZWxlbWVudCBhbmQgcmVuYW1lIGl0ICg8aDIgY2xhc3M9XCJmb29cIj48L2gyPiAgPT4gIDxoMSBjbGFzcz1cImZvb1wiPjwvaDE+KVxuICAgICAgaWYgKG5vZGVOYW1lID09PSBudWxsIHx8IHd5c2lodG1sNS5sYW5nLmFycmF5KEJMT0NLX0VMRU1FTlRTX0dST1VQKS5jb250YWlucyhub2RlTmFtZSkpIHtcbiAgICAgICAgc2VsZWN0ZWROb2RlID0gY29tcG9zZXIuc2VsZWN0aW9uLmdldFNlbGVjdGVkTm9kZSgpO1xuICAgICAgICBibG9ja0VsZW1lbnQgPSBkb20uZ2V0UGFyZW50RWxlbWVudChzZWxlY3RlZE5vZGUsIHtcbiAgICAgICAgICBub2RlTmFtZTogQkxPQ0tfRUxFTUVOVFNfR1JPVVBcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGJsb2NrRWxlbWVudCkge1xuICAgICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZVNpbXBsZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBSZW5hbWUgY3VycmVudCBibG9jayBlbGVtZW50IHRvIG5ldyBibG9jayBlbGVtZW50IGFuZCBhZGQgY2xhc3NcbiAgICAgICAgICAgIGlmIChub2RlTmFtZSkge1xuICAgICAgICAgICAgICBibG9ja0VsZW1lbnQgPSBkb20ucmVuYW1lRWxlbWVudChibG9ja0VsZW1lbnQsIG5vZGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgX2FkZENsYXNzKGJsb2NrRWxlbWVudCwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wb3Nlci5jb21tYW5kcy5zdXBwb3J0KGNvbW1hbmQpKSB7XG4gICAgICAgIF9leGVjQ29tbWFuZChkb2MsIGNvbW1hbmQsIG5vZGVOYW1lIHx8IERFRkFVTFRfTk9ERV9OQU1FLCBjbGFzc05hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGJsb2NrRWxlbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KG5vZGVOYW1lIHx8IERFRkFVTFRfTk9ERV9OQU1FKTtcbiAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgYmxvY2tFbGVtZW50LmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgIH1cbiAgICAgIF9zZWxlY3RMaW5lQW5kV3JhcChjb21wb3NlciwgYmxvY2tFbGVtZW50KTtcbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBub2RlTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCkge1xuICAgICAgbm9kZU5hbWUgPSB0eXBlb2Ygbm9kZU5hbWUgPT09IFwic3RyaW5nXCIgPyBub2RlTmFtZS50b1VwcGVyQ2FzZSgpIDogbm9kZU5hbWU7XG4gICAgICB2YXIgc2VsZWN0ZWROb2RlID0gY29tcG9zZXIuc2VsZWN0aW9uLmdldFNlbGVjdGVkTm9kZSgpO1xuICAgICAgcmV0dXJuIGRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwge1xuICAgICAgICBub2RlTmFtZTogbm9kZU5hbWUsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICBjbGFzc1JlZ0V4cDogY2xhc3NSZWdFeHBcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsgLyoqXG4gICAgICAgICAgICAgICAqIGZvcm1hdElubGluZSBzY2VuYXJpb3MgZm9yIHRhZyBcIkJcIiAofCA9IGNhcmV0LCB8Zm9vfCA9IHNlbGVjdGVkIHRleHQpXG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqICAgIzEgY2FyZXQgaW4gdW5mb3JtYXR0ZWQgdGV4dDpcbiAgICAgICAgICAgICAgICogICAgICBhYmNkZWZnfFxuICAgICAgICAgICAgICAgKiAgIG91dHB1dDpcbiAgICAgICAgICAgICAgICogICAgICBhYmNkZWZnPGI+fDwvYj5cbiAgICAgICAgICAgICAgICogICBcbiAgICAgICAgICAgICAgICogICAjMiB1bmZvcm1hdHRlZCB0ZXh0IHNlbGVjdGVkOlxuICAgICAgICAgICAgICAgKiAgICAgIGFiY3xkZWd8aFxuICAgICAgICAgICAgICAgKiAgIG91dHB1dDpcbiAgICAgICAgICAgICAgICogICAgICBhYmM8Yj58ZGVnfDwvYj5oXG4gICAgICAgICAgICAgICAqICAgXG4gICAgICAgICAgICAgICAqICAgIzMgdW5mb3JtYXR0ZWQgdGV4dCBzZWxlY3RlZCBhY3Jvc3MgYm91bmRhcmllczpcbiAgICAgICAgICAgICAgICogICAgICBhYnxjIDxzcGFuPmRlZmd8aDwvc3Bhbj5cbiAgICAgICAgICAgICAgICogICBvdXRwdXQ6XG4gICAgICAgICAgICAgICAqICAgICAgYWI8Yj58YyA8L2I+PHNwYW4+PGI+ZGVmZzwvYj58aDwvc3Bhbj5cbiAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICogICAjNCBmb3JtYXR0ZWQgdGV4dCBlbnRpcmVseSBzZWxlY3RlZFxuICAgICAgICAgICAgICAgKiAgICAgIDxiPnxhYmN8PC9iPlxuICAgICAgICAgICAgICAgKiAgIG91dHB1dDpcbiAgICAgICAgICAgICAgICogICAgICB8YWJjfFxuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiAgICM1IGZvcm1hdHRlZCB0ZXh0IHBhcnRpYWxseSBzZWxlY3RlZFxuICAgICAgICAgICAgICAgKiAgICAgIDxiPmFifGN8PC9iPlxuICAgICAgICAgICAgICAgKiAgIG91dHB1dDpcbiAgICAgICAgICAgICAgICogICAgICA8Yj5hYjwvYj58Y3xcbiAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICogICAjNiBmb3JtYXR0ZWQgdGV4dCBzZWxlY3RlZCBhY3Jvc3MgYm91bmRhcmllc1xuICAgICAgICAgICAgICAgKiAgICAgIDxzcGFuPmFifGM8L3NwYW4+IDxiPmRlfGZnaDwvYj5cbiAgICAgICAgICAgICAgICogICBvdXRwdXQ6XG4gICAgICAgICAgICAgICAqICAgICAgPHNwYW4+YWJ8Yzwvc3Bhbj4gZGV8PGI+ZmdoPC9iPlxuICAgICAgICAgICAgICAgKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZixcblxuICAvLyBUcmVhdCA8Yj4gYXMgPHN0cm9uZz4gYW5kIHZpY2UgdmVyc2FcbiAgQUxJQVNfTUFQUElORyA9IHtcbiAgICBcInN0cm9uZ1wiOiBcImJcIixcbiAgICBcImVtXCI6IFwiaVwiLFxuICAgIFwiYlwiOiBcInN0cm9uZ1wiLFxuICAgIFwiaVwiOiBcImVtXCJcbiAgfSxcbiAgICAgIGh0bWxBcHBsaWVyID0ge307XG5cbiAgZnVuY3Rpb24gX2dldFRhZ05hbWVzKHRhZ05hbWUpIHtcbiAgICB2YXIgYWxpYXMgPSBBTElBU19NQVBQSU5HW3RhZ05hbWVdO1xuICAgIHJldHVybiBhbGlhcyA/IFt0YWdOYW1lLnRvTG93ZXJDYXNlKCksIGFsaWFzLnRvTG93ZXJDYXNlKCldIDogW3RhZ05hbWUudG9Mb3dlckNhc2UoKV07XG4gIH1cblxuICBmdW5jdGlvbiBfZm9ybWF0Q2xlYXIocmFuZ2UpIHtcbiAgICBib2R5ID0gJChyYW5nZS5lbmRDb250YWluZXIub3duZXJEb2N1bWVudC5ib2R5KTtcbiAgICAkLmVhY2goYm9keS5jaGlsZHJlbignZm9udCcpLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb250X2VsID0gJCh0aGlzKTtcbiAgICAgIGZvbnRfZWwucmVwbGFjZVdpdGgoJzxzcGFuPicgKyBmb250X2VsLmh0bWwoKSArICc8L3NwYW4+Jyk7XG4gICAgfSk7XG5cbiAgICAkLmVhY2goYm9keS5jaGlsZHJlbignc3BhbicpLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzcGFuX2VsID0gJCh0aGlzKTtcbiAgICAgIHJlZHVjZWRfZGltZW5zaW9uKHNwYW5fZWwpO1xuICAgIH0pO1xuICAgIG5vdF9zcGFuX2xpc3QgPSAkKCd0Ym9keTpmaXJzdCA+IHRyJykubm90KCd0ZCcpLnRvQXJyYXkoKTtcbiAgICB3aGlsZSAobm90X3NwYW5fbGlzdC5sZW5ndGgpIHtcbiAgICAgIG5vdF9zcGFuX2xpc3RfaXRlbSA9IG5vdF9zcGFuX2xpc3QucG9wKCk7XG4gICAgICAkLmVhY2gobm90X3NwYW5fbGlzdF9pdGVtLmNoaWxkcmVuKCksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbmV3X2VsID0gJCh0aGlzKTtcbiAgICAgICAgaWYgKG5ld19lbC5pcygnc3BhbicpKSB7XG4gICAgICAgICAgcmVkdWNlZF9kaW1lbnNpb24obmV3X2VsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub3Rfc3Bhbl9saXN0LnB1c2gobmV3X2VsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgICQuZWFjaChib2R5LmZpbmQoJ3NwYW4nKSwgZnVuY3Rpb24gKCkge1xuICAgICAgZWwgPSAkKHRoaXMpO1xuICAgICAgaWYgKCEkLnRyaW0oZWwudGV4dCgpKS5sZW5ndGgpIHtcbiAgICAgICAgZWwucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmFuZ2UuZW5kQ29udGFpbmVyLm93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCkuZW1wdHkoKTtcbiAgfVxuXG4gIC8vIG1ha2UgPHNwYW4gY2xhc3M9J2EnPjEyMzxzcGFuIGNsYXNzPSdiJz40PC9zcGFuPjU8L3NwYW4+IGJlY29tZVxuICAvLyA8c3BhbiBjbGFzcz0nYSc+MTIzPC9zcGFuPiA8c3BhbiBjbGFzcz0nYic+NDwvc3Bhbj4gPHNwYW4gY2xhc3M9J2EnPjU8L3NwYW4+XG4gIGZ1bmN0aW9uIHJlZHVjZWRfZGltZW5zaW9uKHNwYW4pIHtcbiAgICBpZiAoc3Bhbi5jaGlsZHJlbignc3BhbicpLmxlbmd0aCkge1xuICAgICAgY2xhc3NfbmFtZSA9ICQudHJpbShzcGFuLmdldCgwKS5jbGFzc05hbWUpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFuLmNoaWxkcmVuKCdzcGFuJykubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hpbGRfc3BhbiA9ICQoc3Bhbi5jaGlsZHJlbignc3BhbicpW2ldKTtcbiAgICAgICAgcmVkdWNlZF9kaW1lbnNpb24oY2hpbGRfc3Bhbik7XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKHNwYW4ucGFyZW50cygnc3BhbicpLmxlbmd0aCk7XG4gICAgICBodG1sX3RleHQgPSBzcGFuLmh0bWwoKTtcbiAgICAgIGlmICghY2xhc3NfbmFtZS5sZW5ndGgpIHtcbiAgICAgICAgY2xhc3NfbmFtZSA9ICd3eXNpd3lnLWNvbG9yLWNsZWFyJztcbiAgICAgIH1cbiAgICAgIGh0bWxfdGV4dCA9IGh0bWxfdGV4dC5yZXBsYWNlKC88c3BhblxcIC8sICc8L3NwYW4+PHNwYW4gJyk7XG4gICAgICBodG1sX3RleHQgPSBodG1sX3RleHQucmVwbGFjZSgvPFxcL3NwYW4+KD8hW1xcc1xcU10qPFxcL3NwYW4+W1xcc1xcU10qJCkvaSwgXCI8L3NwYW4+PHNwYW4gY2xhc3M9J1wiICsgY2xhc3NfbmFtZSArIFwiJz5cIik7XG4gICAgICBodG1sX3RleHQgPSBcIjxzcGFuIGNsYXNzPSdcIiArIGNsYXNzX25hbWUgKyBcIic+XCIgKyBodG1sX3RleHQgKyBcIjwvc3Bhbj5cIjtcbiAgICAgIHNwYW4ucmVwbGFjZVdpdGgoaHRtbF90ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9nZXRBcHBsaWVyKHRhZ05hbWUsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHApIHtcbiAgICB2YXIgaWRlbnRpZmllciA9IHRhZ05hbWUgKyBcIjpcIiArIGNsYXNzTmFtZTtcbiAgICBpZiAoIWh0bWxBcHBsaWVyW2lkZW50aWZpZXJdKSB7XG4gICAgICBodG1sQXBwbGllcltpZGVudGlmaWVyXSA9IG5ldyB3eXNpaHRtbDUuc2VsZWN0aW9uLkhUTUxBcHBsaWVyKF9nZXRUYWdOYW1lcyh0YWdOYW1lKSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiBodG1sQXBwbGllcltpZGVudGlmaWVyXTtcbiAgfVxuXG4gIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gZXhlYyhjb21wb3NlciwgY29tbWFuZCwgdGFnTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCkge1xuICAgICAgdmFyIHJhbmdlID0gY29tcG9zZXIuc2VsZWN0aW9uLmdldFJhbmdlKCk7XG4gICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIF9nZXRBcHBsaWVyKHRhZ05hbWUsIGNsYXNzTmFtZSwgY2xhc3NSZWdFeHApLnRvZ2dsZVJhbmdlKHJhbmdlKTtcbiAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZXRTZWxlY3Rpb24ocmFuZ2UpO1xuICAgICAgX2Zvcm1hdENsZWFyKHJhbmdlKTtcbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCB0YWdOYW1lLCBjbGFzc05hbWUsIGNsYXNzUmVnRXhwKSB7XG4gICAgICB2YXIgZG9jID0gY29tcG9zZXIuZG9jLFxuICAgICAgICAgIGFsaWFzVGFnTmFtZSA9IEFMSUFTX01BUFBJTkdbdGFnTmFtZV0gfHwgdGFnTmFtZSxcbiAgICAgICAgICByYW5nZTtcblxuICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgZG9jdW1lbnQgY29udGFpbnMgYSBub2RlIHdpdGggdGhlIGRlc2lyZWQgdGFnTmFtZVxuICAgICAgaWYgKCF3eXNpaHRtbDUuZG9tLmhhc0VsZW1lbnRXaXRoVGFnTmFtZShkb2MsIHRhZ05hbWUpICYmICF3eXNpaHRtbDUuZG9tLmhhc0VsZW1lbnRXaXRoVGFnTmFtZShkb2MsIGFsaWFzVGFnTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkb2N1bWVudCBjb250YWlucyBhIG5vZGUgd2l0aCB0aGUgZGVzaXJlZCBjbGFzc05hbWVcbiAgICAgIGlmIChjbGFzc05hbWUgJiYgIXd5c2lodG1sNS5kb20uaGFzRWxlbWVudFdpdGhDbGFzc05hbWUoZG9jLCBjbGFzc05hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmFuZ2UgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0UmFuZ2UoKTtcbiAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2dldEFwcGxpZXIodGFnTmFtZSwgY2xhc3NOYW1lLCBjbGFzc1JlZ0V4cCkuaXNBcHBsaWVkVG9SYW5nZShyYW5nZSk7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpOyhmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZjtcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuaW5zZXJ0SFRNTCA9IHtcbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kLCBodG1sKSB7XG4gICAgICBpZiAoY29tcG9zZXIuY29tbWFuZHMuc3VwcG9ydChjb21tYW5kKSkge1xuICAgICAgICBjb21wb3Nlci5kb2MuZXhlY0NvbW1hbmQoY29tbWFuZCwgZmFsc2UsIGh0bWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLmluc2VydEhUTUwoaHRtbCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIE5PREVfTkFNRSA9IFwiSU1HXCI7XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmluc2VydEltYWdlID0ge1xuICAgIC8qKlxuICAgICAqIEluc2VydHMgYW4gPGltZz5cbiAgICAgKiBJZiBzZWxlY3Rpb24gaXMgYWxyZWFkeSBhbiBpbWFnZSBsaW5rLCBpdCByZW1vdmVzIGl0XG4gICAgICogXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAvLyBlaXRoZXIgLi4uXG4gICAgICogICAgd3lzaWh0bWw1LmNvbW1hbmRzLmluc2VydEltYWdlLmV4ZWMoY29tcG9zZXIsIFwiaW5zZXJ0SW1hZ2VcIiwgXCJodHRwOi8vd3d3Lmdvb2dsZS5kZS9sb2dvLmpwZ1wiKTtcbiAgICAgKiAgICAvLyAuLi4gb3IgLi4uXG4gICAgICogICAgd3lzaWh0bWw1LmNvbW1hbmRzLmluc2VydEltYWdlLmV4ZWMoY29tcG9zZXIsIFwiaW5zZXJ0SW1hZ2VcIiwgeyBzcmM6IFwiaHR0cDovL3d3dy5nb29nbGUuZGUvbG9nby5qcGdcIiwgdGl0bGU6IFwiZm9vXCIgfSk7XG4gICAgICovXG4gICAgZXhlYzogZnVuY3Rpb24gZXhlYyhjb21wb3NlciwgY29tbWFuZCwgdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHZhbHVlKSkgPT09IFwib2JqZWN0XCIgPyB2YWx1ZSA6IHsgc3JjOiB2YWx1ZSB9O1xuXG4gICAgICB2YXIgZG9jID0gY29tcG9zZXIuZG9jLFxuICAgICAgICAgIGltYWdlID0gdGhpcy5zdGF0ZShjb21wb3NlciksXG4gICAgICAgICAgdGV4dE5vZGUsXG4gICAgICAgICAgaSxcbiAgICAgICAgICBwYXJlbnQ7XG5cbiAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICAvLyBJbWFnZSBhbHJlYWR5IHNlbGVjdGVkLCBzZXQgdGhlIGNhcmV0IGJlZm9yZSBpdCBhbmQgZGVsZXRlIGl0XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZXRCZWZvcmUoaW1hZ2UpO1xuICAgICAgICBwYXJlbnQgPSBpbWFnZS5wYXJlbnROb2RlO1xuICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoaW1hZ2UpO1xuXG4gICAgICAgIC8vIGFuZCBpdCdzIHBhcmVudCA8YT4gdG9vIGlmIGl0IGhhc24ndCBnb3QgYW55IG90aGVyIHJlbGV2YW50IGNoaWxkIG5vZGVzXG4gICAgICAgIHd5c2lodG1sNS5kb20ucmVtb3ZlRW1wdHlUZXh0Tm9kZXMocGFyZW50KTtcbiAgICAgICAgaWYgKHBhcmVudC5ub2RlTmFtZSA9PT0gXCJBXCIgJiYgIXBhcmVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLnNldEFmdGVyKHBhcmVudCk7XG4gICAgICAgICAgcGFyZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocGFyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpcmVmb3ggYW5kIGllIHNvbWV0aW1lcyBkb24ndCByZW1vdmUgdGhlIGltYWdlIGhhbmRsZXMsIGV2ZW4gdGhvdWdoIHRoZSBpbWFnZSBnb3QgcmVtb3ZlZFxuICAgICAgICB3eXNpaHRtbDUucXVpcmtzLnJlZHJhdyhjb21wb3Nlci5lbGVtZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpbWFnZSA9IGRvYy5jcmVhdGVFbGVtZW50KE5PREVfTkFNRSk7XG5cbiAgICAgIGZvciAoaSBpbiB2YWx1ZSkge1xuICAgICAgICBpbWFnZVtpXSA9IHZhbHVlW2ldO1xuICAgICAgfVxuXG4gICAgICBjb21wb3Nlci5zZWxlY3Rpb24uaW5zZXJ0Tm9kZShpbWFnZSk7XG4gICAgICBpZiAod3lzaWh0bWw1LmJyb3dzZXIuaGFzUHJvYmxlbXNTZXR0aW5nQ2FyZXRBZnRlckltZygpKSB7XG4gICAgICAgIHRleHROb2RlID0gZG9jLmNyZWF0ZVRleHROb2RlKHd5c2lodG1sNS5JTlZJU0lCTEVfU1BBQ0UpO1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uaW5zZXJ0Tm9kZSh0ZXh0Tm9kZSk7XG4gICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZXRBZnRlcih0ZXh0Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2V0QWZ0ZXIoaW1hZ2UpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoY29tcG9zZXIpIHtcbiAgICAgIHZhciBkb2MgPSBjb21wb3Nlci5kb2MsXG4gICAgICAgICAgc2VsZWN0ZWROb2RlLFxuICAgICAgICAgIHRleHQsXG4gICAgICAgICAgaW1hZ2VzSW5TZWxlY3Rpb247XG5cbiAgICAgIGlmICghd3lzaWh0bWw1LmRvbS5oYXNFbGVtZW50V2l0aFRhZ05hbWUoZG9jLCBOT0RFX05BTUUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgc2VsZWN0ZWROb2RlID0gY29tcG9zZXIuc2VsZWN0aW9uLmdldFNlbGVjdGVkTm9kZSgpO1xuICAgICAgaWYgKCFzZWxlY3RlZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0ZWROb2RlLm5vZGVOYW1lID09PSBOT0RFX05BTUUpIHtcbiAgICAgICAgLy8gVGhpcyB3b3JrcyBwZXJmZWN0bHkgaW4gSUVcbiAgICAgICAgcmV0dXJuIHNlbGVjdGVkTm9kZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbGVjdGVkTm9kZS5ub2RlVHlwZSAhPT0gd3lzaWh0bWw1LkVMRU1FTlRfTk9ERSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRleHQgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0VGV4dCgpO1xuICAgICAgdGV4dCA9IHd5c2lodG1sNS5sYW5nLnN0cmluZyh0ZXh0KS50cmltKCk7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGltYWdlc0luU2VsZWN0aW9uID0gY29tcG9zZXIuc2VsZWN0aW9uLmdldE5vZGVzKHd5c2lodG1sNS5FTEVNRU5UX05PREUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLm5vZGVOYW1lID09PSBcIklNR1wiO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbWFnZXNJblNlbGVjdGlvbi5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW1hZ2VzSW5TZWxlY3Rpb25bMF07XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShjb21wb3Nlcikge1xuICAgICAgdmFyIGltYWdlID0gdGhpcy5zdGF0ZShjb21wb3Nlcik7XG4gICAgICByZXR1cm4gaW1hZ2UgJiYgaW1hZ2Uuc3JjO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmLFxuICAgICAgTElORV9CUkVBSyA9IFwiPGJyPlwiICsgKHd5c2lodG1sNS5icm93c2VyLm5lZWRzU3BhY2VBZnRlckxpbmVCcmVhaygpID8gXCIgXCIgOiBcIlwiKTtcblxuICB3eXNpaHRtbDUuY29tbWFuZHMuaW5zZXJ0TGluZUJyZWFrID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uIGV4ZWMoY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIGlmIChjb21wb3Nlci5jb21tYW5kcy5zdXBwb3J0KGNvbW1hbmQpKSB7XG4gICAgICAgIGNvbXBvc2VyLmRvYy5leGVjQ29tbWFuZChjb21tYW5kLCBmYWxzZSwgbnVsbCk7XG4gICAgICAgIGlmICghd3lzaWh0bWw1LmJyb3dzZXIuYXV0b1Njcm9sbHNUb0NhcmV0KCkpIHtcbiAgICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcG9zZXIuY29tbWFuZHMuZXhlYyhcImluc2VydEhUTUxcIiwgTElORV9CUkVBSyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZSgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7KGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmO1xuICAvL1xuICAvLyBmdW5jdGlvbiBfcmVtb3ZlRm9ybWF0KGNvbXBvc2VyLCBhbmNob3JzKSB7XG4gIC8vICAgdmFyIGxlbmd0aCAgPSBhbmNob3JzLmxlbmd0aCxcbiAgLy8gICAgICAgaSAgICAgICA9IDAsXG4gIC8vICAgICAgIGFuY2hvcixcbiAgLy8gICAgICAgY29kZUVsZW1lbnQsXG4gIC8vICAgICAgIHRleHRDb250ZW50O1xuICAvLyAgIGZvciAoOyBpPGxlbmd0aDsgaSsrKSB7XG4gIC8vICAgICBhbmNob3IgICAgICA9IGFuY2hvcnNbaV07XG4gIC8vICAgICBjb2RlRWxlbWVudCA9IGRvbS5nZXRQYXJlbnRFbGVtZW50KGFuY2hvciwgeyBub2RlTmFtZTogXCJjb2RlXCIgfSk7XG4gIC8vICAgICB0ZXh0Q29udGVudCA9IGRvbS5nZXRUZXh0Q29udGVudChhbmNob3IpO1xuICAvL1xuICAvLyAgICAgLy8gaWYgPGE+IGNvbnRhaW5zIHVybC1saWtlIHRleHQgY29udGVudCwgcmVuYW1lIGl0IHRvIDxjb2RlPiB0byBwcmV2ZW50IHJlLWF1dG9saW5raW5nXG4gIC8vICAgICAvLyBlbHNlIHJlcGxhY2UgPGE+IHdpdGggaXRzIGNoaWxkTm9kZXNcbiAgLy8gICAgIGlmICh0ZXh0Q29udGVudC5tYXRjaChkb20uYXV0b0xpbmsuVVJMX1JFR19FWFApICYmICFjb2RlRWxlbWVudCkge1xuICAvLyAgICAgICAvLyA8Y29kZT4gZWxlbWVudCBpcyB1c2VkIHRvIHByZXZlbnQgbGF0ZXIgYXV0by1saW5raW5nIG9mIHRoZSBjb250ZW50XG4gIC8vICAgICAgIGNvZGVFbGVtZW50ID0gZG9tLnJlbmFtZUVsZW1lbnQoYW5jaG9yLCBcImNvZGVcIik7XG4gIC8vICAgICB9IGVsc2Uge1xuICAvLyAgICAgICBkb20ucmVwbGFjZVdpdGhDaGlsZE5vZGVzKGFuY2hvcik7XG4gIC8vICAgICB9XG4gIC8vICAgfVxuICAvLyB9XG4gIC8vXG4gIC8vXG4gIHd5c2lodG1sNS5jb21tYW5kcy5jbGVhciA9IHtcbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICBjb21wb3Nlci5kb2MuZXhlY0NvbW1hbmQoJ3JlbW92ZUZvcm1hdCcpO1xuICAgICAgUkVHX0VYUCA9IC93eXNpd3lnLWNvbG9yLVthLXpdKy9nO1xuICAgICAgd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5leGVjKGNvbXBvc2VyLCBjb21tYW5kLCBcInNwYW5cIiwgXCJcIiwgUkVHX0VYUCk7XG4gICAgfVxuICB9O1xuICB3eXNpaHRtbDUuY29tbWFuZHMuaW5zZXJ0T3JkZXJlZExpc3QgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gZXhlYyhjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgdmFyIGRvYyA9IGNvbXBvc2VyLmRvYyxcbiAgICAgICAgICBzZWxlY3RlZE5vZGUgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCksXG4gICAgICAgICAgbGlzdCA9IHd5c2lodG1sNS5kb20uZ2V0UGFyZW50RWxlbWVudChzZWxlY3RlZE5vZGUsIHsgbm9kZU5hbWU6IFwiT0xcIiB9KSxcbiAgICAgICAgICBvdGhlckxpc3QgPSB3eXNpaHRtbDUuZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7IG5vZGVOYW1lOiBcIlVMXCIgfSksXG4gICAgICAgICAgdGVtcENsYXNzTmFtZSA9IFwiX3d5c2lodG1sNS10ZW1wLVwiICsgbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICAgICAgaXNFbXB0eSxcbiAgICAgICAgICB0ZW1wRWxlbWVudDtcblxuICAgICAgaWYgKGNvbXBvc2VyLmNvbW1hbmRzLnN1cHBvcnQoY29tbWFuZCkpIHtcbiAgICAgICAgZG9jLmV4ZWNDb21tYW5kKGNvbW1hbmQsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobGlzdCkge1xuICAgICAgICAvLyBVbndyYXAgbGlzdFxuICAgICAgICAvLyA8b2w+PGxpPmZvbzwvbGk+PGxpPmJhcjwvbGk+PC9vbD5cbiAgICAgICAgLy8gYmVjb21lczpcbiAgICAgICAgLy8gZm9vPGJyPmJhcjxicj5cbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlU2ltcGxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3eXNpaHRtbDUuZG9tLnJlc29sdmVMaXN0KGxpc3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob3RoZXJMaXN0KSB7XG4gICAgICAgIC8vIFR1cm4gYW4gdW5vcmRlcmVkIGxpc3QgaW50byBhbiBvcmRlcmVkIGxpc3RcbiAgICAgICAgLy8gPHVsPjxsaT5mb288L2xpPjxsaT5iYXI8L2xpPjwvdWw+XG4gICAgICAgIC8vIGJlY29tZXM6XG4gICAgICAgIC8vIDxvbD48bGk+Zm9vPC9saT48bGk+YmFyPC9saT48L29sPlxuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmVTaW1wbGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHd5c2lodG1sNS5kb20ucmVuYW1lRWxlbWVudChvdGhlckxpc3QsIFwib2xcIik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ3JlYXRlIGxpc3RcbiAgICAgICAgY29tcG9zZXIuY29tbWFuZHMuZXhlYyhcImZvcm1hdEJsb2NrXCIsIFwiZGl2XCIsIHRlbXBDbGFzc05hbWUpO1xuICAgICAgICB0ZW1wRWxlbWVudCA9IGRvYy5xdWVyeVNlbGVjdG9yKFwiLlwiICsgdGVtcENsYXNzTmFtZSk7XG4gICAgICAgIGlzRW1wdHkgPSB0ZW1wRWxlbWVudC5pbm5lckhUTUwgPT09IFwiXCIgfHwgdGVtcEVsZW1lbnQuaW5uZXJIVE1MID09PSB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFO1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmVTaW1wbGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGxpc3QgPSB3eXNpaHRtbDUuZG9tLmNvbnZlcnRUb0xpc3QodGVtcEVsZW1lbnQsIFwib2xcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZWxlY3ROb2RlKGxpc3QucXVlcnlTZWxlY3RvcihcImxpXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoY29tcG9zZXIpIHtcbiAgICAgIHZhciBzZWxlY3RlZE5vZGUgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCk7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwgeyBub2RlTmFtZTogXCJPTFwiIH0pO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsoZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWY7XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmluc2VydFVub3JkZXJlZExpc3QgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gZXhlYyhjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgdmFyIGRvYyA9IGNvbXBvc2VyLmRvYyxcbiAgICAgICAgICBzZWxlY3RlZE5vZGUgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCksXG4gICAgICAgICAgbGlzdCA9IHd5c2lodG1sNS5kb20uZ2V0UGFyZW50RWxlbWVudChzZWxlY3RlZE5vZGUsIHsgbm9kZU5hbWU6IFwiVUxcIiB9KSxcbiAgICAgICAgICBvdGhlckxpc3QgPSB3eXNpaHRtbDUuZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7IG5vZGVOYW1lOiBcIk9MXCIgfSksXG4gICAgICAgICAgdGVtcENsYXNzTmFtZSA9IFwiX3d5c2lodG1sNS10ZW1wLVwiICsgbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gICAgICAgICAgaXNFbXB0eSxcbiAgICAgICAgICB0ZW1wRWxlbWVudDtcblxuICAgICAgaWYgKGNvbXBvc2VyLmNvbW1hbmRzLnN1cHBvcnQoY29tbWFuZCkpIHtcbiAgICAgICAgZG9jLmV4ZWNDb21tYW5kKGNvbW1hbmQsIGZhbHNlLCBudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobGlzdCkge1xuICAgICAgICAvLyBVbndyYXAgbGlzdFxuICAgICAgICAvLyA8dWw+PGxpPmZvbzwvbGk+PGxpPmJhcjwvbGk+PC91bD5cbiAgICAgICAgLy8gYmVjb21lczpcbiAgICAgICAgLy8gZm9vPGJyPmJhcjxicj5cbiAgICAgICAgY29tcG9zZXIuc2VsZWN0aW9uLmV4ZWN1dGVBbmRSZXN0b3JlU2ltcGxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3eXNpaHRtbDUuZG9tLnJlc29sdmVMaXN0KGxpc3QpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob3RoZXJMaXN0KSB7XG4gICAgICAgIC8vIFR1cm4gYW4gb3JkZXJlZCBsaXN0IGludG8gYW4gdW5vcmRlcmVkIGxpc3RcbiAgICAgICAgLy8gPG9sPjxsaT5mb288L2xpPjxsaT5iYXI8L2xpPjwvb2w+XG4gICAgICAgIC8vIGJlY29tZXM6XG4gICAgICAgIC8vIDx1bD48bGk+Zm9vPC9saT48bGk+YmFyPC9saT48L3VsPlxuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmVTaW1wbGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHd5c2lodG1sNS5kb20ucmVuYW1lRWxlbWVudChvdGhlckxpc3QsIFwidWxcIik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ3JlYXRlIGxpc3RcbiAgICAgICAgY29tcG9zZXIuY29tbWFuZHMuZXhlYyhcImZvcm1hdEJsb2NrXCIsIFwiZGl2XCIsIHRlbXBDbGFzc05hbWUpO1xuICAgICAgICB0ZW1wRWxlbWVudCA9IGRvYy5xdWVyeVNlbGVjdG9yKFwiLlwiICsgdGVtcENsYXNzTmFtZSk7XG4gICAgICAgIGlzRW1wdHkgPSB0ZW1wRWxlbWVudC5pbm5lckhUTUwgPT09IFwiXCIgfHwgdGVtcEVsZW1lbnQuaW5uZXJIVE1MID09PSB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFO1xuICAgICAgICBjb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmVTaW1wbGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGxpc3QgPSB3eXNpaHRtbDUuZG9tLmNvbnZlcnRUb0xpc3QodGVtcEVsZW1lbnQsIFwidWxcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNFbXB0eSkge1xuICAgICAgICAgIGNvbXBvc2VyLnNlbGVjdGlvbi5zZWxlY3ROb2RlKGxpc3QucXVlcnlTZWxlY3RvcihcImxpXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoY29tcG9zZXIpIHtcbiAgICAgIHZhciBzZWxlY3RlZE5vZGUgPSBjb21wb3Nlci5zZWxlY3Rpb24uZ2V0U2VsZWN0ZWROb2RlKCk7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmRvbS5nZXRQYXJlbnRFbGVtZW50KHNlbGVjdGVkTm9kZSwgeyBub2RlTmFtZTogXCJVTFwiIH0pO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsoZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWY7XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLml0YWxpYyA9IHtcbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5leGVjKGNvbXBvc2VyLCBjb21tYW5kLCBcImlcIik7XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZShjb21wb3NlciwgY29tbWFuZCwgY29sb3IpIHtcbiAgICAgIC8vIGVsZW1lbnQub3duZXJEb2N1bWVudC5xdWVyeUNvbW1hbmRTdGF0ZShcIml0YWxpY1wiKSByZXN1bHRzOlxuICAgICAgLy8gZmlyZWZveDogb25seSA8aT5cbiAgICAgIC8vIGNocm9tZTogIDxpPiwgPGVtPiwgPGJsb2NrcXVvdGU+LCAuLi5cbiAgICAgIC8vIGllOiAgICAgIDxpPiwgPGVtPlxuICAgICAgLy8gb3BlcmE6ICAgb25seSA8aT5cbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0SW5saW5lLnN0YXRlKGNvbXBvc2VyLCBjb21tYW5kLCBcImlcIik7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpOyhmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZixcbiAgICAgIENMQVNTX05BTUUgPSBcInd5c2l3eWctdGV4dC1hbGlnbi1jZW50ZXJcIixcbiAgICAgIFJFR19FWFAgPSAvd3lzaXd5Zy10ZXh0LWFsaWduLVthLXpdKy9nO1xuXG4gIHd5c2lodG1sNS5jb21tYW5kcy5qdXN0aWZ5Q2VudGVyID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uIGV4ZWMoY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0QmxvY2suZXhlYyhjb21wb3NlciwgXCJmb3JtYXRCbG9ja1wiLCBudWxsLCBDTEFTU19OQU1FLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdEJsb2NrLnN0YXRlKGNvbXBvc2VyLCBcImZvcm1hdEJsb2NrXCIsIG51bGwsIENMQVNTX05BTUUsIFJFR19FWFApO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsoZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWYsXG4gICAgICBDTEFTU19OQU1FID0gXCJ3eXNpd3lnLXRleHQtYWxpZ24tbGVmdFwiLFxuICAgICAgUkVHX0VYUCA9IC93eXNpd3lnLXRleHQtYWxpZ24tW2Etel0rL2c7XG5cbiAgd3lzaWh0bWw1LmNvbW1hbmRzLmp1c3RpZnlMZWZ0ID0ge1xuICAgIGV4ZWM6IGZ1bmN0aW9uIGV4ZWMoY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0QmxvY2suZXhlYyhjb21wb3NlciwgXCJmb3JtYXRCbG9ja1wiLCBudWxsLCBDTEFTU19OQU1FLCBSRUdfRVhQKTtcbiAgICB9LFxuXG4gICAgc3RhdGU6IGZ1bmN0aW9uIHN0YXRlKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdEJsb2NrLnN0YXRlKGNvbXBvc2VyLCBcImZvcm1hdEJsb2NrXCIsIG51bGwsIENMQVNTX05BTUUsIFJFR19FWFApO1xuICAgIH0sXG5cbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XG4gICAgICByZXR1cm4gdW5kZWY7XG4gICAgfVxuICB9O1xufSkod3lzaWh0bWw1KTsoZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgdW5kZWYsXG4gICAgICBDTEFTU19OQU1FID0gXCJ3eXNpd3lnLXRleHQtYWxpZ24tcmlnaHRcIixcbiAgICAgIFJFR19FWFAgPSAvd3lzaXd5Zy10ZXh0LWFsaWduLVthLXpdKy9nO1xuXG4gIHd5c2lodG1sNS5jb21tYW5kcy5qdXN0aWZ5UmlnaHQgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gZXhlYyhjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRCbG9jay5leGVjKGNvbXBvc2VyLCBcImZvcm1hdEJsb2NrXCIsIG51bGwsIENMQVNTX05BTUUsIFJFR19FWFApO1xuICAgIH0sXG5cbiAgICBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQpIHtcbiAgICAgIHJldHVybiB3eXNpaHRtbDUuY29tbWFuZHMuZm9ybWF0QmxvY2suc3RhdGUoY29tcG9zZXIsIFwiZm9ybWF0QmxvY2tcIiwgbnVsbCwgQ0xBU1NfTkFNRSwgUkVHX0VYUCk7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiB1bmRlZjtcbiAgICB9XG4gIH07XG59KSh3eXNpaHRtbDUpOyhmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciB1bmRlZjtcbiAgd3lzaWh0bWw1LmNvbW1hbmRzLnVuZGVybGluZSA9IHtcbiAgICBleGVjOiBmdW5jdGlvbiBleGVjKGNvbXBvc2VyLCBjb21tYW5kKSB7XG4gICAgICByZXR1cm4gd3lzaWh0bWw1LmNvbW1hbmRzLmZvcm1hdElubGluZS5leGVjKGNvbXBvc2VyLCBjb21tYW5kLCBcInVcIik7XG4gICAgfSxcblxuICAgIHN0YXRlOiBmdW5jdGlvbiBzdGF0ZShjb21wb3NlciwgY29tbWFuZCkge1xuICAgICAgcmV0dXJuIHd5c2lodG1sNS5jb21tYW5kcy5mb3JtYXRJbmxpbmUuc3RhdGUoY29tcG9zZXIsIGNvbW1hbmQsIFwidVwiKTtcbiAgICB9LFxuXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgcmV0dXJuIHVuZGVmO1xuICAgIH1cbiAgfTtcbn0pKHd5c2lodG1sNSk7IC8qKlxuICAgICAgICAgICAgICAgKiBVbmRvIE1hbmFnZXIgZm9yIHd5c2lodG1sNVxuICAgICAgICAgICAgICAgKiBzbGlnaHRseSBpbnNwaXJlZCBieSBodHRwOi8vcm5pd2EuY29tL2VkaXRpbmcvdW5kb21hbmFnZXIuaHRtbCN0aGUtdW5kb21hbmFnZXItaW50ZXJmYWNlXG4gICAgICAgICAgICAgICAqL1xuKGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIFpfS0VZID0gOTAsXG4gICAgICBZX0tFWSA9IDg5LFxuICAgICAgQkFDS1NQQUNFX0tFWSA9IDgsXG4gICAgICBERUxFVEVfS0VZID0gNDYsXG4gICAgICBNQVhfSElTVE9SWV9FTlRSSUVTID0gNDAsXG4gICAgICBVTkRPX0hUTUwgPSAnPHNwYW4gaWQ9XCJfd3lzaWh0bWw1LXVuZG9cIiBjbGFzcz1cIl93eXNpaHRtbDUtdGVtcFwiPicgKyB3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFICsgJzwvc3Bhbj4nLFxuICAgICAgUkVET19IVE1MID0gJzxzcGFuIGlkPVwiX3d5c2lodG1sNS1yZWRvXCIgY2xhc3M9XCJfd3lzaWh0bWw1LXRlbXBcIj4nICsgd3lzaWh0bWw1LklOVklTSUJMRV9TUEFDRSArICc8L3NwYW4+JyxcbiAgICAgIGRvbSA9IHd5c2lodG1sNS5kb207XG5cbiAgZnVuY3Rpb24gY2xlYW5UZW1wRWxlbWVudHMoZG9jKSB7XG4gICAgdmFyIHRlbXBFbGVtZW50O1xuICAgIHdoaWxlICh0ZW1wRWxlbWVudCA9IGRvYy5xdWVyeVNlbGVjdG9yKFwiLl93eXNpaHRtbDUtdGVtcFwiKSkge1xuICAgICAgdGVtcEVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0ZW1wRWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgd3lzaWh0bWw1LlVuZG9NYW5hZ2VyID0gd3lzaWh0bWw1LmxhbmcuRGlzcGF0Y2hlci5leHRlbmQoXG4gIC8qKiBAc2NvcGUgd3lzaWh0bWw1LlVuZG9NYW5hZ2VyLnByb3RvdHlwZSAqL3tcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gY29uc3RydWN0b3IoZWRpdG9yKSB7XG4gICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgIHRoaXMuY29tcG9zZXIgPSBlZGl0b3IuY29tcG9zZXI7XG4gICAgICB0aGlzLmVsZW1lbnQgPSB0aGlzLmNvbXBvc2VyLmVsZW1lbnQ7XG4gICAgICB0aGlzLmhpc3RvcnkgPSBbdGhpcy5jb21wb3Nlci5nZXRWYWx1ZSgpXTtcbiAgICAgIHRoaXMucG9zaXRpb24gPSAxO1xuXG4gICAgICAvLyBVbmRvIG1hbmFnZXIgY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIGluIGJyb3dzZXJzIHdobyBoYXZlIHRoZSBpbnNlcnRIVE1MIGNvbW1hbmQgKG5vdCBJRSlcbiAgICAgIGlmICh0aGlzLmNvbXBvc2VyLmNvbW1hbmRzLnN1cHBvcnQoXCJpbnNlcnRIVE1MXCIpKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmUoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX29ic2VydmU6IGZ1bmN0aW9uIF9vYnNlcnZlKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgIGRvYyA9IHRoaXMuY29tcG9zZXIuc2FuZGJveC5nZXREb2N1bWVudCgpLFxuICAgICAgICAgIGxhc3RLZXk7XG5cbiAgICAgIC8vIENhdGNoIENUUkwrWiBhbmQgQ1RSTCtZXG4gICAgICBkb20ub2JzZXJ2ZSh0aGlzLmVsZW1lbnQsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmFsdEtleSB8fCAhZXZlbnQuY3RybEtleSAmJiAhZXZlbnQubWV0YUtleSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZSxcbiAgICAgICAgICAgIGlzVW5kbyA9IGtleUNvZGUgPT09IFpfS0VZICYmICFldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgIGlzUmVkbyA9IGtleUNvZGUgPT09IFpfS0VZICYmIGV2ZW50LnNoaWZ0S2V5IHx8IGtleUNvZGUgPT09IFlfS0VZO1xuXG4gICAgICAgIGlmIChpc1VuZG8pIHtcbiAgICAgICAgICB0aGF0LnVuZG8oKTtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUmVkbykge1xuICAgICAgICAgIHRoYXQucmVkbygpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBDYXRjaCBkZWxldGUgYW5kIGJhY2tzcGFjZVxuICAgICAgZG9tLm9ic2VydmUodGhpcy5lbGVtZW50LCBcImtleWRvd25cIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBrZXlDb2RlID0gZXZlbnQua2V5Q29kZTtcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IGxhc3RLZXkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0S2V5ID0ga2V5Q29kZTtcblxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gQkFDS1NQQUNFX0tFWSB8fCBrZXlDb2RlID09PSBERUxFVEVfS0VZKSB7XG4gICAgICAgICAgdGhhdC50cmFuc2FjdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gTm93IHRoaXMgaXMgdmVyeSBoYWNreTpcbiAgICAgIC8vIFRoZXNlIGRheXMgYnJvd3NlcnMgZG9uJ3Qgb2ZmZXIgYSB1bmRvL3JlZG8gZXZlbnQgd2hpY2ggd2UgY291bGQgaG9vayBpbnRvXG4gICAgICAvLyB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB1c2VyIGhpdHMgdW5kby9yZWRvIGluIHRoZSBjb250ZXh0bWVudS5cbiAgICAgIC8vIFRoZXJlZm9yZSB3ZSBzaW1wbHkgaW5zZXJ0IHR3byBlbGVtZW50cyBhcyBzb29uIGFzIHRoZSBjb250ZXh0bWVudSBnZXRzIG9wZW5lZC5cbiAgICAgIC8vIFRoZSBsYXN0IGVsZW1lbnQgYmVpbmcgaW5zZXJ0ZWQgd2lsbCBiZSBpbW1lZGlhdGVseSBiZSByZW1vdmVkIGFnYWluIGJ5IGEgZXhleENvbW1hbmQoXCJ1bmRvXCIpXG4gICAgICAvLyAgPT4gV2hlbiB0aGUgc2Vjb25kIGVsZW1lbnQgYXBwZWFycyBpbiB0aGUgZG9tIHRyZWUgdGhlbiB3ZSBrbm93IHRoZSB1c2VyIGNsaWNrZWQgXCJyZWRvXCIgaW4gdGhlIGNvbnRleHQgbWVudVxuICAgICAgLy8gID0+IFdoZW4gdGhlIGZpcnN0IGVsZW1lbnQgZGlzYXBwZWFycyBmcm9tIHRoZSBkb20gdHJlZSB0aGVuIHdlIGtub3cgdGhlIHVzZXIgY2xpY2tlZCBcInVuZG9cIiBpbiB0aGUgY29udGV4dCBtZW51XG4gICAgICBpZiAod3lzaWh0bWw1LmJyb3dzZXIuaGFzVW5kb0luQ29udGV4dE1lbnUoKSkge1xuICAgICAgICB2YXIgaW50ZXJ2YWwsXG4gICAgICAgICAgICBvYnNlcnZlZCxcbiAgICAgICAgICAgIGNsZWFuVXAgPSBmdW5jdGlvbiBjbGVhblVwKCkge1xuICAgICAgICAgIGNsZWFuVGVtcEVsZW1lbnRzKGRvYyk7XG4gICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZG9tLm9ic2VydmUodGhpcy5lbGVtZW50LCBcImNvbnRleHRtZW51XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjbGVhblVwKCk7XG4gICAgICAgICAgdGhhdC5jb21wb3Nlci5zZWxlY3Rpb24uZXhlY3V0ZUFuZFJlc3RvcmVTaW1wbGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoYXQuZWxlbWVudC5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgdGhhdC5jb21wb3Nlci5zZWxlY3Rpb24uc2V0QWZ0ZXIodGhhdC5lbGVtZW50Lmxhc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGVuYWJsZSB1bmRvIGJ1dHRvbiBpbiBjb250ZXh0IG1lbnVcbiAgICAgICAgICAgIGRvYy5leGVjQ29tbWFuZChcImluc2VydEhUTUxcIiwgZmFsc2UsIFVORE9fSFRNTCk7XG4gICAgICAgICAgICAvLyBlbmFibGUgcmVkbyBidXR0b24gaW4gY29udGV4dCBtZW51XG4gICAgICAgICAgICBkb2MuZXhlY0NvbW1hbmQoXCJpbnNlcnRIVE1MXCIsIGZhbHNlLCBSRURPX0hUTUwpO1xuICAgICAgICAgICAgZG9jLmV4ZWNDb21tYW5kKFwidW5kb1wiLCBmYWxzZSwgbnVsbCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChkb2MuZ2V0RWxlbWVudEJ5SWQoXCJfd3lzaWh0bWw1LXJlZG9cIikpIHtcbiAgICAgICAgICAgICAgY2xlYW5VcCgpO1xuICAgICAgICAgICAgICB0aGF0LnJlZG8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCA0MDApO1xuXG4gICAgICAgICAgaWYgKCFvYnNlcnZlZCkge1xuICAgICAgICAgICAgb2JzZXJ2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZG9tLm9ic2VydmUoZG9jdW1lbnQsIFwibW91c2Vkb3duXCIsIGNsZWFuVXApO1xuICAgICAgICAgICAgZG9tLm9ic2VydmUoZG9jLCBbXCJtb3VzZWRvd25cIiwgXCJwYXN0ZVwiLCBcImN1dFwiLCBcImNvcHlcIl0sIGNsZWFuVXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWRpdG9yLm9ic2VydmUoXCJuZXd3b3JkOmNvbXBvc2VyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhhdC50cmFuc2FjdCgpO1xuICAgICAgfSkub2JzZXJ2ZShcImJlZm9yZWNvbW1hbmQ6Y29tcG9zZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGF0LnRyYW5zYWN0KCk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgdHJhbnNhY3Q6IGZ1bmN0aW9uIHRyYW5zYWN0KCkge1xuICAgICAgdmFyIHByZXZpb3VzSHRtbCA9IHRoaXMuaGlzdG9yeVt0aGlzLnBvc2l0aW9uIC0gMV0sXG4gICAgICAgICAgY3VycmVudEh0bWwgPSB0aGlzLmNvbXBvc2VyLmdldFZhbHVlKCk7XG5cbiAgICAgIGlmIChjdXJyZW50SHRtbCA9PSBwcmV2aW91c0h0bWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy5oaXN0b3J5Lmxlbmd0aCA9IHRoaXMucG9zaXRpb247XG4gICAgICBpZiAobGVuZ3RoID4gTUFYX0hJU1RPUllfRU5UUklFUykge1xuICAgICAgICB0aGlzLmhpc3Rvcnkuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi0tO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBvc2l0aW9uKys7XG4gICAgICB0aGlzLmhpc3RvcnkucHVzaChjdXJyZW50SHRtbCk7XG4gICAgfSxcblxuICAgIHVuZG86IGZ1bmN0aW9uIHVuZG8oKSB7XG4gICAgICB0aGlzLnRyYW5zYWN0KCk7XG5cbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uIDw9IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldCh0aGlzLmhpc3RvcnlbLS10aGlzLnBvc2l0aW9uIC0gMV0pO1xuICAgICAgdGhpcy5lZGl0b3IuZmlyZShcInVuZG86Y29tcG9zZXJcIik7XG4gICAgfSxcblxuICAgIHJlZG86IGZ1bmN0aW9uIHJlZG8oKSB7XG4gICAgICBpZiAodGhpcy5wb3NpdGlvbiA+PSB0aGlzLmhpc3RvcnkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXQodGhpcy5oaXN0b3J5WysrdGhpcy5wb3NpdGlvbiAtIDFdKTtcbiAgICAgIHRoaXMuZWRpdG9yLmZpcmUoXCJyZWRvOmNvbXBvc2VyXCIpO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChodG1sKSB7XG4gICAgICB0aGlzLmNvbXBvc2VyLnNldFZhbHVlKGh0bWwpO1xuICAgICAgdGhpcy5lZGl0b3IuZm9jdXModHJ1ZSk7XG4gICAgfVxuICB9KTtcbn0pKHd5c2lodG1sNSk7XG4vKipcbiAqIFRPRE86IHRoZSBmb2xsb3dpbmcgbWV0aG9kcyBzdGlsbCBuZWVkIHVuaXQgdGVzdCBjb3ZlcmFnZVxuICovXG53eXNpaHRtbDUudmlld3MuVmlldyA9IEJhc2UuZXh0ZW5kKFxuLyoqIEBzY29wZSB3eXNpaHRtbDUudmlld3MuVmlldy5wcm90b3R5cGUgKi97XG4gIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBjb25zdHJ1Y3RvcihwYXJlbnQsIHRleHRhcmVhRWxlbWVudCwgY29uZmlnKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5lbGVtZW50ID0gdGV4dGFyZWFFbGVtZW50O1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuXG4gICAgdGhpcy5fb2JzZXJ2ZVZpZXdDaGFuZ2UoKTtcbiAgfSxcblxuICBfb2JzZXJ2ZVZpZXdDaGFuZ2U6IGZ1bmN0aW9uIF9vYnNlcnZlVmlld0NoYW5nZSgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhpcy5wYXJlbnQub2JzZXJ2ZShcImJlZm9yZWxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC5wYXJlbnQub2JzZXJ2ZShcImNoYW5nZV92aWV3XCIsIGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgICAgIGlmICh2aWV3ID09PSB0aGF0Lm5hbWUpIHtcbiAgICAgICAgICB0aGF0LnBhcmVudC5jdXJyZW50VmlldyA9IHRoYXQ7XG4gICAgICAgICAgdGhhdC5zaG93KCk7XG4gICAgICAgICAgLy8gVXNpbmcgdGlueSBkZWxheSBoZXJlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBwbGFjZWhvbGRlciBpcyBzZXQgYmVmb3JlIGZvY3VzaW5nXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LmZvY3VzKCk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhhdC5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LFxuXG4gIGZvY3VzOiBmdW5jdGlvbiBmb2N1cygpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIjpmb2N1c1wiKSA9PT0gdGhpcy5lbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuZWxlbWVudC5mb2N1cygpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0sXG5cbiAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICB9LFxuXG4gIHNob3c6IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICB9LFxuXG4gIGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiZGlzYWJsZWRcIik7XG4gIH0sXG5cbiAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpO1xuICB9XG59KTsoZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgZG9tID0gd3lzaWh0bWw1LmRvbSxcbiAgICAgIGJyb3dzZXIgPSB3eXNpaHRtbDUuYnJvd3NlcjtcblxuICB3eXNpaHRtbDUudmlld3MuQ29tcG9zZXIgPSB3eXNpaHRtbDUudmlld3MuVmlldy5leHRlbmQoXG4gIC8qKiBAc2NvcGUgd3lzaWh0bWw1LnZpZXdzLkNvbXBvc2VyLnByb3RvdHlwZSAqL3tcbiAgICBuYW1lOiBcImNvbXBvc2VyXCIsXG5cbiAgICAvLyBOZWVkZWQgZm9yIGZpcmVmb3ggaW4gb3JkZXIgdG8gZGlzcGxheSBhIHByb3BlciBjYXJldCBpbiBhbiBlbXB0eSBjb250ZW50RWRpdGFibGVcbiAgICBDQVJFVF9IQUNLOiBcIjxicj5cIixcblxuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBjb25zdHJ1Y3RvcihwYXJlbnQsIHRleHRhcmVhRWxlbWVudCwgY29uZmlnKSB7XG4gICAgICB0aGlzLmJhc2UocGFyZW50LCB0ZXh0YXJlYUVsZW1lbnQsIGNvbmZpZyk7XG4gICAgICB0aGlzLnRleHRhcmVhID0gdGhpcy5wYXJlbnQudGV4dGFyZWE7XG4gICAgICB0aGlzLl9pbml0U2FuZGJveCgpO1xuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gYnJvd3Nlci5kaXNwbGF5c0NhcmV0SW5FbXB0eUNvbnRlbnRFZGl0YWJsZUNvcnJlY3RseSgpID8gXCJcIiA6IHRoaXMuQ0FSRVRfSEFDSztcbiAgICB9LFxuXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKHBhcnNlKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLmlzRW1wdHkoKSA/IFwiXCIgOiB3eXNpaHRtbDUucXVpcmtzLmdldENvcnJlY3RJbm5lckhUTUwodGhpcy5lbGVtZW50KTtcblxuICAgICAgaWYgKHBhcnNlKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy5wYXJlbnQucGFyc2UodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXBsYWNlIGFsbCBcInplcm8gd2lkdGggbm8gYnJlYWtpbmcgc3BhY2VcIiBjaGFyc1xuICAgICAgLy8gd2hpY2ggYXJlIHVzZWQgYXMgaGFja3MgdG8gZW5hYmxlIHNvbWUgZnVuY3Rpb25hbGl0aWVzXG4gICAgICAvLyBBbHNvIHJlbW92ZSBhbGwgQ0FSRVQgaGFja3MgdGhhdCBzb21laG93IGdvdCBsZWZ0XG4gICAgICB2YWx1ZSA9IHd5c2lodG1sNS5sYW5nLnN0cmluZyh2YWx1ZSkucmVwbGFjZSh3eXNpaHRtbDUuSU5WSVNJQkxFX1NQQUNFKS5ieShcIlwiKTtcblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUoaHRtbCwgcGFyc2UpIHtcbiAgICAgIGlmIChwYXJzZSkge1xuICAgICAgICBodG1sID0gdGhpcy5wYXJlbnQucGFyc2UoaHRtbCk7XG4gICAgICB9XG4gICAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9LFxuXG4gICAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHRoaXMuaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSB0aGlzLl9kaXNwbGF5U3R5bGUgfHwgXCJcIjtcblxuICAgICAgLy8gRmlyZWZveCBuZWVkcyB0aGlzLCBvdGhlcndpc2UgY29udGVudEVkaXRhYmxlIGJlY29tZXMgdW5lZGl0YWJsZVxuICAgICAgdGhpcy5kaXNhYmxlKCk7XG4gICAgICB0aGlzLmVuYWJsZSgpO1xuICAgIH0sXG5cbiAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdGhpcy5fZGlzcGxheVN0eWxlID0gZG9tLmdldFN0eWxlKFwiZGlzcGxheVwiKS5mcm9tKHRoaXMuaWZyYW1lKTtcbiAgICAgIGlmICh0aGlzLl9kaXNwbGF5U3R5bGUgPT09IFwibm9uZVwiKSB7XG4gICAgICAgIHRoaXMuX2Rpc3BsYXlTdHlsZSA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfSxcblxuICAgIGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIpO1xuICAgICAgdGhpcy5iYXNlKCk7XG4gICAgfSxcblxuICAgIGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImNvbnRlbnRFZGl0YWJsZVwiLCBcInRydWVcIik7XG4gICAgICB0aGlzLmJhc2UoKTtcbiAgICB9LFxuXG4gICAgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKHNldFRvRW5kKSB7XG4gICAgICAvLyBJRSA4IGZpcmVzIHRoZSBmb2N1cyBldmVudCBhZnRlciAuZm9jdXMoKVxuICAgICAgLy8gVGhpcyBpcyBuZWVkZWQgYnkgb3VyIHNpbXVsYXRlX3BsYWNlaG9sZGVyLmpzIHRvIHdvcmtcbiAgICAgIC8vIHRoZXJlZm9yZSB3ZSBjbGVhciBpdCBvdXJzZWx2ZXMgdGhpcyB0aW1lXG4gICAgICBpZiAod3lzaWh0bWw1LmJyb3dzZXIuZG9lc0FzeW5jRm9jdXMoKSAmJiB0aGlzLmhhc1BsYWNlaG9sZGVyU2V0KCkpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJhc2UoKTtcblxuICAgICAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuZWxlbWVudC5sYXN0Q2hpbGQ7XG4gICAgICBpZiAoc2V0VG9FbmQgJiYgbGFzdENoaWxkKSB7XG4gICAgICAgIGlmIChsYXN0Q2hpbGQubm9kZU5hbWUgPT09IFwiQlJcIikge1xuICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldEJlZm9yZSh0aGlzLmVsZW1lbnQubGFzdENoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zZXRBZnRlcih0aGlzLmVsZW1lbnQubGFzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRUZXh0Q29udGVudDogZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgICByZXR1cm4gZG9tLmdldFRleHRDb250ZW50KHRoaXMuZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGhhc1BsYWNlaG9sZGVyU2V0OiBmdW5jdGlvbiBoYXNQbGFjZWhvbGRlclNldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRleHRDb250ZW50KCkgPT0gdGhpcy50ZXh0YXJlYS5lbGVtZW50LmdldEF0dHJpYnV0ZShcInBsYWNlaG9sZGVyXCIpO1xuICAgIH0sXG5cbiAgICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgdmFyIGlubmVySFRNTCA9IHRoaXMuZWxlbWVudC5pbm5lckhUTUwsXG4gICAgICAgICAgZWxlbWVudHNXaXRoVmlzdWFsVmFsdWUgPSBcImJsb2NrcXVvdGUsIHVsLCBvbCwgaW1nLCBlbWJlZCwgb2JqZWN0LCB0YWJsZSwgaWZyYW1lLCBzdmcsIHZpZGVvLCBhdWRpbywgYnV0dG9uLCBpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYVwiO1xuICAgICAgcmV0dXJuIGlubmVySFRNTCA9PT0gXCJcIiB8fCBpbm5lckhUTUwgPT09IHRoaXMuQ0FSRVRfSEFDSyB8fCB0aGlzLmhhc1BsYWNlaG9sZGVyU2V0KCkgfHwgdGhpcy5nZXRUZXh0Q29udGVudCgpID09PSBcIlwiICYmICF0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50c1dpdGhWaXN1YWxWYWx1ZSk7XG4gICAgfSxcblxuICAgIF9pbml0U2FuZGJveDogZnVuY3Rpb24gX2luaXRTYW5kYm94KCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICB0aGlzLnNhbmRib3ggPSBuZXcgZG9tLlNhbmRib3goZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGF0Ll9jcmVhdGUoKTtcbiAgICAgIH0sIHtcbiAgICAgICAgc3R5bGVzaGVldHM6IHRoaXMuY29uZmlnLnN0eWxlc2hlZXRzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuaWZyYW1lID0gdGhpcy5zYW5kYm94LmdldElmcmFtZSgpO1xuXG4gICAgICAvLyBDcmVhdGUgaGlkZGVuIGZpZWxkIHdoaWNoIHRlbGxzIHRoZSBzZXJ2ZXIgYWZ0ZXIgc3VibWl0LCB0aGF0IHRoZSB1c2VyIHVzZWQgYW4gd3lzaXd5ZyBlZGl0b3JcbiAgICAgIHZhciBoaWRkZW5GaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgIGhpZGRlbkZpZWxkLnR5cGUgPSBcImhpZGRlblwiO1xuICAgICAgaGlkZGVuRmllbGQubmFtZSA9IFwiX3d5c2lodG1sNV9tb2RlXCI7XG4gICAgICBoaWRkZW5GaWVsZC52YWx1ZSA9IDE7XG5cbiAgICAgIC8vIFN0b3JlIHJlZmVyZW5jZSB0byBjdXJyZW50IHd5c2lodG1sNSBpbnN0YW5jZSBvbiB0aGUgdGV4dGFyZWEgZWxlbWVudFxuICAgICAgdmFyIHRleHRhcmVhRWxlbWVudCA9IHRoaXMudGV4dGFyZWEuZWxlbWVudDtcbiAgICAgIGRvbS5pbnNlcnQodGhpcy5pZnJhbWUpLmFmdGVyKHRleHRhcmVhRWxlbWVudCk7XG4gICAgICBkb20uaW5zZXJ0KGhpZGRlbkZpZWxkKS5hZnRlcih0ZXh0YXJlYUVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICBfY3JlYXRlOiBmdW5jdGlvbiBfY3JlYXRlKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICB0aGlzLmRvYyA9IHRoaXMuc2FuZGJveC5nZXREb2N1bWVudCgpO1xuICAgICAgdGhpcy5lbGVtZW50ID0gdGhpcy5kb2MuYm9keTtcbiAgICAgIHRoaXMudGV4dGFyZWEgPSB0aGlzLnBhcmVudC50ZXh0YXJlYTtcbiAgICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLnRleHRhcmVhLmdldFZhbHVlKHRydWUpO1xuICAgICAgdGhpcy5lbmFibGUoKTtcblxuICAgICAgLy8gTWFrZSBzdXJlIG91ciBzZWxlY3Rpb24gaGFuZGxlciBpcyByZWFkeVxuICAgICAgdGhpcy5zZWxlY3Rpb24gPSBuZXcgd3lzaWh0bWw1LlNlbGVjdGlvbih0aGlzLnBhcmVudCk7XG5cbiAgICAgIC8vIE1ha2Ugc3VyZSBjb21tYW5kcyBkaXNwYXRjaGVyIGlzIHJlYWR5XG4gICAgICB0aGlzLmNvbW1hbmRzID0gbmV3IHd5c2lodG1sNS5Db21tYW5kcyh0aGlzLnBhcmVudCk7XG5cbiAgICAgIGRvbS5jb3B5QXR0cmlidXRlcyhbXCJjbGFzc05hbWVcIiwgXCJzcGVsbGNoZWNrXCIsIFwidGl0bGVcIiwgXCJsYW5nXCIsIFwiZGlyXCIsIFwiYWNjZXNzS2V5XCJdKS5mcm9tKHRoaXMudGV4dGFyZWEuZWxlbWVudCkudG8odGhpcy5lbGVtZW50KTtcblxuICAgICAgZG9tLmFkZENsYXNzKHRoaXMuZWxlbWVudCwgdGhpcy5jb25maWcuY29tcG9zZXJDbGFzc05hbWUpO1xuXG4gICAgICAvLyBNYWtlIHRoZSBlZGl0b3IgbG9vayBsaWtlIHRoZSBvcmlnaW5hbCB0ZXh0YXJlYSwgYnkgc3luY2luZyBzdHlsZXNcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5zdHlsZSkge1xuICAgICAgICB0aGlzLnN0eWxlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub2JzZXJ2ZSgpO1xuXG4gICAgICB2YXIgbmFtZSA9IHRoaXMuY29uZmlnLm5hbWU7XG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBkb20uYWRkQ2xhc3ModGhpcy5lbGVtZW50LCBuYW1lKTtcbiAgICAgICAgZG9tLmFkZENsYXNzKHRoaXMuaWZyYW1lLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2ltdWxhdGUgaHRtbDUgcGxhY2Vob2xkZXIgYXR0cmlidXRlIG9uIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50XG4gICAgICB2YXIgcGxhY2Vob2xkZXJUZXh0ID0gdHlwZW9mIHRoaXMuY29uZmlnLnBsYWNlaG9sZGVyID09PSBcInN0cmluZ1wiID8gdGhpcy5jb25maWcucGxhY2Vob2xkZXIgOiB0aGlzLnRleHRhcmVhLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIik7XG4gICAgICBpZiAocGxhY2Vob2xkZXJUZXh0KSB7XG4gICAgICAgIGRvbS5zaW11bGF0ZVBsYWNlaG9sZGVyKHRoaXMucGFyZW50LCB0aGlzLCBwbGFjZWhvbGRlclRleHQpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgYnJvd3NlciBhdm9pZHMgdXNpbmcgaW5saW5lIHN0eWxlcyB3aGVuZXZlciBwb3NzaWJsZVxuICAgICAgdGhpcy5jb21tYW5kcy5leGVjKFwic3R5bGVXaXRoQ1NTXCIsIGZhbHNlKTtcblxuICAgICAgdGhpcy5faW5pdEF1dG9MaW5raW5nKCk7XG4gICAgICB0aGlzLl9pbml0T2JqZWN0UmVzaXppbmcoKTtcbiAgICAgIHRoaXMuX2luaXRVbmRvTWFuYWdlcigpO1xuXG4gICAgICAvLyBTaW11bGF0ZSBodG1sNSBhdXRvZm9jdXMgb24gY29udGVudEVkaXRhYmxlIGVsZW1lbnRcbiAgICAgIGlmICh0aGlzLnRleHRhcmVhLmVsZW1lbnQuaGFzQXR0cmlidXRlKFwiYXV0b2ZvY3VzXCIpIHx8IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCI6Zm9jdXNcIikgPT0gdGhpcy50ZXh0YXJlYS5lbGVtZW50KSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQuZm9jdXMoKTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICAgIH1cblxuICAgICAgd3lzaWh0bWw1LnF1aXJrcy5pbnNlcnRMaW5lQnJlYWtPblJldHVybih0aGlzKTtcblxuICAgICAgLy8gSUUgc29tZXRpbWVzIGxlYXZlcyBhIHNpbmdsZSBwYXJhZ3JhcGgsIHdoaWNoIGNhbid0IGJlIHJlbW92ZWQgYnkgdGhlIHVzZXJcbiAgICAgIGlmICghYnJvd3Nlci5jbGVhcnNDb250ZW50RWRpdGFibGVDb3JyZWN0bHkoKSkge1xuICAgICAgICB3eXNpaHRtbDUucXVpcmtzLmVuc3VyZVByb3BlckNsZWFyaW5nKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWJyb3dzZXIuY2xlYXJzTGlzdHNJbkNvbnRlbnRFZGl0YWJsZUNvcnJlY3RseSgpKSB7XG4gICAgICAgIHd5c2lodG1sNS5xdWlya3MuZW5zdXJlUHJvcGVyQ2xlYXJpbmdPZkxpc3RzKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdXAgYSBzeW5jIHRoYXQgbWFrZXMgc3VyZSB0aGF0IHRleHRhcmVhIGFuZCBlZGl0b3IgaGF2ZSB0aGUgc2FtZSBjb250ZW50XG4gICAgICBpZiAodGhpcy5pbml0U3luYyAmJiB0aGlzLmNvbmZpZy5zeW5jKSB7XG4gICAgICAgIHRoaXMuaW5pdFN5bmMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gT2theSBoaWRlIHRoZSB0ZXh0YXJlYSwgd2UgYXJlIHJlYWR5IHRvIGdvXG4gICAgICB0aGlzLnRleHRhcmVhLmhpZGUoKTtcblxuICAgICAgLy8gRmlyZSBnbG9iYWwgKGJlZm9yZS0pbG9hZCBldmVudFxuICAgICAgdGhpcy5wYXJlbnQuZmlyZShcImJlZm9yZWxvYWRcIikuZmlyZShcImxvYWRcIik7XG4gICAgfSxcblxuICAgIF9pbml0QXV0b0xpbmtpbmc6IGZ1bmN0aW9uIF9pbml0QXV0b0xpbmtpbmcoKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgc3VwcG9ydHNEaXNhYmxpbmdPZkF1dG9MaW5raW5nID0gYnJvd3Nlci5jYW5EaXNhYmxlQXV0b0xpbmtpbmcoKSxcbiAgICAgICAgICBzdXBwb3J0c0F1dG9MaW5raW5nID0gYnJvd3Nlci5kb2VzQXV0b0xpbmtpbmdJbkNvbnRlbnRFZGl0YWJsZSgpO1xuICAgICAgaWYgKHN1cHBvcnRzRGlzYWJsaW5nT2ZBdXRvTGlua2luZykge1xuICAgICAgICB0aGlzLmNvbW1hbmRzLmV4ZWMoXCJhdXRvVXJsRGV0ZWN0XCIsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmNvbmZpZy5hdXRvTGluaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIE9ubHkgZG8gdGhlIGF1dG8gbGlua2luZyBieSBvdXJzZWx2ZXMgd2hlbiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgYXV0byBsaW5raW5nXG4gICAgICAvLyBPUiB3aGVuIGhlIHN1cHBvcnRzIGF1dG8gbGlua2luZyBidXQgd2Ugd2VyZSBhYmxlIHRvIHR1cm4gaXQgb2ZmIChJRTkrKVxuICAgICAgaWYgKCFzdXBwb3J0c0F1dG9MaW5raW5nIHx8IHN1cHBvcnRzQXV0b0xpbmtpbmcgJiYgc3VwcG9ydHNEaXNhYmxpbmdPZkF1dG9MaW5raW5nKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm9ic2VydmUoXCJuZXd3b3JkOmNvbXBvc2VyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZShmdW5jdGlvbiAoc3RhcnRDb250YWluZXIsIGVuZENvbnRhaW5lcikge1xuICAgICAgICAgICAgZG9tLmF1dG9MaW5rKGVuZENvbnRhaW5lci5wYXJlbnROb2RlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFzc3VtaW5nIHdlIGhhdmUgdGhlIGZvbGxvd2luZzpcbiAgICAgIC8vICA8YSBocmVmPVwiaHR0cDovL3d3dy5nb29nbGUuZGVcIj5odHRwOi8vd3d3Lmdvb2dsZS5kZTwvYT5cbiAgICAgIC8vIElmIGEgdXNlciBub3cgY2hhbmdlcyB0aGUgdXJsIGluIHRoZSBpbm5lckhUTUwgd2Ugd2FudCB0byBtYWtlIHN1cmUgdGhhdFxuICAgICAgLy8gaXQncyBzeW5jaHJvbml6ZWQgd2l0aCB0aGUgaHJlZiBhdHRyaWJ1dGUgKGFzIGxvbmcgYXMgdGhlIGlubmVySFRNTCBpcyBzdGlsbCBhIHVybClcbiAgICAgIHZhciAvLyBVc2UgYSBsaXZlIE5vZGVMaXN0IHRvIGNoZWNrIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBsaW5rcyBpbiB0aGUgZG9jdW1lbnRcbiAgICAgIGxpbmtzID0gdGhpcy5zYW5kYm94LmdldERvY3VtZW50KCkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJhXCIpLFxuXG4gICAgICAvLyBUaGUgYXV0b0xpbmsgaGVscGVyIG1ldGhvZCByZXZlYWxzIGEgcmVnIGV4cCB0byBkZXRlY3QgY29ycmVjdCB1cmxzXG4gICAgICB1cmxSZWdFeHAgPSBkb20uYXV0b0xpbmsuVVJMX1JFR19FWFAsXG4gICAgICAgICAgZ2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiBnZXRUZXh0Q29udGVudChlbGVtZW50KSB7XG4gICAgICAgIHZhciB0ZXh0Q29udGVudCA9IHd5c2lodG1sNS5sYW5nLnN0cmluZyhkb20uZ2V0VGV4dENvbnRlbnQoZWxlbWVudCkpLnRyaW0oKTtcbiAgICAgICAgaWYgKHRleHRDb250ZW50LnN1YnN0cigwLCA0KSA9PT0gXCJ3d3cuXCIpIHtcbiAgICAgICAgICB0ZXh0Q29udGVudCA9IFwiaHR0cDovL1wiICsgdGV4dENvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHRDb250ZW50O1xuICAgICAgfTtcblxuICAgICAgZG9tLm9ic2VydmUodGhpcy5lbGVtZW50LCBcImtleWRvd25cIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghbGlua3MubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNlbGVjdGVkTm9kZSA9IHRoYXQuc2VsZWN0aW9uLmdldFNlbGVjdGVkTm9kZShldmVudC50YXJnZXQub3duZXJEb2N1bWVudCksXG4gICAgICAgICAgICBsaW5rID0gZG9tLmdldFBhcmVudEVsZW1lbnQoc2VsZWN0ZWROb2RlLCB7IG5vZGVOYW1lOiBcIkFcIiB9LCA0KSxcbiAgICAgICAgICAgIHRleHRDb250ZW50O1xuXG4gICAgICAgIGlmICghbGluaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHRDb250ZW50ID0gZ2V0VGV4dENvbnRlbnQobGluayk7XG4gICAgICAgIC8vIGtleWRvd24gaXMgZmlyZWQgYmVmb3JlIHRoZSBhY3R1YWwgY29udGVudCBpcyBjaGFuZ2VkXG4gICAgICAgIC8vIHRoZXJlZm9yZSB3ZSBzZXQgYSB0aW1lb3V0IHRvIGNoYW5nZSB0aGUgaHJlZlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgbmV3VGV4dENvbnRlbnQgPSBnZXRUZXh0Q29udGVudChsaW5rKTtcbiAgICAgICAgICBpZiAobmV3VGV4dENvbnRlbnQgPT09IHRleHRDb250ZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gT25seSBzZXQgaHJlZiB3aGVuIG5ldyBocmVmIGxvb2tzIGxpa2UgYSB2YWxpZCB1cmxcbiAgICAgICAgICBpZiAobmV3VGV4dENvbnRlbnQubWF0Y2godXJsUmVnRXhwKSkge1xuICAgICAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIG5ld1RleHRDb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9pbml0T2JqZWN0UmVzaXppbmc6IGZ1bmN0aW9uIF9pbml0T2JqZWN0UmVzaXppbmcoKSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCJdLFxuICAgICAgICAgIHByb3BlcnRpZXNMZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aCxcbiAgICAgICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXG4gICAgICB0aGlzLmNvbW1hbmRzLmV4ZWMoXCJlbmFibGVPYmplY3RSZXNpemluZ1wiLCB0aGlzLmNvbmZpZy5hbGxvd09iamVjdFJlc2l6aW5nKTtcblxuICAgICAgaWYgKHRoaXMuY29uZmlnLmFsbG93T2JqZWN0UmVzaXppbmcpIHtcbiAgICAgICAgLy8gSUUgc2V0cyBpbmxpbmUgc3R5bGVzIGFmdGVyIHJlc2l6aW5nIG9iamVjdHNcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBsaW5lcyBtYWtlIHN1cmUgdGhhdCB0aGUgd2lkdGgvaGVpZ2h0IGNzcyBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIGFyZSBjb3BpZWQgb3ZlciB0byB0aGUgd2lkdGgvaGVpZ2h0IGF0dHJpYnV0ZXNcbiAgICAgICAgaWYgKGJyb3dzZXIuc3VwcG9ydHNFdmVudChcInJlc2l6ZWVuZFwiKSkge1xuICAgICAgICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwicmVzaXplZW5kXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50LFxuICAgICAgICAgICAgICAgIHN0eWxlID0gdGFyZ2V0LnN0eWxlLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5O1xuICAgICAgICAgICAgZm9yICg7IGkgPCBwcm9wZXJ0aWVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgICAgICBpZiAoc3R5bGVbcHJvcGVydHldKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShwcm9wZXJ0eSwgcGFyc2VJbnQoc3R5bGVbcHJvcGVydHldLCAxMCkpO1xuICAgICAgICAgICAgICAgIHN0eWxlW3Byb3BlcnR5XSA9IFwiXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFmdGVyIHJlc2l6aW5nIElFIHNvbWV0aW1lcyBmb3JnZXRzIHRvIHJlbW92ZSB0aGUgb2xkIHJlc2l6ZSBoYW5kbGVzXG4gICAgICAgICAgICB3eXNpaHRtbDUucXVpcmtzLnJlZHJhdyhlbGVtZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJyb3dzZXIuc3VwcG9ydHNFdmVudChcInJlc2l6ZXN0YXJ0XCIpKSB7XG4gICAgICAgICAgZG9tLm9ic2VydmUoZWxlbWVudCwgXCJyZXNpemVzdGFydFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2luaXRVbmRvTWFuYWdlcjogZnVuY3Rpb24gX2luaXRVbmRvTWFuYWdlcigpIHtcbiAgICAgIG5ldyB3eXNpaHRtbDUuVW5kb01hbmFnZXIodGhpcy5wYXJlbnQpO1xuICAgIH1cbiAgfSk7XG59KSh3eXNpaHRtbDUpOyhmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciBkb20gPSB3eXNpaHRtbDUuZG9tLFxuICAgICAgZG9jID0gZG9jdW1lbnQsXG4gICAgICB3aW4gPSB3aW5kb3csXG4gICAgICBIT1NUX1RFTVBMQVRFID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cbiAgLyoqXG4gICAqIFN0eWxlcyB0byBjb3B5IGZyb20gdGV4dGFyZWEgdG8gdGhlIGNvbXBvc2VyIGVsZW1lbnRcbiAgICovXG4gIFRFWFRfRk9STUFUVElORyA9IFtcImJhY2tncm91bmQtY29sb3JcIiwgXCJjb2xvclwiLCBcImN1cnNvclwiLCBcImZvbnQtZmFtaWx5XCIsIFwiZm9udC1zaXplXCIsIFwiZm9udC1zdHlsZVwiLCBcImZvbnQtdmFyaWFudFwiLCBcImZvbnQtd2VpZ2h0XCIsIFwibGluZS1oZWlnaHRcIiwgXCJsZXR0ZXItc3BhY2luZ1wiLCBcInRleHQtYWxpZ25cIiwgXCJ0ZXh0LWRlY29yYXRpb25cIiwgXCJ0ZXh0LWluZGVudFwiLCBcInRleHQtcmVuZGVyaW5nXCIsIFwid29yZC1icmVha1wiLCBcIndvcmQtd3JhcFwiLCBcIndvcmQtc3BhY2luZ1wiXSxcblxuICAvKipcbiAgICogU3R5bGVzIHRvIGNvcHkgZnJvbSB0ZXh0YXJlYSB0byB0aGUgaWZyYW1lXG4gICAqL1xuICBCT1hfRk9STUFUVElORyA9IFtcImJhY2tncm91bmQtY29sb3JcIiwgXCJib3JkZXItY29sbGFwc2VcIiwgXCJib3JkZXItYm90dG9tLWNvbG9yXCIsIFwiYm9yZGVyLWJvdHRvbS1zdHlsZVwiLCBcImJvcmRlci1ib3R0b20td2lkdGhcIiwgXCJib3JkZXItbGVmdC1jb2xvclwiLCBcImJvcmRlci1sZWZ0LXN0eWxlXCIsIFwiYm9yZGVyLWxlZnQtd2lkdGhcIiwgXCJib3JkZXItcmlnaHQtY29sb3JcIiwgXCJib3JkZXItcmlnaHQtc3R5bGVcIiwgXCJib3JkZXItcmlnaHQtd2lkdGhcIiwgXCJib3JkZXItdG9wLWNvbG9yXCIsIFwiYm9yZGVyLXRvcC1zdHlsZVwiLCBcImJvcmRlci10b3Atd2lkdGhcIiwgXCJjbGVhclwiLCBcImRpc3BsYXlcIiwgXCJmbG9hdFwiLCBcIm1hcmdpbi1ib3R0b21cIiwgXCJtYXJnaW4tbGVmdFwiLCBcIm1hcmdpbi1yaWdodFwiLCBcIm1hcmdpbi10b3BcIiwgXCJvdXRsaW5lLWNvbG9yXCIsIFwib3V0bGluZS1vZmZzZXRcIiwgXCJvdXRsaW5lLXdpZHRoXCIsIFwib3V0bGluZS1zdHlsZVwiLCBcInBhZGRpbmctbGVmdFwiLCBcInBhZGRpbmctcmlnaHRcIiwgXCJwYWRkaW5nLXRvcFwiLCBcInBhZGRpbmctYm90dG9tXCIsIFwicG9zaXRpb25cIiwgXCJ0b3BcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJib3R0b21cIiwgXCJ6LWluZGV4XCIsIFwidmVydGljYWwtYWxpZ25cIiwgXCJ0ZXh0LWFsaWduXCIsIFwiLXdlYmtpdC1ib3gtc2l6aW5nXCIsIFwiLW1vei1ib3gtc2l6aW5nXCIsIFwiLW1zLWJveC1zaXppbmdcIiwgXCJib3gtc2l6aW5nXCIsIFwiLXdlYmtpdC1ib3gtc2hhZG93XCIsIFwiLW1vei1ib3gtc2hhZG93XCIsIFwiLW1zLWJveC1zaGFkb3dcIiwgXCJib3gtc2hhZG93XCIsIFwiLXdlYmtpdC1ib3JkZXItdG9wLXJpZ2h0LXJhZGl1c1wiLCBcIi1tb3otYm9yZGVyLXJhZGl1cy10b3ByaWdodFwiLCBcImJvcmRlci10b3AtcmlnaHQtcmFkaXVzXCIsIFwiLXdlYmtpdC1ib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1c1wiLCBcIi1tb3otYm9yZGVyLXJhZGl1cy1ib3R0b21yaWdodFwiLCBcImJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzXCIsIFwiLXdlYmtpdC1ib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsIFwiLW1vei1ib3JkZXItcmFkaXVzLWJvdHRvbWxlZnRcIiwgXCJib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzXCIsIFwiLXdlYmtpdC1ib3JkZXItdG9wLWxlZnQtcmFkaXVzXCIsIFwiLW1vei1ib3JkZXItcmFkaXVzLXRvcGxlZnRcIiwgXCJib3JkZXItdG9wLWxlZnQtcmFkaXVzXCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIl0sXG5cbiAgLyoqXG4gICAqIFN0eWxlcyB0byBzeW5jIHdoaWxlIHRoZSB3aW5kb3cgZ2V0cyByZXNpemVkXG4gICAqL1xuICBSRVNJWkVfU1RZTEUgPSBbXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcInRvcFwiLCBcImxlZnRcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiXSxcbiAgICAgIEFERElUSU9OQUxfQ1NTX1JVTEVTID0gW1wiaHRtbCAgICAgICAgICAgICB7IGhlaWdodDogMTAwJTsgfVwiLCBcImJvZHkgICAgICAgICAgICAgeyBtaW4taGVpZ2h0OiAxMDAlOyBwYWRkaW5nOiAwOyBtYXJnaW46IDA7IG1hcmdpbi10b3A6IC0xcHg7IHBhZGRpbmctdG9wOiAxcHg7IHdoaXRlLXNwYWNlOiBwcmUtd3JhcDsgfVwiLCBcIi5fd3lzaWh0bWw1LXRlbXAgeyBkaXNwbGF5OiBub25lOyB9XCIsIHd5c2lodG1sNS5icm93c2VyLmlzR2Vja28gPyBcImJvZHkucGxhY2Vob2xkZXIgeyBjb2xvcjogZ3JheXRleHQgIWltcG9ydGFudDsgfVwiIDogXCJib2R5LnBsYWNlaG9sZGVyIHsgY29sb3I6ICNhOWE5YTkgIWltcG9ydGFudDsgfVwiLCBcImJvZHlbZGlzYWJsZWRdICAgeyBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlICFpbXBvcnRhbnQ7IGNvbG9yOiAjOTk5ICFpbXBvcnRhbnQ7IGN1cnNvcjogZGVmYXVsdCAhaW1wb3J0YW50OyB9XCIsXG4gIC8vIEVuc3VyZSB0aGF0IHVzZXIgc2VlJ3MgYnJva2VuIGltYWdlcyBhbmQgY2FuIGRlbGV0ZSB0aGVtXG4gIFwiaW1nOi1tb3otYnJva2VuICB7IC1tb3otZm9yY2UtYnJva2VuLWltYWdlLWljb246IDE7IGhlaWdodDogMjRweDsgd2lkdGg6IDI0cHg7IH1cIl07XG5cbiAgLyoqXG4gICAqIFdpdGggXCJzZXRBY3RpdmVcIiBJRSBvZmZlcnMgYSBzbWFydCB3YXkgb2YgZm9jdXNpbmcgZWxlbWVudHMgd2l0aG91dCBzY3JvbGxpbmcgdGhlbSBpbnRvIHZpZXc6XG4gICAqIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjczOCh2PXZzLjg1KS5hc3B4XG4gICAqXG4gICAqIE90aGVyIGJyb3dzZXJzIG5lZWQgYSBtb3JlIGhhY2t5IHdheTogKHBzc3N0IGRvbid0IHRlbGwgbXkgbWFtYSlcbiAgICogSW4gb3JkZXIgdG8gcHJldmVudCB0aGUgZWxlbWVudCBiZWluZyBzY3JvbGxlZCBpbnRvIHZpZXcgd2hlbiBmb2N1c2luZyBpdCwgd2Ugc2ltcGx5XG4gICAqIG1vdmUgaXQgb3V0IG9mIHRoZSBzY3JvbGxhYmxlIGFyZWEsIGZvY3VzIGl0LCBhbmQgcmVzZXQgaXQncyBwb3NpdGlvblxuICAgKi9cbiAgdmFyIGZvY3VzV2l0aG91dFNjcm9sbGluZyA9IGZ1bmN0aW9uIGZvY3VzV2l0aG91dFNjcm9sbGluZyhlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQuc2V0QWN0aXZlKSB7XG4gICAgICAvLyBGb2xsb3dpbmcgbGluZSBjb3VsZCBjYXVzZSBhIGpzIGVycm9yIHdoZW4gdGhlIHRleHRhcmVhIGlzIGludmlzaWJsZVxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS94aW5nL3d5c2lodG1sNS9pc3N1ZXMvOVxuICAgICAgdHJ5IHtcbiAgICAgICAgZWxlbWVudC5zZXRBY3RpdmUoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBlbGVtZW50U3R5bGUgPSBlbGVtZW50LnN0eWxlLFxuICAgICAgICAgIG9yaWdpbmFsU2Nyb2xsVG9wID0gZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jLmJvZHkuc2Nyb2xsVG9wLFxuICAgICAgICAgIG9yaWdpbmFsU2Nyb2xsTGVmdCA9IGRvYy5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2MuYm9keS5zY3JvbGxMZWZ0LFxuICAgICAgICAgIG9yaWdpbmFsU3R5bGVzID0ge1xuICAgICAgICBwb3NpdGlvbjogZWxlbWVudFN0eWxlLnBvc2l0aW9uLFxuICAgICAgICB0b3A6IGVsZW1lbnRTdHlsZS50b3AsXG4gICAgICAgIGxlZnQ6IGVsZW1lbnRTdHlsZS5sZWZ0LFxuICAgICAgICBXZWJraXRVc2VyU2VsZWN0OiBlbGVtZW50U3R5bGUuV2Via2l0VXNlclNlbGVjdFxuICAgICAgfTtcblxuICAgICAgZG9tLnNldFN0eWxlcyh7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIHRvcDogXCItOTk5OTlweFwiLFxuICAgICAgICBsZWZ0OiBcIi05OTk5OXB4XCIsXG4gICAgICAgIC8vIERvbid0IGFzayB3aHkgYnV0IHRlbXBvcmFyaWx5IHNldHRpbmcgLXdlYmtpdC11c2VyLXNlbGVjdCB0byBub25lIG1ha2VzIHRoZSB3aG9sZSB0aGluZyBwZXJmb3JtaW5nIHNtb290aGVyXG4gICAgICAgIFdlYmtpdFVzZXJTZWxlY3Q6IFwibm9uZVwiXG4gICAgICB9KS5vbihlbGVtZW50KTtcblxuICAgICAgZWxlbWVudC5mb2N1cygpO1xuXG4gICAgICBkb20uc2V0U3R5bGVzKG9yaWdpbmFsU3R5bGVzKS5vbihlbGVtZW50KTtcblxuICAgICAgaWYgKHdpbi5zY3JvbGxUbykge1xuICAgICAgICAvLyBTb21lIGJyb3dzZXIgZXh0ZW5zaW9ucyB1bnNldCB0aGlzIG1ldGhvZCB0byBwcmV2ZW50IGFubm95YW5jZXNcbiAgICAgICAgLy8gXCJCZXR0ZXIgUG9wVXAgQmxvY2tlclwiIGZvciBDaHJvbWUgaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2JldHRlcnBvcHVwYmxvY2tlci9zb3VyY2UvYnJvd3NlL3RydW5rL2Jsb2NrU3RhcnQuanMjMTAwXG4gICAgICAgIC8vIElzc3VlOiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYmV0dGVycG9wdXBibG9ja2VyL2lzc3Vlcy9kZXRhaWw/aWQ9MVxuICAgICAgICB3aW4uc2Nyb2xsVG8ob3JpZ2luYWxTY3JvbGxMZWZ0LCBvcmlnaW5hbFNjcm9sbFRvcCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHd5c2lodG1sNS52aWV3cy5Db21wb3Nlci5wcm90b3R5cGUuc3R5bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICBvcmlnaW5hbEFjdGl2ZUVsZW1lbnQgPSBkb2MucXVlcnlTZWxlY3RvcihcIjpmb2N1c1wiKSxcbiAgICAgICAgdGV4dGFyZWFFbGVtZW50ID0gdGhpcy50ZXh0YXJlYS5lbGVtZW50LFxuICAgICAgICBoYXNQbGFjZWhvbGRlciA9IHRleHRhcmVhRWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiKSxcbiAgICAgICAgb3JpZ2luYWxQbGFjZWhvbGRlciA9IGhhc1BsYWNlaG9sZGVyICYmIHRleHRhcmVhRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiKTtcbiAgICB0aGlzLmZvY3VzU3R5bGVzSG9zdCA9IHRoaXMuZm9jdXNTdHlsZXNIb3N0IHx8IEhPU1RfVEVNUExBVEUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgICB0aGlzLmJsdXJTdHlsZXNIb3N0ID0gdGhpcy5ibHVyU3R5bGVzSG9zdCB8fCBIT1NUX1RFTVBMQVRFLmNsb25lTm9kZShmYWxzZSk7XG5cbiAgICAvLyBSZW1vdmUgcGxhY2Vob2xkZXIgYmVmb3JlIGNvcHlpbmcgKGFzIHRoZSBwbGFjZWhvbGRlciBoYXMgYW4gYWZmZWN0IG9uIHRoZSBjb21wdXRlZCBzdHlsZSlcbiAgICBpZiAoaGFzUGxhY2Vob2xkZXIpIHtcbiAgICAgIHRleHRhcmVhRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiKTtcbiAgICB9XG5cbiAgICBpZiAodGV4dGFyZWFFbGVtZW50ID09PSBvcmlnaW5hbEFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIHRleHRhcmVhRWxlbWVudC5ibHVyKCk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tIGlmcmFtZSBzdHlsZXMgKGhhcyB0byBiZSBzZXQgYmVmb3JlIGVkaXRvciBzdHlsZXMsIG90aGVyd2lzZSBJRTkgc2V0cyB3cm9uZyBmb250RmFtaWx5IG9uIGJsdXJTdHlsZXNIb3N0KSAtLS0tLS0tLS1cbiAgICBkb20uY29weVN0eWxlcyhCT1hfRk9STUFUVElORykuZnJvbSh0ZXh0YXJlYUVsZW1lbnQpLnRvKHRoaXMuaWZyYW1lKS5hbmRUbyh0aGlzLmJsdXJTdHlsZXNIb3N0KTtcblxuICAgIC8vIC0tLS0tLS0tLSBlZGl0b3Igc3R5bGVzIC0tLS0tLS0tLVxuICAgIGRvbS5jb3B5U3R5bGVzKFRFWFRfRk9STUFUVElORykuZnJvbSh0ZXh0YXJlYUVsZW1lbnQpLnRvKHRoaXMuZWxlbWVudCkuYW5kVG8odGhpcy5ibHVyU3R5bGVzSG9zdCk7XG5cbiAgICAvLyAtLS0tLS0tLS0gYXBwbHkgc3RhbmRhcmQgcnVsZXMgLS0tLS0tLS0tXG4gICAgZG9tLmluc2VydENTUyhBRERJVElPTkFMX0NTU19SVUxFUykuaW50byh0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudCk7XG5cbiAgICAvLyAtLS0tLS0tLS0gOmZvY3VzIHN0eWxlcyAtLS0tLS0tLS1cbiAgICBmb2N1c1dpdGhvdXRTY3JvbGxpbmcodGV4dGFyZWFFbGVtZW50KTtcbiAgICBkb20uY29weVN0eWxlcyhCT1hfRk9STUFUVElORykuZnJvbSh0ZXh0YXJlYUVsZW1lbnQpLnRvKHRoaXMuZm9jdXNTdHlsZXNIb3N0KTtcbiAgICBkb20uY29weVN0eWxlcyhURVhUX0ZPUk1BVFRJTkcpLmZyb20odGV4dGFyZWFFbGVtZW50KS50byh0aGlzLmZvY3VzU3R5bGVzSG9zdCk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB3ZSBkb24ndCBjaGFuZ2UgdGhlIGRpc3BsYXkgc3R5bGUgb2YgdGhlIGlmcmFtZSB3aGVuIGNvcHlpbmcgc3R5bGVzIG9ibHVyL29uZm9jdXNcbiAgICAvLyB0aGlzIGlzIG5lZWRlZCBmb3Igd2hlbiB0aGUgY2hhbmdlX3ZpZXcgZXZlbnQgaXMgZmlyZWQgd2hlcmUgdGhlIGlmcmFtZSBpcyBoaWRkZW4gYW5kIHRoZW5cbiAgICAvLyB0aGUgYmx1ciBldmVudCBmaXJlcyBhbmQgcmUtZGlzcGxheXMgaXRcbiAgICB2YXIgYm94Rm9ybWF0dGluZ1N0eWxlcyA9IHd5c2lodG1sNS5sYW5nLmFycmF5KEJPWF9GT1JNQVRUSU5HKS53aXRob3V0KFtcImRpc3BsYXlcIl0pO1xuXG4gICAgLy8gLS0tLS0tLS0tIHJlc3RvcmUgZm9jdXMgLS0tLS0tLS0tXG4gICAgaWYgKG9yaWdpbmFsQWN0aXZlRWxlbWVudCkge1xuICAgICAgb3JpZ2luYWxBY3RpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHRhcmVhRWxlbWVudC5ibHVyKCk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tIHJlc3RvcmUgcGxhY2Vob2xkZXIgLS0tLS0tLS0tXG4gICAgaWYgKGhhc1BsYWNlaG9sZGVyKSB7XG4gICAgICB0ZXh0YXJlYUVsZW1lbnQuc2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIiwgb3JpZ2luYWxQbGFjZWhvbGRlcik7XG4gICAgfVxuXG4gICAgLy8gV2hlbiBjb3B5aW5nIHN0eWxlcywgd2Ugb25seSBnZXQgdGhlIGNvbXB1dGVkIHN0eWxlIHdoaWNoIGlzIG5ldmVyIHJldHVybmVkIGluIHBlcmNlbnQgdW5pdFxuICAgIC8vIFRoZXJlZm9yZSB3ZSd2ZSB0byByZWNhbGN1bGF0ZSBzdHlsZSBvbnJlc2l6ZVxuICAgIGlmICghd3lzaWh0bWw1LmJyb3dzZXIuaGFzQ3VycmVudFN0eWxlUHJvcGVydHkoKSkge1xuICAgICAgdmFyIHdpbk9ic2VydmVyID0gZG9tLm9ic2VydmUod2luLCBcInJlc2l6ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFJlbW92ZSBldmVudCBsaXN0ZW5lciBpZiBjb21wb3NlciBkb2Vzbid0IGV4aXN0IGFueW1vcmVcbiAgICAgICAgaWYgKCFkb20uY29udGFpbnMoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGF0LmlmcmFtZSkpIHtcbiAgICAgICAgICB3aW5PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnaW5hbFRleHRhcmVhRGlzcGxheVN0eWxlID0gZG9tLmdldFN0eWxlKFwiZGlzcGxheVwiKS5mcm9tKHRleHRhcmVhRWxlbWVudCksXG4gICAgICAgICAgICBvcmlnaW5hbENvbXBvc2VyRGlzcGxheVN0eWxlID0gZG9tLmdldFN0eWxlKFwiZGlzcGxheVwiKS5mcm9tKHRoYXQuaWZyYW1lKTtcbiAgICAgICAgdGV4dGFyZWFFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgICB0aGF0LmlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIGRvbS5jb3B5U3R5bGVzKFJFU0laRV9TVFlMRSkuZnJvbSh0ZXh0YXJlYUVsZW1lbnQpLnRvKHRoYXQuaWZyYW1lKS5hbmRUbyh0aGF0LmZvY3VzU3R5bGVzSG9zdCkuYW5kVG8odGhhdC5ibHVyU3R5bGVzSG9zdCk7XG4gICAgICAgIHRoYXQuaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbENvbXBvc2VyRGlzcGxheVN0eWxlO1xuICAgICAgICB0ZXh0YXJlYUVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IG9yaWdpbmFsVGV4dGFyZWFEaXNwbGF5U3R5bGU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0gU3luYyBmb2N1cy9ibHVyIHN0eWxlcyAtLS0tLS0tLS1cbiAgICB0aGlzLnBhcmVudC5vYnNlcnZlKFwiZm9jdXM6Y29tcG9zZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmNvcHlTdHlsZXMoYm94Rm9ybWF0dGluZ1N0eWxlcykuZnJvbSh0aGF0LmZvY3VzU3R5bGVzSG9zdCkudG8odGhhdC5pZnJhbWUpO1xuICAgICAgZG9tLmNvcHlTdHlsZXMoVEVYVF9GT1JNQVRUSU5HKS5mcm9tKHRoYXQuZm9jdXNTdHlsZXNIb3N0KS50byh0aGF0LmVsZW1lbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5wYXJlbnQub2JzZXJ2ZShcImJsdXI6Y29tcG9zZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgZG9tLmNvcHlTdHlsZXMoYm94Rm9ybWF0dGluZ1N0eWxlcykuZnJvbSh0aGF0LmJsdXJTdHlsZXNIb3N0KS50byh0aGF0LmlmcmFtZSk7XG4gICAgICBkb20uY29weVN0eWxlcyhURVhUX0ZPUk1BVFRJTkcpLmZyb20odGhhdC5ibHVyU3R5bGVzSG9zdCkudG8odGhhdC5lbGVtZW50KTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufSkod3lzaWh0bWw1KTsgLyoqXG4gICAgICAgICAgICAgICAqIFRha2luZyBjYXJlIG9mIGV2ZW50c1xuICAgICAgICAgICAgICAgKiAgLSBTaW11bGF0aW5nICdjaGFuZ2UnIGV2ZW50IG9uIGNvbnRlbnRFZGl0YWJsZSBlbGVtZW50XG4gICAgICAgICAgICAgICAqICAtIEhhbmRsaW5nIGRyYWcgJiBkcm9wIGxvZ2ljXG4gICAgICAgICAgICAgICAqICAtIENhdGNoIHBhc3RlIGV2ZW50c1xuICAgICAgICAgICAgICAgKiAgLSBEaXNwYXRjaCBwcm9wcmlldGFyeSBuZXd3b3JkOmNvbXBvc2VyIGV2ZW50XG4gICAgICAgICAgICAgICAqICAtIEtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAgICAgICAgICAgKi9cbihmdW5jdGlvbiAod3lzaWh0bWw1KSB7XG4gIHZhciBkb20gPSB3eXNpaHRtbDUuZG9tLFxuICAgICAgYnJvd3NlciA9IHd5c2lodG1sNS5icm93c2VyLFxuXG4gIC8qKlxuICAgKiBNYXAga2V5Q29kZXMgdG8gcXVlcnkgY29tbWFuZHNcbiAgICovXG4gIHNob3J0Y3V0cyA9IHtcbiAgICBcIjY2XCI6IFwiYm9sZFwiLCAvLyBCXG4gICAgXCI3M1wiOiBcIml0YWxpY1wiLCAvLyBJXG4gICAgXCI4NVwiOiBcInVuZGVybGluZVwiIC8vIFVcbiAgfTtcblxuICB3eXNpaHRtbDUudmlld3MuQ29tcG9zZXIucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICBzdGF0ZSA9IHRoaXMuZ2V0VmFsdWUoKSxcbiAgICAgICAgaWZyYW1lID0gdGhpcy5zYW5kYm94LmdldElmcmFtZSgpLFxuICAgICAgICBlbGVtZW50ID0gdGhpcy5lbGVtZW50LFxuICAgICAgICBmb2N1c0JsdXJFbGVtZW50ID0gYnJvd3Nlci5zdXBwb3J0c0V2ZW50c0luSWZyYW1lQ29ycmVjdGx5KCkgPyBlbGVtZW50IDogdGhpcy5zYW5kYm94LmdldFdpbmRvdygpLFxuXG4gICAgLy8gRmlyZWZveCA8IDMuNSBkb2Vzbid0IHN1cHBvcnQgdGhlIGRyb3AgZXZlbnQsIGluc3RlYWQgaXQgc3VwcG9ydHMgYSBzbyBjYWxsZWQgXCJkcmFnZHJvcFwiIGV2ZW50IHdoaWNoIGJlaGF2ZXMgYWxtb3N0IHRoZSBzYW1lXG4gICAgcGFzdGVFdmVudHMgPSBicm93c2VyLnN1cHBvcnRzRXZlbnQoXCJkcm9wXCIpID8gW1wiZHJvcFwiLCBcInBhc3RlXCJdIDogW1wiZHJhZ2Ryb3BcIiwgXCJwYXN0ZVwiXTtcblxuICAgIC8vIC0tLS0tLS0tLSBkZXN0cm95OmNvbXBvc2VyIGV2ZW50IC0tLS0tLS0tLVxuICAgIGRvbS5vYnNlcnZlKGlmcmFtZSwgXCJET01Ob2RlUmVtb3ZlZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjbGVhckludGVydmFsKGRvbU5vZGVSZW1vdmVkSW50ZXJ2YWwpO1xuICAgICAgdGhhdC5wYXJlbnQuZmlyZShcImRlc3Ryb3k6Y29tcG9zZXJcIik7XG4gICAgfSk7XG5cbiAgICAvLyBET01Ob2RlUmVtb3ZlZCBldmVudCBpcyBub3Qgc3VwcG9ydGVkIGluIElFIDhcbiAgICB2YXIgZG9tTm9kZVJlbW92ZWRJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghZG9tLmNvbnRhaW5zKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgaWZyYW1lKSkge1xuICAgICAgICBjbGVhckludGVydmFsKGRvbU5vZGVSZW1vdmVkSW50ZXJ2YWwpO1xuICAgICAgICB0aGF0LnBhcmVudC5maXJlKFwiZGVzdHJveTpjb21wb3NlclwiKTtcbiAgICAgIH1cbiAgICB9LCAyNTApO1xuXG4gICAgLy8gLS0tLS0tLS0tIEZvY3VzICYgYmx1ciBsb2dpYyAtLS0tLS0tLS1cbiAgICBkb20ub2JzZXJ2ZShmb2N1c0JsdXJFbGVtZW50LCBcImZvY3VzXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoYXQucGFyZW50LmZpcmUoXCJmb2N1c1wiKS5maXJlKFwiZm9jdXM6Y29tcG9zZXJcIik7XG5cbiAgICAgIC8vIERlbGF5IHN0b3Jpbmcgb2Ygc3RhdGUgdW50aWwgYWxsIGZvY3VzIGhhbmRsZXIgYXJlIGZpcmVkXG4gICAgICAvLyBlc3BlY2lhbGx5IHRoZSBvbmUgd2hpY2ggcmVzZXRzIHRoZSBwbGFjZWhvbGRlclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0YXRlID0gdGhhdC5nZXRWYWx1ZSgpO1xuICAgICAgfSwgMCk7XG4gICAgfSk7XG5cbiAgICBkb20ub2JzZXJ2ZShmb2N1c0JsdXJFbGVtZW50LCBcImJsdXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHN0YXRlICE9PSB0aGF0LmdldFZhbHVlKCkpIHtcbiAgICAgICAgdGhhdC5wYXJlbnQuZmlyZShcImNoYW5nZVwiKS5maXJlKFwiY2hhbmdlOmNvbXBvc2VyXCIpO1xuICAgICAgfVxuICAgICAgdGhhdC5wYXJlbnQuZmlyZShcImJsdXJcIikuZmlyZShcImJsdXI6Y29tcG9zZXJcIik7XG4gICAgfSk7XG5cbiAgICBpZiAod3lzaWh0bWw1LmJyb3dzZXIuaXNJb3MoKSkge1xuICAgICAgLy8gV2hlbiBvbiBpUGFkL2lQaG9uZS9JUG9kIGFmdGVyIGNsaWNraW5nIG91dHNpZGUgb2YgZWRpdG9yLCB0aGUgZWRpdG9yIGxvc2VzIGZvY3VzXG4gICAgICAvLyBidXQgdGhlIFVJIHN0aWxsIGFjdHMgYXMgaWYgdGhlIGVkaXRvciBoYXMgZm9jdXMgKGJsaW5raW5nIGNhcmV0IGFuZCBvbnNjcmVlbiBrZXlib2FyZCB2aXNpYmxlKVxuICAgICAgLy8gV2UgcHJldmVudCB0aGF0IGJ5IGZvY3VzaW5nIGEgdGVtcG9yYXJ5IGlucHV0IGVsZW1lbnQgd2hpY2ggaW1tZWRpYXRlbHkgbG9zZXMgZm9jdXNcbiAgICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwiYmx1clwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksXG4gICAgICAgICAgICBvcmlnaW5hbFNjcm9sbFRvcCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICAgICAgICBvcmlnaW5hbFNjcm9sbExlZnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhhdC5zZWxlY3Rpb24uaW5zZXJ0Tm9kZShpbnB1dCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICBpbnB1dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlucHV0KTtcblxuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8ob3JpZ2luYWxTY3JvbGxMZWZ0LCBvcmlnaW5hbFNjcm9sbFRvcCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0gRHJhZyAmIERyb3AgbG9naWMgLS0tLS0tLS0tXG4gICAgZG9tLm9ic2VydmUoZWxlbWVudCwgXCJkcmFnZW50ZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhhdC5wYXJlbnQuZmlyZShcInVuc2V0X3BsYWNlaG9sZGVyXCIpO1xuICAgIH0pO1xuXG4gICAgaWYgKGJyb3dzZXIuZmlyZXNPbkRyb3BPbmx5V2hlbk9uRHJhZ092ZXJJc0NhbmNlbGxlZCgpKSB7XG4gICAgICBkb20ub2JzZXJ2ZShlbGVtZW50LCBbXCJkcmFnb3ZlclwiLCBcImRyYWdlbnRlclwiXSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBkb20ub2JzZXJ2ZShlbGVtZW50LCBwYXN0ZUV2ZW50cywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgZGF0YVRyYW5zZmVyID0gZXZlbnQuZGF0YVRyYW5zZmVyLFxuICAgICAgICAgIGRhdGE7XG5cbiAgICAgIGlmIChkYXRhVHJhbnNmZXIgJiYgYnJvd3Nlci5zdXBwb3J0c0RhdGFUcmFuc2ZlcigpKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHQvaHRtbFwiKSB8fCBkYXRhVHJhbnNmZXIuZ2V0RGF0YShcInRleHQvcGxhaW5cIik7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIHRoYXQuY29tbWFuZHMuZXhlYyhcImluc2VydEhUTUxcIiwgZGF0YSk7XG4gICAgICAgIHRoYXQucGFyZW50LmZpcmUoXCJwYXN0ZVwiKS5maXJlKFwicGFzdGU6Y29tcG9zZXJcIik7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhhdC5wYXJlbnQuZmlyZShcInBhc3RlXCIpLmZpcmUoXCJwYXN0ZTpjb21wb3NlclwiKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyAtLS0tLS0tLS0gbmV3b3JkIGV2ZW50IC0tLS0tLSstLS1cbiAgICBkb20ub2JzZXJ2ZShlbGVtZW50LCBcImtleXVwXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgICAgaWYgKGtleUNvZGUgPT09IHd5c2lodG1sNS5FTlRFUl9LRVkpIHtcbiAgICAgICAgdGhhdC5wYXJlbnQuZmlyZShcIm5ld3dvcmQ6Y29tcG9zZXJcIik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLnBhcmVudC5vYnNlcnZlKFwicGFzdGU6Y29tcG9zZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoYXQucGFyZW50LmZpcmUoXCJuZXd3b3JkOmNvbXBvc2VyXCIpO1xuICAgICAgfSwgMCk7XG4gICAgfSk7XG5cbiAgICAvLyAtLS0tLS0tLS0gTWFrZSBzdXJlIHRoYXQgaW1hZ2VzIGFyZSBzZWxlY3RlZCB3aGVuIGNsaWNraW5nIG9uIHRoZW0gLS0tLS0tLS0tXG4gICAgaWYgKCFicm93c2VyLmNhblNlbGVjdEltYWdlc0luQ29udGVudEVkaXRhYmxlKCkpIHtcbiAgICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBpZiAodGFyZ2V0Lm5vZGVOYW1lID09PSBcIklNR1wiKSB7XG4gICAgICAgICAgdGhhdC5zZWxlY3Rpb24uc2VsZWN0Tm9kZSh0YXJnZXQpO1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLSBTaG9ydGN1dCBsb2dpYyAtLS0tLS0tLS1cbiAgICBkb20ub2JzZXJ2ZShlbGVtZW50LCBcImtleWRvd25cIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIga2V5Q29kZSA9IGV2ZW50LmtleUNvZGUsXG4gICAgICAgICAgY29tbWFuZCA9IHNob3J0Y3V0c1trZXlDb2RlXTtcbiAgICAgIGlmICgoZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSAmJiAhZXZlbnQuYWx0S2V5ICYmIGNvbW1hbmQpIHtcbiAgICAgICAgdGhhdC5jb21tYW5kcy5leGVjKGNvbW1hbmQpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gLS0tLS0tLS0tIE1ha2Ugc3VyZSB0aGF0IHdoZW4gcHJlc3NpbmcgYmFja3NwYWNlL2RlbGV0ZSBvbiBzZWxlY3RlZCBpbWFnZXMgZGVsZXRlcyB0aGUgaW1hZ2UgYW5kIGl0J3MgYW5jaG9yIC0tLS0tLS0tLVxuICAgIGRvbS5vYnNlcnZlKGVsZW1lbnQsIFwia2V5ZG93blwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGF0LnNlbGVjdGlvbi5nZXRTZWxlY3RlZE5vZGUodHJ1ZSksXG4gICAgICAgICAga2V5Q29kZSA9IGV2ZW50LmtleUNvZGUsXG4gICAgICAgICAgcGFyZW50O1xuICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQubm9kZU5hbWUgPT09IFwiSU1HXCIgJiYgKGtleUNvZGUgPT09IHd5c2lodG1sNS5CQUNLU1BBQ0VfS0VZIHx8IGtleUNvZGUgPT09IHd5c2lodG1sNS5ERUxFVEVfS0VZKSkge1xuICAgICAgICAvLyA4ID0+IGJhY2tzcGFjZSwgNDYgPT4gZGVsZXRlXG4gICAgICAgIHBhcmVudCA9IHRhcmdldC5wYXJlbnROb2RlO1xuICAgICAgICAvLyBkZWxldGUgdGhlIDxpbWc+XG4gICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0YXJnZXQpO1xuICAgICAgICAvLyBhbmQgaXQncyBwYXJlbnQgPGE+IHRvbyBpZiBpdCBoYXNuJ3QgZ290IGFueSBvdGhlciBjaGlsZCBub2Rlc1xuICAgICAgICBpZiAocGFyZW50Lm5vZGVOYW1lID09PSBcIkFcIiAmJiAhcGFyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBwYXJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChwYXJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd3lzaWh0bWw1LnF1aXJrcy5yZWRyYXcoZWxlbWVudCk7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gLS0tLS0tLS0tIFNob3cgdXJsIGluIHRvb2x0aXAgd2hlbiBob3ZlcmluZyBsaW5rcyBvciBpbWFnZXMgLS0tLS0tLS0tXG4gICAgdmFyIHRpdGxlUHJlZml4ZXMgPSB7XG4gICAgICBJTUc6IFwiSW1hZ2U6IFwiLFxuICAgICAgQTogXCJMaW5rOiBcIlxuICAgIH07XG5cbiAgICBkb20ub2JzZXJ2ZShlbGVtZW50LCBcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQsXG4gICAgICAgICAgbm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWUsXG4gICAgICAgICAgdGl0bGU7XG4gICAgICBpZiAobm9kZU5hbWUgIT09IFwiQVwiICYmIG5vZGVOYW1lICE9PSBcIklNR1wiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNUaXRsZSA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoXCJ0aXRsZVwiKTtcbiAgICAgIGlmICghaGFzVGl0bGUpIHtcbiAgICAgICAgdGl0bGUgPSB0aXRsZVByZWZpeGVzW25vZGVOYW1lXSArICh0YXJnZXQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSB8fCB0YXJnZXQuZ2V0QXR0cmlidXRlKFwic3JjXCIpKTtcbiAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcInRpdGxlXCIsIHRpdGxlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0pKHd5c2lodG1sNSk7IC8qKlxuICAgICAgICAgICAgICAgKiBDbGFzcyB0aGF0IHRha2VzIGNhcmUgdGhhdCB0aGUgdmFsdWUgb2YgdGhlIGNvbXBvc2VyIGFuZCB0aGUgdGV4dGFyZWEgaXMgYWx3YXlzIGluIHN5bmNcbiAgICAgICAgICAgICAgICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgSU5URVJWQUwgPSA0MDA7XG5cbiAgd3lzaWh0bWw1LnZpZXdzLlN5bmNocm9uaXplciA9IEJhc2UuZXh0ZW5kKFxuICAvKiogQHNjb3BlIHd5c2lodG1sNS52aWV3cy5TeW5jaHJvbml6ZXIucHJvdG90eXBlICove1xuXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKGVkaXRvciwgdGV4dGFyZWEsIGNvbXBvc2VyKSB7XG4gICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgIHRoaXMudGV4dGFyZWEgPSB0ZXh0YXJlYTtcbiAgICAgIHRoaXMuY29tcG9zZXIgPSBjb21wb3NlcjtcblxuICAgICAgdGhpcy5fb2JzZXJ2ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTeW5jIGh0bWwgZnJvbSBjb21wb3NlciB0byB0ZXh0YXJlYVxuICAgICAqIFRha2VzIGNhcmUgb2YgcGxhY2Vob2xkZXJzXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaG91bGRQYXJzZUh0bWwgV2hldGhlciB0aGUgaHRtbCBzaG91bGQgYmUgc2FuaXRpemVkIGJlZm9yZSBpbnNlcnRpbmcgaXQgaW50byB0aGUgdGV4dGFyZWFcbiAgICAgKi9cbiAgICBmcm9tQ29tcG9zZXJUb1RleHRhcmVhOiBmdW5jdGlvbiBmcm9tQ29tcG9zZXJUb1RleHRhcmVhKHNob3VsZFBhcnNlSHRtbCkge1xuICAgICAgdGhpcy50ZXh0YXJlYS5zZXRWYWx1ZSh3eXNpaHRtbDUubGFuZy5zdHJpbmcodGhpcy5jb21wb3Nlci5nZXRWYWx1ZSgpKS50cmltKCksIHNob3VsZFBhcnNlSHRtbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN5bmMgdmFsdWUgb2YgdGV4dGFyZWEgdG8gY29tcG9zZXJcbiAgICAgKiBUYWtlcyBjYXJlIG9mIHBsYWNlaG9sZGVyc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvdWxkUGFyc2VIdG1sIFdoZXRoZXIgdGhlIGh0bWwgc2hvdWxkIGJlIHNhbml0aXplZCBiZWZvcmUgaW5zZXJ0aW5nIGl0IGludG8gdGhlIGNvbXBvc2VyXG4gICAgICovXG4gICAgZnJvbVRleHRhcmVhVG9Db21wb3NlcjogZnVuY3Rpb24gZnJvbVRleHRhcmVhVG9Db21wb3NlcihzaG91bGRQYXJzZUh0bWwpIHtcbiAgICAgIHZhciB0ZXh0YXJlYVZhbHVlID0gdGhpcy50ZXh0YXJlYS5nZXRWYWx1ZSgpO1xuICAgICAgaWYgKHRleHRhcmVhVmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb21wb3Nlci5zZXRWYWx1ZSh0ZXh0YXJlYVZhbHVlLCBzaG91bGRQYXJzZUh0bWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jb21wb3Nlci5jbGVhcigpO1xuICAgICAgICB0aGlzLmVkaXRvci5maXJlKFwic2V0X3BsYWNlaG9sZGVyXCIpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbnZva2Ugc3luY2luZyBiYXNlZCBvbiB2aWV3IHN0YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaG91bGRQYXJzZUh0bWwgV2hldGhlciB0aGUgaHRtbCBzaG91bGQgYmUgc2FuaXRpemVkIGJlZm9yZSBpbnNlcnRpbmcgaXQgaW50byB0aGUgY29tcG9zZXIvdGV4dGFyZWFcbiAgICAgKi9cbiAgICBzeW5jOiBmdW5jdGlvbiBzeW5jKHNob3VsZFBhcnNlSHRtbCkge1xuICAgICAgaWYgKHRoaXMuZWRpdG9yLmN1cnJlbnRWaWV3Lm5hbWUgPT09IFwidGV4dGFyZWFcIikge1xuICAgICAgICB0aGlzLmZyb21UZXh0YXJlYVRvQ29tcG9zZXIoc2hvdWxkUGFyc2VIdG1sKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZnJvbUNvbXBvc2VyVG9UZXh0YXJlYShzaG91bGRQYXJzZUh0bWwpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBpbnRlcnZhbC1iYXNlZCBzeW5jaW5nXG4gICAgICogYWxzbyBtYWtlcyBzdXJlIHRoYXQgb24tc3VibWl0IHRoZSBjb21wb3NlcidzIGNvbnRlbnQgaXMgc3luY2VkIHdpdGggdGhlIHRleHRhcmVhXG4gICAgICogaW1tZWRpYXRlbHkgd2hlbiB0aGUgZm9ybSBnZXRzIHN1Ym1pdHRlZFxuICAgICAqL1xuICAgIF9vYnNlcnZlOiBmdW5jdGlvbiBfb2JzZXJ2ZSgpIHtcbiAgICAgIHZhciBpbnRlcnZhbCxcbiAgICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgICBmb3JtID0gdGhpcy50ZXh0YXJlYS5lbGVtZW50LmZvcm0sXG4gICAgICAgICAgc3RhcnRJbnRlcnZhbCA9IGZ1bmN0aW9uIHN0YXJ0SW50ZXJ2YWwoKSB7XG4gICAgICAgIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoYXQuZnJvbUNvbXBvc2VyVG9UZXh0YXJlYSgpO1xuICAgICAgICB9LCBJTlRFUlZBTCk7XG4gICAgICB9LFxuICAgICAgICAgIHN0b3BJbnRlcnZhbCA9IGZ1bmN0aW9uIHN0b3BJbnRlcnZhbCgpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgIGludGVydmFsID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIHN0YXJ0SW50ZXJ2YWwoKTtcblxuICAgICAgaWYgKGZvcm0pIHtcbiAgICAgICAgLy8gSWYgdGhlIHRleHRhcmVhIGlzIGluIGEgZm9ybSBtYWtlIHN1cmUgdGhhdCBhZnRlciBvbnJlc2V0IGFuZCBvbnN1Ym1pdCB0aGUgY29tcG9zZXJcbiAgICAgICAgLy8gaGFzIHRoZSBjb3JyZWN0IHN0YXRlXG4gICAgICAgIHd5c2lodG1sNS5kb20ub2JzZXJ2ZShmb3JtLCBcInN1Ym1pdFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhhdC5zeW5jKHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgd3lzaWh0bWw1LmRvbS5vYnNlcnZlKGZvcm0sIFwicmVzZXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5mcm9tVGV4dGFyZWFUb0NvbXBvc2VyKCk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVkaXRvci5vYnNlcnZlKFwiY2hhbmdlX3ZpZXdcIiwgZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgaWYgKHZpZXcgPT09IFwiY29tcG9zZXJcIiAmJiAhaW50ZXJ2YWwpIHtcbiAgICAgICAgICB0aGF0LmZyb21UZXh0YXJlYVRvQ29tcG9zZXIodHJ1ZSk7XG4gICAgICAgICAgc3RhcnRJbnRlcnZhbCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHZpZXcgPT09IFwidGV4dGFyZWFcIikge1xuICAgICAgICAgIHRoYXQuZnJvbUNvbXBvc2VyVG9UZXh0YXJlYSh0cnVlKTtcbiAgICAgICAgICBzdG9wSW50ZXJ2YWwoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuZWRpdG9yLm9ic2VydmUoXCJkZXN0cm95OmNvbXBvc2VyXCIsIHN0b3BJbnRlcnZhbCk7XG4gICAgfVxuICB9KTtcbn0pKHd5c2lodG1sNSk7XG53eXNpaHRtbDUudmlld3MuVGV4dGFyZWEgPSB3eXNpaHRtbDUudmlld3MuVmlldy5leHRlbmQoXG4vKiogQHNjb3BlIHd5c2lodG1sNS52aWV3cy5UZXh0YXJlYS5wcm90b3R5cGUgKi97XG4gIG5hbWU6IFwidGV4dGFyZWFcIixcblxuICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gY29uc3RydWN0b3IocGFyZW50LCB0ZXh0YXJlYUVsZW1lbnQsIGNvbmZpZykge1xuICAgIHRoaXMuYmFzZShwYXJlbnQsIHRleHRhcmVhRWxlbWVudCwgY29uZmlnKTtcblxuICAgIHRoaXMuX29ic2VydmUoKTtcbiAgfSxcblxuICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5lbGVtZW50LnZhbHVlID0gXCJcIjtcbiAgfSxcblxuICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUocGFyc2UpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmlzRW1wdHkoKSA/IFwiXCIgOiB0aGlzLmVsZW1lbnQudmFsdWU7XG4gICAgaWYgKHBhcnNlKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMucGFyZW50LnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LFxuXG4gIHNldFZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZShodG1sLCBwYXJzZSkge1xuICAgIGlmIChwYXJzZSkge1xuICAgICAgaHRtbCA9IHRoaXMucGFyZW50LnBhcnNlKGh0bWwpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnQudmFsdWUgPSBodG1sO1xuICB9LFxuXG4gIGhhc1BsYWNlaG9sZGVyU2V0OiBmdW5jdGlvbiBoYXNQbGFjZWhvbGRlclNldCgpIHtcbiAgICB2YXIgc3VwcG9ydHNQbGFjZWhvbGRlciA9IHd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzUGxhY2Vob2xkZXJBdHRyaWJ1dGVPbih0aGlzLmVsZW1lbnQpLFxuICAgICAgICBwbGFjZWhvbGRlclRleHQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIikgfHwgbnVsbCxcbiAgICAgICAgdmFsdWUgPSB0aGlzLmVsZW1lbnQudmFsdWUsXG4gICAgICAgIGlzRW1wdHkgPSAhdmFsdWU7XG4gICAgcmV0dXJuIHN1cHBvcnRzUGxhY2Vob2xkZXIgJiYgaXNFbXB0eSB8fCB2YWx1ZSA9PT0gcGxhY2Vob2xkZXJUZXh0O1xuICB9LFxuXG4gIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICF3eXNpaHRtbDUubGFuZy5zdHJpbmcodGhpcy5lbGVtZW50LnZhbHVlKS50cmltKCkgfHwgdGhpcy5oYXNQbGFjZWhvbGRlclNldCgpO1xuICB9LFxuXG4gIF9vYnNlcnZlOiBmdW5jdGlvbiBfb2JzZXJ2ZSgpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudCxcbiAgICAgICAgcGFyZW50ID0gdGhpcy5wYXJlbnQsXG4gICAgICAgIGV2ZW50TWFwcGluZyA9IHtcbiAgICAgIGZvY3VzaW46IFwiZm9jdXNcIixcbiAgICAgIGZvY3Vzb3V0OiBcImJsdXJcIlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsaW5nIGZvY3VzKCkgb3IgYmx1cigpIG9uIGFuIGVsZW1lbnQgZG9lc24ndCBzeW5jaHJvbm91c2x5IHRyaWdnZXIgdGhlIGF0dGFjaGVkIGZvY3VzL2JsdXIgZXZlbnRzXG4gICAgICogVGhpcyBpcyB0aGUgY2FzZSBmb3IgZm9jdXNpbiBhbmQgZm9jdXNvdXQsIHNvIGxldCdzIHVzZSB0aGVtIHdoZW5ldmVyIHBvc3NpYmxlLCBra3RoeGJhaVxuICAgICAqL1xuICAgIGV2ZW50cyA9IHd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRzRXZlbnQoXCJmb2N1c2luXCIpID8gW1wiZm9jdXNpblwiLCBcImZvY3Vzb3V0XCIsIFwiY2hhbmdlXCJdIDogW1wiZm9jdXNcIiwgXCJibHVyXCIsIFwiY2hhbmdlXCJdO1xuXG4gICAgcGFyZW50Lm9ic2VydmUoXCJiZWZvcmVsb2FkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHd5c2lodG1sNS5kb20ub2JzZXJ2ZShlbGVtZW50LCBldmVudHMsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgZXZlbnROYW1lID0gZXZlbnRNYXBwaW5nW2V2ZW50LnR5cGVdIHx8IGV2ZW50LnR5cGU7XG4gICAgICAgIHBhcmVudC5maXJlKGV2ZW50TmFtZSkuZmlyZShldmVudE5hbWUgKyBcIjp0ZXh0YXJlYVwiKTtcbiAgICAgIH0pO1xuXG4gICAgICB3eXNpaHRtbDUuZG9tLm9ic2VydmUoZWxlbWVudCwgW1wicGFzdGVcIiwgXCJkcm9wXCJdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBhcmVudC5maXJlKFwicGFzdGVcIikuZmlyZShcInBhc3RlOnRleHRhcmVhXCIpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59KTsgLyoqXG4gICAgKiBUb29sYmFyIERpYWxvZ1xuICAgICpcbiAgICAqIEBwYXJhbSB7RWxlbWVudH0gbGluayBUaGUgdG9vbGJhciBsaW5rIHdoaWNoIGNhdXNlcyB0aGUgZGlhbG9nIHRvIHNob3cgdXBcbiAgICAqIEBwYXJhbSB7RWxlbWVudH0gY29udGFpbmVyIFRoZSBkaWFsb2cgY29udGFpbmVyXG4gICAgKlxuICAgICogQGV4YW1wbGVcbiAgICAqICAgIDwhLS0gVG9vbGJhciBsaW5rIC0tPlxuICAgICogICAgPGEgZGF0YS13eXNpaHRtbDUtY29tbWFuZD1cImluc2VydEltYWdlXCI+aW5zZXJ0IGFuIGltYWdlPC9hPlxuICAgICpcbiAgICAqICAgIDwhLS0gRGlhbG9nIC0tPlxuICAgICogICAgPGRpdiBkYXRhLXd5c2lodG1sNS1kaWFsb2c9XCJpbnNlcnRJbWFnZVwiIHN0eWxlPVwiZGlzcGxheTogbm9uZTtcIj5cbiAgICAqICAgICAgPGxhYmVsPlxuICAgICogICAgICAgIFVSTDogPGlucHV0IGRhdGEtd3lzaWh0bWw1LWRpYWxvZy1maWVsZD1cInNyY1wiIHZhbHVlPVwiaHR0cDovL1wiPlxuICAgICogICAgICA8L2xhYmVsPlxuICAgICogICAgICA8bGFiZWw+XG4gICAgKiAgICAgICAgQWx0ZXJuYXRpdmUgdGV4dDogPGlucHV0IGRhdGEtd3lzaWh0bWw1LWRpYWxvZy1maWVsZD1cImFsdFwiIHZhbHVlPVwiXCI+XG4gICAgKiAgICAgIDwvbGFiZWw+XG4gICAgKiAgICA8L2Rpdj5cbiAgICAqXG4gICAgKiAgICA8c2NyaXB0PlxuICAgICogICAgICB2YXIgZGlhbG9nID0gbmV3IHd5c2lodG1sNS50b29sYmFyLkRpYWxvZyhcbiAgICAqICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiW2RhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2luc2VydEltYWdlJ11cIiksXG4gICAgKiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIltkYXRhLXd5c2lodG1sNS1kaWFsb2c9J2luc2VydEltYWdlJ11cIilcbiAgICAqICAgICAgKTtcbiAgICAqICAgICAgZGlhbG9nLm9ic2VydmUoXCJzYXZlXCIsIGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICAqICAgICAgICAvLyBkbyBzb21ldGhpbmdcbiAgICAqICAgICAgfSk7XG4gICAgKiAgICA8L3NjcmlwdD5cbiAgICAqL1xuKGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIGRvbSA9IHd5c2lodG1sNS5kb20sXG4gICAgICBDTEFTU19OQU1FX09QRU5FRCA9IFwid3lzaWh0bWw1LWNvbW1hbmQtZGlhbG9nLW9wZW5lZFwiLFxuICAgICAgU0VMRUNUT1JfRk9STV9FTEVNRU5UUyA9IFwiaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWFcIixcbiAgICAgIFNFTEVDVE9SX0ZJRUxEUyA9IFwiW2RhdGEtd3lzaWh0bWw1LWRpYWxvZy1maWVsZF1cIixcbiAgICAgIEFUVFJJQlVURV9GSUVMRFMgPSBcImRhdGEtd3lzaWh0bWw1LWRpYWxvZy1maWVsZFwiO1xuXG4gIHd5c2lodG1sNS50b29sYmFyLkRpYWxvZyA9IHd5c2lodG1sNS5sYW5nLkRpc3BhdGNoZXIuZXh0ZW5kKFxuICAvKiogQHNjb3BlIHd5c2lodG1sNS50b29sYmFyLkRpYWxvZy5wcm90b3R5cGUgKi97XG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIGNvbnN0cnVjdG9yKGxpbmssIGNvbnRhaW5lcikge1xuICAgICAgdGhpcy5saW5rID0gbGluaztcbiAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIH0sXG5cbiAgICBfb2JzZXJ2ZTogZnVuY3Rpb24gX29ic2VydmUoKSB7XG4gICAgICBpZiAodGhpcy5fb2JzZXJ2ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgY2FsbGJhY2tXcmFwcGVyID0gZnVuY3Rpb24gY2FsbGJhY2tXcmFwcGVyKGV2ZW50KSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhhdC5fc2VyaWFsaXplKCk7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzID09IHRoYXQuZWxlbWVudFRvQ2hhbmdlKSB7XG4gICAgICAgICAgdGhhdC5maXJlKFwiZWRpdFwiLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGF0LmZpcmUoXCJzYXZlXCIsIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQuaGlkZSgpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH07XG5cbiAgICAgIGRvbS5vYnNlcnZlKHRoYXQubGluaywgXCJjbGlja1wiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGRvbS5oYXNDbGFzcyh0aGF0LmxpbmssIENMQVNTX05BTUVfT1BFTkVEKSkge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5oaWRlKCk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBkb20ub2JzZXJ2ZSh0aGlzLmNvbnRhaW5lciwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgICAgIGlmIChrZXlDb2RlID09PSB3eXNpaHRtbDUuRU5URVJfS0VZKSB7XG4gICAgICAgICAgY2FsbGJhY2tXcmFwcGVyKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gd3lzaWh0bWw1LkVTQ0FQRV9LRVkpIHtcbiAgICAgICAgICAvLyB0aGF0LmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGRvbS5kZWxlZ2F0ZSh0aGlzLmNvbnRhaW5lciwgXCJbZGF0YS13eXNpaHRtbDUtZGlhbG9nLWFjdGlvbj1zYXZlXVwiLCBcImNsaWNrXCIsIGNhbGxiYWNrV3JhcHBlcik7XG5cbiAgICAgIGRvbS5kZWxlZ2F0ZSh0aGlzLmNvbnRhaW5lciwgXCJbZGF0YS13eXNpaHRtbDUtZGlhbG9nLWFjdGlvbj1jYW5jZWxdXCIsIFwiY2xpY2tcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoYXQuZmlyZShcImNhbmNlbFwiKTtcbiAgICAgICAgdGhhdC5oaWRlKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBmb3JtRWxlbWVudHMgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0ZPUk1fRUxFTUVOVFMpLFxuICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgIGxlbmd0aCA9IGZvcm1FbGVtZW50cy5sZW5ndGgsXG4gICAgICAgICAgX2NsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbiBfY2xlYXJJbnRlcnZhbCgpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGF0LmludGVydmFsKTtcbiAgICAgIH07XG4gICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRvbS5vYnNlcnZlKGZvcm1FbGVtZW50c1tpXSwgXCJjaGFuZ2VcIiwgX2NsZWFySW50ZXJ2YWwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vYnNlcnZlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdyYWJzIGFsbCBmaWVsZHMgaW4gdGhlIGRpYWxvZyBhbmQgcHV0cyB0aGVtIGluIGtleT0+dmFsdWUgc3R5bGUgaW4gYW4gb2JqZWN0IHdoaWNoXG4gICAgICogdGhlbiBnZXRzIHJldHVybmVkXG4gICAgICovXG4gICAgX3NlcmlhbGl6ZTogZnVuY3Rpb24gX3NlcmlhbGl6ZSgpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5lbGVtZW50VG9DaGFuZ2UgfHwge30sXG4gICAgICAgICAgZmllbGRzID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUl9GSUVMRFMpLFxuICAgICAgICAgIGxlbmd0aCA9IGZpZWxkcy5sZW5ndGgsXG4gICAgICAgICAgaSA9IDA7XG4gICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGFbZmllbGRzW2ldLmdldEF0dHJpYnV0ZShBVFRSSUJVVEVfRklFTERTKV0gPSBmaWVsZHNbaV0udmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGFrZXMgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIFwiZWxlbWVudFRvQ2hhbmdlXCJcbiAgICAgKiBhbmQgaW5zZXJ0cyB0aGVtIGluIHRoZWlyIGNvcnJlc3BvbmRpbmcgZGlhbG9nIGlucHV0IGZpZWxkc1xuICAgICAqIFxuICAgICAqIEFzc3VtZSB0aGUgXCJlbGVtZW50VG9DaGFuZ2VcIiBsb29rcyBsaWtlIHRoaXM6XG4gICAgICogICAgPGEgaHJlZj1cImh0dHA6Ly93d3cuZ29vZ2xlLmNvbVwiIHRhcmdldD1cIl9ibGFua1wiPmZvbzwvYT5cbiAgICAgKlxuICAgICAqIGFuZCB3ZSBoYXZlIHRoZSBmb2xsb3dpbmcgZGlhbG9nOlxuICAgICAqICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtd3lzaWh0bWw1LWRpYWxvZy1maWVsZD1cImhyZWZcIiB2YWx1ZT1cIlwiPlxuICAgICAqICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGRhdGEtd3lzaWh0bWw1LWRpYWxvZy1maWVsZD1cInRhcmdldFwiIHZhbHVlPVwiXCI+XG4gICAgICogXG4gICAgICogYWZ0ZXIgY2FsbGluZyBfaW50ZXJwb2xhdGUoKSB0aGUgZGlhbG9nIHdpbGwgbG9vayBsaWtlIHRoaXNcbiAgICAgKiAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBkYXRhLXd5c2lodG1sNS1kaWFsb2ctZmllbGQ9XCJocmVmXCIgdmFsdWU9XCJodHRwOi8vd3d3Lmdvb2dsZS5jb21cIj5cbiAgICAgKiAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBkYXRhLXd5c2lodG1sNS1kaWFsb2ctZmllbGQ9XCJ0YXJnZXRcIiB2YWx1ZT1cIl9ibGFua1wiPlxuICAgICAqXG4gICAgICogQmFzaWNhbGx5IGl0IGFkb3B0ZWQgdGhlIGF0dHJpYnV0ZSB2YWx1ZXMgaW50byB0aGUgY29ycmVzcG9uZGluZyBpbnB1dCBmaWVsZHNcbiAgICAgKlxuICAgICAqL1xuICAgIF9pbnRlcnBvbGF0ZTogZnVuY3Rpb24gX2ludGVycG9sYXRlKGF2b2lkSGlkZGVuRmllbGRzKSB7XG4gICAgICB2YXIgZmllbGQsXG4gICAgICAgICAgZmllbGROYW1lLFxuICAgICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICAgIGZvY3VzZWRFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIjpmb2N1c1wiKSxcbiAgICAgICAgICBmaWVsZHMgPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0ZJRUxEUyksXG4gICAgICAgICAgbGVuZ3RoID0gZmllbGRzLmxlbmd0aCxcbiAgICAgICAgICBpID0gMDtcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZmllbGQgPSBmaWVsZHNbaV07XG5cbiAgICAgICAgLy8gTmV2ZXIgY2hhbmdlIGVsZW1lbnRzIHdoZXJlIHRoZSB1c2VyIGlzIGN1cnJlbnRseSB0eXBpbmcgaW5cbiAgICAgICAgaWYgKGZpZWxkID09PSBmb2N1c2VkRWxlbWVudCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRG9uJ3QgdXBkYXRlIGhpZGRlbiBmaWVsZHNcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS94aW5nL3d5c2lodG1sNS9wdWxsLzE0XG4gICAgICAgIGlmIChhdm9pZEhpZGRlbkZpZWxkcyAmJiBmaWVsZC50eXBlID09PSBcImhpZGRlblwiKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmaWVsZE5hbWUgPSBmaWVsZC5nZXRBdHRyaWJ1dGUoQVRUUklCVVRFX0ZJRUxEUyk7XG4gICAgICAgIG5ld1ZhbHVlID0gdGhpcy5lbGVtZW50VG9DaGFuZ2UgPyB0aGlzLmVsZW1lbnRUb0NoYW5nZVtmaWVsZE5hbWVdIHx8IFwiXCIgOiBmaWVsZC5kZWZhdWx0VmFsdWU7XG4gICAgICAgIGZpZWxkLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIGRpYWxvZyBlbGVtZW50XG4gICAgICovXG4gICAgc2hvdzogZnVuY3Rpb24gc2hvdyhlbGVtZW50VG9DaGFuZ2UpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICBmaXJzdEZpZWxkID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9GT1JNX0VMRU1FTlRTKTtcbiAgICAgIHRoaXMuZWxlbWVudFRvQ2hhbmdlID0gZWxlbWVudFRvQ2hhbmdlO1xuICAgICAgdGhpcy5fb2JzZXJ2ZSgpO1xuICAgICAgdGhpcy5faW50ZXJwb2xhdGUoKTtcbiAgICAgIGlmIChlbGVtZW50VG9DaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0Ll9pbnRlcnBvbGF0ZSh0cnVlKTtcbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH1cbiAgICAgIGRvbS5hZGRDbGFzcyh0aGlzLmxpbmssIENMQVNTX05BTUVfT1BFTkVEKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgICAgdGhpcy5maXJlKFwic2hvd1wiKTtcbiAgICAgIGlmIChmaXJzdEZpZWxkICYmICFlbGVtZW50VG9DaGFuZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmaXJzdEZpZWxkLmZvY3VzKCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEhpZGUgdGhlIGRpYWxvZyBlbGVtZW50XG4gICAgICovXG4gICAgaGlkZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgICB0aGlzLmVsZW1lbnRUb0NoYW5nZSA9IG51bGw7XG4gICAgICBkb20ucmVtb3ZlQ2xhc3ModGhpcy5saW5rLCBDTEFTU19OQU1FX09QRU5FRCk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICB0aGlzLmZpcmUoXCJoaWRlXCIpO1xuICAgIH1cbiAgfSk7XG59KSh3eXNpaHRtbDUpO1xuLyoqXG4gKiBDb252ZXJ0cyBzcGVlY2gtdG8tdGV4dCBhbmQgaW5zZXJ0cyB0aGlzIGludG8gdGhlIGVkaXRvclxuICogQXMgb2Ygbm93ICgyMDExLzAzLzI1KSB0aGlzIG9ubHkgaXMgc3VwcG9ydGVkIGluIENocm9tZSA+PSAxMVxuICpcbiAqIE5vdGUgdGhhdCBpdCBzZW5kcyB0aGUgcmVjb3JkZWQgYXVkaW8gdG8gdGhlIGdvb2dsZSBzcGVlY2ggcmVjb2duaXRpb24gYXBpOlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MzYxODI2L2RvZXMtY2hyb21lLWhhdmUtYnVpbC1pbi1zcGVlY2gtcmVjb2duaXRpb24tZm9yLWlucHV0LXR5cGUtdGV4dC14LXdlYmtpdC1zcGVlY1xuICpcbiAqIEN1cnJlbnQgSFRNTDUgZHJhZnQgY2FuIGJlIGZvdW5kIGhlcmVcbiAqIGh0dHA6Ly9saXN0cy53My5vcmcvQXJjaGl2ZXMvUHVibGljL3B1YmxpYy14Zy1odG1sc3BlZWNoLzIwMTFGZWIvYXR0LTAwMjAvYXBpLWRyYWZ0Lmh0bWxcbiAqIFxuICogXCJBY2Nlc3NpbmcgR29vZ2xlIFNwZWVjaCBBUEkgQ2hyb21lIDExXCJcbiAqIGh0dHA6Ly9taWtlcHVsdHouY29tLzIwMTEvMDMvYWNjZXNzaW5nLWdvb2dsZS1zcGVlY2gtYXBpLWNocm9tZS0xMS9cbiAqL1xuKGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIGRvbSA9IHd5c2lodG1sNS5kb207XG5cbiAgdmFyIGxpbmtTdHlsZXMgPSB7XG4gICAgcG9zaXRpb246IFwicmVsYXRpdmVcIlxuICB9O1xuXG4gIHZhciB3cmFwcGVyU3R5bGVzID0ge1xuICAgIGxlZnQ6IDAsXG4gICAgbWFyZ2luOiAwLFxuICAgIG9wYWNpdHk6IDAsXG4gICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgcGFkZGluZzogMCxcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIHRvcDogMCxcbiAgICB6SW5kZXg6IDFcbiAgfTtcblxuICB2YXIgaW5wdXRTdHlsZXMgPSB7XG4gICAgY3Vyc29yOiBcImluaGVyaXRcIixcbiAgICBmb250U2l6ZTogXCI1MHB4XCIsXG4gICAgaGVpZ2h0OiBcIjUwcHhcIixcbiAgICBtYXJnaW5Ub3A6IFwiLTI1cHhcIixcbiAgICBvdXRsaW5lOiAwLFxuICAgIHBhZGRpbmc6IDAsXG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICByaWdodDogXCItNHB4XCIsXG4gICAgdG9wOiBcIjUwJVwiXG4gIH07XG5cbiAgdmFyIGlucHV0QXR0cmlidXRlcyA9IHtcbiAgICBcIngtd2Via2l0LXNwZWVjaFwiOiBcIlwiLFxuICAgIFwic3BlZWNoXCI6IFwiXCJcbiAgfTtcblxuICB3eXNpaHRtbDUudG9vbGJhci5TcGVlY2ggPSBmdW5jdGlvbiAocGFyZW50LCBsaW5rKSB7XG4gICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIGlmICghd3lzaWh0bWw1LmJyb3dzZXIuc3VwcG9ydHNTcGVlY2hBcGlPbihpbnB1dCkpIHtcbiAgICAgIGxpbmsuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgIHd5c2lodG1sNS5sYW5nLm9iamVjdCh3cmFwcGVyU3R5bGVzKS5tZXJnZSh7XG4gICAgICB3aWR0aDogbGluay5vZmZzZXRXaWR0aCArIFwicHhcIixcbiAgICAgIGhlaWdodDogbGluay5vZmZzZXRIZWlnaHQgKyBcInB4XCJcbiAgICB9KTtcblxuICAgIGRvbS5pbnNlcnQoaW5wdXQpLmludG8od3JhcHBlcik7XG4gICAgZG9tLmluc2VydCh3cmFwcGVyKS5pbnRvKGxpbmspO1xuXG4gICAgZG9tLnNldFN0eWxlcyhpbnB1dFN0eWxlcykub24oaW5wdXQpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGVzKGlucHV0QXR0cmlidXRlcykub24oaW5wdXQpO1xuXG4gICAgZG9tLnNldFN0eWxlcyh3cmFwcGVyU3R5bGVzKS5vbih3cmFwcGVyKTtcbiAgICBkb20uc2V0U3R5bGVzKGxpbmtTdHlsZXMpLm9uKGxpbmspO1xuXG4gICAgdmFyIGV2ZW50TmFtZSA9IFwib253ZWJraXRzcGVlY2hjaGFuZ2VcIiBpbiBpbnB1dCA/IFwid2Via2l0c3BlZWNoY2hhbmdlXCIgOiBcInNwZWVjaGNoYW5nZVwiO1xuICAgIGRvbS5vYnNlcnZlKGlucHV0LCBldmVudE5hbWUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHBhcmVudC5leGVjQ29tbWFuZChcImluc2VydFRleHRcIiwgaW5wdXQudmFsdWUpO1xuICAgICAgaW5wdXQudmFsdWUgPSBcIlwiO1xuICAgIH0pO1xuXG4gICAgZG9tLm9ic2VydmUoaW5wdXQsIFwiY2xpY2tcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoZG9tLmhhc0NsYXNzKGxpbmssIFwid3lzaWh0bWw1LWNvbW1hbmQtZGlzYWJsZWRcIikpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSk7XG4gIH07XG59KSh3eXNpaHRtbDUpOyAvKipcbiAgICAgICAgICAgICAgICogVG9vbGJhclxuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyZW50IFJlZmVyZW5jZSB0byBpbnN0YW5jZSBvZiBFZGl0b3IgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBjb250YWluZXIgUmVmZXJlbmNlIHRvIHRoZSB0b29sYmFyIGNvbnRhaW5lciBlbGVtZW50XG4gICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgICAqICAgIDxkaXYgaWQ9XCJ0b29sYmFyXCI+XG4gICAgICAgICAgICAgICAqICAgICAgPGEgZGF0YS13eXNpaHRtbDUtY29tbWFuZD1cImNyZWF0ZUxpbmtcIj5pbnNlcnQgbGluazwvYT5cbiAgICAgICAgICAgICAgICogICAgICA8YSBkYXRhLXd5c2lodG1sNS1jb21tYW5kPVwiZm9ybWF0QmxvY2tcIiBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPVwiaDFcIj5pbnNlcnQgaDE8L2E+XG4gICAgICAgICAgICAgICAqICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgKiAgICA8c2NyaXB0PlxuICAgICAgICAgICAgICAgKiAgICAgIHZhciB0b29sYmFyID0gbmV3IHd5c2lodG1sNS50b29sYmFyLlRvb2xiYXIoZWRpdG9yLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRvb2xiYXJcIikpO1xuICAgICAgICAgICAgICAgKiAgICA8L3NjcmlwdD5cbiAgICAgICAgICAgICAgICovXG4oZnVuY3Rpb24gKHd5c2lodG1sNSkge1xuICB2YXIgQ0xBU1NfTkFNRV9DT01NQU5EX0RJU0FCTEVEID0gXCJ3eXNpaHRtbDUtY29tbWFuZC1kaXNhYmxlZFwiLFxuICAgICAgQ0xBU1NfTkFNRV9DT01NQU5EU19ESVNBQkxFRCA9IFwid3lzaWh0bWw1LWNvbW1hbmRzLWRpc2FibGVkXCIsXG4gICAgICBDTEFTU19OQU1FX0NPTU1BTkRfQUNUSVZFID0gXCJ3eXNpaHRtbDUtY29tbWFuZC1hY3RpdmVcIixcbiAgICAgIENMQVNTX05BTUVfQUNUSU9OX0FDVElWRSA9IFwid3lzaWh0bWw1LWFjdGlvbi1hY3RpdmVcIixcbiAgICAgIGRvbSA9IHd5c2lodG1sNS5kb207XG5cbiAgd3lzaWh0bWw1LnRvb2xiYXIuVG9vbGJhciA9IEJhc2UuZXh0ZW5kKFxuICAvKiogQHNjb3BlIHd5c2lodG1sNS50b29sYmFyLlRvb2xiYXIucHJvdG90eXBlICove1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiBjb25zdHJ1Y3RvcihlZGl0b3IsIGNvbnRhaW5lcikge1xuICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IHR5cGVvZiBjb250YWluZXIgPT09IFwic3RyaW5nXCIgPyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb250YWluZXIpIDogY29udGFpbmVyO1xuICAgICAgdGhpcy5jb21wb3NlciA9IGVkaXRvci5jb21wb3NlcjtcblxuICAgICAgdGhpcy5fZ2V0TGlua3MoXCJjb21tYW5kXCIpO1xuICAgICAgdGhpcy5fZ2V0TGlua3MoXCJhY3Rpb25cIik7XG5cbiAgICAgIHRoaXMuX29ic2VydmUoKTtcbiAgICAgIHRoaXMuc2hvdygpO1xuXG4gICAgICB2YXIgc3BlZWNoSW5wdXRMaW5rcyA9IHRoaXMuY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbZGF0YS13eXNpaHRtbDUtY29tbWFuZD1pbnNlcnRTcGVlY2hdXCIpLFxuICAgICAgICAgIGxlbmd0aCA9IHNwZWVjaElucHV0TGlua3MubGVuZ3RoLFxuICAgICAgICAgIGkgPSAwO1xuICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBuZXcgd3lzaWh0bWw1LnRvb2xiYXIuU3BlZWNoKHRoaXMsIHNwZWVjaElucHV0TGlua3NbaV0pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZ2V0TGlua3M6IGZ1bmN0aW9uIF9nZXRMaW5rcyh0eXBlKSB7XG4gICAgICB2YXIgbGlua3MgPSB0aGlzW3R5cGUgKyBcIkxpbmtzXCJdID0gd3lzaWh0bWw1LmxhbmcuYXJyYXkodGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLXd5c2lodG1sNS1cIiArIHR5cGUgKyBcIl1cIikpLmdldCgpLFxuICAgICAgICAgIGxlbmd0aCA9IGxpbmtzLmxlbmd0aCxcbiAgICAgICAgICBpID0gMCxcbiAgICAgICAgICBtYXBwaW5nID0gdGhpc1t0eXBlICsgXCJNYXBwaW5nXCJdID0ge30sXG4gICAgICAgICAgbGluayxcbiAgICAgICAgICBncm91cCxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGRpYWxvZztcbiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGluayA9IGxpbmtzW2ldO1xuICAgICAgICBuYW1lID0gbGluay5nZXRBdHRyaWJ1dGUoXCJkYXRhLXd5c2lodG1sNS1cIiArIHR5cGUpO1xuICAgICAgICB2YWx1ZSA9IGxpbmsuZ2V0QXR0cmlidXRlKFwiZGF0YS13eXNpaHRtbDUtXCIgKyB0eXBlICsgXCItdmFsdWVcIik7XG4gICAgICAgIGdyb3VwID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIltkYXRhLXd5c2lodG1sNS1cIiArIHR5cGUgKyBcIi1ncm91cD0nXCIgKyBuYW1lICsgXCInXVwiKTtcbiAgICAgICAgZGlhbG9nID0gdGhpcy5fZ2V0RGlhbG9nKGxpbmssIG5hbWUpO1xuXG4gICAgICAgIG1hcHBpbmdbbmFtZSArIFwiOlwiICsgdmFsdWVdID0ge1xuICAgICAgICAgIGxpbms6IGxpbmssXG4gICAgICAgICAgZ3JvdXA6IGdyb3VwLFxuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgIGRpYWxvZzogZGlhbG9nLFxuICAgICAgICAgIHN0YXRlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZ2V0RGlhbG9nOiBmdW5jdGlvbiBfZ2V0RGlhbG9nKGxpbmssIGNvbW1hbmQpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcbiAgICAgICAgICBkaWFsb2dFbGVtZW50ID0gdGhpcy5jb250YWluZXIucXVlcnlTZWxlY3RvcihcIltkYXRhLXd5c2lodG1sNS1kaWFsb2c9J1wiICsgY29tbWFuZCArIFwiJ11cIiksXG4gICAgICAgICAgZGlhbG9nLFxuICAgICAgICAgIGNhcmV0Qm9va21hcms7XG5cbiAgICAgIGlmIChkaWFsb2dFbGVtZW50KSB7XG4gICAgICAgIGRpYWxvZyA9IG5ldyB3eXNpaHRtbDUudG9vbGJhci5EaWFsb2cobGluaywgZGlhbG9nRWxlbWVudCk7XG5cbiAgICAgICAgZGlhbG9nLm9ic2VydmUoXCJzaG93XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYXJldEJvb2ttYXJrID0gdGhhdC5jb21wb3Nlci5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKTtcblxuICAgICAgICAgIHRoYXQuZWRpdG9yLmZpcmUoXCJzaG93OmRpYWxvZ1wiLCB7IGNvbW1hbmQ6IGNvbW1hbmQsIGRpYWxvZ0NvbnRhaW5lcjogZGlhbG9nRWxlbWVudCwgY29tbWFuZExpbms6IGxpbmsgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRpYWxvZy5vYnNlcnZlKFwic2F2ZVwiLCBmdW5jdGlvbiAoYXR0cmlidXRlcykge1xuICAgICAgICAgIGlmIChjYXJldEJvb2ttYXJrKSB7XG4gICAgICAgICAgICB0aGF0LmNvbXBvc2VyLnNlbGVjdGlvbi5zZXRCb29rbWFyayhjYXJldEJvb2ttYXJrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhhdC5fZXhlY0NvbW1hbmQoY29tbWFuZCwgYXR0cmlidXRlcyk7XG5cbiAgICAgICAgICB0aGF0LmVkaXRvci5maXJlKFwic2F2ZTpkaWFsb2dcIiwgeyBjb21tYW5kOiBjb21tYW5kLCBkaWFsb2dDb250YWluZXI6IGRpYWxvZ0VsZW1lbnQsIGNvbW1hbmRMaW5rOiBsaW5rIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBkaWFsb2cub2JzZXJ2ZShcImNhbmNlbFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhhdC5lZGl0b3IuZm9jdXMoZmFsc2UpO1xuICAgICAgICAgIHRoYXQuZWRpdG9yLmZpcmUoXCJjYW5jZWw6ZGlhbG9nXCIsIHsgY29tbWFuZDogY29tbWFuZCwgZGlhbG9nQ29udGFpbmVyOiBkaWFsb2dFbGVtZW50LCBjb21tYW5kTGluazogbGluayB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlhbG9nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgIHZhciB0b29sYmFyID0gbmV3IHd5c2lodG1sNS5Ub29sYmFyKCk7XG4gICAgICogICAgLy8gSW5zZXJ0IGEgPGJsb2NrcXVvdGU+IGVsZW1lbnQgb3Igd3JhcCBjdXJyZW50IHNlbGVjdGlvbiBpbiA8YmxvY2txdW90ZT5cbiAgICAgKiAgICB0b29sYmFyLmV4ZWNDb21tYW5kKFwiZm9ybWF0QmxvY2tcIiwgXCJibG9ja3F1b3RlXCIpO1xuICAgICAqL1xuICAgIGV4ZWNDb21tYW5kOiBmdW5jdGlvbiBleGVjQ29tbWFuZChjb21tYW5kLCBjb21tYW5kVmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLmNvbW1hbmRzRGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29tbWFuZE9iaiA9IHRoaXMuY29tbWFuZE1hcHBpbmdbY29tbWFuZCArIFwiOlwiICsgY29tbWFuZFZhbHVlXTtcblxuICAgICAgLy8gU2hvdyBkaWFsb2cgd2hlbiBhdmFpbGFibGVcbiAgICAgIGlmIChjb21tYW5kT2JqICYmIGNvbW1hbmRPYmouZGlhbG9nICYmICFjb21tYW5kT2JqLnN0YXRlKSB7XG4gICAgICAgIGNvbW1hbmRPYmouZGlhbG9nLnNob3coKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2V4ZWNDb21tYW5kKGNvbW1hbmQsIGNvbW1hbmRWYWx1ZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9leGVjQ29tbWFuZDogZnVuY3Rpb24gX2V4ZWNDb21tYW5kKGNvbW1hbmQsIGNvbW1hbmRWYWx1ZSkge1xuICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgY29tcG9zZXIgaXMgZm9jdXNzZWQgKGZhbHNlID0+IGRvbid0IG1vdmUgY2FyZXQgdG8gdGhlIGVuZClcbiAgICAgIHRoaXMuZWRpdG9yLmZvY3VzKGZhbHNlKTtcblxuICAgICAgdGhpcy5jb21wb3Nlci5jb21tYW5kcy5leGVjKGNvbW1hbmQsIGNvbW1hbmRWYWx1ZSk7XG4gICAgICB0aGlzLl91cGRhdGVMaW5rU3RhdGVzKCk7XG4gICAgfSxcblxuICAgIGV4ZWNBY3Rpb246IGZ1bmN0aW9uIGV4ZWNBY3Rpb24oYWN0aW9uKSB7XG4gICAgICB2YXIgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICBjYXNlIFwiY2hhbmdlX3ZpZXdcIjpcbiAgICAgICAgICBpZiAoZWRpdG9yLmN1cnJlbnRWaWV3ID09PSBlZGl0b3IudGV4dGFyZWEpIHtcbiAgICAgICAgICAgIGVkaXRvci5maXJlKFwiY2hhbmdlX3ZpZXdcIiwgXCJjb21wb3NlclwiKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWRpdG9yLmZpcmUoXCJjaGFuZ2Vfdmlld1wiLCBcInRleHRhcmVhXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX29ic2VydmU6IGZ1bmN0aW9uIF9vYnNlcnZlKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxuICAgICAgICAgIGVkaXRvciA9IHRoaXMuZWRpdG9yLFxuICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyLFxuICAgICAgICAgIGxpbmtzID0gdGhpcy5jb21tYW5kTGlua3MuY29uY2F0KHRoaXMuYWN0aW9uTGlua3MpLFxuICAgICAgICAgIGxlbmd0aCA9IGxpbmtzLmxlbmd0aCxcbiAgICAgICAgICBpID0gMDtcblxuICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAvLyAnamF2YXNjcmlwdDo7JyBhbmQgdW5zZWxlY3RhYmxlPW9uIE5lZWRlZCBmb3IgSUUsIGJ1dCBkb25lIGluIGFsbCBicm93c2VycyB0byBtYWtlIHN1cmUgdGhhdCBhbGwgZ2V0IHRoZSBzYW1lIGNzcyBhcHBsaWVkXG4gICAgICAgIC8vICh5b3Uga25vdywgYTpsaW5rIHsgLi4uIH0gZG9lc24ndCBtYXRjaCBhbmNob3JzIHdpdGggbWlzc2luZyBocmVmIGF0dHJpYnV0ZSlcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgIGhyZWY6IFwiamF2YXNjcmlwdDo7XCIsXG4gICAgICAgICAgdW5zZWxlY3RhYmxlOiBcIm9uXCJcbiAgICAgICAgfSkub24obGlua3NbaV0pO1xuICAgICAgfVxuXG4gICAgICAvLyBOZWVkZWQgZm9yIG9wZXJhXG4gICAgICBkb20uZGVsZWdhdGUoY29udGFpbmVyLCBcIltkYXRhLXd5c2lodG1sNS1jb21tYW5kXVwiLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBkb20uZGVsZWdhdGUoY29udGFpbmVyLCBcIltkYXRhLXd5c2lodG1sNS1jb21tYW5kXVwiLCBcImNsaWNrXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgbGluayA9IHRoaXMsXG4gICAgICAgICAgICBjb21tYW5kID0gbGluay5nZXRBdHRyaWJ1dGUoXCJkYXRhLXd5c2lodG1sNS1jb21tYW5kXCIpLFxuICAgICAgICAgICAgY29tbWFuZFZhbHVlID0gbGluay5nZXRBdHRyaWJ1dGUoXCJkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlXCIpO1xuICAgICAgICB0aGF0LmV4ZWNDb21tYW5kKGNvbW1hbmQsIGNvbW1hbmRWYWx1ZSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9KTtcblxuICAgICAgZG9tLmRlbGVnYXRlKGNvbnRhaW5lciwgXCJbZGF0YS13eXNpaHRtbDUtYWN0aW9uXVwiLCBcImNsaWNrXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXd5c2lodG1sNS1hY3Rpb25cIik7XG4gICAgICAgIHRoYXQuZXhlY0FjdGlvbihhY3Rpb24pO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfSk7XG5cbiAgICAgIGVkaXRvci5vYnNlcnZlKFwiZm9jdXM6Y29tcG9zZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGF0LmJvb2ttYXJrID0gbnVsbDtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGF0LmludGVydmFsKTtcbiAgICAgICAgdGhhdC5pbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0Ll91cGRhdGVMaW5rU3RhdGVzKCk7XG4gICAgICAgIH0sIDUwMCk7XG4gICAgICB9KTtcblxuICAgICAgZWRpdG9yLm9ic2VydmUoXCJibHVyOmNvbXBvc2VyXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGF0LmludGVydmFsKTtcbiAgICAgIH0pO1xuXG4gICAgICBlZGl0b3Iub2JzZXJ2ZShcImRlc3Ryb3k6Y29tcG9zZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoYXQuaW50ZXJ2YWwpO1xuICAgICAgfSk7XG5cbiAgICAgIGVkaXRvci5vYnNlcnZlKFwiY2hhbmdlX3ZpZXdcIiwgZnVuY3Rpb24gKGN1cnJlbnRWaWV3KSB7XG4gICAgICAgIC8vIFNldCB0aW1lb3V0IG5lZWRlZCBpbiBvcmRlciB0byBsZXQgdGhlIGJsdXIgZXZlbnQgZmlyZSBmaXJzdFxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LmNvbW1hbmRzRGlzYWJsZWQgPSBjdXJyZW50VmlldyAhPT0gXCJjb21wb3NlclwiO1xuICAgICAgICAgIHRoYXQuX3VwZGF0ZUxpbmtTdGF0ZXMoKTtcbiAgICAgICAgICBpZiAodGhhdC5jb21tYW5kc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICBkb20uYWRkQ2xhc3MoY29udGFpbmVyLCBDTEFTU19OQU1FX0NPTU1BTkRTX0RJU0FCTEVEKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgQ0xBU1NfTkFNRV9DT01NQU5EU19ESVNBQkxFRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBfdXBkYXRlTGlua1N0YXRlczogZnVuY3Rpb24gX3VwZGF0ZUxpbmtTdGF0ZXMoKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuY29tcG9zZXIuZWxlbWVudCxcbiAgICAgICAgICBjb21tYW5kTWFwcGluZyA9IHRoaXMuY29tbWFuZE1hcHBpbmcsXG4gICAgICAgICAgYWN0aW9uTWFwcGluZyA9IHRoaXMuYWN0aW9uTWFwcGluZyxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICBjb21tYW5kO1xuICAgICAgLy8gZXZlcnkgbWlsbGlzZWNvbmQgY291bnRzLi4uIHRoaXMgaXMgZXhlY3V0ZWQgcXVpdGUgb2Z0ZW5cbiAgICAgIGZvciAoaSBpbiBjb21tYW5kTWFwcGluZykge1xuICAgICAgICBjb21tYW5kID0gY29tbWFuZE1hcHBpbmdbaV07XG4gICAgICAgIGlmICh0aGlzLmNvbW1hbmRzRGlzYWJsZWQpIHtcbiAgICAgICAgICBzdGF0ZSA9IGZhbHNlO1xuICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhjb21tYW5kLmxpbmssIENMQVNTX05BTUVfQ09NTUFORF9BQ1RJVkUpO1xuICAgICAgICAgIGlmIChjb21tYW5kLmdyb3VwKSB7XG4gICAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoY29tbWFuZC5ncm91cCwgQ0xBU1NfTkFNRV9DT01NQU5EX0FDVElWRSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb21tYW5kLmRpYWxvZykge1xuICAgICAgICAgICAgY29tbWFuZC5kaWFsb2cuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZSA9IHRoaXMuY29tcG9zZXIuY29tbWFuZHMuc3RhdGUoY29tbWFuZC5uYW1lLCBjb21tYW5kLnZhbHVlKTtcbiAgICAgICAgICBpZiAod3lzaWh0bWw1Lmxhbmcub2JqZWN0KHN0YXRlKS5pc0FycmF5KCkpIHtcbiAgICAgICAgICAgIC8vIEdyYWIgZmlyc3QgYW5kIG9ubHkgb2JqZWN0L2VsZW1lbnQgaW4gc3RhdGUgYXJyYXksIG90aGVyd2lzZSBjb252ZXJ0IHN0YXRlIGludG8gYm9vbGVhblxuICAgICAgICAgICAgLy8gdG8gYXZvaWQgc2hvd2luZyBhIGRpYWxvZyBmb3IgbXVsdGlwbGUgc2VsZWN0ZWQgZWxlbWVudHMgd2hpY2ggbWF5IGhhdmUgZGlmZmVyZW50IGF0dHJpYnV0ZXNcbiAgICAgICAgICAgIC8vIGVnLiB3aGVuIHR3byBsaW5rcyB3aXRoIGRpZmZlcmVudCBocmVmIGFyZSBzZWxlY3RlZCwgdGhlIHN0YXRlIHdpbGwgYmUgYW4gYXJyYXkgY29uc2lzdGluZyBvZiBib3RoIGxpbmsgZWxlbWVudHNcbiAgICAgICAgICAgIC8vIGJ1dCB0aGUgZGlhbG9nIGludGVyZmFjZSBjYW4gb25seSB1cGRhdGUgb25lXG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlLmxlbmd0aCA9PT0gMSA/IHN0YXRlWzBdIDogdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGNvbW1hbmQubGluaywgQ0xBU1NfTkFNRV9DT01NQU5EX0RJU0FCTEVEKTtcbiAgICAgICAgICBpZiAoY29tbWFuZC5ncm91cCkge1xuICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGNvbW1hbmQuZ3JvdXAsIENMQVNTX05BTUVfQ09NTUFORF9ESVNBQkxFRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1hbmQuc3RhdGUgPT09IHN0YXRlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb21tYW5kLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIGRvbS5hZGRDbGFzcyhjb21tYW5kLmxpbmssIENMQVNTX05BTUVfQ09NTUFORF9BQ1RJVkUpO1xuICAgICAgICAgIGlmIChjb21tYW5kLmdyb3VwKSB7XG4gICAgICAgICAgICBkb20uYWRkQ2xhc3MoY29tbWFuZC5ncm91cCwgQ0xBU1NfTkFNRV9DT01NQU5EX0FDVElWRSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb21tYW5kLmRpYWxvZykge1xuICAgICAgICAgICAgaWYgKCh0eXBlb2Ygc3RhdGUgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihzdGF0ZSkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIGNvbW1hbmQuZGlhbG9nLnNob3coc3RhdGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29tbWFuZC5kaWFsb2cuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb20ucmVtb3ZlQ2xhc3MoY29tbWFuZC5saW5rLCBDTEFTU19OQU1FX0NPTU1BTkRfQUNUSVZFKTtcbiAgICAgICAgICBpZiAoY29tbWFuZC5ncm91cCkge1xuICAgICAgICAgICAgZG9tLnJlbW92ZUNsYXNzKGNvbW1hbmQuZ3JvdXAsIENMQVNTX05BTUVfQ09NTUFORF9BQ1RJVkUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tbWFuZC5kaWFsb2cpIHtcbiAgICAgICAgICAgIGNvbW1hbmQuZGlhbG9nLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpIGluIGFjdGlvbk1hcHBpbmcpIHtcbiAgICAgICAgYWN0aW9uID0gYWN0aW9uTWFwcGluZ1tpXTtcblxuICAgICAgICBpZiAoYWN0aW9uLm5hbWUgPT09IFwiY2hhbmdlX3ZpZXdcIikge1xuICAgICAgICAgIGFjdGlvbi5zdGF0ZSA9IHRoaXMuZWRpdG9yLmN1cnJlbnRWaWV3ID09PSB0aGlzLmVkaXRvci50ZXh0YXJlYTtcbiAgICAgICAgICBpZiAoYWN0aW9uLnN0YXRlKSB7XG4gICAgICAgICAgICBkb20uYWRkQ2xhc3MoYWN0aW9uLmxpbmssIENMQVNTX05BTUVfQUNUSU9OX0FDVElWRSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvbS5yZW1vdmVDbGFzcyhhY3Rpb24ubGluaywgQ0xBU1NfTkFNRV9BQ1RJT05fQUNUSVZFKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuICAgIH0sXG5cbiAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH1cbiAgfSk7XG59KSh3eXNpaHRtbDUpO1xuLyoqXG4gKiBXWVNJSFRNTDUgRWRpdG9yXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSB0ZXh0YXJlYUVsZW1lbnQgUmVmZXJlbmNlIHRvIHRoZSB0ZXh0YXJlYSB3aGljaCBzaG91bGQgYmUgdHVybmVkIGludG8gYSByaWNoIHRleHQgaW50ZXJmYWNlXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gU2VlIGRlZmF1bHRDb25maWcgb2JqZWN0IGJlbG93IGZvciBleHBsYW5hdGlvbiBvZiBlYWNoIGluZGl2aWR1YWwgY29uZmlnIG9wdGlvblxuICpcbiAqIEBldmVudHNcbiAqICAgIGxvYWRcbiAqICAgIGJlZm9yZWxvYWQgKGZvciBpbnRlcm5hbCB1c2Ugb25seSlcbiAqICAgIGZvY3VzXG4gKiAgICBmb2N1czpjb21wb3NlclxuICogICAgZm9jdXM6dGV4dGFyZWFcbiAqICAgIGJsdXJcbiAqICAgIGJsdXI6Y29tcG9zZXJcbiAqICAgIGJsdXI6dGV4dGFyZWFcbiAqICAgIGNoYW5nZVxuICogICAgY2hhbmdlOmNvbXBvc2VyXG4gKiAgICBjaGFuZ2U6dGV4dGFyZWFcbiAqICAgIHBhc3RlXG4gKiAgICBwYXN0ZTpjb21wb3NlclxuICogICAgcGFzdGU6dGV4dGFyZWFcbiAqICAgIG5ld3dvcmQ6Y29tcG9zZXJcbiAqICAgIGRlc3Ryb3k6Y29tcG9zZXJcbiAqICAgIHVuZG86Y29tcG9zZXJcbiAqICAgIHJlZG86Y29tcG9zZXJcbiAqICAgIGJlZm9yZWNvbW1hbmQ6Y29tcG9zZXJcbiAqICAgIGFmdGVyY29tbWFuZDpjb21wb3NlclxuICogICAgY2hhbmdlX3ZpZXdcbiAqL1xuKGZ1bmN0aW9uICh3eXNpaHRtbDUpIHtcbiAgdmFyIHVuZGVmO1xuXG4gIHZhciBkZWZhdWx0Q29uZmlnID0ge1xuICAgIC8vIEdpdmUgdGhlIGVkaXRvciBhIG5hbWUsIHRoZSBuYW1lIHdpbGwgYWxzbyBiZSBzZXQgYXMgY2xhc3MgbmFtZSBvbiB0aGUgaWZyYW1lIGFuZCBvbiB0aGUgaWZyYW1lJ3MgYm9keSBcbiAgICBuYW1lOiB1bmRlZixcbiAgICAvLyBXaGV0aGVyIHRoZSBlZGl0b3Igc2hvdWxkIGxvb2sgbGlrZSB0aGUgdGV4dGFyZWEgKGJ5IGFkb3B0aW5nIHN0eWxlcylcbiAgICBzdHlsZTogdHJ1ZSxcbiAgICAvLyBJZCBvZiB0aGUgdG9vbGJhciBlbGVtZW50LCBwYXNzIGZhbHNleSB2YWx1ZSBpZiB5b3UgZG9uJ3Qgd2FudCBhbnkgdG9vbGJhciBsb2dpY1xuICAgIHRvb2xiYXI6IHVuZGVmLFxuICAgIC8vIFdoZXRoZXIgdXJscywgZW50ZXJlZCBieSB0aGUgdXNlciBzaG91bGQgYXV0b21hdGljYWxseSBiZWNvbWUgY2xpY2thYmxlLWxpbmtzXG4gICAgYXV0b0xpbms6IHRydWUsXG4gICAgLy8gT2JqZWN0IHdoaWNoIGluY2x1ZGVzIHBhcnNlciBydWxlcyB0byBhcHBseSB3aGVuIGh0bWwgZ2V0cyBpbnNlcnRlZCB2aWEgY29weSAmIHBhc3RlXG4gICAgLy8gU2VlIHBhcnNlcl9ydWxlcy8qLmpzIGZvciBleGFtcGxlc1xuICAgIHBhcnNlclJ1bGVzOiB7IHRhZ3M6IHsgYnI6IHt9LCBzcGFuOiB7fSwgZGl2OiB7fSwgcDoge30gfSwgY2xhc3Nlczoge30gfSxcbiAgICAvLyBQYXJzZXIgbWV0aG9kIHRvIHVzZSB3aGVuIHRoZSB1c2VyIGluc2VydHMgY29udGVudCB2aWEgY29weSAmIHBhc3RlXG4gICAgcGFyc2VyOiB3eXNpaHRtbDUuZG9tLnBhcnNlLFxuICAgIC8vIENsYXNzIG5hbWUgd2hpY2ggc2hvdWxkIGJlIHNldCBvbiB0aGUgY29udGVudEVkaXRhYmxlIGVsZW1lbnQgaW4gdGhlIGNyZWF0ZWQgc2FuZGJveCBpZnJhbWUsIGNhbiBiZSBzdHlsZWQgdmlhIHRoZSAnc3R5bGVzaGVldHMnIG9wdGlvblxuICAgIGNvbXBvc2VyQ2xhc3NOYW1lOiBcInd5c2lodG1sNS1lZGl0b3JcIixcbiAgICAvLyBDbGFzcyBuYW1lIHRvIGFkZCB0byB0aGUgYm9keSB3aGVuIHRoZSB3eXNpaHRtbDUgZWRpdG9yIGlzIHN1cHBvcnRlZFxuICAgIGJvZHlDbGFzc05hbWU6IFwid3lzaWh0bWw1LXN1cHBvcnRlZFwiLFxuICAgIC8vIEFycmF5IChvciBzaW5nbGUgc3RyaW5nKSBvZiBzdHlsZXNoZWV0IHVybHMgdG8gYmUgbG9hZGVkIGluIHRoZSBlZGl0b3IncyBpZnJhbWVcbiAgICBzdHlsZXNoZWV0czogW10sXG4gICAgLy8gUGxhY2Vob2xkZXIgdGV4dCB0byB1c2UsIGRlZmF1bHRzIHRvIHRoZSBwbGFjZWhvbGRlciBhdHRyaWJ1dGUgb24gdGhlIHRleHRhcmVhIGVsZW1lbnRcbiAgICBwbGFjZWhvbGRlclRleHQ6IHVuZGVmLFxuICAgIC8vIFdoZXRoZXIgdGhlIGNvbXBvc2VyIHNob3VsZCBhbGxvdyB0aGUgdXNlciB0byBtYW51YWxseSByZXNpemUgaW1hZ2VzLCB0YWJsZXMgZXRjLlxuICAgIGFsbG93T2JqZWN0UmVzaXppbmc6IHRydWUsXG4gICAgLy8gV2hldGhlciB0aGUgcmljaCB0ZXh0IGVkaXRvciBzaG91bGQgYmUgcmVuZGVyZWQgb24gdG91Y2ggZGV2aWNlcyAod3lzaWh0bWw1ID49IDAuMy4wIGNvbWVzIHdpdGggYmFzaWMgc3VwcG9ydCBmb3IgaU9TIDUpXG4gICAgc3VwcG9ydFRvdWNoRGV2aWNlczogdHJ1ZVxuICB9O1xuXG4gIHd5c2lodG1sNS5FZGl0b3IgPSB3eXNpaHRtbDUubGFuZy5EaXNwYXRjaGVyLmV4dGVuZChcbiAgLyoqIEBzY29wZSB3eXNpaHRtbDUuRWRpdG9yLnByb3RvdHlwZSAqL3tcbiAgICBjb25zdHJ1Y3RvcjogZnVuY3Rpb24gY29uc3RydWN0b3IodGV4dGFyZWFFbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHRoaXMudGV4dGFyZWFFbGVtZW50ID0gdHlwZW9mIHRleHRhcmVhRWxlbWVudCA9PT0gXCJzdHJpbmdcIiA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRleHRhcmVhRWxlbWVudCkgOiB0ZXh0YXJlYUVsZW1lbnQ7XG4gICAgICB0aGlzLmNvbmZpZyA9IHd5c2lodG1sNS5sYW5nLm9iamVjdCh7fSkubWVyZ2UoZGVmYXVsdENvbmZpZykubWVyZ2UoY29uZmlnKS5nZXQoKTtcbiAgICAgIHRoaXMudGV4dGFyZWEgPSBuZXcgd3lzaWh0bWw1LnZpZXdzLlRleHRhcmVhKHRoaXMsIHRoaXMudGV4dGFyZWFFbGVtZW50LCB0aGlzLmNvbmZpZyk7XG4gICAgICB0aGlzLmN1cnJlbnRWaWV3ID0gdGhpcy50ZXh0YXJlYTtcbiAgICAgIHRoaXMuX2lzQ29tcGF0aWJsZSA9IHd5c2lodG1sNS5icm93c2VyLnN1cHBvcnRlZCgpO1xuXG4gICAgICAvLyBTb3J0IG91dCB1bnN1cHBvcnRlZC91bndhbnRlZCBicm93c2VycyBoZXJlXG4gICAgICBpZiAoIXRoaXMuX2lzQ29tcGF0aWJsZSB8fCAhdGhpcy5jb25maWcuc3VwcG9ydFRvdWNoRGV2aWNlcyAmJiB3eXNpaHRtbDUuYnJvd3Nlci5pc1RvdWNoRGV2aWNlKCkpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGF0LmZpcmUoXCJiZWZvcmVsb2FkXCIpLmZpcmUoXCJsb2FkXCIpO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgY2xhc3MgbmFtZSB0byBib2R5LCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBlZGl0b3IgaXMgc3VwcG9ydGVkXG4gICAgICB3eXNpaHRtbDUuZG9tLmFkZENsYXNzKGRvY3VtZW50LmJvZHksIHRoaXMuY29uZmlnLmJvZHlDbGFzc05hbWUpO1xuXG4gICAgICB0aGlzLmNvbXBvc2VyID0gbmV3IHd5c2lodG1sNS52aWV3cy5Db21wb3Nlcih0aGlzLCB0aGlzLnRleHRhcmVhRWxlbWVudCwgdGhpcy5jb25maWcpO1xuICAgICAgdGhpcy5jdXJyZW50VmlldyA9IHRoaXMuY29tcG9zZXI7XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5jb25maWcucGFyc2VyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5faW5pdFBhcnNlcigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9ic2VydmUoXCJiZWZvcmVsb2FkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zeW5jaHJvbml6ZXIgPSBuZXcgd3lzaWh0bWw1LnZpZXdzLlN5bmNocm9uaXplcih0aGlzLCB0aGlzLnRleHRhcmVhLCB0aGlzLmNvbXBvc2VyKTtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRvb2xiYXIpIHtcbiAgICAgICAgICB0aGlzLnRvb2xiYXIgPSBuZXcgd3lzaWh0bWw1LnRvb2xiYXIuVG9vbGJhcih0aGlzLCB0aGlzLmNvbmZpZy50b29sYmFyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSGV5YSEgVGhpcyBwYWdlIGlzIHVzaW5nIHd5c2lodG1sNSBmb3IgcmljaCB0ZXh0IGVkaXRpbmcuIENoZWNrIG91dCBodHRwczovL2dpdGh1Yi5jb20veGluZy93eXNpaHRtbDVcIik7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH0sXG5cbiAgICBpc0NvbXBhdGlibGU6IGZ1bmN0aW9uIGlzQ29tcGF0aWJsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc0NvbXBhdGlibGU7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuY3VycmVudFZpZXcuY2xlYXIoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24gZ2V0VmFsdWUocGFyc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRWaWV3LmdldFZhbHVlKHBhcnNlKTtcbiAgICB9LFxuXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKGh0bWwsIHBhcnNlKSB7XG4gICAgICBpZiAoIWh0bWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3VycmVudFZpZXcuc2V0VmFsdWUoaHRtbCwgcGFyc2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZvY3VzOiBmdW5jdGlvbiBmb2N1cyhzZXRUb0VuZCkge1xuICAgICAgdGhpcy5jdXJyZW50Vmlldy5mb2N1cyhzZXRUb0VuZCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGVhY3RpdmF0ZSBlZGl0b3IgKG1ha2UgaXQgcmVhZG9ubHkpXG4gICAgICovXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgIHRoaXMuY3VycmVudFZpZXcuZGlzYWJsZSgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFjdGl2YXRlIGVkaXRvclxuICAgICAqL1xuICAgIGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgICAgdGhpcy5jdXJyZW50Vmlldy5lbmFibGUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpc0VtcHR5OiBmdW5jdGlvbiBpc0VtcHR5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFZpZXcuaXNFbXB0eSgpO1xuICAgIH0sXG5cbiAgICBoYXNQbGFjZWhvbGRlclNldDogZnVuY3Rpb24gaGFzUGxhY2Vob2xkZXJTZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50Vmlldy5oYXNQbGFjZWhvbGRlclNldCgpO1xuICAgIH0sXG5cbiAgICBwYXJzZTogZnVuY3Rpb24gcGFyc2UoaHRtbE9yRWxlbWVudCkge1xuICAgICAgdmFyIHJldHVyblZhbHVlID0gdGhpcy5jb25maWcucGFyc2VyKGh0bWxPckVsZW1lbnQsIHRoaXMuY29uZmlnLnBhcnNlclJ1bGVzLCB0aGlzLmNvbXBvc2VyLnNhbmRib3guZ2V0RG9jdW1lbnQoKSwgdHJ1ZSk7XG4gICAgICBpZiAoKHR5cGVvZiBodG1sT3JFbGVtZW50ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoaHRtbE9yRWxlbWVudCkpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHd5c2lodG1sNS5xdWlya3MucmVkcmF3KGh0bWxPckVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIGh0bWwgcGFyc2VyIGxvZ2ljXG4gICAgICogIC0gT2JzZXJ2ZXMgZm9yIHBhc3RlIGFuZCBkcm9wXG4gICAgICovXG4gICAgX2luaXRQYXJzZXI6IGZ1bmN0aW9uIF9pbml0UGFyc2VyKCkge1xuICAgICAgdGhpcy5vYnNlcnZlKFwicGFzdGU6Y29tcG9zZXJcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIga2VlcFNjcm9sbFBvc2l0aW9uID0gdHJ1ZSxcbiAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgICB0aGF0LmNvbXBvc2VyLnNlbGVjdGlvbi5leGVjdXRlQW5kUmVzdG9yZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd3lzaWh0bWw1LnF1aXJrcy5jbGVhblBhc3RlZEhUTUwodGhhdC5jb21wb3Nlci5lbGVtZW50KTtcbiAgICAgICAgICB0aGF0LnBhcnNlKHRoYXQuY29tcG9zZXIuZWxlbWVudCk7XG4gICAgICAgIH0sIGtlZXBTY3JvbGxQb3NpdGlvbik7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5vYnNlcnZlKFwicGFzdGU6dGV4dGFyZWFcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnRleHRhcmVhLmdldFZhbHVlKCksXG4gICAgICAgICAgICBuZXdWYWx1ZTtcbiAgICAgICAgbmV3VmFsdWUgPSB0aGlzLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgdGhpcy50ZXh0YXJlYS5zZXRWYWx1ZShuZXdWYWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufSkod3lzaWh0bWw1KTtcbi8qKlxuQm9vdHN0cmFwIHd5c2lodG1sNSBlZGl0b3IuIEJhc2VkIG9uIFtib290c3RyYXAtd3lzaWh0bWw1XShodHRwczovL2dpdGh1Yi5jb20vamhvbGxpbmd3b3J0aC9ib290c3RyYXAtd3lzaWh0bWw1KS4gIFxuWW91IHNob3VsZCBpbmNsdWRlICoqbWFudWFsbHkqKiBkaXN0cmlidXRpdmVzIG9mIGB3eXNpaHRtbDVgIGFuZCBgYm9vdHN0cmFwLXd5c2lodG1sNWA6XG5cbiAgICA8bGluayBocmVmPVwianMvaW5wdXRzLWV4dC93eXNpaHRtbDUvYm9vdHN0cmFwLXd5c2lodG1sNS0wLjAuMi9ib290c3RyYXAtd3lzaWh0bWw1LTAuMC4yLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIiB0eXBlPVwidGV4dC9jc3NcIj48L2xpbms+ICBcbiAgICA8c2NyaXB0IHNyYz1cImpzL2lucHV0cy1leHQvd3lzaWh0bWw1L2Jvb3RzdHJhcC13eXNpaHRtbDUtMC4wLjIvd3lzaWh0bWw1LTAuMy4wLm1pbi5qc1wiPjwvc2NyaXB0PiAgXG4gICAgPHNjcmlwdCBzcmM9XCJqcy9pbnB1dHMtZXh0L3d5c2lodG1sNS9ib290c3RyYXAtd3lzaWh0bWw1LTAuMC4yL2Jvb3RzdHJhcC13eXNpaHRtbDUtMC4wLjIubWluLmpzXCI+PC9zY3JpcHQ+XG4gICAgXG5BbmQgYWxzbyBpbmNsdWRlIGB3eXNpaHRtbDUuanNgIGZyb20gYGlucHV0cy1leHRgIGRpcmVjdG9yeSBvZiB4LWVkaXRhYmxlOlxuICAgICAgXG4gICAgPHNjcmlwdCBzcmM9XCJqcy9pbnB1dHMtZXh0L3d5c2lodG1sNS93eXNpaHRtbDUuanNcIj48L3NjcmlwdD4gIFxuXG4qKk5vdGU6KiogSXQncyBiZXR0ZXIgdG8gdXNlIGZyZXNoIGJvb3RzdHJhcC13eXNpaHRtbDUgZnJvbSBpdCdzIFttYXN0ZXIgYnJhbmNoXShodHRwczovL2dpdGh1Yi5jb20vamhvbGxpbmd3b3J0aC9ib290c3RyYXAtd3lzaWh0bWw1L3RyZWUvbWFzdGVyL3NyYykgYXMgdGhlcmUgaXMgdXBkYXRlIGZvciBjb3JyZWN0IGltYWdlIGluc2VydGlvbi4gICAgXG4gICAgXG5AY2xhc3Mgd3lzaWh0bWw1XG5AZXh0ZW5kcyBhYnN0cmFjdGlucHV0XG5AZmluYWxcbkBzaW5jZSAxLjQuMFxuQGV4YW1wbGVcbjxkaXYgaWQ9XCJjb21tZW50c1wiIGRhdGEtdHlwZT1cInd5c2lodG1sNVwiIGRhdGEtcGs9XCIxXCI+PGgyPmF3ZXNvbWU8L2gyPiBjb21tZW50ITwvZGl2PlxuPHNjcmlwdD5cbiQoZnVuY3Rpb24oKXtcbiAgICAkKCcjY29tbWVudHMnKS5lZGl0YWJsZSh7XG4gICAgICAgIHVybDogJy9wb3N0JyxcbiAgICAgICAgdGl0bGU6ICdFbnRlciBjb21tZW50cydcbiAgICB9KTtcbn0pO1xuPC9zY3JpcHQ+XG4qKi9cbihmdW5jdGlvbiAoJCkge1xuXG4gIHdpbmRvdy5XeXNpaHRtbDUgPSBmdW5jdGlvbiBXeXNpaHRtbDUob3B0aW9ucykge1xuICAgIHRoaXMuaW5pdCgnd3lzaWh0bWw1Jywgb3B0aW9ucywgV3lzaWh0bWw1LmRlZmF1bHRzKTtcblxuICAgIC8vZXh0ZW5kIHd5c2lodG1sNSBtYW51YWxseSBhcyAkLmV4dGVuZCBub3QgcmVjdXJzaXZlIFxuICAgIHRoaXMub3B0aW9ucy53eXNpaHRtbDUgPSAkLmV4dGVuZCh7fSwgV3lzaWh0bWw1LmRlZmF1bHRzLnd5c2lodG1sNSwgb3B0aW9ucy53eXNpaHRtbDUpO1xuICB9O1xuXG4gIHdpbmRvdy4kLmZuLmVkaXRhYmxldXRpbHMuaW5oZXJpdChXeXNpaHRtbDUsIHdpbmRvdy4kLmZuLmVkaXRhYmxldHlwZXMuYWJzdHJhY3RpbnB1dCk7XG5cbiAgJC5leHRlbmQoV3lzaWh0bWw1LnByb3RvdHlwZSwge1xuICAgIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpLFxuICAgICAgICAgIG1zaWVPbGQ7XG5cbiAgICAgIC8vZ2VuZXJhdGUgdW5pcXVlIGlkIGFzIGl0IHJlcXVpcmVkIGZvciB3eXNpaHRtbDVcbiAgICAgIHRoaXMuJGlucHV0LmF0dHIoJ2lkJywgJ3RleHRhcmVhXycgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG5cbiAgICAgIHRoaXMuc2V0Q2xhc3MoKTtcbiAgICAgIHRoaXMuc2V0QXR0cigncGxhY2Vob2xkZXInKTtcblxuICAgICAgLy9yZXNvbHZlIGRlZmZlcmVkIHdoZW4gd2lkZ2V0IGxvYWRlZFxuICAgICAgJC5leHRlbmQodGhpcy5vcHRpb25zLnd5c2lodG1sNSwge1xuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICBsb2FkOiBmdW5jdGlvbiBsb2FkKCkge1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuJGlucHV0Lnd5c2lodG1sNSh0aGlzLm9wdGlvbnMud3lzaWh0bWw1KTtcblxuICAgICAgLypcbiAgICAgICBJbiBJRTggd3lzaWh0bWw1IGlmcmFtZSBzdGF5cyBvbiB0aGUgc2FtZSBsaW5lIHdpdGggYnV0dG9ucyB0b29sYmFyIChpbnNpZGUgcG9wb3ZlcikuXG4gICAgICAgVGhlIG9ubHkgc29sdXRpb24gSSBmb3VuZCBpcyB0byBhZGQgPGJyPi4gSWYgeW91IGZpbmUgYmV0dGVyIHdheSwgcGxlYXNlIHNlbmQgUFIuICAgXG4gICAgICAqL1xuICAgICAgbXNpZU9sZCA9IC9tc2llXFxzKig4fDd8NikvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIGlmIChtc2llT2xkKSB7XG4gICAgICAgIHRoaXMuJGlucHV0LmJlZm9yZSgnPGJyPjxicj4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2UoKTtcbiAgICB9LFxuXG4gICAgdmFsdWUyaHRtbDogZnVuY3Rpb24gdmFsdWUyaHRtbCh2YWx1ZSwgZWxlbWVudCkge1xuICAgICAgJChlbGVtZW50KS5odG1sKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgaHRtbDJ2YWx1ZTogZnVuY3Rpb24gaHRtbDJ2YWx1ZShodG1sKSB7XG4gICAgICByZXR1cm4gaHRtbDtcbiAgICB9LFxuXG4gICAgdmFsdWUyaW5wdXQ6IGZ1bmN0aW9uIHZhbHVlMmlucHV0KHZhbHVlKSB7XG4gICAgICB0aGlzLiRpbnB1dC5kYXRhKFwid3lzaWh0bWw1XCIpLmVkaXRvci5zZXRWYWx1ZSh2YWx1ZSwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIGFjdGl2YXRlOiBmdW5jdGlvbiBhY3RpdmF0ZSgpIHtcbiAgICAgIHRoaXMuJGlucHV0LmRhdGEoXCJ3eXNpaHRtbDVcIikuZWRpdG9yLmZvY3VzKCk7XG4gICAgfSxcblxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uIGlzRW1wdHkoJGVsZW1lbnQpIHtcbiAgICAgIGlmICgkLnRyaW0oJGVsZW1lbnQuaHRtbCgpKSA9PT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCQudHJpbSgkZWxlbWVudC50ZXh0KCkpICE9PSAnJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2UuZy4gJzxpbWc+JywgJzxicj4nLCAnPHA+PC9wPidcbiAgICAgICAgcmV0dXJuICEkZWxlbWVudC5oZWlnaHQoKSB8fCAhJGVsZW1lbnQud2lkdGgoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIFd5c2lodG1sNS5kZWZhdWx0cyA9ICQuZXh0ZW5kKHt9LCB3aW5kb3cuJC5mbi5lZGl0YWJsZXR5cGVzLmFic3RyYWN0aW5wdXQuZGVmYXVsdHMsIHtcbiAgICAvKipcbiAgICBAcHJvcGVydHkgdHBsXG4gICAgQGRlZmF1bHQgPHRleHRhcmVhPjwvdGV4dGFyZWE+XG4gICAgKiovXG4gICAgdHBsOiAnPHRleHRhcmVhPjwvdGV4dGFyZWE+JyxcbiAgICAvKipcbiAgICBAcHJvcGVydHkgaW5wdXRjbGFzc1xuICAgIEBkZWZhdWx0IGVkaXRhYmxlLXd5c2lodG1sNVxuICAgICoqL1xuICAgIGlucHV0Y2xhc3M6ICdlZGl0YWJsZS13eXNpaHRtbDUnLFxuICAgIC8qKlxuICAgIFBsYWNlaG9sZGVyIGF0dHJpYnV0ZSBvZiBpbnB1dC4gU2hvd24gd2hlbiBpbnB1dCBpcyBlbXB0eS5cbiAgICAgQHByb3BlcnR5IHBsYWNlaG9sZGVyXG4gICAgQHR5cGUgc3RyaW5nXG4gICAgQGRlZmF1bHQgbnVsbFxuICAgICoqL1xuICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgIC8qKlxuICAgIFd5c2lodG1sNSBkZWZhdWx0IG9wdGlvbnMuICBcbiAgICBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pob2xsaW5nd29ydGgvYm9vdHN0cmFwLXd5c2lodG1sNSNvcHRpb25zXG4gICAgIEBwcm9wZXJ0eSB3eXNpaHRtbDVcbiAgICBAdHlwZSBvYmplY3RcbiAgICBAZGVmYXVsdCB7c3R5bGVzaGVldHM6IGZhbHNlfVxuICAgICoqL1xuICAgIHd5c2lodG1sNToge1xuICAgICAgc3R5bGVzaGVldHM6IGZhbHNlXG4gICAgfVxuICB9KTtcblxuICB3aW5kb3cuJC5mbi5lZGl0YWJsZXR5cGVzLnd5c2lodG1sNSA9IFd5c2lodG1sNTtcbn0pKHdpbmRvdy5qUXVlcnkpO1xuXG4hZnVuY3Rpb24gKCQsIHd5c2kpIHtcblxuICB2YXIgdHBsID0ge1xuICAgIFwiZm9udC1zdHlsZXNcIjogZnVuY3Rpb24gZm9udFN0eWxlcyhsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzaXplID0gb3B0aW9ucyAmJiBvcHRpb25zLnNpemUgPyAnIGJ0bi0nICsgb3B0aW9ucy5zaXplIDogJyc7XG4gICAgICByZXR1cm4gXCI8bGkgY2xhc3M9J2Ryb3Bkb3duJz5cIiArIFwiPGEgY2xhc3M9J2J0biBidG4tZGVmYXVsdCBkcm9wZG93bi10b2dnbGVcIiArIHNpemUgKyBcIicgZGF0YS10b2dnbGU9J2Ryb3Bkb3duJyBocmVmPScjJz5cIiArIFwiPGkgY2xhc3M9J2ZhIGZhLWZvbnQnPjwvaT4mbmJzcDs8c3BhbiBjbGFzcz0nY3VycmVudC1mb250Jz5cIiArIGxvY2FsZS5mb250X3N0eWxlcy5ub3JtYWwgKyBcIjwvc3Bhbj4mbmJzcDs8YiBjbGFzcz0nY2FyZXQnPjwvYj5cIiArIFwiPC9hPlwiICsgXCI8dWwgY2xhc3M9J2Ryb3Bkb3duLW1lbnUnPlwiICsgXCI8bGk+PGEgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0nZm9ybWF0QmxvY2snIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J2RpdicgdGFiaW5kZXg9Jy0xJz5cIiArIGxvY2FsZS5mb250X3N0eWxlcy5ub3JtYWwgKyBcIjwvYT48L2xpPlwiICsgXCI8bGk+PGEgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0nZm9ybWF0QmxvY2snIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J2gxJyB0YWJpbmRleD0nLTEnPlwiICsgbG9jYWxlLmZvbnRfc3R5bGVzLmgxICsgXCI8L2E+PC9saT5cIiArIFwiPGxpPjxhIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2Zvcm1hdEJsb2NrJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdoMicgdGFiaW5kZXg9Jy0xJz5cIiArIGxvY2FsZS5mb250X3N0eWxlcy5oMiArIFwiPC9hPjwvbGk+XCIgKyBcIjxsaT48YSBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JtYXRCbG9jaycgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT0naDMnIHRhYmluZGV4PSctMSc+XCIgKyBsb2NhbGUuZm9udF9zdHlsZXMuaDMgKyBcIjwvYT48L2xpPlwiICsgXCI8L3VsPlwiICsgXCI8L2xpPlwiO1xuICAgIH0sXG5cbiAgICBcImVtcGhhc2lzXCI6IGZ1bmN0aW9uIGVtcGhhc2lzKGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHNpemUgPSBvcHRpb25zICYmIG9wdGlvbnMuc2l6ZSA/ICcgYnRuLScgKyBvcHRpb25zLnNpemUgOiAnJztcbiAgICAgIHJldHVybiBcIjxsaT5cIiArIFwiPGRpdiBjbGFzcz0nYnRuLWdyb3VwJz5cIiArIFwiPGEgY2xhc3M9J2J0biBidG4tZGVmYXVsdFwiICsgc2l6ZSArIFwiJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdib2xkJyB0aXRsZT0nQ1RSTCtCJyB0YWJpbmRleD0nLTEnPlwiICsgbG9jYWxlLmVtcGhhc2lzLmJvbGQgKyBcIjwvYT5cIiArIFwiPGEgY2xhc3M9J2J0biBidG4tZGVmYXVsdFwiICsgc2l6ZSArIFwiJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdpdGFsaWMnIHRpdGxlPSdDVFJMK0knIHRhYmluZGV4PSctMSc+XCIgKyBsb2NhbGUuZW1waGFzaXMuaXRhbGljICsgXCI8L2E+XCIgKyBcIjxhIGNsYXNzPSdidG4gYnRuLWRlZmF1bHRcIiArIHNpemUgKyBcIicgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0ndW5kZXJsaW5lJyB0aXRsZT0nQ1RSTCtVJyB0YWJpbmRleD0nLTEnPlwiICsgbG9jYWxlLmVtcGhhc2lzLnVuZGVybGluZSArIFwiPC9hPlwiICsgXCI8L2Rpdj5cIiArIFwiPC9saT5cIjtcbiAgICB9LFxuXG4gICAgXCJsaXN0c1wiOiBmdW5jdGlvbiBsaXN0cyhsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzaXplID0gb3B0aW9ucyAmJiBvcHRpb25zLnNpemUgPyAnIGJ0bi0nICsgb3B0aW9ucy5zaXplIDogJyc7XG4gICAgICByZXR1cm4gXCI8bGk+XCIgKyBcIjxkaXYgY2xhc3M9J2J0bi1ncm91cCc+XCIgKyBcIjxhIGNsYXNzPSdidG4gYnRuLWRlZmF1bHRcIiArIHNpemUgKyBcIicgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0naW5zZXJ0VW5vcmRlcmVkTGlzdCcgdGl0bGU9J1wiICsgbG9jYWxlLmxpc3RzLnVub3JkZXJlZCArIFwiJyB0YWJpbmRleD0nLTEnPjxpIGNsYXNzPSdmYSBmYS1saXN0Jz48L2k+PC9hPlwiICsgXCI8YSBjbGFzcz0nYnRuIGJ0bi1kZWZhdWx0XCIgKyBzaXplICsgXCInIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2luc2VydE9yZGVyZWRMaXN0JyB0aXRsZT0nXCIgKyBsb2NhbGUubGlzdHMub3JkZXJlZCArIFwiJyB0YWJpbmRleD0nLTEnPjxpIGNsYXNzPSdmYSBmYS10aC1saXN0Jz48L2k+PC9hPlwiICsgXCI8YSBjbGFzcz0nYnRuIGJ0bi1kZWZhdWx0XCIgKyBzaXplICsgXCInIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2NsZWFyJyB0aXRsZT0nYmFuJyB0YWJpbmRleD0nLTEnPjxpIGNsYXNzPSdmYSBmYS1iYW4nPjwvaT48L2E+XCIgKyBcIjwvZGl2PlwiICsgXCI8L2xpPlwiO1xuICAgIH0sXG5cbiAgICBcImxpbmtcIjogZnVuY3Rpb24gbGluayhsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzaXplID0gb3B0aW9ucyAmJiBvcHRpb25zLnNpemUgPyAnIGJ0bi0nICsgb3B0aW9ucy5zaXplIDogJyc7XG4gICAgICByZXR1cm4gXCI8bGk+XCIgKyBcIjxkaXYgY2xhc3M9J2Jvb3RzdHJhcC13eXNpaHRtbDUtaW5zZXJ0LWxpbmstbW9kYWwgbW9kYWwgaGlkZSBmYWRlJz5cIiArIFwiPGRpdiBjbGFzcz0nbW9kYWwtaGVhZGVyJz5cIiArIFwiPGEgY2xhc3M9J2Nsb3NlJyBkYXRhLWRpc21pc3M9J21vZGFsJz4mdGltZXM7PC9hPlwiICsgXCI8aDM+XCIgKyBsb2NhbGUubGluay5pbnNlcnQgKyBcIjwvaDM+XCIgKyBcIjwvZGl2PlwiICsgXCI8ZGl2IGNsYXNzPSdtb2RhbC1ib2R5Jz5cIiArIFwiPGlucHV0IHZhbHVlPSdodHRwOi8vJyBjbGFzcz0nYm9vdHN0cmFwLXd5c2lodG1sNS1pbnNlcnQtbGluay11cmwgaW5wdXQteGxhcmdlJz5cIiArIFwiPC9kaXY+XCIgKyBcIjxkaXYgY2xhc3M9J21vZGFsLWZvb3Rlcic+XCIgKyBcIjxhIGhyZWY9JyMnIGNsYXNzPSdidG4gYnRuLWRlZmF1bHQnIGRhdGEtZGlzbWlzcz0nbW9kYWwnPlwiICsgbG9jYWxlLmxpbmsuY2FuY2VsICsgXCI8L2E+XCIgKyBcIjxhIGhyZWY9JyMnIGNsYXNzPSdidG4gYnRuLXByaW1hcnknIGRhdGEtZGlzbWlzcz0nbW9kYWwnPlwiICsgbG9jYWxlLmxpbmsuaW5zZXJ0ICsgXCI8L2E+XCIgKyBcIjwvZGl2PlwiICsgXCI8L2Rpdj5cIiArIFwiPGEgY2xhc3M9J2J0biBidG4tZGVmYXVsdFwiICsgc2l6ZSArIFwiJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdjcmVhdGVMaW5rJyB0aXRsZT0nXCIgKyBsb2NhbGUubGluay5pbnNlcnQgKyBcIicgdGFiaW5kZXg9Jy0xJz48aSBjbGFzcz0nZmEgZmEtc2hhcmUnPjwvaT48L2E+XCIgKyBcIjwvbGk+XCI7XG4gICAgfSxcblxuICAgIFwiaW1hZ2VcIjogZnVuY3Rpb24gaW1hZ2UobG9jYWxlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgc2l6ZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5zaXplID8gJyBidG4tJyArIG9wdGlvbnMuc2l6ZSA6ICcnO1xuICAgICAgcmV0dXJuIFwiPGxpPlwiICsgXCI8ZGl2IGNsYXNzPSdib290c3RyYXAtd3lzaWh0bWw1LWluc2VydC1pbWFnZS1tb2RhbCBtb2RhbCBoaWRlIGZhZGUnPlwiICsgXCI8ZGl2IGNsYXNzPSdtb2RhbC1oZWFkZXInPlwiICsgXCI8YSBjbGFzcz0nY2xvc2UnIGRhdGEtZGlzbWlzcz0nbW9kYWwnPiZ0aW1lczs8L2E+XCIgKyBcIjxoMz5cIiArIGxvY2FsZS5pbWFnZS5pbnNlcnQgKyBcIjwvaDM+XCIgKyBcIjwvZGl2PlwiICsgXCI8ZGl2IGNsYXNzPSdtb2RhbC1ib2R5Jz5cIiArIFwiPGlucHV0IHZhbHVlPSdodHRwOi8vJyBjbGFzcz0nYm9vdHN0cmFwLXd5c2lodG1sNS1pbnNlcnQtaW1hZ2UtdXJsIGlucHV0LXhsYXJnZSc+XCIgKyBcIjwvZGl2PlwiICsgXCI8ZGl2IGNsYXNzPSdtb2RhbC1mb290ZXInPlwiICsgXCI8YSBocmVmPScjJyBjbGFzcz0nYnRuIGJ0bi1kZWZhdWx0JyBkYXRhLWRpc21pc3M9J21vZGFsJz5cIiArIGxvY2FsZS5pbWFnZS5jYW5jZWwgKyBcIjwvYT5cIiArIFwiPGEgaHJlZj0nIycgY2xhc3M9J2J0biBidG4tcHJpbWFyeScgZGF0YS1kaXNtaXNzPSdtb2RhbCc+XCIgKyBsb2NhbGUuaW1hZ2UuaW5zZXJ0ICsgXCI8L2E+XCIgKyBcIjwvZGl2PlwiICsgXCI8L2Rpdj5cIiArIFwiPGEgY2xhc3M9J2J0biBidG4tZGVmYXVsdFwiICsgc2l6ZSArIFwiJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdpbnNlcnRJbWFnZScgdGl0bGU9J1wiICsgbG9jYWxlLmltYWdlLmluc2VydCArIFwiJyB0YWJpbmRleD0nLTEnPjxpIGNsYXNzPSdmYSBmYS1waWN0dXJlJz48L2k+PC9hPlwiICsgXCI8L2xpPlwiO1xuICAgIH0sXG5cbiAgICBcImh0bWxcIjogZnVuY3Rpb24gaHRtbChsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzaXplID0gb3B0aW9ucyAmJiBvcHRpb25zLnNpemUgPyAnIGJ0bi0nICsgb3B0aW9ucy5zaXplIDogJyc7XG4gICAgICByZXR1cm4gXCI8bGk+XCIgKyBcIjxkaXYgY2xhc3M9J2J0bi1ncm91cCc+XCIgKyBcIjxhIGNsYXNzPSdidG4gYnRuLWRlZmF1bHRcIiArIHNpemUgKyBcIicgZGF0YS13eXNpaHRtbDUtYWN0aW9uPSdjaGFuZ2VfdmlldycgdGl0bGU9J1wiICsgbG9jYWxlLmh0bWwuZWRpdCArIFwiJyB0YWJpbmRleD0nLTEnPjxpIGNsYXNzPSdmYSBmYS1wZW5jaWwnPjwvaT48L2E+XCIgKyBcIjwvZGl2PlwiICsgXCI8L2xpPlwiO1xuICAgIH0sXG5cbiAgICBcImNvbG9yXCI6IGZ1bmN0aW9uIGNvbG9yKGxvY2FsZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHNpemUgPSBvcHRpb25zICYmIG9wdGlvbnMuc2l6ZSA/ICcgYnRuLScgKyBvcHRpb25zLnNpemUgOiAnJztcbiAgICAgIHJldHVybiBcIjxsaSBjbGFzcz0nZHJvcGRvd24nPlwiICsgXCI8YSBjbGFzcz0nYnRuIGJ0bi1kZWZhdWx0IGRyb3Bkb3duLXRvZ2dsZVwiICsgc2l6ZSArIFwiJyBkYXRhLXRvZ2dsZT0nZHJvcGRvd24nIGhyZWY9JyMnIHRhYmluZGV4PSctMSc+XCIgKyBcIjxzcGFuIGNsYXNzPSdjdXJyZW50LWNvbG9yJz7ljp/oibI8L3NwYW4+Jm5ic3A7PGIgY2xhc3M9J2NhcmV0Jz48L2I+XCIgKyBcIjwvYT5cIiArIFwiPHVsIGNsYXNzPSdkcm9wZG93bi1tZW51Jz5cIiArIFwiPGxpPjxkaXYgY2xhc3M9J3d5c2lodG1sNS1jb2xvcnMnIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J2NsZWFyJz48L2Rpdj48YSBjbGFzcz0nd3lzaWh0bWw1LWNvbG9ycy10aXRsZScgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0nZm9yZUNvbG9yJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdjbGVhcic+XCIgKyBsb2NhbGUuY29sb3Vycy5jbGVhciArIFwiPC9hPjwvbGk+XCIgKyBcIjxsaT48ZGl2IGNsYXNzPSd3eXNpaHRtbDUtY29sb3JzJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdmaXJzdCc+PC9kaXY+PGEgY2xhc3M9J3d5c2lodG1sNS1jb2xvcnMtdGl0bGUnIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQ9J2ZvcmVDb2xvcicgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT0nZmlyc3QnPlwiICsgbG9jYWxlLmNvbG91cnMuZmlyc3QgKyBcIjwvYT48L2xpPlwiICsgXCI8bGk+PGRpdiBjbGFzcz0nd3lzaWh0bWw1LWNvbG9ycycgZGF0YS13eXNpaHRtbDUtY29tbWFuZC12YWx1ZT0nc2Vjb25kJz48L2Rpdj48YSBjbGFzcz0nd3lzaWh0bWw1LWNvbG9ycy10aXRsZScgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0nZm9yZUNvbG9yJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSdzZWNvbmQnPlwiICsgbG9jYWxlLmNvbG91cnMuc2Vjb25kICsgXCI8L2E+PC9saT5cIiArIFwiPGxpPjxkaXYgY2xhc3M9J3d5c2lodG1sNS1jb2xvcnMnIGRhdGEtd3lzaWh0bWw1LWNvbW1hbmQtdmFsdWU9J3RocmVlJz48L2Rpdj48YSBjbGFzcz0nd3lzaWh0bWw1LWNvbG9ycy10aXRsZScgZGF0YS13eXNpaHRtbDUtY29tbWFuZD0nZm9yZUNvbG9yJyBkYXRhLXd5c2lodG1sNS1jb21tYW5kLXZhbHVlPSd0aHJlZSc+XCIgKyBsb2NhbGUuY29sb3Vycy50aHJlZSArIFwiPC9hPjwvbGk+XCIgKyBcIjwvdWw+XCIgKyBcIjwvbGk+XCI7XG4gICAgfVxuICB9O1xuXG4gIHZhciB0ZW1wbGF0ZXMgPSBmdW5jdGlvbiB0ZW1wbGF0ZXMoa2V5LCBsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdHBsW2tleV0obG9jYWxlLCBvcHRpb25zKTtcbiAgfTtcblxuICB2YXIgV3lzaWh0bWw1ID0gZnVuY3Rpb24gV3lzaWh0bWw1KGVsLCBvcHRpb25zKSB7XG4gICAgdGhpcy5lbCA9IGVsO1xuICAgIHZhciB0b29sYmFyT3B0cyA9IG9wdGlvbnMgfHwgZGVmYXVsdE9wdGlvbnM7XG4gICAgZm9yICh2YXIgdCBpbiB0b29sYmFyT3B0cy5jdXN0b21UZW1wbGF0ZXMpIHtcbiAgICAgIHRwbFt0XSA9IHRvb2xiYXJPcHRzLmN1c3RvbVRlbXBsYXRlc1t0XTtcbiAgICB9XG4gICAgdGhpcy50b29sYmFyID0gdGhpcy5jcmVhdGVUb29sYmFyKGVsLCB0b29sYmFyT3B0cyk7XG4gICAgdGhpcy5lZGl0b3IgPSB0aGlzLmNyZWF0ZUVkaXRvcihvcHRpb25zKTtcblxuICAgIHdpbmRvdy5lZGl0b3IgPSB0aGlzLmVkaXRvcjtcblxuICAgICQoJ2lmcmFtZS53eXNpaHRtbDUtc2FuZGJveCcpLmVhY2goZnVuY3Rpb24gKGksIGVsKSB7XG4gICAgICAkKGVsLmNvbnRlbnRXaW5kb3cpLm9mZignZm9jdXMud3lzaWh0bWw1Jykub24oe1xuICAgICAgICAnZm9jdXMud3lzaWh0bWw1JzogZnVuY3Rpb24gZm9jdXNXeXNpaHRtbDUoKSB7XG4gICAgICAgICAgJCgnbGkuZHJvcGRvd24nKS5yZW1vdmVDbGFzcygnb3BlbicpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBXeXNpaHRtbDUucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IFd5c2lodG1sNSxcblxuICAgIGNyZWF0ZUVkaXRvcjogZnVuY3Rpb24gY3JlYXRlRWRpdG9yKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAvLyBBZGQgdGhlIHRvb2xiYXIgdG8gYSBjbG9uZSBvZiB0aGUgb3B0aW9ucyBvYmplY3Qgc28gbXVsdGlwbGUgaW5zdGFuY2VzXG4gICAgICAvLyBvZiB0aGUgV1lJU1lXRyBkb24ndCBicmVhayBiZWNhdXNlIFwidG9vbGJhclwiIGlzIGFscmVhZHkgZGVmaW5lZFxuICAgICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMudG9vbGJhciA9IHRoaXMudG9vbGJhclswXTtcblxuICAgICAgdmFyIGVkaXRvciA9IG5ldyB3eXNpaHRtbDUuRWRpdG9yKHRoaXMuZWxbMF0sIG9wdGlvbnMpO1xuXG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmV2ZW50cykge1xuICAgICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gb3B0aW9ucy5ldmVudHMpIHtcbiAgICAgICAgICBlZGl0b3Iub24oZXZlbnROYW1lLCBvcHRpb25zLmV2ZW50c1tldmVudE5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICB9LFxuXG4gICAgY3JlYXRlVG9vbGJhcjogZnVuY3Rpb24gY3JlYXRlVG9vbGJhcihlbCwgb3B0aW9ucykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIHRvb2xiYXIgPSAkKFwiPHVsLz5cIiwge1xuICAgICAgICAnY2xhc3MnOiBcInd5c2lodG1sNS10b29sYmFyXCIsXG4gICAgICAgICdzdHlsZSc6IFwiZGlzcGxheTpub25lXCJcbiAgICAgIH0pO1xuICAgICAgdmFyIGN1bHR1cmUgPSBvcHRpb25zLmxvY2FsZSB8fCBkZWZhdWx0T3B0aW9ucy5sb2NhbGUgfHwgXCJlblwiO1xuICAgICAgZm9yICh2YXIga2V5IGluIHdpbmRvdy4kLmZuLnd5c2lodG1sNS5kZWZhdWx0T3B0aW9ucykge1xuICAgICAgICB2YXIgdmFsdWUgPSBmYWxzZTtcblxuICAgICAgICBpZiAob3B0aW9uc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAob3B0aW9uc1trZXldID09PSB0cnVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gZGVmYXVsdE9wdGlvbnNba2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRvb2xiYXIuYXBwZW5kKHRlbXBsYXRlcyhrZXksIGxvY2FsZVtjdWx0dXJlXSwgb3B0aW9ucykpO1xuXG4gICAgICAgICAgaWYgKGtleSA9PT0gXCJodG1sXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdEh0bWwodG9vbGJhcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGtleSA9PT0gXCJsaW5rXCIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdEluc2VydExpbmsodG9vbGJhcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGtleSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRJbnNlcnRJbWFnZSh0b29sYmFyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMudG9vbGJhcikge1xuICAgICAgICBmb3IgKGtleSBpbiBvcHRpb25zLnRvb2xiYXIpIHtcbiAgICAgICAgICB0b29sYmFyLmFwcGVuZChvcHRpb25zLnRvb2xiYXJba2V5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG9vbGJhci5maW5kKFwiYVtkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JtYXRCbG9jayddXCIpLmNsaWNrKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gICAgICAgIHZhciBlbCA9ICQodGFyZ2V0KTtcbiAgICAgICAgc2VsZi50b29sYmFyLmZpbmQoJy5jdXJyZW50LWZvbnQnKS50ZXh0KGVsLmh0bWwoKSk7XG4gICAgICB9KTtcblxuICAgICAgdG9vbGJhci5maW5kKFwiYVtkYXRhLXd5c2lodG1sNS1jb21tYW5kPSdmb3JlQ29sb3InXVwiKS5jbGljayhmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgICAgICB2YXIgZWwgPSAkKHRhcmdldCk7XG4gICAgICAgIHNlbGYudG9vbGJhci5maW5kKCcuY3VycmVudC1jb2xvcicpLnRleHQoZWwuaHRtbCgpKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmVsLmJlZm9yZSh0b29sYmFyKTtcblxuICAgICAgcmV0dXJuIHRvb2xiYXI7XG4gICAgfSxcblxuICAgIGluaXRIdG1sOiBmdW5jdGlvbiBpbml0SHRtbCh0b29sYmFyKSB7XG4gICAgICB2YXIgY2hhbmdlVmlld1NlbGVjdG9yID0gXCJhW2RhdGEtd3lzaWh0bWw1LWFjdGlvbj0nY2hhbmdlX3ZpZXcnXVwiO1xuICAgICAgdG9vbGJhci5maW5kKGNoYW5nZVZpZXdTZWxlY3RvcikuY2xpY2soZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdG9vbGJhci5maW5kKCdhLmJ0bicpLm5vdChjaGFuZ2VWaWV3U2VsZWN0b3IpLnRvZ2dsZUNsYXNzKCdkaXNhYmxlZCcpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGluaXRJbnNlcnRJbWFnZTogZnVuY3Rpb24gaW5pdEluc2VydEltYWdlKHRvb2xiYXIpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBpbnNlcnRJbWFnZU1vZGFsID0gdG9vbGJhci5maW5kKCcuYm9vdHN0cmFwLXd5c2lodG1sNS1pbnNlcnQtaW1hZ2UtbW9kYWwnKTtcbiAgICAgIHZhciB1cmxJbnB1dCA9IGluc2VydEltYWdlTW9kYWwuZmluZCgnLmJvb3RzdHJhcC13eXNpaHRtbDUtaW5zZXJ0LWltYWdlLXVybCcpO1xuICAgICAgdmFyIGluc2VydEJ1dHRvbiA9IGluc2VydEltYWdlTW9kYWwuZmluZCgnYS5idG4tcHJpbWFyeScpO1xuICAgICAgdmFyIGluaXRpYWxWYWx1ZSA9IHVybElucHV0LnZhbCgpO1xuICAgICAgdmFyIGNhcmV0Qm9va21hcms7XG5cbiAgICAgIHZhciBpbnNlcnRJbWFnZSA9IGZ1bmN0aW9uIGluc2VydEltYWdlKCkge1xuICAgICAgICB2YXIgdXJsID0gdXJsSW5wdXQudmFsKCk7XG4gICAgICAgIHVybElucHV0LnZhbChpbml0aWFsVmFsdWUpO1xuICAgICAgICBzZWxmLmVkaXRvci5jdXJyZW50Vmlldy5lbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIGlmIChjYXJldEJvb2ttYXJrKSB7XG4gICAgICAgICAgc2VsZi5lZGl0b3IuY29tcG9zZXIuc2VsZWN0aW9uLnNldEJvb2ttYXJrKGNhcmV0Qm9va21hcmspO1xuICAgICAgICAgIGNhcmV0Qm9va21hcmsgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuZWRpdG9yLmNvbXBvc2VyLmNvbW1hbmRzLmV4ZWMoXCJpbnNlcnRJbWFnZVwiLCB1cmwpO1xuICAgICAgfTtcblxuICAgICAgdXJsSW5wdXQua2V5cHJlc3MoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUud2hpY2ggPT0gMTMpIHtcbiAgICAgICAgICBpbnNlcnRJbWFnZSgpO1xuICAgICAgICAgIGluc2VydEltYWdlTW9kYWwubW9kYWwoJ2hpZGUnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGluc2VydEJ1dHRvbi5jbGljayhpbnNlcnRJbWFnZSk7XG5cbiAgICAgIGluc2VydEltYWdlTW9kYWwub24oJ3Nob3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB1cmxJbnB1dC5mb2N1cygpO1xuICAgICAgfSk7XG5cbiAgICAgIGluc2VydEltYWdlTW9kYWwub24oJ2hpZGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZWRpdG9yLmN1cnJlbnRWaWV3LmVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIH0pO1xuXG4gICAgICB0b29sYmFyLmZpbmQoJ2FbZGF0YS13eXNpaHRtbDUtY29tbWFuZD1pbnNlcnRJbWFnZV0nKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhY3RpdmVCdXR0b24gPSAkKHRoaXMpLmhhc0NsYXNzKFwid3lzaWh0bWw1LWNvbW1hbmQtYWN0aXZlXCIpO1xuXG4gICAgICAgIGlmICghYWN0aXZlQnV0dG9uKSB7XG4gICAgICAgICAgc2VsZi5lZGl0b3IuY3VycmVudFZpZXcuZWxlbWVudC5mb2N1cyhmYWxzZSk7XG4gICAgICAgICAgY2FyZXRCb29rbWFyayA9IHNlbGYuZWRpdG9yLmNvbXBvc2VyLnNlbGVjdGlvbi5nZXRCb29rbWFyaygpO1xuICAgICAgICAgIGluc2VydEltYWdlTW9kYWwuYXBwZW5kVG8oJ2JvZHknKS5tb2RhbCgnc2hvdycpO1xuICAgICAgICAgIGluc2VydEltYWdlTW9kYWwub24oJ2NsaWNrLmRpc21pc3MubW9kYWwnLCAnW2RhdGEtZGlzbWlzcz1cIm1vZGFsXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgaW5pdEluc2VydExpbms6IGZ1bmN0aW9uIGluaXRJbnNlcnRMaW5rKHRvb2xiYXIpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBpbnNlcnRMaW5rTW9kYWwgPSB0b29sYmFyLmZpbmQoJy5ib290c3RyYXAtd3lzaWh0bWw1LWluc2VydC1saW5rLW1vZGFsJyk7XG4gICAgICB2YXIgdXJsSW5wdXQgPSBpbnNlcnRMaW5rTW9kYWwuZmluZCgnLmJvb3RzdHJhcC13eXNpaHRtbDUtaW5zZXJ0LWxpbmstdXJsJyk7XG4gICAgICB2YXIgaW5zZXJ0QnV0dG9uID0gaW5zZXJ0TGlua01vZGFsLmZpbmQoJ2EuYnRuLXByaW1hcnknKTtcbiAgICAgIHZhciBpbml0aWFsVmFsdWUgPSB1cmxJbnB1dC52YWwoKTtcbiAgICAgIHZhciBjYXJldEJvb2ttYXJrO1xuXG4gICAgICB2YXIgaW5zZXJ0TGluayA9IGZ1bmN0aW9uIGluc2VydExpbmsoKSB7XG4gICAgICAgIHZhciB1cmwgPSB1cmxJbnB1dC52YWwoKTtcbiAgICAgICAgdXJsSW5wdXQudmFsKGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIHNlbGYuZWRpdG9yLmN1cnJlbnRWaWV3LmVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgaWYgKGNhcmV0Qm9va21hcmspIHtcbiAgICAgICAgICBzZWxmLmVkaXRvci5jb21wb3Nlci5zZWxlY3Rpb24uc2V0Qm9va21hcmsoY2FyZXRCb29rbWFyayk7XG4gICAgICAgICAgY2FyZXRCb29rbWFyayA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5lZGl0b3IuY29tcG9zZXIuY29tbWFuZHMuZXhlYyhcImNyZWF0ZUxpbmtcIiwge1xuICAgICAgICAgIGhyZWY6IHVybCxcbiAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgcmVsOiBcIm5vZm9sbG93XCJcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdmFyIHByZXNzZWRFbnRlciA9IGZhbHNlO1xuXG4gICAgICB1cmxJbnB1dC5rZXlwcmVzcyhmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoZS53aGljaCA9PSAxMykge1xuICAgICAgICAgIGluc2VydExpbmsoKTtcbiAgICAgICAgICBpbnNlcnRMaW5rTW9kYWwubW9kYWwoJ2hpZGUnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGluc2VydEJ1dHRvbi5jbGljayhpbnNlcnRMaW5rKTtcblxuICAgICAgaW5zZXJ0TGlua01vZGFsLm9uKCdzaG93bicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXJsSW5wdXQuZm9jdXMoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpbnNlcnRMaW5rTW9kYWwub24oJ2hpZGUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZWRpdG9yLmN1cnJlbnRWaWV3LmVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIH0pO1xuXG4gICAgICB0b29sYmFyLmZpbmQoJ2FbZGF0YS13eXNpaHRtbDUtY29tbWFuZD1jcmVhdGVMaW5rXScpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFjdGl2ZUJ1dHRvbiA9ICQodGhpcykuaGFzQ2xhc3MoXCJ3eXNpaHRtbDUtY29tbWFuZC1hY3RpdmVcIik7XG5cbiAgICAgICAgaWYgKCFhY3RpdmVCdXR0b24pIHtcbiAgICAgICAgICBzZWxmLmVkaXRvci5jdXJyZW50Vmlldy5lbGVtZW50LmZvY3VzKGZhbHNlKTtcbiAgICAgICAgICBjYXJldEJvb2ttYXJrID0gc2VsZi5lZGl0b3IuY29tcG9zZXIuc2VsZWN0aW9uLmdldEJvb2ttYXJrKCk7XG4gICAgICAgICAgaW5zZXJ0TGlua01vZGFsLmFwcGVuZFRvKCdib2R5JykubW9kYWwoJ3Nob3cnKTtcbiAgICAgICAgICBpbnNlcnRMaW5rTW9kYWwub24oJ2NsaWNrLmRpc21pc3MubW9kYWwnLCAnW2RhdGEtZGlzbWlzcz1cIm1vZGFsXCJdJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gdGhlc2UgZGVmaW5lIG91ciBwdWJsaWMgYXBpXG4gIHZhciBtZXRob2RzID0ge1xuICAgIHJlc2V0RGVmYXVsdHM6IGZ1bmN0aW9uIHJlc2V0RGVmYXVsdHMoKSB7XG4gICAgICB3aW5kb3cuJC5mbi53eXNpaHRtbDUuZGVmYXVsdE9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgd2luZG93LiQuZm4ud3lzaWh0bWw1LmRlZmF1bHRPcHRpb25zQ2FjaGUpO1xuICAgIH0sXG4gICAgYnlwYXNzRGVmYXVsdHM6IGZ1bmN0aW9uIGJ5cGFzc0RlZmF1bHRzKG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICAkdGhpcy5kYXRhKCd3eXNpaHRtbDUnLCBuZXcgV3lzaWh0bWw1KCR0aGlzLCBvcHRpb25zKSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNoYWxsb3dFeHRlbmQ6IGZ1bmN0aW9uIHNoYWxsb3dFeHRlbmQob3B0aW9ucykge1xuICAgICAgdmFyIHNldHRpbmdzID0gJC5leHRlbmQoe30sIHdpbmRvdy4kLmZuLnd5c2lodG1sNS5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICByZXR1cm4gbWV0aG9kcy5ieXBhc3NEZWZhdWx0cy5hcHBseSh0aGF0LCBbc2V0dGluZ3NdKTtcbiAgICB9LFxuICAgIGRlZXBFeHRlbmQ6IGZ1bmN0aW9uIGRlZXBFeHRlbmQob3B0aW9ucykge1xuICAgICAgdmFyIHNldHRpbmdzID0gJC5leHRlbmQodHJ1ZSwge30sIHdpbmRvdy4kLmZuLnd5c2lodG1sNS5kZWZhdWx0T3B0aW9ucywgb3B0aW9ucyB8fCB7fSk7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICByZXR1cm4gbWV0aG9kcy5ieXBhc3NEZWZhdWx0cy5hcHBseSh0aGF0LCBbc2V0dGluZ3NdKTtcbiAgICB9LFxuICAgIGluaXQ6IGZ1bmN0aW9uIGluaXQob3B0aW9ucykge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgcmV0dXJuIG1ldGhvZHMuc2hhbGxvd0V4dGVuZC5hcHBseSh0aGF0LCBbb3B0aW9uc10pO1xuICAgIH1cbiAgfTtcblxuICB3aW5kb3cuJC5mbi53eXNpaHRtbDUgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgaWYgKG1ldGhvZHNbbWV0aG9kXSkge1xuICAgICAgcmV0dXJuIG1ldGhvZHNbbWV0aG9kXS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YgbWV0aG9kID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YobWV0aG9kKSkgPT09ICdvYmplY3QnIHx8ICFtZXRob2QpIHtcbiAgICAgIHJldHVybiBtZXRob2RzLmluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJC5lcnJvcignTWV0aG9kICcgKyBtZXRob2QgKyAnIGRvZXMgbm90IGV4aXN0IG9uIGpRdWVyeS53eXNpaHRtbDUnKTtcbiAgICB9XG4gIH07XG5cbiAgd2luZG93LiQuZm4ud3lzaWh0bWw1LkNvbnN0cnVjdG9yID0gV3lzaWh0bWw1O1xuXG4gIHdpbmRvdy4kLmZuLnd5c2lodG1sNS5kZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBcImZvbnQtc3R5bGVzXCI6IHRydWUsXG4gICAgXCJjb2xvclwiOiBmYWxzZSxcbiAgICBcImVtcGhhc2lzXCI6IHRydWUsXG4gICAgXCJsaXN0c1wiOiB0cnVlLFxuICAgIFwiaHRtbFwiOiBmYWxzZSxcbiAgICBcImxpbmtcIjogdHJ1ZSxcbiAgICBcImltYWdlXCI6IHRydWUsXG4gICAgZXZlbnRzOiB7fSxcbiAgICBwYXJzZXJSdWxlczoge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAvLyAocGF0aF90b19wcm9qZWN0L2xpYi9jc3Mvd3lzaXd5Zy1jb2xvci5jc3MpXG4gICAgICAgIFwid3lzaXd5Zy1jb2xvci1jbGVhclwiOiAxLFxuICAgICAgICBcInd5c2l3eWctY29sb3ItZmlyc3RcIjogMSxcbiAgICAgICAgXCJ3eXNpd3lnLWNvbG9yLXNlY29uZFwiOiAxLFxuICAgICAgICBcInd5c2l3eWctY29sb3ItdGhyZWVcIjogMVxuICAgICAgfSxcbiAgICAgIHRhZ3M6IHtcbiAgICAgICAgXCJiXCI6IHt9LFxuICAgICAgICBcImlcIjoge30sXG4gICAgICAgIFwiYnJcIjoge30sXG4gICAgICAgIFwib2xcIjoge30sXG4gICAgICAgIFwidWxcIjoge30sXG4gICAgICAgIFwibGlcIjoge30sXG4gICAgICAgIFwiaDFcIjoge30sXG4gICAgICAgIFwiaDJcIjoge30sXG4gICAgICAgIFwiaDNcIjoge30sXG4gICAgICAgIFwiYmxvY2txdW90ZVwiOiB7fSxcbiAgICAgICAgXCJ1XCI6IDEsXG4gICAgICAgIFwiaW1nXCI6IHtcbiAgICAgICAgICBcImNoZWNrX2F0dHJpYnV0ZXNcIjoge1xuICAgICAgICAgICAgXCJ3aWR0aFwiOiBcIm51bWJlcnNcIixcbiAgICAgICAgICAgIFwiYWx0XCI6IFwiYWx0XCIsXG4gICAgICAgICAgICBcInNyY1wiOiBcInVybFwiLFxuICAgICAgICAgICAgXCJoZWlnaHRcIjogXCJudW1iZXJzXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiYVwiOiB7XG4gICAgICAgICAgc2V0X2F0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICAgIHJlbDogXCJub2ZvbGxvd1wiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGVja19hdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBocmVmOiBcInVybFwiIC8vIGltcG9ydGFudCB0byBhdm9pZCBYU1NcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwic3BhblwiOiAxLFxuICAgICAgICBcImRpdlwiOiAxLFxuICAgICAgICAvLyB0byBhbGxvdyBzYXZlIGFuZCBlZGl0IGZpbGVzIHdpdGggY29kZSB0YWcgaGFja3NcbiAgICAgICAgXCJjb2RlXCI6IDEsXG4gICAgICAgIFwicHJlXCI6IDFcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0eWxlc2hlZXRzOiBbXCIuL2xpYi9jc3Mvd3lzaXd5Zy1jb2xvci5jc3NcIl0sIC8vIChwYXRoX3RvX3Byb2plY3QvbGliL2Nzcy93eXNpd3lnLWNvbG9yLmNzcylcbiAgICBsb2NhbGU6IFwiZW5cIlxuICB9O1xuXG4gIGlmICh0eXBlb2Ygd2luZG93LiQuZm4ud3lzaWh0bWw1LmRlZmF1bHRPcHRpb25zQ2FjaGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LiQuZm4ud3lzaWh0bWw1LmRlZmF1bHRPcHRpb25zQ2FjaGUgPSAkLmV4dGVuZCh0cnVlLCB7fSwgd2luZG93LiQuZm4ud3lzaWh0bWw1LmRlZmF1bHRPcHRpb25zKTtcbiAgfVxuXG4gIHZhciBsb2NhbGUgPSB3aW5kb3cuJC5mbi53eXNpaHRtbDUubG9jYWxlID0ge1xuICAgIGVuOiB7XG4gICAgICBmb250X3N0eWxlczoge1xuICAgICAgICBub3JtYWw6IFwiTm9ybWFsIHRleHRcIixcbiAgICAgICAgaDE6IFwiSGVhZGluZyAxXCIsXG4gICAgICAgIGgyOiBcIkhlYWRpbmcgMlwiLFxuICAgICAgICBoMzogXCJIZWFkaW5nIDNcIlxuICAgICAgfSxcbiAgICAgIGVtcGhhc2lzOiB7XG4gICAgICAgIGJvbGQ6IFwiQm9sZFwiLFxuICAgICAgICBpdGFsaWM6IFwiSXRhbGljXCIsXG4gICAgICAgIHVuZGVybGluZTogXCJVbmRlcmxpbmVcIlxuICAgICAgfSxcbiAgICAgIGxpc3RzOiB7XG4gICAgICAgIHVub3JkZXJlZDogXCJVbm9yZGVyZWQgbGlzdFwiLFxuICAgICAgICBvcmRlcmVkOiBcIk9yZGVyZWQgbGlzdFwiLFxuICAgICAgICBvdXRkZW50OiBcIk91dGRlbnRcIixcbiAgICAgICAgaW5kZW50OiBcIkluZGVudFwiXG4gICAgICB9LFxuICAgICAgbGluazoge1xuICAgICAgICBpbnNlcnQ6IFwiSW5zZXJ0IGxpbmtcIixcbiAgICAgICAgY2FuY2VsOiBcIkNhbmNlbFwiXG4gICAgICB9LFxuICAgICAgaW1hZ2U6IHtcbiAgICAgICAgaW5zZXJ0OiBcIkluc2VydCBpbWFnZVwiLFxuICAgICAgICBjYW5jZWw6IFwiQ2FuY2VsXCJcbiAgICAgIH0sXG4gICAgICBodG1sOiB7XG4gICAgICAgIGVkaXQ6IFwiRWRpdCBIVE1MXCJcbiAgICAgIH0sXG4gICAgICBjb2xvdXJzOiB7XG4gICAgICAgIGNsZWFyOiBcIkNsZWFyXCIsXG4gICAgICAgIGZpcnN0OiBcIummlumAiVwiLFxuICAgICAgICBzZWNvbmQ6IFwi5qyh6YCJXCIsXG4gICAgICAgIHRocmVlOiBcIuWkh+mAiVwiLFxuICAgICAgICBibGFjazogXCJCbGFja1wiLFxuICAgICAgICBzaWx2ZXI6IFwiU2lsdmVyXCIsXG4gICAgICAgIGdyYXk6IFwiR3JleVwiLFxuICAgICAgICBtYXJvb246IFwiTWFyb29uXCIsXG4gICAgICAgIHJlZDogXCJSZWRcIixcbiAgICAgICAgcHVycGxlOiBcIlB1cnBsZVwiLFxuICAgICAgICBncmVlbjogXCJHcmVlblwiLFxuICAgICAgICBvbGl2ZTogXCJPbGl2ZVwiLFxuICAgICAgICBuYXZ5OiBcIk5hdnlcIixcbiAgICAgICAgYmx1ZTogXCJCbHVlXCIsXG4gICAgICAgIG9yYW5nZTogXCJPcmFuZ2VcIlxuICAgICAgfVxuICAgIH1cbiAgfTtcbn0od2luZG93LmpRdWVyeSwgd2luZG93Lnd5c2lodG1sNSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvZWRpdGFibGUvanMvd3lzaWh0bWw1LmpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22\n");

/***/ })
/******/ ]);